##CONTEXT_SIZE=53530
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.agent.builder;
public interface AgentBuilder {
    AgentBuilder with(ByteBuddy byteBuddy);
    AgentBuilder with(Listener listener);
    AgentBuilder with(CircularityLock circularityLock);
    AgentBuilder with(PoolStrategy poolStrategy);
    AgentBuilder with(LocationStrategy locationStrategy);
    AgentBuilder with(ClassFileLocator classFileLocator);
    AgentBuilder with(TypeStrategy typeStrategy);
    AgentBuilder with(InitializationStrategy initializationStrategy);
    RedefinitionListenable.WithoutBatchStrategy with(RedefinitionStrategy redefinitionStrategy);
    AgentBuilder with(LambdaInstrumentationStrategy lambdaInstrumentationStrategy);
    AgentBuilder with(DescriptionStrategy descriptionStrategy);
    AgentBuilder with(FallbackStrategy fallbackStrategy);
    AgentBuilder with(ClassFileBufferStrategy classFileBufferStrategy);
    AgentBuilder with(InstallationListener installationListener);
    AgentBuilder with(InjectionStrategy injectionStrategy);
    AgentBuilder with(TransformerDecorator transformerDecorator);
    AgentBuilder enableNativeMethodPrefix(String prefix);
    AgentBuilder disableNativeMethodPrefix();
    AgentBuilder disableClassFormatChanges();
    AgentBuilder warmUp(Class<?>... type);
    AgentBuilder warmUp(Collection<Class<?>> types);
    AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, Class<?>... type);
    AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, JavaModule... module);
    AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, Collection<? extends JavaModule> modules);
    AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, Class<?>... type);
    AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, JavaModule... module);
    AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, Collection<? extends JavaModule> modules);
    Identified.Narrowable type(ElementMatcher<? super TypeDescription> typeMatcher);
    Identified.Narrowable type(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher);
    Identified.Narrowable type(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher);
    Identified.Narrowable type(RawMatcher matcher);
    Ignored ignore(ElementMatcher<? super TypeDescription> typeMatcher);
    Ignored ignore(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher);
    Ignored ignore(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher);
    Ignored ignore(RawMatcher rawMatcher);
    ClassFileTransformer makeRaw();
    ResettableClassFileTransformer installOn(Instrumentation instrumentation);
    ResettableClassFileTransformer installOnByteBuddyAgent();
    ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer);
    ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, RawMatcher differentialMatcher);
    ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, PatchMode patchMode);
    ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, RawMatcher differentialMatcher, PatchMode patchMode);
    ResettableClassFileTransformer patchOnByteBuddyAgent(ResettableClassFileTransformer classFileTransformer);
    ResettableClassFileTransformer patchOnByteBuddyAgent(ResettableClassFileTransformer classFileTransformer, PatchMode patchMode);
    interface Matchable<T extends Matchable<T>> {
        T and(ElementMatcher<? super TypeDescription> typeMatcher);
        T and(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher);
        T and(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher);
        T and(RawMatcher rawMatcher);
        T or(ElementMatcher<? super TypeDescription> typeMatcher);
        T or(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher);
        T or(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher);
        T or(RawMatcher rawMatcher);
    }
    interface Ignored extends Matchable<Ignored>, AgentBuilder {
    }
    interface RedefinitionListenable extends AgentBuilder {
        RedefinitionListenable with(RedefinitionStrategy.Listener redefinitionListener);
        WithoutResubmissionSpecification withResubmission(RedefinitionStrategy.ResubmissionScheduler resubmissionScheduler);
        interface ResubmissionOnErrorMatcher {
            boolean matches(Throwable throwable, String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module);
            enum Trivial implements ResubmissionOnErrorMatcher {
                MATCHING(true), NON_MATCHING(false);
                private final boolean matching;
                Trivial(boolean matching) {
                    this.matching = matching;
                }
                public boolean matches(Throwable throwable, String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                    return matching;
                }
            }
            class Conjunction implements ResubmissionOnErrorMatcher {
                private final List<ResubmissionOnErrorMatcher> matchers;
                public Conjunction(ResubmissionOnErrorMatcher... matcher) {
                    this(Arrays.asList(matcher));
                }
                public Conjunction(List<? extends ResubmissionOnErrorMatcher> matchers) {
                    this.matchers = new ArrayList<ResubmissionOnErrorMatcher>(matchers.size());
                    for (ResubmissionOnErrorMatcher matcher : matchers) {
                        if (matcher instanceof Conjunction) {
                            this.matchers.addAll(((Conjunction) matcher).matchers);
                        } else if (matcher != Trivial.MATCHING) {
                            this.matchers.add(matcher);
                        }
                    }
                }
                public boolean matches(Throwable throwable, String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                    for (ResubmissionOnErrorMatcher matcher : matchers) {
                        if (!matcher.matches(throwable, typeName, classLoader, module)) {
                            return false;
                        }
                    }
                    return true;
                }
            }
            class Disjunction implements ResubmissionOnErrorMatcher {
                private final List<ResubmissionOnErrorMatcher> matchers;
                public Disjunction(ResubmissionOnErrorMatcher... matcher) {
                    this(Arrays.asList(matcher));
                }
                public Disjunction(List<? extends ResubmissionOnErrorMatcher> matchers) {
                    this.matchers = new ArrayList<ResubmissionOnErrorMatcher>(matchers.size());
                    for (ResubmissionOnErrorMatcher matcher : matchers) {
                        if (matcher instanceof Disjunction) {
                            this.matchers.addAll(((Disjunction) matcher).matchers);
                        } else if (matcher != Trivial.NON_MATCHING) {
                            this.matchers.add(matcher);
                        }
                    }
                }
                public boolean matches(Throwable throwable, String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                    for (ResubmissionOnErrorMatcher matcher : matchers) {
                        if (matcher.matches(throwable, typeName, classLoader, module)) {
                            return true;
                        }
                    }
                    return false;
                }
            }
            class ForElementMatchers implements ResubmissionOnErrorMatcher {
                private final ElementMatcher<? super Throwable> exceptionMatcher;
                private final ElementMatcher<String> typeNameMatcher;
                private final ElementMatcher<? super ClassLoader> classLoaderMatcher;
                private final ElementMatcher<? super JavaModule> moduleMatcher;
                public ForElementMatchers(ElementMatcher<? super Throwable> exceptionMatcher, ElementMatcher<String> typeNameMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher) {
                    this.exceptionMatcher = exceptionMatcher;
                    this.typeNameMatcher = typeNameMatcher;
                    this.classLoaderMatcher = classLoaderMatcher;
                    this.moduleMatcher = moduleMatcher;
                }
                public boolean matches(Throwable throwable, String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                    return exceptionMatcher.matches(throwable) && typeNameMatcher.matches(typeName) && classLoaderMatcher.matches(classLoader) && moduleMatcher.matches(module);
                }
            }
        }
        interface ResubmissionImmediateMatcher {
            boolean matches(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module);
            enum Trivial implements ResubmissionImmediateMatcher {
                MATCHING(true), NON_MATCHING(false);
                private final boolean matching;
                Trivial(boolean matching) {
                    this.matching = matching;
                }
                public boolean matches(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                    return matching;
                }
            }
            class Conjunction implements ResubmissionImmediateMatcher {
                private final List<ResubmissionImmediateMatcher> matchers;
                public Conjunction(ResubmissionImmediateMatcher... matcher) {
                    this(Arrays.asList(matcher));
                }
                public Conjunction(List<? extends ResubmissionImmediateMatcher> matchers) {
                    this.matchers = new ArrayList<ResubmissionImmediateMatcher>(matchers.size());
                    for (ResubmissionImmediateMatcher matcher : matchers) {
                        if (matcher instanceof Conjunction) {
                            this.matchers.addAll(((Conjunction) matcher).matchers);
                        } else if (matcher != Trivial.NON_MATCHING) {
                            this.matchers.add(matcher);
                        }
                    }
                }
                public boolean matches(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                    for (ResubmissionImmediateMatcher matcher : matchers) {
                        if (!matcher.matches(typeName, classLoader, module)) {
                            return false;
                        }
                    }
                    return true;
                }
            }
            class Disjunction implements ResubmissionImmediateMatcher {
                private final List<ResubmissionImmediateMatcher> matchers;
                public Disjunction(ResubmissionImmediateMatcher... matcher) {
                    this(Arrays.asList(matcher));
                }
                public Disjunction(List<? extends ResubmissionImmediateMatcher> matchers) {
                    this.matchers = new ArrayList<ResubmissionImmediateMatcher>(matchers.size());
                    for (ResubmissionImmediateMatcher matcher : matchers) {
                        if (matcher instanceof Disjunction) {
                            this.matchers.addAll(((Disjunction) matcher).matchers);
                        } else if (matcher != Trivial.NON_MATCHING) {
                            this.matchers.add(matcher);
                        }
                    }
                }
                public boolean matches(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                    for (ResubmissionImmediateMatcher matcher : matchers) {
                        if (matcher.matches(typeName, classLoader, module)) {
                            return true;
                        }
                    }
                    return false;
                }
            }
            class ForElementMatchers implements ResubmissionImmediateMatcher {
                private final ElementMatcher<String> typeNameMatcher;
                private final ElementMatcher<? super ClassLoader> classLoaderMatcher;
                private final ElementMatcher<? super JavaModule> moduleMatcher;
                public ForElementMatchers(ElementMatcher<String> typeNameMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher) {
                    this.typeNameMatcher = typeNameMatcher;
                    this.classLoaderMatcher = classLoaderMatcher;
                    this.moduleMatcher = moduleMatcher;
                }
                public boolean matches(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                    return typeNameMatcher.matches(typeName) && classLoaderMatcher.matches(classLoader) && moduleMatcher.matches(module);
                }
            }
        }
        interface WithoutResubmissionSpecification {
            WithResubmissionSpecification resubmitOnError();
            WithResubmissionSpecification resubmitOnError(ElementMatcher<? super Throwable> exceptionMatcher);
            WithResubmissionSpecification resubmitOnError(ElementMatcher<? super Throwable> exceptionMatcher, ElementMatcher<String> typeNameMatcher);
            WithResubmissionSpecification resubmitOnError(ElementMatcher<? super Throwable> exceptionMatcher, ElementMatcher<String> typeNameMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher);
            WithResubmissionSpecification resubmitOnError(ElementMatcher<? super Throwable> exceptionMatcher, ElementMatcher<String> typeNameMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher);
            WithResubmissionSpecification resubmitOnError(ResubmissionOnErrorMatcher matcher);
            WithResubmissionSpecification resubmitImmediate();
            WithResubmissionSpecification resubmitImmediate(ElementMatcher<String> typeNameMatcher);
            WithResubmissionSpecification resubmitImmediate(ElementMatcher<String> typeNameMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher);
            WithResubmissionSpecification resubmitImmediate(ElementMatcher<String> typeNameMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher);
            WithResubmissionSpecification resubmitImmediate(ResubmissionImmediateMatcher matcher);
        }
        interface WithResubmissionSpecification extends WithoutResubmissionSpecification, AgentBuilder {
        }
        interface WithImplicitDiscoveryStrategy extends RedefinitionListenable {
            RedefinitionListenable redefineOnly(Class<?>... type);
            RedefinitionListenable with(RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy);
        }
        interface WithoutBatchStrategy extends WithImplicitDiscoveryStrategy {
            WithImplicitDiscoveryStrategy with(RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator);
        }
    }
    interface Identified {
        Extendable transform(Transformer transformer);
        interface Narrowable extends Matchable<Narrowable>, Identified {
        }
        interface Extendable extends AgentBuilder, Identified {
            AgentBuilder asTerminalTransformation();
        }
    }
    interface RawMatcher {
        boolean matches(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain);
        enum Trivial implements RawMatcher {
            MATCHING(true), NON_MATCHING(false);
            private final boolean matches;
            Trivial(boolean matches) {
                this.matches = matches;
            }
            public boolean matches(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain) {
                return matches;
            }
        }
        enum ForLoadState implements RawMatcher {
            LOADED(false), UNLOADED(true);
            private final boolean unloaded;
            ForLoadState(boolean unloaded) {
                this.unloaded = unloaded;
            }
            public boolean matches(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain) {
                return classBeingRedefined == null == unloaded;
            }
        }
        enum ForResolvableTypes implements RawMatcher {
            INSTANCE;
            public boolean matches(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain) {
                if (classBeingRedefined != null) {
                    try {
                        return Class.forName(classBeingRedefined.getName(), true, classLoader) == classBeingRedefined;
                    } catch (Throwable ignored) {
                        return false;
                    }
                } else {
                    return true;
                }
            }
            public RawMatcher inverted() {
                return new Inversion(this);
            }
        }
        class Conjunction implements RawMatcher {
            private final List<RawMatcher> matchers;
            protected Conjunction(RawMatcher... matcher) {
                this(Arrays.asList(matcher));
            }
            protected Conjunction(List<? extends RawMatcher> matchers) {
                this.matchers = new ArrayList<RawMatcher>(matchers.size());
                for (RawMatcher matcher : matchers) {
                    if (matcher instanceof Conjunction) {
                        this.matchers.addAll(((Conjunction) matcher).matchers);
                    } else if (matcher != Trivial.MATCHING) {
                        this.matchers.add(matcher);
                    }
                }
            }
            public boolean matches(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain) {
                for (RawMatcher matcher : matchers) {
                    if (!matcher.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {
                        return false;
                    }
                }
                return true;
            }
        }
        class Disjunction implements RawMatcher {
            private final List<RawMatcher> matchers;
            protected Disjunction(RawMatcher... matcher) {
                this(Arrays.asList(matcher));
            }
            protected Disjunction(List<? extends RawMatcher> matchers) {
                this.matchers = new ArrayList<RawMatcher>(matchers.size());
                for (RawMatcher matcher : matchers) {
                    if (matcher instanceof Disjunction) {
                        this.matchers.addAll(((Disjunction) matcher).matchers);
                    } else if (matcher != Trivial.NON_MATCHING) {
                        this.matchers.add(matcher);
                    }
                }
            }
            public boolean matches(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain) {
                for (RawMatcher matcher : matchers) {
                    if (matcher.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {
                        return true;
                    }
                }
                return false;
            }
        }
        class Inversion implements RawMatcher {
            private final RawMatcher matcher;
            public Inversion(RawMatcher matcher) {
                this.matcher = matcher;
            }
            public boolean matches(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain) {
                return !matcher.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain);
            }
        }
        class ForElementMatchers implements RawMatcher {
            private final ElementMatcher<? super TypeDescription> typeMatcher;
            private final ElementMatcher<? super ClassLoader> classLoaderMatcher;
            private final ElementMatcher<? super JavaModule> moduleMatcher;
            public ForElementMatchers(ElementMatcher<? super TypeDescription> typeMatcher) {
                this(typeMatcher, any());
            }
            public ForElementMatchers(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher) {
                this(typeMatcher, classLoaderMatcher, any());
            }
            public ForElementMatchers(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher) {
                this.typeMatcher = typeMatcher;
                this.classLoaderMatcher = classLoaderMatcher;
                this.moduleMatcher = moduleMatcher;
            }
            public boolean matches(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain) {
                return moduleMatcher.matches(module) && classLoaderMatcher.matches(classLoader) && typeMatcher.matches(typeDescription);
            }
        }
    }
    interface Listener {
        boolean LOADED = true;
        void onDiscovery(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded);
        void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, DynamicType dynamicType);
        void onIgnored(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded);
        void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable);
        void onComplete(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded);
        enum NoOp implements Listener {
            INSTANCE;
            public void onDiscovery(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
            }
            public void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, DynamicType dynamicType) {
            }
            public void onIgnored(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
            }
            public void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable) {
            }
            public void onComplete(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
            }
        }
        abstract class Adapter implements Listener {
            public void onDiscovery(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
            }
            public void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, DynamicType dynamicType) {
            }
            public void onIgnored(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
            }
            public void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable) {
            }
            public void onComplete(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
            }
        }
        class StreamWriting implements Listener {
            protected static final String PREFIX = "[Byte Buddy]";
            private final PrintStream printStream;
            public StreamWriting(PrintStream printStream) {
                this.printStream = printStream;
            }
            public static StreamWriting toSystemOut() {
                return new StreamWriting(System.out);
            }
            public static StreamWriting toSystemError() {
                return new StreamWriting(System.err);
            }
            public Listener withTransformationsOnly() {
                return new WithTransformationsOnly(this);
            }
            public Listener withErrorsOnly() {
                return new WithErrorsOnly(this);
            }
            public void onDiscovery(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
                printStream.printf(PREFIX + " DISCOVERY %s [%s, %s, %s, loaded=%b]%n", typeName, classLoader, module, Thread.currentThread(), loaded);
            }
            public void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, DynamicType dynamicType) {
                printStream.printf(PREFIX + " TRANSFORM %s [%s, %s, %s, loaded=%b]%n", typeDescription.getName(), classLoader, module, Thread.currentThread(), loaded);
            }
            public void onIgnored(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
                printStream.printf(PREFIX + " IGNORE %s [%s, %s, %s, loaded=%b]%n", typeDescription.getName(), classLoader, module, Thread.currentThread(), loaded);
            }
            public void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable) {
                synchronized (printStream) {
                    printStream.printf(PREFIX + " ERROR %s [%s, %s, %s, loaded=%b]%n", typeName, classLoader, module, Thread.currentThread(), loaded);
                    throwable.printStackTrace(printStream);
                }
            }
            public void onComplete(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
                printStream.printf(PREFIX + " COMPLETE %s [%s, %s, %s, loaded=%b]%n", typeName, classLoader, module, Thread.currentThread(), loaded);
            }
        }
        class Filtering implements Listener {
            private final ElementMatcher<? super String> matcher;
            private final Listener delegate;
            public Filtering(ElementMatcher<? super String> matcher, Listener delegate) {
                this.matcher = matcher;
                this.delegate = delegate;
            }
            public void onDiscovery(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
                if (matcher.matches(typeName)) {
                    delegate.onDiscovery(typeName, classLoader, module, loaded);
                }
            }
            public void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, DynamicType dynamicType) {
                if (matcher.matches(typeDescription.getName())) {
                    delegate.onTransformation(typeDescription, classLoader, module, loaded, dynamicType);
                }
            }
            public void onIgnored(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
                if (matcher.matches(typeDescription.getName())) {
                    delegate.onIgnored(typeDescription, classLoader, module, loaded);
                }
            }
            public void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable) {
                if (matcher.matches(typeName)) {
                    delegate.onError(typeName, classLoader, module, loaded, throwable);
                }
            }
            public void onComplete(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
                if (matcher.matches(typeName)) {
                    delegate.onComplete(typeName, classLoader, module, loaded);
                }
            }
        }
        class WithTransformationsOnly extends Adapter {
            private final Listener delegate;
            public WithTransformationsOnly(Listener delegate) {
                this.delegate = delegate;
            }
            public void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, DynamicType dynamicType) {
                delegate.onTransformation(typeDescription, classLoader, module, loaded, dynamicType);
            }
            public void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable) {
                delegate.onError(typeName, classLoader, module, loaded, throwable);
            }
        }
        class WithErrorsOnly extends Adapter {
            private final Listener delegate;
            public WithErrorsOnly(Listener delegate) {
                this.delegate = delegate;
            }
            public void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable) {
                delegate.onError(typeName, classLoader, module, loaded, throwable);
            }
        }
        class ModuleReadEdgeCompleting extends Adapter {
            private final Instrumentation instrumentation;
            private final boolean addTargetEdge;
            private final Set<? extends JavaModule> modules;
            public ModuleReadEdgeCompleting(Instrumentation instrumentation, boolean addTargetEdge, Set<? extends JavaModule> modules) {
                this.instrumentation = instrumentation;
                this.addTargetEdge = addTargetEdge;
                this.modules = modules;
            }
            public static Listener of(Instrumentation instrumentation, boolean addTargetEdge, Class<?>... type) {
                Set<JavaModule> modules = new HashSet<JavaModule>();
                for (Class<?> aType : type) {
                    modules.add(JavaModule.ofType(aType));
                }
                return modules.isEmpty() ? Listener.NoOp.INSTANCE : new Listener.ModuleReadEdgeCompleting(instrumentation, addTargetEdge, modules);
            }
            public void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, DynamicType dynamicType) {
                if (module != JavaModule.UNSUPPORTED && module.isNamed()) {
                    for (JavaModule target : modules) {
                        if (!module.canRead(target) || addTargetEdge && !module.isOpened(typeDescription.getPackage(), target)) {
                            PackageDescription location = typeDescription.getPackage();
                            ClassInjector.UsingInstrumentation.redefineModule(instrumentation, module, Collections.singleton(target), Collections.<String, Set<JavaModule>>emptyMap(), !addTargetEdge || location == null || location.isDefault() ? Collections.<String, Set<JavaModule>>emptyMap() : Collections.singletonMap(location.getName(), Collections.singleton(target)), Collections.<Class<?>>emptySet(), Collections.<Class<?>, List<Class<?>>>emptyMap());
                        }
                        if (addTargetEdge && !target.canRead(module)) {
                            ClassInjector.UsingInstrumentation.redefineModule(instrumentation, target, Collections.singleton(module), Collections.<String, Set<JavaModule>>emptyMap(), Collections.<String, Set<JavaModule>>emptyMap(), Collections.<Class<?>>emptySet(), Collections.<Class<?>, List<Class<?>>>emptyMap());
                        }
                    }
                }
            }
        }
        class Compound implements Listener {
            private final List<Listener> listeners;
            public Compound(Listener... listener) {
                this(Arrays.asList(listener));
            }
            public Compound(List<? extends Listener> listeners) {
                this.listeners = new ArrayList<Listener>();
                for (Listener listener : listeners) {
                    if (listener instanceof Compound) {
                        this.listeners.addAll(((Compound) listener).listeners);
                    } else if (!(listener instanceof NoOp)) {
                        this.listeners.add(listener);
                    }
                }
            }
            public void onDiscovery(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
                for (Listener listener : listeners) {
                    listener.onDiscovery(typeName, classLoader, module, loaded);
                }
            }
            public void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, DynamicType dynamicType) {
                for (Listener listener : listeners) {
                    listener.onTransformation(typeDescription, classLoader, module, loaded, dynamicType);
                }
            }
            public void onIgnored(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
                for (Listener listener : listeners) {
                    listener.onIgnored(typeDescription, classLoader, module, loaded);
                }
            }
            public void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable) {
                for (Listener listener : listeners) {
                    listener.onError(typeName, classLoader, module, loaded, throwable);
                }
            }
            public void onComplete(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
                for (Listener listener : listeners) {
                    listener.onComplete(typeName, classLoader, module, loaded);
                }
            }
        }
    }
    interface CircularityLock {
        boolean acquire();
        void release();
        enum Inactive implements CircularityLock {
            INSTANCE;
            public boolean acquire() {
                return true;
            }
            public void release() {
            }
        }
        abstract class WithInnerClassLoadingLock implements CircularityLock {
            protected static final int DEFAULT_SIZE = 100;
            private final TrivialLock[] lock;
            protected WithInnerClassLoadingLock(int size) {
                lock = new TrivialLock[size];
                for (int index = 0; index < size; index++) {
                    this.lock[index] = new TrivialLock();
                }
            }
            public boolean acquire() {
                if (lock.length == 0) {
                    return doAcquire();
                }
                TrivialLock lock;
                if (this.lock.length == 1) {
                    lock = this.lock[0];
                } else {
                    int hash = System.identityHashCode(Thread.currentThread());
                    lock = this.lock[hash == Integer.MIN_VALUE ? 0 : Math.abs(hash) % this.lock.length];
                }
                synchronized (lock) {
                    if (lock.locked) {
                        return false;
                    } else {
                        lock.locked = true;
                        try {
                            return doAcquire();
                        } finally {
                            lock.locked = false;
                        }
                    }
                }
            }
            protected abstract boolean doAcquire();
            protected static class TrivialLock {
                protected boolean locked;
            }
        }
        class Default extends WithInnerClassLoadingLock {
            private final ConcurrentMap<Thread, Boolean> threads = new ConcurrentHashMap<Thread, Boolean>();
            public Default() {
                super(DEFAULT_SIZE);
            }
            public Default(int size) {
                super(size);
            }
            protected boolean doAcquire() {
                return threads.putIfAbsent(Thread.currentThread(), true) == null;
            }
            public void release() {
                threads.remove(Thread.currentThread());
            }
            protected boolean isLocked() {
                return threads.containsKey(Thread.currentThread());
            }
        }
        class Global extends WithInnerClassLoadingLock {
            private final Lock lock;
            private final long time;
            private final TimeUnit timeUnit;
            public Global() {
                this(DEFAULT_SIZE);
            }
            public Global(long time, TimeUnit timeUnit) {
                this(DEFAULT_SIZE, time, timeUnit);
            }
            public Global(int size) {
                this(size, 0, TimeUnit.MILLISECONDS);
            }
            public Global(int size, long time, TimeUnit timeUnit) {
                super(size);
                lock = new ReentrantLock();
                this.time = time;
                this.timeUnit = timeUnit;
            }
            protected boolean doAcquire() {
                try {
                    return time == 0 ? lock.tryLock() : lock.tryLock(time, timeUnit);
                } catch (InterruptedException ignored) {
                    return false;
                }
            }
            public void release() {
                lock.unlock();
            }
        }
    }
    interface TypeStrategy {
        DynamicType.Builder<?> builder(TypeDescription typeDescription, ByteBuddy byteBuddy, ClassFileLocator classFileLocator, MethodNameTransformer methodNameTransformer, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull ProtectionDomain protectionDomain);
        enum Default implements TypeStrategy {
            REBASE {
                public DynamicType.Builder<?> builder(TypeDescription typeDescription, ByteBuddy byteBuddy, ClassFileLocator classFileLocator, MethodNameTransformer methodNameTransformer, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull ProtectionDomain protectionDomain) {
                    return byteBuddy.rebase(typeDescription, classFileLocator, methodNameTransformer);
                }
            }
            , REDEFINE {
                public DynamicType.Builder<?> builder(TypeDescription typeDescription, ByteBuddy byteBuddy, ClassFileLocator classFileLocator, MethodNameTransformer methodNameTransformer, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull ProtectionDomain protectionDomain) {
                    return byteBuddy.redefine(typeDescription, classFileLocator);
                }
            }
            , REDEFINE_FROZEN {
                public DynamicType.Builder<?> builder(TypeDescription typeDescription, ByteBuddy byteBuddy, ClassFileLocator classFileLocator, MethodNameTransformer methodNameTransformer, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull ProtectionDomain protectionDomain) {
                    return byteBuddy.with(InstrumentedType.Factory.Default.FROZEN).with(VisibilityBridgeStrategy.Default.NEVER).redefine(typeDescription, classFileLocator).ignoreAlso(LatentMatcher.ForSelfDeclaredMethod.NOT_DECLARED);
                }
            }
            , DECORATE {
                public DynamicType.Builder<?> builder(TypeDescription typeDescription, ByteBuddy byteBuddy, ClassFileLocator classFileLocator, MethodNameTransformer methodNameTransformer, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull ProtectionDomain protectionDomain) {
                    return byteBuddy.decorate(typeDescription, classFileLocator);
                }
            }
        }
        class ForBuildEntryPoint implements TypeStrategy {
            private final EntryPoint entryPoint;
            public ForBuildEntryPoint(EntryPoint entryPoint) {
                this.entryPoint = entryPoint;
            }
            public DynamicType.Builder<?> builder(TypeDescription typeDescription, ByteBuddy byteBuddy, ClassFileLocator classFileLocator, MethodNameTransformer methodNameTransformer, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull ProtectionDomain protectionDomain) {
                return entryPoint.transform(typeDescription, byteBuddy, classFileLocator, methodNameTransformer);
            }
        }
    }
    interface Transformer {
        DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull ProtectionDomain protectionDomain);
        class ForBuildPlugin implements Transformer {
            private final Plugin plugin;
            public ForBuildPlugin(Plugin plugin) {
                this.plugin = plugin;
            }
            public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull ProtectionDomain protectionDomain) {
                return plugin.apply(builder, typeDescription, ClassFileLocator.ForClassLoader.of(classLoader));
            }
        }
        class ForAdvice implements Transformer {
            private final Advice.WithCustomMapping advice;
            private final Advice.ExceptionHandler exceptionHandler;
            private final Assigner assigner;
            private final ClassFileLocator classFileLocator;
            private final PoolStrategy poolStrategy;
            private final LocationStrategy locationStrategy;
            private final List<Entry> entries;
            private final List<String> auxiliaries;
            public ForAdvice() {
                this(Advice.withCustomMapping());
            }
            public ForAdvice(Advice.WithCustomMapping advice) {
                this(advice, Advice.ExceptionHandler.Default.SUPPRESSING, Assigner.DEFAULT, ClassFileLocator.NoOp.INSTANCE, PoolStrategy.Default.FAST, LocationStrategy.ForClassLoader.STRONG, Collections.<Entry>emptyList(), Collections.<String>emptyList());
            }
            protected ForAdvice(Advice.WithCustomMapping advice, Advice.ExceptionHandler exceptionHandler, Assigner assigner, ClassFileLocator classFileLocator, PoolStrategy poolStrategy, LocationStrategy locationStrategy, List<Entry> entries, List<String> auxiliaries) {
                this.advice = advice;
                this.exceptionHandler = exceptionHandler;
                this.assigner = assigner;
                this.classFileLocator = classFileLocator;
                this.poolStrategy = poolStrategy;
                this.locationStrategy = locationStrategy;
                this.entries = entries;
                this.auxiliaries = auxiliaries;
            }
            public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull ProtectionDomain protectionDomain) {
                ClassFileLocator classFileLocator = new ClassFileLocator.Compound(this.classFileLocator, locationStrategy.classFileLocator(classLoader, module));
                TypePool typePool = poolStrategy.typePool(classFileLocator, classLoader);
                for (String auxiliary : auxiliaries) {
                    builder = builder.require(new LazyDynamicType(typePool.describe(auxiliary).resolve(), classFileLocator));
                }
                AsmVisitorWrapper.ForDeclaredMethods asmVisitorWrapper = new AsmVisitorWrapper.ForDeclaredMethods();
                for (Entry entry : entries) {
                    asmVisitorWrapper = asmVisitorWrapper.invokable(entry.getMatcher().resolve(typeDescription), wrap(typeDescription, classLoader, module, protectionDomain, entry.resolve(advice, typePool, classFileLocator).withAssigner(assigner).withExceptionHandler(exceptionHandler)));
                }
                return builder.visit(asmVisitorWrapper);
            }
            protected AsmVisitorWrapper.ForDeclaredMethods.MethodVisitorWrapper wrap(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull ProtectionDomain protectionDomain, Advice advice) {
                return advice;
            }
            protected ForAdvice make(Advice.WithCustomMapping advice, Advice.ExceptionHandler exceptionHandler, Assigner assigner, ClassFileLocator classFileLocator, PoolStrategy poolStrategy, LocationStrategy locationStrategy, List<Entry> entries, List<String> auxiliaries) {
                return new ForAdvice(advice, exceptionHandler, assigner, classFileLocator, poolStrategy, locationStrategy, entries, auxiliaries);
            }
            public ForAdvice with(PoolStrategy poolStrategy) {
                return make(advice, exceptionHandler, assigner, classFileLocator, poolStrategy, locationStrategy, entries, auxiliaries);
            }
            public ForAdvice with(LocationStrategy locationStrategy) {
                return make(advice, exceptionHandler, assigner, classFileLocator, poolStrategy, locationStrategy, entries, auxiliaries);
            }
            public ForAdvice withExceptionHandler(Advice.ExceptionHandler exceptionHandler) {
                return make(advice, exceptionHandler, assigner, classFileLocator, poolStrategy, locationStrategy, entries, auxiliaries);
            }
            public ForAdvice with(Assigner assigner) {
                return make(advice, exceptionHandler, assigner, classFileLocator, poolStrategy, locationStrategy, entries, auxiliaries);
            }
            public ForAdvice include(ClassLoader... classLoader) {
                Set<ClassFileLocator> classFileLocators = new LinkedHashSet<ClassFileLocator>();
                for (ClassLoader aClassLoader : classLoader) {
                    classFileLocators.add(ClassFileLocator.ForClassLoader.of(aClassLoader));
                }
                return include(new ArrayList<ClassFileLocator>(classFileLocators));
            }
            public ForAdvice include(ClassFileLocator... classFileLocator) {
                return include(Arrays.asList(classFileLocator));
            }
            public ForAdvice include(List<? extends ClassFileLocator> classFileLocators) {
                return make(advice, exceptionHandler, assigner, new ClassFileLocator.Compound(CompoundList.of(classFileLocator, classFileLocators)), poolStrategy, locationStrategy, entries, auxiliaries);
            }
            public ForAdvice advice(ElementMatcher<? super MethodDescription> matcher, String name) {
                return advice(new LatentMatcher.Resolved<MethodDescription>(matcher), name);
            }
            public ForAdvice advice(LatentMatcher<? super MethodDescription> matcher, String name) {
                return make(advice, exceptionHandler, assigner, classFileLocator, poolStrategy, locationStrategy, CompoundList.of(entries, new Entry.ForUnifiedAdvice(matcher, name)), auxiliaries);
            }
            public ForAdvice advice(ElementMatcher<? super MethodDescription> matcher, String enter, String exit) {
                return advice(new LatentMatcher.Resolved<MethodDescription>(matcher), enter, exit);
            }
            public ForAdvice advice(LatentMatcher<? super MethodDescription> matcher, String enter, String exit) {
                return make(advice, exceptionHandler, assigner, classFileLocator, poolStrategy, locationStrategy, CompoundList.of(entries, new Entry.ForSplitAdvice(matcher, enter, exit)), auxiliaries);
            }
            public ForAdvice auxiliary(String... auxiliary) {
                return auxiliary(Arrays.asList(auxiliary));
            }
            public ForAdvice auxiliary(List<String> auxiliaries) {
                return make(advice, exceptionHandler, assigner, classFileLocator, poolStrategy, locationStrategy, entries, CompoundList.of(this.auxiliaries, auxiliaries));
            }
            protected abstract static class Entry {
                private final LatentMatcher<? super MethodDescription> matcher;
                protected Entry(LatentMatcher<? super MethodDescription> matcher) {
                    this.matcher = matcher;
                }
                protected LatentMatcher<? super MethodDescription> getMatcher() {
                    return matcher;
                }
                protected abstract Advice resolve(Advice.WithCustomMapping advice, TypePool typePool, ClassFileLocator classFileLocator);
                protected static class ForUnifiedAdvice extends Entry {
                    protected final String name;
                    protected ForUnifiedAdvice(LatentMatcher<? super MethodDescription> matcher, String name) {
                        super(matcher);
                        this.name = name;
                    }
                    protected Advice resolve(Advice.WithCustomMapping advice, TypePool typePool, ClassFileLocator classFileLocator) {
                        return advice.to(typePool.describe(name).resolve(), classFileLocator);
                    }
                }
                protected static class ForSplitAdvice extends Entry {
                    private final String enter;
                    private final String exit;
                    protected ForSplitAdvice(LatentMatcher<? super MethodDescription> matcher, String enter, String exit) {
                        super(matcher);
                        this.enter = enter;
                        this.exit = exit;
                    }
                    protected Advice resolve(Advice.WithCustomMapping advice, TypePool typePool, ClassFileLocator classFileLocator) {
                        return advice.to(typePool.describe(enter).resolve(), typePool.describe(exit).resolve(), classFileLocator);
                    }
                }
            }
            protected static class LazyDynamicType extends DynamicType.AbstractBase {
                private final TypeDescription typeDescription;
                private final ClassFileLocator classFileLocator;
                protected LazyDynamicType(TypeDescription typeDescription, ClassFileLocator classFileLocator) {
                    this.typeDescription = typeDescription;
                    this.classFileLocator = classFileLocator;
                }
                public TypeDescription getTypeDescription() {
                    return typeDescription;
                }
                public byte[] getBytes() {
                    try {
                        return classFileLocator.locate(typeDescription.getName()).resolve();
                    } catch (IOException exception) {
                        throw new IllegalStateException("Failed to resolve class file for " + typeDescription, exception);
                    }
                }
                public List<? extends DynamicType> getAuxiliaries() {
                    return Collections.<DynamicType>emptyList();
                }
                public LoadedTypeInitializer getLoadedTypeInitializer() {
                    return LoadedTypeInitializer.NoOp.INSTANCE;
                }
            }
        }
    }
    interface PoolStrategy {
        TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader);
        TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader, String name);
        enum Default implements PoolStrategy {
            EXTENDED(TypePool.Default.ReaderMode.EXTENDED), FAST(TypePool.Default.ReaderMode.FAST);
            private final TypePool.Default.ReaderMode readerMode;
            Default(TypePool.Default.ReaderMode readerMode) {
                this.readerMode = readerMode;
            }
            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader) {
                return new TypePool.LazyFacade(new TypePool.Default.WithLazyResolution(TypePool.CacheProvider.Simple.withObjectType(), classFileLocator, readerMode));
            }
            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader, String name) {
                return typePool(classFileLocator, classLoader);
            }
        }
        enum ExtraLazy implements PoolStrategy {
            EXTENDED(TypePool.Default.ReaderMode.EXTENDED), FAST(TypePool.Default.ReaderMode.FAST);
            private final TypePool.Default.ReaderMode readerMode;
            ExtraLazy(TypePool.Default.ReaderMode readerMode) {
                this.readerMode = readerMode;
            }
            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader) {
                return new TypePool.LazyFacade(new TypePool.Default.WithLazyResolution(TypePool.CacheProvider.Simple.withObjectType(), classFileLocator, readerMode, TypePool.Default.WithLazyResolution.LazinessMode.EXTENDED));
            }
            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader, String name) {
                return typePool(classFileLocator, classLoader);
            }
        }
        enum Eager implements PoolStrategy {
            EXTENDED(TypePool.Default.ReaderMode.EXTENDED), FAST(TypePool.Default.ReaderMode.FAST);
            private final TypePool.Default.ReaderMode readerMode;
            Eager(TypePool.Default.ReaderMode readerMode) {
                this.readerMode = readerMode;
            }
            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader) {
                return new TypePool.Default(TypePool.CacheProvider.Simple.withObjectType(), classFileLocator, readerMode);
            }
            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader, String name) {
                return typePool(classFileLocator, classLoader);
            }
        }
        enum ClassLoading implements PoolStrategy {
            EXTENDED(TypePool.Default.ReaderMode.EXTENDED), FAST(TypePool.Default.ReaderMode.FAST);
            private final TypePool.Default.ReaderMode readerMode;
            ClassLoading(TypePool.Default.ReaderMode readerMode) {
                this.readerMode = readerMode;
            }
            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader) {
                return TypePool.ClassLoading.of(classLoader, new TypePool.Default.WithLazyResolution(TypePool.CacheProvider.Simple.withObjectType(), classFileLocator, readerMode));
            }
            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader, String name) {
                return typePool(classFileLocator, classLoader);
            }
        }
        abstract class WithTypePoolCache implements PoolStrategy {
            protected final TypePool.Default.ReaderMode readerMode;
            protected final TypePool.Default.WithLazyResolution.LazinessMode lazinessMode;
            protected WithTypePoolCache(TypePool.Default.ReaderMode readerMode) {
                this(readerMode, TypePool.Default.WithLazyResolution.LazinessMode.NAME);
            }
            protected WithTypePoolCache(TypePool.Default.ReaderMode readerMode, TypePool.Default.WithLazyResolution.LazinessMode lazinessMode) {
                this.readerMode = readerMode;
                this.lazinessMode = lazinessMode;
            }
            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader) {
                return new TypePool.LazyFacade(new TypePool.Default.WithLazyResolution(locate(classLoader), classFileLocator, readerMode, lazinessMode));
            }
            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader, String name) {
                return new TypePool.LazyFacade(new TypePool.Default.WithLazyResolution(new TypePool.CacheProvider.Discriminating(ElementMatchers.<String>is(name), new TypePool.CacheProvider.Simple(), locate(classLoader)), classFileLocator, readerMode, lazinessMode));
            }
            protected abstract TypePool.CacheProvider locate(@MaybeNull ClassLoader classLoader);
            public static class Simple extends WithTypePoolCache {
                private static final ClassLoader BOOTSTRAP_MARKER = doPrivileged(BootstrapMarkerAction.INSTANCE);
                private final ConcurrentMap<? super ClassLoader, TypePool.CacheProvider> cacheProviders;
                public Simple(ConcurrentMap<? super ClassLoader, TypePool.CacheProvider> cacheProviders) {
                    this(TypePool.Default.ReaderMode.FAST, cacheProviders);
                }
                public Simple(TypePool.Default.ReaderMode readerMode, ConcurrentMap<? super ClassLoader, TypePool.CacheProvider> cacheProviders) {
                    super(readerMode);
                    this.cacheProviders = cacheProviders;
                }
                public Simple(TypePool.Default.ReaderMode readerMode, TypePool.Default.WithLazyResolution.LazinessMode lazinessMode, ConcurrentMap<? super ClassLoader, TypePool.CacheProvider> cacheProviders) {
                    super(readerMode, lazinessMode);
                    this.cacheProviders = cacheProviders;
                }
                private static <T> T doPrivileged(PrivilegedAction<T> action) {
                    return action.run();
                }
                protected TypePool.CacheProvider locate(@MaybeNull ClassLoader classLoader) {
                    classLoader = classLoader == null ? getBootstrapMarkerLoader() : classLoader;
                    TypePool.CacheProvider cacheProvider = cacheProviders.get(classLoader);
                    while (cacheProvider == null) {
                        cacheProvider = TypePool.CacheProvider.Simple.withObjectType();
                        TypePool.CacheProvider previous = cacheProviders.putIfAbsent(classLoader, cacheProvider);
                        if (previous != null) {
                            cacheProvider = previous;
                        }
                    }
                    return cacheProvider;
                }
                protected ClassLoader getBootstrapMarkerLoader() {
                    return BOOTSTRAP_MARKER;
                }
                protected enum BootstrapMarkerAction implements PrivilegedAction<ClassLoader> {
                    INSTANCE;
                    public ClassLoader run() {
                        return new URLClassLoader(new URL[0], ClassLoadingStrategy.BOOTSTRAP_LOADER);
                    }
                }
            }
        }
    }
    interface InitializationStrategy {
        Dispatcher dispatcher();
        interface Dispatcher {
            DynamicType.Builder<?> apply(DynamicType.Builder<?> builder);
            void register(DynamicType dynamicType, @MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain, InjectionStrategy injectionStrategy);
        }
        enum NoOp implements InitializationStrategy, Dispatcher {
            INSTANCE;
            public Dispatcher dispatcher() {
                return this;
            }
            public DynamicType.Builder<?> apply(DynamicType.Builder<?> builder) {
                return builder;
            }
            public void register(DynamicType dynamicType, @MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain, InjectionStrategy injectionStrategy) {
            }
        }
        enum Minimal implements InitializationStrategy, Dispatcher {
            INSTANCE;
            public Dispatcher dispatcher() {
                return this;
            }
            public DynamicType.Builder<?> apply(DynamicType.Builder<?> builder) {
                return builder;
            }
            public void register(DynamicType dynamicType, @MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain, InjectionStrategy injectionStrategy) {
                Set<TypeDescription> auxiliaryTypes = dynamicType.getAuxiliaryTypeDescriptions(), independentTypes = new LinkedHashSet<TypeDescription>(auxiliaryTypes);
                for (TypeDescription auxiliaryType : auxiliaryTypes) {
                    if (!auxiliaryType.getDeclaredAnnotations().isAnnotationPresent(AuxiliaryType.SignatureRelevant.class)) {
                        independentTypes.remove(auxiliaryType);
                    }
                }
                if (!independentTypes.isEmpty()) {
                    ClassInjector classInjector = injectionStrategy.resolve(classLoader, protectionDomain);
                    Map<TypeDescription, LoadedTypeInitializer> loadedTypeInitializers = dynamicType.getLoadedTypeInitializers();
                    for (Map.Entry<TypeDescription, Class<?>> entry : classInjector.inject(independentTypes, dynamicType).entrySet()) {
                        loadedTypeInitializers.get(entry.getKey()).onLoad(entry.getValue());
                    }
                }
            }
        }
        abstract class SelfInjection implements InitializationStrategy {
            protected final NexusAccessor nexusAccessor;
            protected SelfInjection(NexusAccessor nexusAccessor) {
                this.nexusAccessor = nexusAccessor;
            }
            public InitializationStrategy.Dispatcher dispatcher() {
                return dispatcher(new Random().nextInt());
            }
            protected abstract InitializationStrategy.Dispatcher dispatcher(int identification);
            protected abstract static class Dispatcher implements InitializationStrategy.Dispatcher {
                protected final NexusAccessor nexusAccessor;
                protected final int identification;
                protected Dispatcher(NexusAccessor nexusAccessor, int identification) {
                    this.nexusAccessor = nexusAccessor;
                    this.identification = identification;
                }
                public DynamicType.Builder<?> apply(DynamicType.Builder<?> builder) {
                    return builder.initializer(new NexusAccessor.InitializationAppender(identification));
                }
                protected static class InjectingInitializer implements LoadedTypeInitializer {
                    private final TypeDescription instrumentedType;
                    private final Set<TypeDescription> auxiliaryTypes;
                    private final ClassFileLocator classFileLocator;
                    private final Map<TypeDescription, LoadedTypeInitializer> loadedTypeInitializers;
                    private final ClassInjector classInjector;
                    protected InjectingInitializer(TypeDescription instrumentedType, Set<TypeDescription> auxiliaryTypes, ClassFileLocator classFileLocator, Map<TypeDescription, LoadedTypeInitializer> loadedTypeInitializers, ClassInjector classInjector) {
                        this.instrumentedType = instrumentedType;
                        this.auxiliaryTypes = auxiliaryTypes;
                        this.classFileLocator = classFileLocator;
                        this.loadedTypeInitializers = loadedTypeInitializers;
                        this.classInjector = classInjector;
                    }
                    public void onLoad(Class<?> type) {
                        for (Map.Entry<TypeDescription, Class<?>> auxiliary : classInjector.inject(auxiliaryTypes, classFileLocator).entrySet()) {
                            loadedTypeInitializers.get(auxiliary.getKey()).onLoad(auxiliary.getValue());
                        }
                        loadedTypeInitializers.get(instrumentedType).onLoad(type);
                    }
                    public boolean isAlive() {
                        return true;
                    }
                }
            }
            public static class Split extends SelfInjection {
                public Split() {
                    this(new NexusAccessor());
                }
                public Split(NexusAccessor nexusAccessor) {
                    super(nexusAccessor);
                }
                protected InitializationStrategy.Dispatcher dispatcher(int identification) {
                    return new Dispatcher(nexusAccessor, identification);
                }
                protected static class Dispatcher extends SelfInjection.Dispatcher {
                    protected Dispatcher(NexusAccessor nexusAccessor, int identification) {
                        super(nexusAccessor, identification);
                    }
                    public void register(DynamicType dynamicType, @MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain, InjectionStrategy injectionStrategy) {
                        Set<TypeDescription> auxiliaryTypes = dynamicType.getAuxiliaryTypeDescriptions();
                        LoadedTypeInitializer loadedTypeInitializer;
                        if (!auxiliaryTypes.isEmpty()) {
                            TypeDescription instrumentedType = dynamicType.getTypeDescription();
                            ClassInjector classInjector = injectionStrategy.resolve(classLoader, protectionDomain);
                            Set<TypeDescription> independentTypes = new LinkedHashSet<TypeDescription>(auxiliaryTypes);
                            Set<TypeDescription> dependentTypes = new LinkedHashSet<TypeDescription>(auxiliaryTypes);
                            for (TypeDescription auxiliaryType : auxiliaryTypes) {
                                (auxiliaryType.getDeclaredAnnotations().isAnnotationPresent(AuxiliaryType.SignatureRelevant.class) ? dependentTypes : independentTypes).remove(auxiliaryType);
                            }
                            Map<TypeDescription, LoadedTypeInitializer> loadedTypeInitializers = dynamicType.getLoadedTypeInitializers();
                            if (!independentTypes.isEmpty()) {
                                for (Map.Entry<TypeDescription, Class<?>> entry : classInjector.inject(independentTypes, dynamicType).entrySet()) {
                                    loadedTypeInitializers.get(entry.getKey()).onLoad(entry.getValue());
                                }
                            }
                            Map<TypeDescription, LoadedTypeInitializer> lazyInitializers = new HashMap<TypeDescription, LoadedTypeInitializer>(loadedTypeInitializers);
                            loadedTypeInitializers.keySet().removeAll(independentTypes);
                            loadedTypeInitializer = lazyInitializers.size() > 1 ? new Dispatcher.InjectingInitializer(instrumentedType, dependentTypes, dynamicType, lazyInitializers, classInjector) : lazyInitializers.get(instrumentedType);
                        } else {
                            loadedTypeInitializer = dynamicType.getLoadedTypeInitializers().get(dynamicType.getTypeDescription());
                        }
                        nexusAccessor.register(dynamicType.getTypeDescription().getName(), classLoader, identification, loadedTypeInitializer);
                    }
                }
            }
            public static class Lazy extends SelfInjection {
                public Lazy() {
                    this(new NexusAccessor());
                }
                public Lazy(NexusAccessor nexusAccessor) {
                    super(nexusAccessor);
                }
                protected InitializationStrategy.Dispatcher dispatcher(int identification) {
                    return new Dispatcher(nexusAccessor, identification);
                }
                protected static class Dispatcher extends SelfInjection.Dispatcher {
                    protected Dispatcher(NexusAccessor nexusAccessor, int identification) {
                        super(nexusAccessor, identification);
                    }
                    public void register(DynamicType dynamicType, @MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain, InjectionStrategy injectionStrategy) {
                        Set<TypeDescription> auxiliaryTypes = dynamicType.getAuxiliaryTypeDescriptions();
                        LoadedTypeInitializer loadedTypeInitializer = auxiliaryTypes.isEmpty() ? dynamicType.getLoadedTypeInitializers().get(dynamicType.getTypeDescription()) : new Dispatcher.InjectingInitializer(dynamicType.getTypeDescription(), auxiliaryTypes, dynamicType, dynamicType.getLoadedTypeInitializers(), injectionStrategy.resolve(classLoader, protectionDomain));
                        nexusAccessor.register(dynamicType.getTypeDescription().getName(), classLoader, identification, loadedTypeInitializer);
                    }
                }
            }
            public static class Eager extends SelfInjection {
                public Eager() {
                    this(new NexusAccessor());
                }
                public Eager(NexusAccessor nexusAccessor) {
                    super(nexusAccessor);
                }
                protected InitializationStrategy.Dispatcher dispatcher(int identification) {
                    return new Dispatcher(nexusAccessor, identification);
                }
                protected static class Dispatcher extends SelfInjection.Dispatcher {
                    protected Dispatcher(NexusAccessor nexusAccessor, int identification) {
                        super(nexusAccessor, identification);
                    }
                    public void register(DynamicType dynamicType, @MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain, InjectionStrategy injectionStrategy) {
                        Set<TypeDescription> auxiliaryTypes = dynamicType.getAuxiliaryTypeDescriptions();
                        Map<TypeDescription, LoadedTypeInitializer> loadedTypeInitializers = dynamicType.getLoadedTypeInitializers();
                        if (!auxiliaryTypes.isEmpty()) {
                            for (Map.Entry<TypeDescription, Class<?>> entry : injectionStrategy.resolve(classLoader, protectionDomain).inject(auxiliaryTypes, dynamicType).entrySet()) {
                                loadedTypeInitializers.get(entry.getKey()).onLoad(entry.getValue());
                            }
                        }
                        LoadedTypeInitializer loadedTypeInitializer = loadedTypeInitializers.get(dynamicType.getTypeDescription());
                        nexusAccessor.register(dynamicType.getTypeDescription().getName(), classLoader, identification, loadedTypeInitializer);
                    }
                }
            }
        }
    }
    interface InjectionStrategy {
        ClassInjector resolve(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain);
        enum Disabled implements InjectionStrategy {
            INSTANCE;
            public ClassInjector resolve(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
                throw new IllegalStateException("Class injection is disabled");
            }
        }
        enum UsingReflection implements InjectionStrategy {
            INSTANCE;
            public ClassInjector resolve(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
                if (classLoader == null) {
                    throw new IllegalStateException("Cannot inject auxiliary class into bootstrap loader using reflection");
                } else if (ClassInjector.UsingReflection.isAvailable()) {
                    return new ClassInjector.UsingReflection(classLoader, protectionDomain);
                } else {
                    throw new IllegalStateException("Reflection-based injection is not available on the current VM");
                }
            }
        }
        enum UsingUnsafe implements InjectionStrategy {
            INSTANCE;
            public ClassInjector resolve(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
                if (ClassInjector.UsingUnsafe.isAvailable()) {
                    return new ClassInjector.UsingUnsafe(classLoader, protectionDomain);
                } else {
                    throw new IllegalStateException("Unsafe-based injection is not available on the current VM");
                }
            }
            public static class OfFactory implements InjectionStrategy {
                private final ClassInjector.UsingUnsafe.Factory factory;
                public OfFactory(ClassInjector.UsingUnsafe.Factory factory) {
                    this.factory = factory;
                }
                public ClassInjector resolve(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
                    return factory.make(classLoader, protectionDomain);
                }
            }
        }
        enum UsingJna implements InjectionStrategy {
            INSTANCE;
            public ClassInjector resolve(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
                if (ClassInjector.UsingJna.isAvailable()) {
                    return new ClassInjector.UsingJna(classLoader, protectionDomain);
                } else {
                    throw new IllegalStateException("JNA-based injection is not available on the current VM");
                }
            }
        }
        class UsingInstrumentation implements InjectionStrategy {
            private final Instrumentation instrumentation;
            private final File folder;
            public UsingInstrumentation(Instrumentation instrumentation, File folder) {
                this.instrumentation = instrumentation;
                this.folder = folder;
            }
            public ClassInjector resolve(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
                return classLoader == null ? ClassInjector.UsingInstrumentation.of(folder, ClassInjector.UsingInstrumentation.Target.BOOTSTRAP, instrumentation) : UsingReflection.INSTANCE.resolve(classLoader, protectionDomain);
            }
        }
    }
    interface DescriptionStrategy {
        boolean isLoadedFirst();
        TypeDescription apply(String name, @MaybeNull Class<?> type, TypePool typePool, CircularityLock circularityLock, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module);
        enum Default implements DescriptionStrategy {
            HYBRID(true) {
                public TypeDescription apply(String name, @MaybeNull Class<?> type, TypePool typePool, CircularityLock circularityLock, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                    return type == null ? typePool.describe(name).resolve() : TypeDescription.ForLoadedType.of(type);
                }
            }
            , POOL_ONLY(false) {
                public TypeDescription apply(String name, @MaybeNull Class<?> type, TypePool typePool, CircularityLock circularityLock, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                    return typePool.describe(name).resolve();
                }
            }
            , POOL_FIRST(false) {
                public TypeDescription apply(String name, @MaybeNull Class<?> type, TypePool typePool, CircularityLock circularityLock, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                    TypePool.Resolution resolution = typePool.describe(name);
                    return resolution.isResolved() || type == null ? resolution.resolve() : TypeDescription.ForLoadedType.of(type);
                }
            }
            ;
            private final boolean loadedFirst;
            Default(boolean loadedFirst) {
                this.loadedFirst = loadedFirst;
            }
            public DescriptionStrategy withSuperTypeLoading() {
                return new SuperTypeLoading(this);
            }
            public boolean isLoadedFirst() {
                return loadedFirst;
            }
            public DescriptionStrategy withSuperTypeLoading(ExecutorService executorService) {
                return new SuperTypeLoading.Asynchronous(this, executorService);
            }
        }
        class SuperTypeLoading implements DescriptionStrategy {
            private final DescriptionStrategy delegate;
            public SuperTypeLoading(DescriptionStrategy delegate) {
                this.delegate = delegate;
            }
            public boolean isLoadedFirst() {
                return delegate.isLoadedFirst();
            }
            public TypeDescription apply(String name, @MaybeNull Class<?> type, TypePool typePool, CircularityLock circularityLock, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                TypeDescription typeDescription = delegate.apply(name, type, typePool, circularityLock, classLoader, module);
                return typeDescription instanceof TypeDescription.ForLoadedType ? typeDescription : new TypeDescription.SuperTypeLoading(typeDescription, classLoader, new UnlockingClassLoadingDelegate(circularityLock));
            }
            protected static class UnlockingClassLoadingDelegate implements TypeDescription.SuperTypeLoading.ClassLoadingDelegate {
                private final CircularityLock circularityLock;
                protected UnlockingClassLoadingDelegate(CircularityLock circularityLock) {
                    this.circularityLock = circularityLock;
                }
                public Class<?> load(String name, @MaybeNull ClassLoader classLoader) throws ClassNotFoundException {
                    circularityLock.release();
                    try {
                        return Class.forName(name, false, classLoader);
                    } finally {
                        circularityLock.acquire();
                    }
                }
            }
            public static class Asynchronous implements DescriptionStrategy {
                private final DescriptionStrategy delegate;
                private final ExecutorService executorService;
                public Asynchronous(DescriptionStrategy delegate, ExecutorService executorService) {
                    this.delegate = delegate;
                    this.executorService = executorService;
                }
                public boolean isLoadedFirst() {
                    return delegate.isLoadedFirst();
                }
                public TypeDescription apply(String name, @MaybeNull Class<?> type, TypePool typePool, CircularityLock circularityLock, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                    TypeDescription typeDescription = delegate.apply(name, type, typePool, circularityLock, classLoader, module);
                    return typeDescription instanceof TypeDescription.ForLoadedType ? typeDescription : new TypeDescription.SuperTypeLoading(typeDescription, classLoader, new ThreadSwitchingClassLoadingDelegate(executorService));
                }
                protected static class ThreadSwitchingClassLoadingDelegate implements TypeDescription.SuperTypeLoading.ClassLoadingDelegate {
                    private final ExecutorService executorService;
                    protected ThreadSwitchingClassLoadingDelegate(ExecutorService executorService) {
                        this.executorService = executorService;
                    }
                    public Class<?> load(String name, @MaybeNull ClassLoader classLoader) {
                        boolean holdsLock = classLoader != null && Thread.holdsLock(classLoader);
                        AtomicBoolean signal = new AtomicBoolean(holdsLock);
                        Future<Class<?>> future = executorService.submit(holdsLock ? new NotifyingClassLoadingAction(name, classLoader, signal) : new SimpleClassLoadingAction(name, classLoader));
                        try {
                            while (holdsLock && signal.get()) {
                                classLoader.wait();
                            }
                            return future.get();
                        } catch (ExecutionException exception) {
                            throw new IllegalStateException("Could not load " + name + " asynchronously", exception.getCause());
                        } catch (Exception exception) {
                            throw new IllegalStateException("Could not load " + name + " asynchronously", exception);
                        }
                    }
                    protected static class SimpleClassLoadingAction implements Callable<Class<?>> {
                        private final String name;
                        private final ClassLoader classLoader;
                        protected SimpleClassLoadingAction(String name, @MaybeNull ClassLoader classLoader) {
                            this.name = name;
                            this.classLoader = classLoader;
                        }
                        public Class<?> call() throws ClassNotFoundException {
                            return Class.forName(name, false, classLoader);
                        }
                    }
                    protected static class NotifyingClassLoadingAction implements Callable<Class<?>> {
                        private final String name;
                        private final ClassLoader classLoader;
                        private final AtomicBoolean signal;
                        protected NotifyingClassLoadingAction(String name, ClassLoader classLoader, AtomicBoolean signal) {
                            this.name = name;
                            this.classLoader = classLoader;
                            this.signal = signal;
                        }
                        public Class<?> call() throws ClassNotFoundException {
                            synchronized (classLoader) {
                                try {
                                    return Class.forName(name, false, classLoader);
                                } finally {
                                    signal.set(false);
                                    classLoader.notifyAll();
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    interface LocationStrategy {
        ClassFileLocator classFileLocator(@MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module);
        enum NoOp implements LocationStrategy {
            INSTANCE;
            public ClassFileLocator classFileLocator(@MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                return ClassFileLocator.NoOp.INSTANCE;
            }
        }
        enum ForClassLoader implements LocationStrategy {
            STRONG {
                public ClassFileLocator classFileLocator(@MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                    return ClassFileLocator.ForClassLoader.of(classLoader);
                }
            }
            , WEAK {
                public ClassFileLocator classFileLocator(@MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                    return ClassFileLocator.ForClassLoader.WeaklyReferenced.of(classLoader);
                }
            }
            ;
            public LocationStrategy withFallbackTo(ClassFileLocator... classFileLocator) {
                return withFallbackTo(Arrays.asList(classFileLocator));
            }
            public LocationStrategy withFallbackTo(Collection<? extends ClassFileLocator> classFileLocators) {
                List<LocationStrategy> locationStrategies = new ArrayList<LocationStrategy>(classFileLocators.size());
                for (ClassFileLocator classFileLocator : classFileLocators) {
                    locationStrategies.add(new Simple(classFileLocator));
                }
                return withFallbackTo(locationStrategies);
            }
            public LocationStrategy withFallbackTo(LocationStrategy... locationStrategy) {
                return withFallbackTo(Arrays.asList(locationStrategy));
            }
            public LocationStrategy withFallbackTo(List<? extends LocationStrategy> locationStrategies) {
                List<LocationStrategy> allLocationStrategies = new ArrayList<LocationStrategy>(locationStrategies.size() + 1);
                allLocationStrategies.add(this);
                allLocationStrategies.addAll(locationStrategies);
                return new Compound(allLocationStrategies);
            }
        }
        class Simple implements LocationStrategy {
            private final ClassFileLocator classFileLocator;
            public Simple(ClassFileLocator classFileLocator) {
                this.classFileLocator = classFileLocator;
            }
            public ClassFileLocator classFileLocator(@MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                return classFileLocator;
            }
        }
        class Compound implements LocationStrategy {
            private final List<LocationStrategy> locationStrategies;
            public Compound(LocationStrategy... locationStrategy) {
                this(Arrays.asList(locationStrategy));
            }
            public Compound(List<? extends LocationStrategy> locationStrategies) {
                this.locationStrategies = new ArrayList<LocationStrategy>();
                for (LocationStrategy locationStrategy : locationStrategies) {
                    if (locationStrategy instanceof Compound) {
                        this.locationStrategies.addAll(((Compound) locationStrategy).locationStrategies);
                    } else if (!(locationStrategy instanceof NoOp)) {
                        this.locationStrategies.add(locationStrategy);
                    }
                }
            }
            public ClassFileLocator classFileLocator(@MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
                List<ClassFileLocator> classFileLocators = new ArrayList<ClassFileLocator>(locationStrategies.size());
                for (LocationStrategy locationStrategy : locationStrategies) {
                    classFileLocators.add(locationStrategy.classFileLocator(classLoader, module));
                }
                return new ClassFileLocator.Compound(classFileLocators);
            }
        }
    }
    interface FallbackStrategy {
        boolean isFallback(Class<?> type, Throwable throwable);
        enum Simple implements FallbackStrategy {
            ENABLED(true), DISABLED(false);
            private final boolean enabled;
            Simple(boolean enabled) {
                this.enabled = enabled;
            }
            public boolean isFallback(Class<?> type, Throwable throwable) {
                return enabled;
            }
        }
        class ByThrowableType implements FallbackStrategy {
            private final Set<? extends Class<? extends Throwable>> types;
            @SafeVarargsPlugin.Enhance
            @SuppressWarnings("unchecked")
            public ByThrowableType(Class<? extends Throwable>... type) {
                this(new HashSet<Class<? extends Throwable>>(Arrays.asList(type)));
            }
            public ByThrowableType(Set<? extends Class<? extends Throwable>> types) {
                this.types = types;
            }
            public static FallbackStrategy ofOptionalTypes() {
                return new ByThrowableType(LinkageError.class, TypeNotPresentException.class);
            }
            public boolean isFallback(Class<?> type, Throwable throwable) {
                for (Class<? extends Throwable> aType : types) {
                    if (aType.isInstance(throwable)) {
                        return true;
                    }
                }
                return false;
            }
        }
    }
    interface InstallationListener {
        Throwable SUPPRESS_ERROR = null;
        void onBeforeInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer);
        void onInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer);
        Throwable onError(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, Throwable throwable);
        void onReset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer);
        void onBeforeWarmUp(Set<Class<?>> types, ResettableClassFileTransformer classFileTransformer);
        void onWarmUpError(Class<?> type, ResettableClassFileTransformer classFileTransformer, Throwable throwable);
        void onAfterWarmUp(Map<Class<?>, byte[]> types, ResettableClassFileTransformer classFileTransformer, boolean transformed);
        enum NoOp implements InstallationListener {
            INSTANCE;
            public void onBeforeInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
            }
            public void onInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
            }
            public Throwable onError(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
                return throwable;
            }
            public void onReset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
            }
            public void onBeforeWarmUp(Set<Class<?>> types, ResettableClassFileTransformer classFileTransformer) {
            }
            public void onWarmUpError(Class<?> type, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
            }
            public void onAfterWarmUp(Map<Class<?>, byte[]> types, ResettableClassFileTransformer classFileTransformer, boolean transformed) {
            }
        }
        enum ErrorSuppressing implements InstallationListener {
            INSTANCE;
            public void onBeforeInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
            }
            public void onInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
            }
            public Throwable onError(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
                return SUPPRESS_ERROR;
            }
            public void onReset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
            }
            public void onBeforeWarmUp(Set<Class<?>> types, ResettableClassFileTransformer classFileTransformer) {
            }
            public void onWarmUpError(Class<?> type, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
            }
            public void onAfterWarmUp(Map<Class<?>, byte[]> types, ResettableClassFileTransformer classFileTransformer, boolean transformed) {
            }
        }
        abstract class Adapter implements InstallationListener {
            public void onBeforeInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
            }
            public void onInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
            }
            public Throwable onError(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
                return throwable;
            }
            public void onReset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
            }
            public void onBeforeWarmUp(Set<Class<?>> types, ResettableClassFileTransformer classFileTransformer) {
            }
            public void onWarmUpError(Class<?> type, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
            }
            public void onAfterWarmUp(Map<Class<?>, byte[]> types, ResettableClassFileTransformer classFileTransformer, boolean transformed) {
            }
        }
        class StreamWriting implements InstallationListener {
            protected static final String PREFIX = "[Byte Buddy]";
            private final PrintStream printStream;
            public StreamWriting(PrintStream printStream) {
                this.printStream = printStream;
            }
            public static InstallationListener toSystemOut() {
                return new StreamWriting(System.out);
            }
            public static InstallationListener toSystemError() {
                return new StreamWriting(System.err);
            }
            public void onBeforeInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
                printStream.printf(PREFIX + " BEFORE_INSTALL %s on %s%n", classFileTransformer, instrumentation);
            }
            public void onInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
                printStream.printf(PREFIX + " INSTALL %s on %s%n", classFileTransformer, instrumentation);
            }
            public Throwable onError(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
                synchronized (printStream) {
                    printStream.printf(PREFIX + " ERROR %s on %s%n", classFileTransformer, instrumentation);
                    throwable.printStackTrace(printStream);
                }
                return throwable;
            }
            public void onReset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
                printStream.printf(PREFIX + " RESET %s on %s%n", classFileTransformer, instrumentation);
            }
            public void onBeforeWarmUp(Set<Class<?>> types, ResettableClassFileTransformer classFileTransformer) {
                printStream.printf(PREFIX + " BEFORE_WARMUP %s on %s%n", classFileTransformer, types);
            }
            public void onWarmUpError(Class<?> type, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
                synchronized (printStream) {
                    printStream.printf(PREFIX + " ERROR_WARMUP %s on %s%n", classFileTransformer, type);
                    throwable.printStackTrace(printStream);
                }
            }
            public void onAfterWarmUp(Map<Class<?>, byte[]> types, ResettableClassFileTransformer classFileTransformer, boolean transformed) {
                printStream.printf(PREFIX + " AFTER_WARMUP %s %s on %s%n", transformed ? "transformed" : "not transformed", classFileTransformer, types.keySet());
            }
        }
        class Compound implements InstallationListener {
            private final List<InstallationListener> installationListeners;
            public Compound(InstallationListener... installationListener) {
                this(Arrays.asList(installationListener));
            }
            public Compound(List<? extends InstallationListener> installationListeners) {
                this.installationListeners = new ArrayList<InstallationListener>();
                for (InstallationListener installationListener : installationListeners) {
                    if (installationListener instanceof Compound) {
                        this.installationListeners.addAll(((Compound) installationListener).installationListeners);
                    } else if (!(installationListener instanceof NoOp)) {
                        this.installationListeners.add(installationListener);
                    }
                }
            }
            public void onBeforeInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
                for (InstallationListener installationListener : installationListeners) {
                    installationListener.onBeforeInstall(instrumentation, classFileTransformer);
                }
            }
            public void onInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
                for (InstallationListener installationListener : installationListeners) {
                    installationListener.onInstall(instrumentation, classFileTransformer);
                }
            }
            public Throwable onError(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
                for (InstallationListener installationListener : installationListeners) {
                    if (throwable == SUPPRESS_ERROR) {
                        return SUPPRESS_ERROR;
                    }
                    throwable = installationListener.onError(instrumentation, classFileTransformer, throwable);
                }
                return throwable;
            }
            public void onReset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
                for (InstallationListener installationListener : installationListeners) {
                    installationListener.onReset(instrumentation, classFileTransformer);
                }
            }
            public void onBeforeWarmUp(Set<Class<?>> types, ResettableClassFileTransformer classFileTransformer) {
                for (InstallationListener installationListener : installationListeners) {
                    installationListener.onBeforeWarmUp(types, classFileTransformer);
                }
            }
            public void onWarmUpError(Class<?> type, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
                for (InstallationListener installationListener : installationListeners) {
                    installationListener.onWarmUpError(type, classFileTransformer, throwable);
                }
            }
            public void onAfterWarmUp(Map<Class<?>, byte[]> types, ResettableClassFileTransformer classFileTransformer, boolean transformed) {
                for (InstallationListener installationListener : installationListeners) {
                    installationListener.onAfterWarmUp(types, classFileTransformer, transformed);
                }
            }
        }
    }
    interface ClassFileBufferStrategy {
        ClassFileLocator resolve(String name, byte[] binaryRepresentation, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull ProtectionDomain protectionDomain);
        TypePool typePool(PoolStrategy poolStrategy, ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader, String name);
        enum Default implements ClassFileBufferStrategy {
            RETAINING {
                public ClassFileLocator resolve(String name, byte[] binaryRepresentation, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull ProtectionDomain protectionDomain) {
                    return ClassFileLocator.Simple.of(name, binaryRepresentation);
                }
                public TypePool typePool(PoolStrategy poolStrategy, ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader, String name) {
                    return poolStrategy.typePool(classFileLocator, classLoader, name);
                }
            }
            , DISCARDING {
                public ClassFileLocator resolve(String name, byte[] binaryRepresentation, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull ProtectionDomain protectionDomain) {
                    return ClassFileLocator.NoOp.INSTANCE;
                }
                public TypePool typePool(PoolStrategy poolStrategy, ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader, String name) {
                    return poolStrategy.typePool(classFileLocator, classLoader);
                }
            }
        }
    }
    interface TransformerDecorator {
        ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer);
        enum NoOp implements TransformerDecorator {
            INSTANCE;
            public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {
                return classFileTransformer;
            }
        }
        enum ForSubstitution implements TransformerDecorator {
            INSTANCE;
            public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {
                return ResettableClassFileTransformer.WithDelegation.Substitutable.of(classFileTransformer);
            }
        }
        class Compound implements TransformerDecorator {
            private final List<TransformerDecorator> transformerDecorators;
            public Compound(TransformerDecorator... transformerDecorator) {
                this(Arrays.asList(transformerDecorator));
            }
            public Compound(List<? extends TransformerDecorator> transformerDecorators) {
                this.transformerDecorators = new ArrayList<TransformerDecorator>();
                for (TransformerDecorator transformerDecorator : transformerDecorators) {
                    if (transformerDecorator instanceof Compound) {
                        this.transformerDecorators.addAll(((Compound) transformerDecorator).transformerDecorators);
                    } else if (!(transformerDecorator instanceof NoOp)) {
                        this.transformerDecorators.add(transformerDecorator);
                    }
                }
            }
            public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {
                for (TransformerDecorator transformerDecorator : transformerDecorators) {
                    classFileTransformer = transformerDecorator.decorate(classFileTransformer);
                }
                return classFileTransformer;
            }
        }
    }
    enum RedefinitionStrategy {
        DISABLED(false, false) {
            @Override
            public void apply(Instrumentation instrumentation, PoolStrategy poolStrategy, LocationStrategy locationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, DiscoveryStrategy discoveryStrategy, LambdaInstrumentationStrategy lambdaInstrumentationStrategy, AgentBuilder.Listener listener, Listener redefinitionListener, RawMatcher matcher, BatchAllocator redefinitionBatchAllocator, CircularityLock circularityLock) {
            }
            @Override
            protected void check(Instrumentation instrumentation) {
                throw new IllegalStateException("Cannot apply redefinition on disabled strategy");
            }
            @Override
            protected Collector make(PoolStrategy poolStrategy, LocationStrategy locationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, AgentBuilder.Listener listener, RawMatcher matcher, CircularityLock circularityLock) {
                throw new IllegalStateException("A disabled redefinition strategy cannot create a collector");
            }
        }
        , REDEFINITION(true, false) {
            @Override
            protected void check(Instrumentation instrumentation) {
                if (!instrumentation.isRedefineClassesSupported()) {
                    throw new IllegalStateException("Cannot apply redefinition on " + instrumentation);
                }
            }
            @Override
            protected Collector make(PoolStrategy poolStrategy, LocationStrategy locationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, AgentBuilder.Listener listener, RawMatcher matcher, CircularityLock circularityLock) {
                return new Collector.ForRedefinition(matcher, poolStrategy, locationStrategy, descriptionStrategy, listener, fallbackStrategy, circularityLock);
            }
        }
        , RETRANSFORMATION(true, true) {
            @Override
            protected void check(Instrumentation instrumentation) {
                if (!DISPATCHER.isRetransformClassesSupported(instrumentation)) {
                    throw new IllegalStateException("Cannot apply retransformation on " + instrumentation);
                }
            }
            @Override
            protected Collector make(PoolStrategy poolStrategy, LocationStrategy locationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, AgentBuilder.Listener listener, RawMatcher matcher, CircularityLock circularityLock) {
                return new Collector.ForRetransformation(matcher, poolStrategy, locationStrategy, descriptionStrategy, listener, fallbackStrategy, circularityLock);
            }
        }
        ;
        protected static final Dispatcher DISPATCHER = Default.doPrivileged(JavaDispatcher.of(Dispatcher.class));
        private final boolean enabled;
        private final boolean retransforming;
        RedefinitionStrategy(boolean enabled, boolean retransforming) {
            this.enabled = enabled;
            this.retransforming = retransforming;
        }
        protected boolean isRetransforming() {
            return retransforming;
        }
        protected abstract void check(Instrumentation instrumentation);
        protected boolean isEnabled() {
            return enabled;
        }
        protected abstract Collector make(PoolStrategy poolStrategy, LocationStrategy locationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, AgentBuilder.Listener listener, RawMatcher matcher, CircularityLock circularityLock);
        protected void apply(Instrumentation instrumentation, PoolStrategy poolStrategy, LocationStrategy locationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, DiscoveryStrategy redefinitionDiscoveryStrategy, LambdaInstrumentationStrategy lambdaInstrumentationStrategy, AgentBuilder.Listener listener, Listener redefinitionListener, RawMatcher matcher, BatchAllocator redefinitionBatchAllocator, CircularityLock circularityLock) {
            check(instrumentation);
            int batch = RedefinitionStrategy.BatchAllocator.FIRST_BATCH;
            for (Iterable<Class<?>> types : redefinitionDiscoveryStrategy.resolve(instrumentation)) {
                RedefinitionStrategy.Collector collector = make(poolStrategy, locationStrategy, descriptionStrategy, fallbackStrategy, listener, matcher, circularityLock);
                for (Class<?> type : types) {
                    if (type == null || type.isArray() || type.isPrimitive() || !lambdaInstrumentationStrategy.isInstrumented(type)) {
                        continue;
                    }
                    collector.consider(type, DISPATCHER.isModifiableClass(instrumentation, type) || ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isAtMost(ClassFileVersion.JAVA_V5));
                }
                batch = collector.apply(instrumentation, redefinitionBatchAllocator, redefinitionListener, batch);
            }
        }
        public interface BatchAllocator {
            int FIRST_BATCH = 0;
            Iterable<? extends List<Class<?>>> batch(List<Class<?>> types);
            enum ForTotal implements BatchAllocator {
                INSTANCE;
                public Iterable<? extends List<Class<?>>> batch(List<Class<?>> types) {
                    return types.isEmpty() ? Collections.<List<Class<?>>>emptySet() : Collections.singleton(types);
                }
            }
            class ForFixedSize implements BatchAllocator {
                private final int size;
                protected ForFixedSize(int size) {
                    this.size = size;
                }
                public static BatchAllocator ofSize(int size) {
                    if (size > 0) {
                        return new ForFixedSize(size);
                    } else if (size == 0) {
                        return ForTotal.INSTANCE;
                    } else {
                        throw new IllegalArgumentException("Cannot define a batch with a negative size: " + size);
                    }
                }
                public Iterable<? extends List<Class<?>>> batch(List<Class<?>> types) {
                    List<List<Class<?>>> batches = new ArrayList<List<Class<?>>>();
                    for (int index = 0; index < types.size(); index += size) {
                        batches.add(new ArrayList<Class<?>>(types.subList(index, Math.min(types.size(), index + size))));
                    }
                    return batches;
                }
            }
            class ForMatchedGrouping implements BatchAllocator {
                private final Collection<? extends ElementMatcher<? super TypeDescription>> matchers;
                @SafeVarargsPlugin.Enhance
                @SuppressWarnings("unchecked")
                public ForMatchedGrouping(ElementMatcher<? super TypeDescription>... matcher) {
                    this(new LinkedHashSet<ElementMatcher<? super TypeDescription>>(Arrays.asList(matcher)));
                }
                public ForMatchedGrouping(Collection<? extends ElementMatcher<? super TypeDescription>> matchers) {
                    this.matchers = matchers;
                }
                public BatchAllocator withMinimum(int threshold) {
                    return Slicing.withMinimum(threshold, this);
                }
                public BatchAllocator withMaximum(int threshold) {
                    return Slicing.withMaximum(threshold, this);
                }
                public BatchAllocator withinRange(int minimum, int maximum) {
                    return Slicing.withinRange(minimum, maximum, this);
                }
                public Iterable<? extends List<Class<?>>> batch(List<Class<?>> types) {
                    Map<ElementMatcher<? super TypeDescription>, List<Class<?>>> matched = new LinkedHashMap<ElementMatcher<? super TypeDescription>, List<Class<?>>>();
                    List<Class<?>> unmatched = new ArrayList<Class<?>>();
                    for (ElementMatcher<? super TypeDescription> matcher : matchers) {
                        matched.put(matcher, new ArrayList<Class<?>>());
                    }
                    typeLoop: for (Class<?> type : types) {
                        for (ElementMatcher<? super TypeDescription> matcher : matchers) {
                            if (matcher.matches(TypeDescription.ForLoadedType.of(type))) {
                                matched.get(matcher).add(type);
                                continue typeLoop;
                            }
                        }
                        unmatched.add(type);
                    }
                    List<List<Class<?>>> batches = new ArrayList<List<Class<?>>>(matchers.size() + 1);
                    for (List<Class<?>> batch : matched.values()) {
                        if (!batch.isEmpty()) {
                            batches.add(batch);
                        }
                    }
                    if (!unmatched.isEmpty()) {
                        batches.add(unmatched);
                    }
                    return batches;
                }
            }
            class Slicing implements BatchAllocator {
                private final int minimum;
                private final int maximum;
                private final BatchAllocator batchAllocator;
                protected Slicing(int minimum, int maximum, BatchAllocator batchAllocator) {
                    this.minimum = minimum;
                    this.maximum = maximum;
                    this.batchAllocator = batchAllocator;
                }
                public static BatchAllocator withMinimum(int minimum, BatchAllocator batchAllocator) {
                    return withinRange(minimum, Integer.MAX_VALUE, batchAllocator);
                }
                public static BatchAllocator withMaximum(int maximum, BatchAllocator batchAllocator) {
                    return withinRange(1, maximum, batchAllocator);
                }
                public static BatchAllocator withinRange(int minimum, int maximum, BatchAllocator batchAllocator) {
                    if (minimum <= 0) {
                        throw new IllegalArgumentException("Minimum must be a positive number: " + minimum);
                    } else if (minimum > maximum) {
                        throw new IllegalArgumentException("Minimum must not be bigger than maximum: " + minimum + " >" + maximum);
                    }
                    return new Slicing(minimum, maximum, batchAllocator);
                }
                public Iterable<? extends List<Class<?>>> batch(List<Class<?>> types) {
                    return new SlicingIterable(minimum, maximum, batchAllocator.batch(types));
                }
                protected static class SlicingIterable implements Iterable<List<Class<?>>> {
                    private final int minimum;
                    private final int maximum;
                    private final Iterable<? extends List<Class<?>>> iterable;
                    protected SlicingIterable(int minimum, int maximum, Iterable<? extends List<Class<?>>> iterable) {
                        this.minimum = minimum;
                        this.maximum = maximum;
                        this.iterable = iterable;
                    }
                    public Iterator<List<Class<?>>> iterator() {
                        return new SlicingIterator(minimum, maximum, iterable.iterator());
                    }
                    protected static class SlicingIterator implements Iterator<List<Class<?>>> {
                        private final int minimum;
                        private final int maximum;
                        private final Iterator<? extends List<Class<?>>> iterator;
                        private List<Class<?>> buffer;
                        protected SlicingIterator(int minimum, int maximum, Iterator<? extends List<Class<?>>> iterator) {
                            this.minimum = minimum;
                            this.maximum = maximum;
                            this.iterator = iterator;
                            buffer = new ArrayList<Class<?>>();
                        }
                        public boolean hasNext() {
                            return !buffer.isEmpty() || iterator.hasNext();
                        }
                        public List<Class<?>> next() {
                            if (buffer.isEmpty()) {
                                buffer = iterator.next();
                            }
                            while (buffer.size() < minimum && iterator.hasNext()) {
                                buffer.addAll(iterator.next());
                            }
                            if (buffer.size() > maximum) {
                                try {
                                    return buffer.subList(0, maximum);
                                } finally {
                                    buffer = new ArrayList<Class<?>>(buffer.subList(maximum, buffer.size()));
                                }
                            } else {
                                try {
                                    return buffer;
                                } finally {
                                    buffer = new ArrayList<Class<?>>();
                                }
                            }
                        }
                        public void remove() {
                            throw new UnsupportedOperationException("remove");
                        }
                    }
                }
            }
            class Partitioning implements BatchAllocator {
                private final int parts;
                protected Partitioning(int parts) {
                    this.parts = parts;
                }
                public static BatchAllocator of(int parts) {
                    if (parts < 1) {
                        throw new IllegalArgumentException("A batch size must be positive: " + parts);
                    }
                    return new Partitioning(parts);
                }
                public Iterable<? extends List<Class<?>>> batch(List<Class<?>> types) {
                    if (types.isEmpty()) {
                        return Collections.emptyList();
                    } else {
                        List<List<Class<?>>> batches = new ArrayList<List<Class<?>>>();
                        int size = types.size() / parts, reminder = types.size() % parts;
                        for (int index = reminder; index < types.size(); index += size) {
                            batches.add(new ArrayList<Class<?>>(types.subList(index, index + size)));
                        }
                        if (batches.isEmpty()) {
                            return Collections.singletonList(types);
                        } else {
                            batches.get(0).addAll(0, types.subList(0, reminder));
                            return batches;
                        }
                    }
                }
            }
        }
        public interface Listener {
            void onBatch(int index, List<Class<?>> batch, List<Class<?>> types);
            Iterable<? extends List<Class<?>>> onError(int index, List<Class<?>> batch, Throwable throwable, List<Class<?>> types);
            void onComplete(int amount, List<Class<?>> types, Map<List<Class<?>>, Throwable> failures);
            enum NoOp implements Listener {
                INSTANCE;
                public void onBatch(int index, List<Class<?>> batch, List<Class<?>> types) {
                }
                public Iterable<? extends List<Class<?>>> onError(int index, List<Class<?>> batch, Throwable throwable, List<Class<?>> types) {
                    return Collections.emptyList();
                }
                public void onComplete(int amount, List<Class<?>> types, Map<List<Class<?>>, Throwable> failures) {
                }
            }
            enum Yielding implements Listener {
                INSTANCE;
                public void onBatch(int index, List<Class<?>> batch, List<Class<?>> types) {
                    if (index > 0) {
                        Thread.yield();
                    }
                }
                public Iterable<? extends List<Class<?>>> onError(int index, List<Class<?>> batch, Throwable throwable, List<Class<?>> types) {
                    return Collections.emptyList();
                }
                public void onComplete(int amount, List<Class<?>> types, Map<List<Class<?>>, Throwable> failures) {
                }
            }
            enum ErrorEscalating implements Listener {
                FAIL_FAST {
                    public Iterable<? extends List<Class<?>>> onError(int index, List<Class<?>> batch, Throwable throwable, List<Class<?>> types) {
                        throw new IllegalStateException("Could not transform any of " + batch, throwable);
                    }
                    public void onComplete(int amount, List<Class<?>> types, Map<List<Class<?>>, Throwable> failures) {
                    }
                }
                , FAIL_LAST {
                    public Iterable<? extends List<Class<?>>> onError(int index, List<Class<?>> batch, Throwable throwable, List<Class<?>> types) {
                        return Collections.emptyList();
                    }
                    public void onComplete(int amount, List<Class<?>> types, Map<List<Class<?>>, Throwable> failures) {
                        if (!failures.isEmpty()) {
                            throw new IllegalStateException("Could not transform any of " + failures);
                        }
                    }
                }
                ;
                public void onBatch(int index, List<Class<?>> batch, List<Class<?>> types) {
                }
            }
            abstract class Adapter implements Listener {
                public void onBatch(int index, List<Class<?>> batch, List<Class<?>> types) {
                }
                public Iterable<? extends List<Class<?>>> onError(int index, List<Class<?>> batch, Throwable throwable, List<Class<?>> types) {
                    return Collections.emptyList();
                }
                public void onComplete(int amount, List<Class<?>> types, Map<List<Class<?>>, Throwable> failures) {
                }
            }
            class BatchReallocator extends Adapter {
                private final BatchAllocator batchAllocator;
                public BatchReallocator(BatchAllocator batchAllocator) {
                    this.batchAllocator = batchAllocator;
                }
                public static Listener splitting() {
                    return new BatchReallocator(new BatchAllocator.Partitioning(2));
                }
                public Iterable<? extends List<Class<?>>> onError(int index, List<Class<?>> batch, Throwable throwable, List<Class<?>> types) {
                    return batch.size() < 2 ? Collections.<List<Class<?>>>emptyList() : batchAllocator.batch(batch);
                }
            }
            class Pausing extends Adapter {
                private final long value;
                protected Pausing(long value) {
                    this.value = value;
                }
                public static Listener of(long value, TimeUnit timeUnit) {
                    if (value > 0L) {
                        return new Pausing(timeUnit.toMillis(value));
                    } else if (value == 0L) {
                        return NoOp.INSTANCE;
                    } else {
                        throw new IllegalArgumentException("Cannot sleep for a non-positive amount of time: " + value);
                    }
                }
                public void onBatch(int index, List<Class<?>> batch, List<Class<?>> types) {
                    if (index > 0) {
                        try {
                            Thread.sleep(value);
                        } catch (InterruptedException exception) {
                            Thread.currentThread().interrupt();
                            throw new IllegalStateException(exception);
                        }
                    }
                }
            }
            class StreamWriting implements Listener {
                private final PrintStream printStream;
                public StreamWriting(PrintStream printStream) {
                    this.printStream = printStream;
                }
                public static Listener toSystemOut() {
                    return new StreamWriting(System.out);
                }
                public static Listener toSystemError() {
                    return new StreamWriting(System.err);
                }
                public void onBatch(int index, List<Class<?>> batch, List<Class<?>> types) {
                    printStream.printf(AgentBuilder.Listener.StreamWriting.PREFIX + " REDEFINE BATCH #%d [%d of %d type(s)]%n", index, batch.size(), types.size());
                }
                public Iterable<? extends List<Class<?>>> onError(int index, List<Class<?>> batch, Throwable throwable, List<Class<?>> types) {
                    synchronized (printStream) {
                        printStream.printf(AgentBuilder.Listener.StreamWriting.PREFIX + " REDEFINE ERROR #%d [%d of %d type(s)]%n", index, batch.size(), types.size());
                        throwable.printStackTrace(printStream);
                    }
                    return Collections.emptyList();
                }
                public void onComplete(int amount, List<Class<?>> types, Map<List<Class<?>>, Throwable> failures) {
                    printStream.printf(AgentBuilder.Listener.StreamWriting.PREFIX + " REDEFINE COMPLETE %d batch(es) containing %d types [%d failed batch(es)]%n", amount, types.size(), failures.size());
                }
            }
            class Compound implements Listener {
                private final List<Listener> listeners;
                public Compound(Listener... listener) {
                    this(Arrays.asList(listener));
                }
                public Compound(List<? extends Listener> listeners) {
                    this.listeners = new ArrayList<Listener>();
                    for (Listener listener : listeners) {
                        if (listener instanceof Compound) {
                            this.listeners.addAll(((Compound) listener).listeners);
                        } else if (!(listener instanceof NoOp)) {
                            this.listeners.add(listener);
                        }
                    }
                }
                public void onBatch(int index, List<Class<?>> batch, List<Class<?>> types) {
                    for (Listener listener : listeners) {
                        listener.onBatch(index, batch, types);
                    }
                }
                public Iterable<? extends List<Class<?>>> onError(int index, List<Class<?>> batch, Throwable throwable, List<Class<?>> types) {
                    List<Iterable<? extends List<Class<?>>>> reattempts = new ArrayList<Iterable<? extends List<Class<?>>>>();
                    for (Listener listener : listeners) {
                        reattempts.add(listener.onError(index, batch, throwable, types));
                    }
                    return new CompoundIterable(reattempts);
                }
                public void onComplete(int amount, List<Class<?>> types, Map<List<Class<?>>, Throwable> failures) {
                    for (Listener listener : listeners) {
                        listener.onComplete(amount, types, failures);
                    }
                }
                protected static class CompoundIterable implements Iterable<List<Class<?>>> {
                    private final List<Iterable<? extends List<Class<?>>>> iterables;
                    protected CompoundIterable(List<Iterable<? extends List<Class<?>>>> iterables) {
                        this.iterables = iterables;
                    }
                    public Iterator<List<Class<?>>> iterator() {
                        return new CompoundIterator(new ArrayList<Iterable<? extends List<Class<?>>>>(iterables));
                    }
                    protected static class CompoundIterator implements Iterator<List<Class<?>>> {
                        private Iterator<? extends List<Class<?>>> current;
                        private final List<Iterable<? extends List<Class<?>>>> backlog;
                        protected CompoundIterator(List<Iterable<? extends List<Class<?>>>> iterables) {
                            backlog = iterables;
                            forward();
                        }
                        public boolean hasNext() {
                            return current != null && current.hasNext();
                        }
                        public List<Class<?>> next() {
                            try {
                                if (current != null) {
                                    return current.next();
                                } else {
                                    throw new NoSuchElementException();
                                }
                            } finally {
                                forward();
                            }
                        }
                        private void forward() {
                            while ((current == null || !current.hasNext()) && !backlog.isEmpty()) {
                                current = backlog.remove(0).iterator();
                            }
                        }
                        public void remove() {
                            throw new UnsupportedOperationException("remove");
                        }
                    }
                }
            }
        }
        public interface DiscoveryStrategy {
            Iterable<Iterable<Class<?>>> resolve(Instrumentation instrumentation);
            enum SinglePass implements DiscoveryStrategy {
                INSTANCE;
                public Iterable<Iterable<Class<?>>> resolve(Instrumentation instrumentation) {
                    return Collections.<Iterable<Class<?>>>singleton(Arrays.<Class<?>>asList(instrumentation.getAllLoadedClasses()));
                }
            }
            enum Reiterating implements DiscoveryStrategy {
                INSTANCE;
                public Iterable<Iterable<Class<?>>> resolve(Instrumentation instrumentation) {
                    return new ReiteratingIterable(instrumentation);
                }
                protected static class ReiteratingIterable implements Iterable<Iterable<Class<?>>> {
                    private final Instrumentation instrumentation;
                    protected ReiteratingIterable(Instrumentation instrumentation) {
                        this.instrumentation = instrumentation;
                    }
                    public Iterator<Iterable<Class<?>>> iterator() {
                        return new ReiteratingIterator(instrumentation);
                    }
                }
                protected static class ReiteratingIterator implements Iterator<Iterable<Class<?>>> {
                    private final Instrumentation instrumentation;
                    private final Set<Class<?>> processed;
                    private List<Class<?>> types;
                    protected ReiteratingIterator(Instrumentation instrumentation) {
                        this.instrumentation = instrumentation;
                        processed = new HashSet<Class<?>>();
                    }
                    public boolean hasNext() {
                        if (types == null) {
                            types = new ArrayList<Class<?>>();
                            for (Class<?> type : instrumentation.getAllLoadedClasses()) {
                                if (type != null && processed.add(type)) {
                                    types.add(type);
                                }
                            }
                        }
                        return !types.isEmpty();
                    }
                    public Iterable<Class<?>> next() {
                        if (hasNext()) {
                            try {
                                return types;
                            } finally {
                                types = null;
                            }
                        } else {
                            throw new NoSuchElementException();
                        }
                    }
                    public void remove() {
                        throw new UnsupportedOperationException("remove");
                    }
                }
                public enum WithSortOrderAssumption implements DiscoveryStrategy {
                    INSTANCE;
                    public Iterable<Iterable<Class<?>>> resolve(Instrumentation instrumentation) {
                        return new OrderedReiteratingIterable(instrumentation);
                    }
                    protected static class OrderedReiteratingIterable implements Iterable<Iterable<Class<?>>> {
                        private final Instrumentation instrumentation;
                        protected OrderedReiteratingIterable(Instrumentation instrumentation) {
                            this.instrumentation = instrumentation;
                        }
                        public Iterator<Iterable<Class<?>>> iterator() {
                            return new OrderedReiteratingIterator(instrumentation);
                        }
                    }
                    protected static class OrderedReiteratingIterator implements Iterator<Iterable<Class<?>>> {
                        private final Instrumentation instrumentation;
                        private int index;
                        private List<Class<?>> types;
                        protected OrderedReiteratingIterator(Instrumentation instrumentation) {
                            this.instrumentation = instrumentation;
                            index = 0;
                        }
                        public boolean hasNext() {
                            if (types == null) {
                                Class<?>[] type = instrumentation.getAllLoadedClasses();
                                types = new ArrayList<Class<?>>(Arrays.asList(type).subList(index, type.length));
                                index = type.length;
                            }
                            return !types.isEmpty();
                        }
                        public Iterable<Class<?>> next() {
                            if (hasNext()) {
                                try {
                                    return types;
                                } finally {
                                    types = null;
                                }
                            } else {
                                throw new NoSuchElementException();
                            }
                        }
                        public void remove() {
                            throw new UnsupportedOperationException("remove");
                        }
                    }
                }
            }
            class Explicit implements DiscoveryStrategy {
                private final Set<Class<?>> types;
                public Explicit(Class<?>... type) {
                    this(new LinkedHashSet<Class<?>>(Arrays.asList(type)));
                }
                public Explicit(Set<Class<?>> types) {
                    this.types = types;
                }
                public Iterable<Iterable<Class<?>>> resolve(Instrumentation instrumentation) {
                    return Collections.<Iterable<Class<?>>>singleton(types);
                }
            }
        }
        public interface ResubmissionScheduler {
            boolean isAlive();
            Cancelable schedule(Runnable job);
            interface Cancelable {
                void cancel();
                enum NoOp implements Cancelable {
                    INSTANCE;
                    public void cancel() {
                    }
                }
                class ForFuture implements Cancelable {
                    private final Future<?> future;
                    public ForFuture(Future<?> future) {
                        this.future = future;
                    }
                    public void cancel() {
                        future.cancel(true);
                    }
                }
            }
            enum NoOp implements ResubmissionScheduler {
                INSTANCE;
                public boolean isAlive() {
                    return false;
                }
                public Cancelable schedule(Runnable job) {
                    return Cancelable.NoOp.INSTANCE;
                }
            }
            class AtFixedRate implements ResubmissionScheduler {
                private final ScheduledExecutorService scheduledExecutorService;
                private final long time;
                private final TimeUnit timeUnit;
                public AtFixedRate(ScheduledExecutorService scheduledExecutorService, long time, TimeUnit timeUnit) {
                    this.scheduledExecutorService = scheduledExecutorService;
                    this.time = time;
                    this.timeUnit = timeUnit;
                }
                public boolean isAlive() {
                    return !scheduledExecutorService.isShutdown();
                }
                public Cancelable schedule(Runnable job) {
                    return new Cancelable.ForFuture(scheduledExecutorService.scheduleAtFixedRate(job, time, time, timeUnit));
                }
            }
            class WithFixedDelay implements ResubmissionScheduler {
                private final ScheduledExecutorService scheduledExecutorService;
                private final long time;
                private final TimeUnit timeUnit;
                public WithFixedDelay(ScheduledExecutorService scheduledExecutorService, long time, TimeUnit timeUnit) {
                    this.scheduledExecutorService = scheduledExecutorService;
                    this.time = time;
                    this.timeUnit = timeUnit;
                }
                public boolean isAlive() {
                    return !scheduledExecutorService.isShutdown();
                }
                public Cancelable schedule(Runnable job) {
                    return new Cancelable.ForFuture(scheduledExecutorService.scheduleWithFixedDelay(job, time, time, timeUnit));
                }
            }
        }
        protected interface ResubmissionStrategy {
            Installation apply(Instrumentation instrumentation, PoolStrategy poolStrategy, LocationStrategy locationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, AgentBuilder.Listener listener, InstallationListener installationListener, CircularityLock circularityLock, RawMatcher matcher, RedefinitionStrategy redefinitionStrategy, RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator, RedefinitionStrategy.Listener redefinitionBatchListener);
            enum Disabled implements ResubmissionStrategy {
                INSTANCE;
                public Installation apply(Instrumentation instrumentation, PoolStrategy poolStrategy, LocationStrategy locationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, AgentBuilder.Listener listener, InstallationListener installationListener, CircularityLock circularityLock, RawMatcher matcher, RedefinitionStrategy redefinitionStrategy, RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator, RedefinitionStrategy.Listener redefinitionBatchListener) {
                    return new Installation(listener, installationListener, ResubmissionEnforcer.Disabled.INSTANCE);
                }
            }
            class Enabled implements ResubmissionStrategy {
                private final ResubmissionScheduler resubmissionScheduler;
                private final RedefinitionListenable.ResubmissionOnErrorMatcher resubmissionOnErrorMatcher;
                private final RedefinitionListenable.ResubmissionImmediateMatcher resubmissionImmediateMatcher;
                protected Enabled(ResubmissionScheduler resubmissionScheduler, RedefinitionListenable.ResubmissionOnErrorMatcher resubmissionOnErrorMatcher, RedefinitionListenable.ResubmissionImmediateMatcher resubmissionImmediateMatcher) {
                    this.resubmissionScheduler = resubmissionScheduler;
                    this.resubmissionOnErrorMatcher = resubmissionOnErrorMatcher;
                    this.resubmissionImmediateMatcher = resubmissionImmediateMatcher;
                }
                public Installation apply(Instrumentation instrumentation, PoolStrategy poolStrategy, LocationStrategy locationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, AgentBuilder.Listener listener, InstallationListener installationListener, CircularityLock circularityLock, RawMatcher matcher, RedefinitionStrategy redefinitionStrategy, RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator, RedefinitionStrategy.Listener redefinitionBatchListener) {
                    if (resubmissionScheduler.isAlive()) {
                        ConcurrentMap<StorageKey, Set<String>> types = new ConcurrentHashMap<StorageKey, Set<String>>();
                        Resubmitter resubmitter = new Resubmitter(resubmissionOnErrorMatcher, resubmissionImmediateMatcher, types);
                        return new Installation(new AgentBuilder.Listener.Compound(resubmitter, listener), new InstallationListener.Compound(new ResubmissionInstallationListener(instrumentation, resubmissionScheduler, poolStrategy, locationStrategy, descriptionStrategy, fallbackStrategy, listener, circularityLock, matcher, redefinitionStrategy, redefinitionBatchAllocator, redefinitionBatchListener, types), installationListener), resubmitter);
                    } else {
                        throw new IllegalStateException("Resubmission scheduler " + resubmissionScheduler + " is not alive");
                    }
                }
                protected static class Resubmitter extends AgentBuilder.Listener.Adapter implements ResubmissionEnforcer {
                    private final RedefinitionListenable.ResubmissionOnErrorMatcher resubmissionOnErrorMatcher;
                    private final RedefinitionListenable.ResubmissionImmediateMatcher resubmissionImmediateMatcher;
                    private final ConcurrentMap<StorageKey, Set<String>> types;
                    protected Resubmitter(RedefinitionListenable.ResubmissionOnErrorMatcher resubmissionOnErrorMatcher, RedefinitionListenable.ResubmissionImmediateMatcher resubmissionImmediateMatcher, ConcurrentMap<StorageKey, Set<String>> types) {
                        this.resubmissionOnErrorMatcher = resubmissionOnErrorMatcher;
                        this.resubmissionImmediateMatcher = resubmissionImmediateMatcher;
                        this.types = types;
                    }
                    public void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable) {
                        if (!loaded && resubmissionOnErrorMatcher.matches(throwable, typeName, classLoader, module)) {
                            Set<String> types = this.types.get(new LookupKey(classLoader));
                            if (types == null) {
                                types = new ConcurrentHashSet<String>();
                                Set<String> previous = this.types.putIfAbsent(new StorageKey(classLoader), types);
                                if (previous != null) {
                                    types = previous;
                                }
                            }
                            types.add(typeName);
                        }
                    }
                    public boolean isEnforced(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined) {
                        if (classBeingRedefined == null && resubmissionImmediateMatcher.matches(typeName, classLoader, module)) {
                            Set<String> types = this.types.get(new LookupKey(classLoader));
                            if (types == null) {
                                types = new ConcurrentHashSet<String>();
                                Set<String> previous = this.types.putIfAbsent(new StorageKey(classLoader), types);
                                if (previous != null) {
                                    types = previous;
                                }
                            }
                            types.add(typeName);
                            return true;
                        } else {
                            return false;
                        }
                    }
                    protected static class ConcurrentHashSet<T> extends AbstractSet<T> {
                        private final ConcurrentMap<T, Boolean> delegate;
                        protected ConcurrentHashSet() {
                            delegate = new ConcurrentHashMap<T, Boolean>();
                        }
                        public boolean add(T value) {
                            return delegate.put(value, Boolean.TRUE) == null;
                        }
                        public boolean remove(Object value) {
                            return delegate.remove(value) != null;
                        }
                        public Iterator<T> iterator() {
                            return delegate.keySet().iterator();
                        }
                        public int size() {
                            return delegate.size();
                        }
                    }
                }
                protected static class ResubmissionInstallationListener extends AgentBuilder.InstallationListener.Adapter implements Runnable {
                    private final Instrumentation instrumentation;
                    private final ResubmissionScheduler resubmissionScheduler;
                    private final LocationStrategy locationStrategy;
                    private final PoolStrategy poolStrategy;
                    private final DescriptionStrategy descriptionStrategy;
                    private final FallbackStrategy fallbackStrategy;
                    private final AgentBuilder.Listener listener;
                    private final CircularityLock circularityLock;
                    private final RawMatcher matcher;
                    private final RedefinitionStrategy redefinitionStrategy;
                    private final BatchAllocator redefinitionBatchAllocator;
                    private final Listener redefinitionBatchListener;
                    private final ConcurrentMap<StorageKey, Set<String>> types;
                    private volatile ResubmissionScheduler.Cancelable cancelable;
                    protected ResubmissionInstallationListener(Instrumentation instrumentation, ResubmissionScheduler resubmissionScheduler, PoolStrategy poolStrategy, LocationStrategy locationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, AgentBuilder.Listener listener, CircularityLock circularityLock, RawMatcher matcher, RedefinitionStrategy redefinitionStrategy, BatchAllocator redefinitionBatchAllocator, Listener redefinitionBatchListener, ConcurrentMap<StorageKey, Set<String>> types) {
                        this.instrumentation = instrumentation;
                        this.resubmissionScheduler = resubmissionScheduler;
                        this.poolStrategy = poolStrategy;
                        this.locationStrategy = locationStrategy;
                        this.descriptionStrategy = descriptionStrategy;
                        this.fallbackStrategy = fallbackStrategy;
                        this.listener = listener;
                        this.circularityLock = circularityLock;
                        this.matcher = matcher;
                        this.redefinitionStrategy = redefinitionStrategy;
                        this.redefinitionBatchAllocator = redefinitionBatchAllocator;
                        this.redefinitionBatchListener = redefinitionBatchListener;
                        this.types = types;
                    }
                    public void onInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
                        cancelable = resubmissionScheduler.schedule(this);
                    }
                    public void onReset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
                        ResubmissionScheduler.Cancelable cancelable = this.cancelable;
                        if (cancelable != null) {
                            cancelable.cancel();
                        }
                    }
                    public void run() {
                        boolean release = circularityLock.acquire();
                        try {
                            RedefinitionStrategy.Collector collector = redefinitionStrategy.make(poolStrategy, locationStrategy, descriptionStrategy, fallbackStrategy, listener, matcher, circularityLock);
                            Iterator<Map.Entry<StorageKey, Set<String>>> entries = types.entrySet().iterator();
                            while (entries.hasNext()) {
                                if (Thread.interrupted()) {
                                    return;
                                }
                                Map.Entry<StorageKey, Set<String>> entry = entries.next();
                                ClassLoader classLoader = entry.getKey().get();
                                if (classLoader != null || entry.getKey().isBootstrapLoader()) {
                                    Iterator<String> iterator = entry.getValue().iterator();
                                    while (iterator.hasNext()) {
                                        if (Thread.interrupted()) {
                                            return;
                                        }
                                        try {
                                            Class<?> type = Class.forName(iterator.next(), false, classLoader);
                                            collector.consider(type, !type.isArray() && !type.isPrimitive() && (DISPATCHER.isModifiableClass(instrumentation, type) || ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isAtMost(ClassFileVersion.JAVA_V5)));
                                        } catch (Throwable ignored) {
                                        } finally {
                                            iterator.remove();
                                        }
                                    }
                                } else {
                                    entries.remove();
                                }
                            }
                            collector.apply(instrumentation, redefinitionBatchAllocator, redefinitionBatchListener, BatchAllocator.FIRST_BATCH);
                        } finally {
                            if (release) {
                                circularityLock.release();
                            }
                        }
                    }
                }
                protected static class LookupKey {
                    private final ClassLoader classLoader;
                    private final int hashCode;
                    protected LookupKey(@MaybeNull ClassLoader classLoader) {
                        this.classLoader = classLoader;
                        hashCode = System.identityHashCode(classLoader);
                    }
                    public int hashCode() {
                        return hashCode;
                    }
                    public boolean equals(@MaybeNull Object other) {
                        if (this == other) {
                            return true;
                        } else if (other instanceof LookupKey) {
                            return classLoader == ((LookupKey) other).classLoader;
                        } else if (other instanceof StorageKey) {
                            StorageKey storageKey = (StorageKey) other;
                            return hashCode == storageKey.hashCode && classLoader == storageKey.get();
                        } else {
                            return false;
                        }
                    }
                }
                protected static class StorageKey extends WeakReference<ClassLoader> {
                    private final int hashCode;
                    protected StorageKey(@MaybeNull ClassLoader classLoader) {
                        super(classLoader);
                        hashCode = System.identityHashCode(classLoader);
                    }
                    protected boolean isBootstrapLoader() {
                        return hashCode == 0;
                    }
                    public int hashCode() {
                        return hashCode;
                    }
                    public boolean equals(@MaybeNull Object other) {
                        if (this == other) {
                            return true;
                        } else if (other instanceof LookupKey) {
                            LookupKey lookupKey = (LookupKey) other;
                            return hashCode == lookupKey.hashCode && get() == lookupKey.classLoader;
                        } else if (other instanceof StorageKey) {
                            StorageKey storageKey = (StorageKey) other;
                            return hashCode == storageKey.hashCode && get() == storageKey.get();
                        } else {
                            return false;
                        }
                    }
                }
            }
            class Installation {
                private final AgentBuilder.Listener listener;
                private final InstallationListener installationListener;
                private final ResubmissionEnforcer resubmissionEnforcer;
                protected Installation(AgentBuilder.Listener listener, InstallationListener installationListener, ResubmissionEnforcer resubmissionEnforcer) {
                    this.listener = listener;
                    this.installationListener = installationListener;
                    this.resubmissionEnforcer = resubmissionEnforcer;
                }
                protected AgentBuilder.Listener getListener() {
                    return listener;
                }
                protected InstallationListener getInstallationListener() {
                    return installationListener;
                }
                protected ResubmissionEnforcer getResubmissionEnforcer() {
                    return resubmissionEnforcer;
                }
            }
        }
        protected interface ResubmissionEnforcer {
            boolean isEnforced(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined);
            enum Disabled implements ResubmissionEnforcer {
                INSTANCE;
                public boolean isEnforced(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined) {
                    return false;
                }
            }
        }
        protected interface Dispatcher {
            boolean isModifiableClass(Instrumentation instrumentation, Class<?> type);
            boolean isRetransformClassesSupported(Instrumentation instrumentation);
            void retransformClasses(Instrumentation instrumentation, Class<?>[] type) throws UnmodifiableClassException;
        }
        protected abstract static class Collector {
            private final RawMatcher matcher;
            private final PoolStrategy poolStrategy;
            protected final LocationStrategy locationStrategy;
            private final DescriptionStrategy descriptionStrategy;
            protected final AgentBuilder.Listener listener;
            private final FallbackStrategy fallbackStrategy;
            protected final CircularityLock circularityLock;
            protected final List<Class<?>> types;
            protected Collector(RawMatcher matcher, PoolStrategy poolStrategy, LocationStrategy locationStrategy, DescriptionStrategy descriptionStrategy, AgentBuilder.Listener listener, FallbackStrategy fallbackStrategy, CircularityLock circularityLock) {
                this.matcher = matcher;
                this.poolStrategy = poolStrategy;
                this.locationStrategy = locationStrategy;
                this.descriptionStrategy = descriptionStrategy;
                this.listener = listener;
                this.fallbackStrategy = fallbackStrategy;
                this.circularityLock = circularityLock;
                types = new ArrayList<Class<?>>();
            }
            protected void consider(Class<?> type, boolean modifiable) {
                JavaModule module = JavaModule.ofType(type);
                try {
                    TypePool typePool = poolStrategy.typePool(locationStrategy.classFileLocator(type.getClassLoader(), module), type.getClassLoader());
                    try {
                        doConsider(matcher, listener, descriptionStrategy.apply(TypeDescription.ForLoadedType.getName(type), type, typePool, circularityLock, type.getClassLoader(), module), type, type, module, modifiable);
                    } catch (Throwable throwable) {
                        if (descriptionStrategy.isLoadedFirst() && fallbackStrategy.isFallback(type, throwable)) {
                            doConsider(matcher, listener, typePool.describe(TypeDescription.ForLoadedType.getName(type)).resolve(), type, null, module, true);
                        } else {
                            throw throwable;
                        }
                    }
                } catch (Throwable throwable) {
                    try {
                        try {
                            listener.onDiscovery(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, AgentBuilder.Listener.LOADED);
                        } finally {
                            try {
                                listener.onError(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, AgentBuilder.Listener.LOADED, throwable);
                            } finally {
                                listener.onComplete(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, AgentBuilder.Listener.LOADED);
                            }
                        }
                    } catch (Throwable ignored) {
                    }
                }
            }
            private void doConsider(RawMatcher matcher, AgentBuilder.Listener listener, TypeDescription typeDescription, Class<?> type, @MaybeNull Class<?> classBeingRedefined, @MaybeNull JavaModule module, boolean modifiable) {
                if (!modifiable || !matcher.matches(typeDescription, type.getClassLoader(), module, classBeingRedefined, type.getProtectionDomain())) {
                    try {
                        try {
                            listener.onDiscovery(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, classBeingRedefined != null);
                            listener.onIgnored(typeDescription, type.getClassLoader(), module, classBeingRedefined != null);
                        } catch (Throwable throwable) {
                            listener.onError(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, classBeingRedefined != null, throwable);
                        } finally {
                            listener.onComplete(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, classBeingRedefined != null);
                        }
                    } catch (Throwable ignored) {
                    }
                } else {
                    types.add(type);
                }
            }
            protected int apply(Instrumentation instrumentation, BatchAllocator redefinitionBatchAllocator, Listener redefinitionListener, int batch) {
                Map<List<Class<?>>, Throwable> failures = new HashMap<List<Class<?>>, Throwable>();
                PrependableIterator prependableIterator = new PrependableIterator(redefinitionBatchAllocator.batch(this.types));
                while (prependableIterator.hasNext()) {
                    List<Class<?>> types = prependableIterator.next();
                    redefinitionListener.onBatch(batch, types, this.types);
                    try {
                        doApply(instrumentation, types);
                    } catch (Throwable throwable) {
                        prependableIterator.prepend(redefinitionListener.onError(batch, types, throwable, this.types));
                        failures.put(types, throwable);
                    }
                    batch += 1;
                }
                redefinitionListener.onComplete(batch, types, failures);
                return batch;
            }
            protected abstract void doApply(Instrumentation instrumentation, List<Class<?>> types) throws UnmodifiableClassException, ClassNotFoundException;
            protected static class PrependableIterator implements Iterator<List<Class<?>>> {
                private Iterator<? extends List<Class<?>>> current;
                private final List<Iterator<? extends List<Class<?>>>> backlog;
                protected PrependableIterator(Iterable<? extends List<Class<?>>> origin) {
                    current = origin.iterator();
                    backlog = new ArrayList<Iterator<? extends List<Class<?>>>>();
                }
                public void prepend(Iterable<? extends List<Class<?>>> iterable) {
                    Iterator<? extends List<Class<?>>> iterator = iterable.iterator();
                    if (iterator.hasNext()) {
                        if (current.hasNext()) {
                            backlog.add(current);
                        }
                        current = iterator;
                    }
                }
                public boolean hasNext() {
                    return current.hasNext();
                }
                public List<Class<?>> next() {
                    try {
                        return current.next();
                    } finally {
                        while (!current.hasNext() && !backlog.isEmpty()) {
                            current = backlog.remove(backlog.size() - 1);
                        }
                    }
                }
                public void remove() {
                    throw new UnsupportedOperationException("remove");
                }
            }
            protected static class ForRedefinition extends Collector {
                protected ForRedefinition(RawMatcher matcher, PoolStrategy poolStrategy, LocationStrategy locationStrategy, DescriptionStrategy descriptionStrategy, AgentBuilder.Listener listener, FallbackStrategy fallbackStrategy, CircularityLock circularityLock) {
                    super(matcher, poolStrategy, locationStrategy, descriptionStrategy, listener, fallbackStrategy, circularityLock);
                }
                protected void doApply(Instrumentation instrumentation, List<Class<?>> types) throws UnmodifiableClassException, ClassNotFoundException {
                    List<ClassDefinition> classDefinitions = new ArrayList<ClassDefinition>(types.size());
                    for (Class<?> type : types) {
                        try {
                            try {
                                classDefinitions.add(new ClassDefinition(type, locationStrategy.classFileLocator(type.getClassLoader(), JavaModule.ofType(type)).locate(TypeDescription.ForLoadedType.getName(type)).resolve()));
                            } catch (Throwable throwable) {
                                JavaModule module = JavaModule.ofType(type);
                                try {
                                    listener.onDiscovery(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, AgentBuilder.Listener.LOADED);
                                } finally {
                                    try {
                                        listener.onError(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, AgentBuilder.Listener.LOADED, throwable);
                                    } finally {
                                        listener.onComplete(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, AgentBuilder.Listener.LOADED);
                                    }
                                }
                            }
                        } catch (Throwable ignored) {
                        }
                    }
                    if (!classDefinitions.isEmpty()) {
                        circularityLock.release();
                        try {
                            instrumentation.redefineClasses(classDefinitions.toArray(new ClassDefinition[0]));
                        } finally {
                            circularityLock.acquire();
                        }
                    }
                }
            }
            protected static class ForRetransformation extends Collector {
                protected ForRetransformation(RawMatcher matcher, PoolStrategy poolStrategy, LocationStrategy locationStrategy, DescriptionStrategy descriptionStrategy, AgentBuilder.Listener listener, FallbackStrategy fallbackStrategy, CircularityLock circularityLock) {
                    super(matcher, poolStrategy, locationStrategy, descriptionStrategy, listener, fallbackStrategy, circularityLock);
                }
                protected void doApply(Instrumentation instrumentation, List<Class<?>> types) throws UnmodifiableClassException {
                    if (!types.isEmpty()) {
                        circularityLock.release();
                        try {
                            DISPATCHER.retransformClasses(instrumentation, types.toArray(new Class<?>[0]));
                        } finally {
                            circularityLock.acquire();
                        }
                    }
                }
            }
        }
    }
    enum LambdaInstrumentationStrategy {
        ENABLED {
            @Override
            protected void apply(ByteBuddy byteBuddy, Instrumentation instrumentation, ClassFileTransformer classFileTransformer) {
                if (LambdaFactory.register(classFileTransformer, new LambdaInstanceFactory(byteBuddy))) {
                    Class<?> lambdaMetaFactory;
                    try {
                        lambdaMetaFactory = Class.forName("java.lang.invoke.LambdaMetafactory");
                    } catch (ClassNotFoundException ignored) {
                        return;
                    }
                    byteBuddy.with(Implementation.Context.Disabled.Factory.INSTANCE).redefine(lambdaMetaFactory).method(ElementMatchers.<MethodDescription>isPublic().and(named("metafactory"))).intercept(new Implementation.Simple(LambdaMetafactoryFactory.REGULAR)).method(ElementMatchers.<MethodDescription>isPublic().and(named("altMetafactory"))).intercept(new Implementation.Simple(LambdaMetafactoryFactory.ALTERNATIVE)).make().load(lambdaMetaFactory.getClassLoader(), ClassReloadingStrategy.of(instrumentation));
                }
            }
            @Override
            protected boolean isInstrumented(@MaybeNull Class<?> type) {
                return true;
            }
        }
        , DISABLED {
            @Override
            protected void apply(ByteBuddy byteBuddy, Instrumentation instrumentation, ClassFileTransformer classFileTransformer) {
            }
            @Override
            protected boolean isInstrumented(@MaybeNull Class<?> type) {
                return type == null || !type.getName().contains("/");
            }
        }
        ;
        public static void release(ClassFileTransformer classFileTransformer, Instrumentation instrumentation) {
            if (LambdaFactory.release(classFileTransformer)) {
                try {
                    ClassReloadingStrategy.of(instrumentation).reset(Class.forName("java.lang.invoke.LambdaMetafactory"));
                } catch (Exception exception) {
                    throw new IllegalStateException("Could not release lambda transformer", exception);
                }
            }
        }
        public static LambdaInstrumentationStrategy of(boolean enabled) {
            return enabled ? ENABLED : DISABLED;
        }
        protected abstract void apply(ByteBuddy byteBuddy, Instrumentation instrumentation, ClassFileTransformer classFileTransformer);
        public boolean isEnabled() {
            return this == ENABLED;
        }
        protected abstract boolean isInstrumented(@MaybeNull Class<?> type);
        protected enum LambdaMetafactoryFactory implements ByteCodeAppender {
            REGULAR(6, 11) {
                @Override
                protected void onDispatch(MethodVisitor methodVisitor) {
                    methodVisitor.visitInsn(Opcodes.ICONST_0);
                    methodVisitor.visitVarInsn(Opcodes.ISTORE, 6);
                    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, "java/util/Collections", "emptyList", "()Ljava/util/List;", false);
                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 7);
                    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, "java/util/Collections", "emptyList", "()Ljava/util/List;", false);
                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 8);
                    methodVisitor.visitFrame(Opcodes.F_APPEND, 3, new Object[] { Opcodes.INTEGER, "java/util/List", "java/util/List" }, 0, null);
                }
            }
            , ALTERNATIVE(6, 16) {
                @Override
                protected void onDispatch(MethodVisitor methodVisitor) {
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);
                    methodVisitor.visitInsn(Opcodes.ICONST_3);
                    methodVisitor.visitInsn(Opcodes.AALOAD);
                    methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/Integer");
                    methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false);
                    methodVisitor.visitVarInsn(Opcodes.ISTORE, 4);
                    methodVisitor.visitInsn(Opcodes.ICONST_4);
                    methodVisitor.visitVarInsn(Opcodes.ISTORE, 5);
                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 4);
                    methodVisitor.visitInsn(Opcodes.ICONST_2);
                    methodVisitor.visitInsn(Opcodes.IAND);
                    Label first = new Label();
                    methodVisitor.visitJumpInsn(Opcodes.IFEQ, first);
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);
                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 5);
                    methodVisitor.visitIincInsn(5, 1);
                    methodVisitor.visitInsn(Opcodes.AALOAD);
                    methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/Integer");
                    methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false);
                    methodVisitor.visitVarInsn(Opcodes.ISTORE, 7);
                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 7);
                    methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Class");
                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 6);
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);
                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 5);
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 6);
                    methodVisitor.visitInsn(Opcodes.ICONST_0);
                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 7);
                    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/System", "arraycopy", "(Ljava/lang/Object;ILjava/lang/Object;II)V", false);
                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 5);
                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 7);
                    methodVisitor.visitInsn(Opcodes.IADD);
                    methodVisitor.visitVarInsn(Opcodes.ISTORE, 5);
                    Label second = new Label();
                    methodVisitor.visitJumpInsn(Opcodes.GOTO, second);
                    methodVisitor.visitLabel(first);
                    methodVisitor.visitFrame(Opcodes.F_APPEND, 2, new Object[] { Opcodes.INTEGER, Opcodes.INTEGER }, 0, null);
                    methodVisitor.visitInsn(Opcodes.ICONST_0);
                    methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Class");
                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 6);
                    methodVisitor.visitLabel(second);
                    methodVisitor.visitFrame(Opcodes.F_APPEND, 1, new Object[] { "[Ljava/lang/Class;" }, 0, null);
                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 4);
                    methodVisitor.visitInsn(Opcodes.ICONST_2);
                    methodVisitor.visitInsn(Opcodes.IAND);
                    Label third = new Label();
                    methodVisitor.visitJumpInsn(Opcodes.IFEQ, third);
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);
                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 5);
                    methodVisitor.visitIincInsn(5, 1);
                    methodVisitor.visitInsn(Opcodes.AALOAD);
                    methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/Integer");
                    methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false);
                    methodVisitor.visitVarInsn(Opcodes.ISTORE, 8);
                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 8);
                    methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/invoke/MethodType");
                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 7);
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);
                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 5);
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 7);
                    methodVisitor.visitInsn(Opcodes.ICONST_0);
                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 8);
                    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/System", "arraycopy", "(Ljava/lang/Object;ILjava/lang/Object;II)V", false);
                    Label forth = new Label();
                    methodVisitor.visitJumpInsn(Opcodes.GOTO, forth);
                    methodVisitor.visitLabel(third);
                    methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);
                    methodVisitor.visitInsn(Opcodes.ICONST_0);
                    methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/invoke/MethodType");
                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 7);
                    methodVisitor.visitLabel(forth);
                    methodVisitor.visitFrame(Opcodes.F_APPEND, 1, new Object[] { "[Ljava/lang/invoke/MethodType;" }, 0, null);
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);
                    methodVisitor.visitInsn(Opcodes.ICONST_0);
                    methodVisitor.visitInsn(Opcodes.AALOAD);
                    methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/invoke/MethodType");
                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 8);
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);
                    methodVisitor.visitInsn(Opcodes.ICONST_1);
                    methodVisitor.visitInsn(Opcodes.AALOAD);
                    methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/invoke/MethodHandle");
                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 9);
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);
                    methodVisitor.visitInsn(Opcodes.ICONST_2);
                    methodVisitor.visitInsn(Opcodes.AALOAD);
                    methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, "java/lang/invoke/MethodType");
                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 10);
                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 4);
                    methodVisitor.visitInsn(Opcodes.ICONST_1);
                    methodVisitor.visitInsn(Opcodes.IAND);
                    Label fifth = new Label();
                    methodVisitor.visitJumpInsn(Opcodes.IFEQ, fifth);
                    methodVisitor.visitInsn(Opcodes.ICONST_1);
                    Label sixth = new Label();
                    methodVisitor.visitJumpInsn(Opcodes.GOTO, sixth);
                    methodVisitor.visitLabel(fifth);
                    methodVisitor.visitFrame(Opcodes.F_APPEND, 3, new Object[] { "java/lang/invoke/MethodType", "java/lang/invoke/MethodHandle", "java/lang/invoke/MethodType" }, 0, null);
                    methodVisitor.visitInsn(Opcodes.ICONST_0);
                    methodVisitor.visitLabel(sixth);
                    methodVisitor.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[] { Opcodes.INTEGER });
                    methodVisitor.visitVarInsn(Opcodes.ISTORE, 11);
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 6);
                    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, "java/util/Arrays", "asList", "([Ljava/lang/Object;)Ljava/util/List;", false);
                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 12);
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 7);
                    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, "java/util/Arrays", "asList", "([Ljava/lang/Object;)Ljava/util/List;", false);
                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 13);
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 8);
                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 3);
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 9);
                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 4);
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 10);
                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 5);
                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 11);
                    methodVisitor.visitVarInsn(Opcodes.ISTORE, 6);
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 12);
                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 7);
                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 13);
                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 8);
                    methodVisitor.visitFrame(Opcodes.F_FULL, 9, new Object[] { "java/lang/invoke/MethodHandles$Lookup", "java/lang/String", "java/lang/invoke/MethodType", "java/lang/invoke/MethodType", "java/lang/invoke/MethodHandle", "java/lang/invoke/MethodType", Opcodes.INTEGER, "java/util/List", "java/util/List" }, 0, null);
                }
            }
            ;
            private static final Loader LOADER = resolve();
            private static Loader resolve() {
                try {
                    Class<?> type = Class.forName("java.lang.invoke.MethodHandles$Lookup", false, null);
                    type.getMethod("defineHiddenClass", byte[].class, boolean.class, Class.forName("[Ljava.lang.invoke.MethodHandles$Lookup$ClassOption;", false, null));
                    type.getMethod("defineHiddenClassWithClassData", byte[].class, Object.class, boolean.class, Class.forName("[Ljava.lang.invoke.MethodHandles$Lookup$ClassOption;", false, null));
                    return Loader.UsingMethodHandleLookup.INSTANCE;
                } catch (Exception ignored) {
                }
                for (Loader.UsingUnsafe loader : Loader.UsingUnsafe.values()) {
                    try {
                        Class.forName(loader.getType().replace('/', '.'), false, null).getMethod("defineAnonymousClass", Class.class, byte[].class, Object[].class);
                        return loader;
                    } catch (Exception ignored) {
                    }
                }
                return Loader.Unavailable.INSTANCE;
            }
            private final int stackSize;
            private final int localVariableLength;
            LambdaMetafactoryFactory(int stackSize, int localVariableLength) {
                this.stackSize = stackSize;
                this.localVariableLength = localVariableLength;
            }
            public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
                onDispatch(methodVisitor);
                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/ClassLoader", "getSystemClassLoader", "()Ljava/lang/ClassLoader;", false);
                methodVisitor.visitLdcInsn("net.bytebuddy.agent.builder.LambdaFactory");
                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/ClassLoader", "loadClass", "(Ljava/lang/String;)Ljava/lang/Class;", false);
                methodVisitor.visitLdcInsn("make");
                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 9);
                methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Class");
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitInsn(Opcodes.ICONST_0);
                methodVisitor.visitLdcInsn(Type.getType("Ljava/lang/Object;"));
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitInsn(Opcodes.ICONST_1);
                methodVisitor.visitLdcInsn(Type.getType("Ljava/lang/String;"));
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitInsn(Opcodes.ICONST_2);
                methodVisitor.visitLdcInsn(Type.getType("Ljava/lang/Object;"));
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitInsn(Opcodes.ICONST_3);
                methodVisitor.visitLdcInsn(Type.getType("Ljava/lang/Object;"));
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitInsn(Opcodes.ICONST_4);
                methodVisitor.visitLdcInsn(Type.getType("Ljava/lang/Object;"));
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitInsn(Opcodes.ICONST_5);
                methodVisitor.visitLdcInsn(Type.getType("Ljava/lang/Object;"));
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 6);
                methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/Boolean", "TYPE", "Ljava/lang/Class;");
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 7);
                methodVisitor.visitLdcInsn(Type.getType("Ljava/util/List;"));
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 8);
                methodVisitor.visitLdcInsn(Type.getType("Ljava/util/List;"));
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/Class", "getDeclaredMethod", "(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;", false);
                methodVisitor.visitInsn(Opcodes.ACONST_NULL);
                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 9);
                methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Object");
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitInsn(Opcodes.ICONST_0);
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitInsn(Opcodes.ICONST_1);
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitInsn(Opcodes.ICONST_2);
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitInsn(Opcodes.ICONST_3);
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitInsn(Opcodes.ICONST_4);
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 4);
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitInsn(Opcodes.ICONST_5);
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 5);
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 6);
                methodVisitor.visitVarInsn(Opcodes.ILOAD, 6);
                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean;", false);
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 7);
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 7);
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 8);
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 8);
                methodVisitor.visitInsn(Opcodes.AASTORE);
                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/reflect/Method", "invoke", "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;", false);
                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, "[B");
                methodVisitor.visitVarInsn(Opcodes.ASTORE, 9);
                LOADER.apply(methodVisitor);
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);
                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/invoke/MethodType", "parameterCount", "()I", false);
                Label first = new Label();
                methodVisitor.visitJumpInsn(Opcodes.IFNE, first);
                methodVisitor.visitTypeInsn(Opcodes.NEW, "java/lang/invoke/ConstantCallSite");
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);
                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/invoke/MethodType", "returnType", "()Ljava/lang/Class;", false);
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 10);
                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/Class", "getDeclaredConstructors", "()[Ljava/lang/reflect/Constructor;", false);
                methodVisitor.visitInsn(Opcodes.ICONST_0);
                methodVisitor.visitInsn(Opcodes.AALOAD);
                methodVisitor.visitInsn(Opcodes.ICONST_0);
                methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/Object");
                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/reflect/Constructor", "newInstance", "([Ljava/lang/Object;)Ljava/lang/Object;", false);
                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/invoke/MethodHandles", "constant", "(Ljava/lang/Class;Ljava/lang/Object;)Ljava/lang/invoke/MethodHandle;", false);
                methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/invoke/ConstantCallSite", "<init>", "(Ljava/lang/invoke/MethodHandle;)V", false);
                Label second = new Label();
                methodVisitor.visitJumpInsn(Opcodes.GOTO, second);
                methodVisitor.visitLabel(first);
                methodVisitor.visitFrame(Opcodes.F_FULL, 11, new Object[] { "java/lang/invoke/MethodHandles$Lookup", "java/lang/String", "java/lang/invoke/MethodType", "java/lang/invoke/MethodType", "java/lang/invoke/MethodHandle", "java/lang/invoke/MethodType", Opcodes.INTEGER, "java/util/List", "java/util/List", "[B", "java/lang/Class" }, 0, new Object[] {});
                methodVisitor.visitTypeInsn(Opcodes.NEW, "java/lang/invoke/ConstantCallSite");
                methodVisitor.visitInsn(Opcodes.DUP);
                methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/invoke/MethodHandles$Lookup", "IMPL_LOOKUP", "Ljava/lang/invoke/MethodHandles$Lookup;");
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 10);
                methodVisitor.visitLdcInsn("get$Lambda");
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);
                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/invoke/MethodHandles$Lookup", "findStatic", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", false);
                methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/invoke/ConstantCallSite", "<init>", "(Ljava/lang/invoke/MethodHandle;)V", false);
                methodVisitor.visitLabel(second);
                methodVisitor.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[] { "java/lang/invoke/CallSite" });
                methodVisitor.visitInsn(Opcodes.ARETURN);
                return new Size(Math.max(stackSize, LOADER.getStackSize()), Math.max(localVariableLength, LOADER.getLocalVariableLength()));
            }
            protected abstract void onDispatch(MethodVisitor methodVisitor);
            protected interface Loader {
                void apply(MethodVisitor methodVisitor);
                int getStackSize();
                int getLocalVariableLength();
                enum Unavailable implements Loader {
                    INSTANCE;
                    public void apply(MethodVisitor methodVisitor) {
                        throw new IllegalStateException("No lambda expression loading strategy available on current VM");
                    }
                    public int getStackSize() {
                        throw new IllegalStateException("No lambda expression loading strategy available on current VM");
                    }
                    public int getLocalVariableLength() {
                        throw new IllegalStateException("No lambda expression loading strategy available on current VM");
                    }
                }
                enum UsingMethodHandleLookup implements Loader {
                    INSTANCE;
                    public void apply(MethodVisitor methodVisitor) {
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 4);
                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/invoke/MethodHandles$Lookup", "revealDirect", "(Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandleInfo;", false);
                        methodVisitor.visitVarInsn(Opcodes.ASTORE, 10);
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 10);
                        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, "java/lang/invoke/MethodHandleInfo", "getModifiers", "()I", true);
                        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/reflect/Modifier", "isProtected", "(I)Z", false);
                        Label first = new Label();
                        methodVisitor.visitJumpInsn(Opcodes.IFEQ, first);
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/invoke/MethodHandles$Lookup", "lookupClass", "()Ljava/lang/Class;", false);
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 10);
                        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, "java/lang/invoke/MethodHandleInfo", "getDeclaringClass", "()Ljava/lang/Class;", true);
                        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, "sun/invoke/util/VerifyAccess", "isSamePackage", "(Ljava/lang/Class;Ljava/lang/Class;)Z", false);
                        Label second = new Label();
                        methodVisitor.visitJumpInsn(Opcodes.IFEQ, second);
                        methodVisitor.visitLabel(first);
                        methodVisitor.visitFrame(Opcodes.F_FULL, 11, new Object[] { "java/lang/invoke/MethodHandles$Lookup", "java/lang/String", "java/lang/invoke/MethodType", "java/lang/invoke/MethodType", "java/lang/invoke/MethodHandle", "java/lang/invoke/MethodType", Opcodes.INTEGER, "java/util/List", "java/util/List", "[B", "java/lang/invoke/MethodHandleInfo" }, 0, new Object[] {});
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 10);
                        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, "java/lang/invoke/MethodHandleInfo", "getReferenceKind", "()I", true);
                        methodVisitor.visitIntInsn(Opcodes.BIPUSH, 7);
                        Label third = new Label();
                        methodVisitor.visitJumpInsn(Opcodes.IF_ICMPNE, third);
                        methodVisitor.visitLabel(second);
                        methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);
                        methodVisitor.visitInsn(Opcodes.ICONST_1);
                        Label forth = new Label();
                        methodVisitor.visitJumpInsn(Opcodes.GOTO, forth);
                        methodVisitor.visitLabel(third);
                        methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);
                        methodVisitor.visitInsn(Opcodes.ICONST_0);
                        methodVisitor.visitLabel(forth);
                        methodVisitor.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[] { Opcodes.INTEGER });
                        methodVisitor.visitVarInsn(Opcodes.ISTORE, 11);
                        methodVisitor.visitVarInsn(Opcodes.ILOAD, 11);
                        Label fifth = new Label();
                        methodVisitor.visitJumpInsn(Opcodes.IFEQ, fifth);
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 9);
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 10);
                        methodVisitor.visitInsn(Opcodes.ICONST_1);
                        methodVisitor.visitInsn(Opcodes.ICONST_2);
                        methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/invoke/MethodHandles$Lookup$ClassOption");
                        methodVisitor.visitInsn(Opcodes.DUP);
                        methodVisitor.visitInsn(Opcodes.ICONST_0);
                        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/invoke/MethodHandles$Lookup$ClassOption", "NESTMATE", "Ljava/lang/invoke/MethodHandles$Lookup$ClassOption;");
                        methodVisitor.visitInsn(Opcodes.AASTORE);
                        methodVisitor.visitInsn(Opcodes.DUP);
                        methodVisitor.visitInsn(Opcodes.ICONST_1);
                        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/invoke/MethodHandles$Lookup$ClassOption", "STRONG", "Ljava/lang/invoke/MethodHandles$Lookup$ClassOption;");
                        methodVisitor.visitInsn(Opcodes.AASTORE);
                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/invoke/MethodHandles$Lookup", "defineHiddenClassWithClassData", "([BLjava/lang/Object;Z[Ljava/lang/invoke/MethodHandles$Lookup$ClassOption;)Ljava/lang/invoke/MethodHandles$Lookup;", false);
                        methodVisitor.visitVarInsn(Opcodes.ASTORE, 12);
                        Label sixth = new Label();
                        methodVisitor.visitLabel(sixth);
                        Label seventh = new Label();
                        methodVisitor.visitJumpInsn(Opcodes.GOTO, seventh);
                        methodVisitor.visitLabel(fifth);
                        methodVisitor.visitFrame(Opcodes.F_APPEND, 1, new Object[] { Opcodes.INTEGER }, 0, null);
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 9);
                        methodVisitor.visitInsn(Opcodes.ICONST_1);
                        methodVisitor.visitInsn(Opcodes.ICONST_2);
                        methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, "java/lang/invoke/MethodHandles$Lookup$ClassOption");
                        methodVisitor.visitInsn(Opcodes.DUP);
                        methodVisitor.visitInsn(Opcodes.ICONST_0);
                        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/invoke/MethodHandles$Lookup$ClassOption", "NESTMATE", "Ljava/lang/invoke/MethodHandles$Lookup$ClassOption;");
                        methodVisitor.visitInsn(Opcodes.AASTORE);
                        methodVisitor.visitInsn(Opcodes.DUP);
                        methodVisitor.visitInsn(Opcodes.ICONST_1);
                        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, "java/lang/invoke/MethodHandles$Lookup$ClassOption", "STRONG", "Ljava/lang/invoke/MethodHandles$Lookup$ClassOption;");
                        methodVisitor.visitInsn(Opcodes.AASTORE);
                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/invoke/MethodHandles$Lookup", "defineHiddenClass", "([BZ[Ljava/lang/invoke/MethodHandles$Lookup$ClassOption;)Ljava/lang/invoke/MethodHandles$Lookup;", false);
                        methodVisitor.visitVarInsn(Opcodes.ASTORE, 12);
                        methodVisitor.visitLabel(seventh);
                        methodVisitor.visitFrame(Opcodes.F_APPEND, 1, new Object[] { "java/lang/invoke/MethodHandles$Lookup" }, 0, null);
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 12);
                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/invoke/MethodHandles$Lookup", "lookupClass", "()Ljava/lang/Class;", false);
                        methodVisitor.visitVarInsn(Opcodes.ASTORE, 10);
                        methodVisitor.visitFrame(Opcodes.F_FULL, 10, new Object[] { "java/lang/invoke/MethodHandles$Lookup", "java/lang/String", "java/lang/invoke/MethodType", "java/lang/invoke/MethodType", "java/lang/invoke/MethodHandle", "java/lang/invoke/MethodType", Opcodes.INTEGER, "java/util/List", "java/util/List", "java/lang/Class" }, 0, null);
                    }
                    public int getStackSize() {
                        return 8;
                    }
                    public int getLocalVariableLength() {
                        return 15;
                    }
                }
                enum UsingUnsafe implements Loader {
                    JDK_INTERNAL_MISC_UNSAFE("jdk/internal/misc/Unsafe"), SUN_MISC_UNSAFE("sun/misc/Unsafe");
                    private final String type;
                    UsingUnsafe(String type) {
                        this.type = type;
                    }
                    protected String getType() {
                        return type;
                    }
                    public void apply(MethodVisitor methodVisitor) {
                        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, type, "getUnsafe", "()L" + type + ";", false);
                        methodVisitor.visitVarInsn(Opcodes.ASTORE, 11);
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 11);
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/invoke/MethodHandles$Lookup", "lookupClass", "()Ljava/lang/Class;", false);
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 9);
                        methodVisitor.visitInsn(Opcodes.ACONST_NULL);
                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, type, "defineAnonymousClass", "(Ljava/lang/Class;[B[Ljava/lang/Object;)Ljava/lang/Class;", false);
                        methodVisitor.visitVarInsn(Opcodes.ASTORE, 10);
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 11);
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 10);
                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, type, "ensureClassInitialized", "(Ljava/lang/Class;)V", false);
                    }
                    public int getStackSize() {
                        return 4;
                    }
                    public int getLocalVariableLength() {
                        return 13;
                    }
                }
            }
        }
        protected static class LambdaInstanceFactory {
            private static final String LAMBDA_FACTORY = "get$Lambda";
            private static final String FIELD_PREFIX = "arg$";
            private static final String LAMBDA_TYPE_INFIX = "$$Lambda$ByteBuddy$";
            private static final Class<?> NOT_PREVIOUSLY_DEFINED = null;
            private static final AtomicInteger LAMBDA_NAME_COUNTER = new AtomicInteger();
            private final ByteBuddy byteBuddy;
            protected LambdaInstanceFactory(ByteBuddy byteBuddy) {
                this.byteBuddy = byteBuddy;
            }
            public byte[] make(Object targetTypeLookup, String lambdaMethodName, Object factoryMethodType, Object lambdaMethodType, Object targetMethodHandle, Object specializedLambdaMethodType, boolean serializable, List<Class<?>> markerInterfaces, List<?> additionalBridges, Collection<? extends ClassFileTransformer> classFileTransformers) {
                JavaConstant.MethodType factoryMethod = JavaConstant.MethodType.ofLoaded(factoryMethodType);
                JavaConstant.MethodType lambdaMethod = JavaConstant.MethodType.ofLoaded(lambdaMethodType);
                JavaConstant.MethodHandle targetMethod = JavaConstant.MethodHandle.ofLoaded(targetMethodHandle, targetTypeLookup);
                JavaConstant.MethodType specializedLambdaMethod = JavaConstant.MethodType.ofLoaded(specializedLambdaMethodType);
                Class<?> targetType = JavaConstant.MethodHandle.lookupType(targetTypeLookup);
                String lambdaClassName = targetType.getName() + LAMBDA_TYPE_INFIX + LAMBDA_NAME_COUNTER.incrementAndGet();
                DynamicType.Builder<?> builder = byteBuddy.subclass(factoryMethod.getReturnType(), ConstructorStrategy.Default.NO_CONSTRUCTORS).modifiers(TypeManifestation.FINAL, Visibility.PUBLIC).implement(markerInterfaces).name(lambdaClassName).defineConstructor(Visibility.PUBLIC).withParameters(factoryMethod.getParameterTypes()).intercept(ConstructorImplementation.INSTANCE).method(named(lambdaMethodName).and(takesArguments(lambdaMethod.getParameterTypes())).and(returns(lambdaMethod.getReturnType()))).intercept(new LambdaMethodImplementation(TypeDescription.ForLoadedType.of(targetType), targetMethod, specializedLambdaMethod));
                int index = 0;
                for (TypeDescription capturedType : factoryMethod.getParameterTypes()) {
                    builder = builder.defineField(FIELD_PREFIX + ++index, capturedType, Visibility.PRIVATE, FieldManifestation.FINAL);
                }
                if (!factoryMethod.getParameterTypes().isEmpty()) {
                    builder = builder.defineMethod(LAMBDA_FACTORY, factoryMethod.getReturnType(), Visibility.PRIVATE, Ownership.STATIC).withParameters(factoryMethod.getParameterTypes()).intercept(FactoryImplementation.INSTANCE);
                }
                if (serializable) {
                    if (!markerInterfaces.contains(Serializable.class)) {
                        builder = builder.implement(Serializable.class);
                    }
                    builder = builder.defineMethod("writeReplace", Object.class, Visibility.PRIVATE).intercept(new SerializationImplementation(TypeDescription.ForLoadedType.of(targetType), factoryMethod.getReturnType(), lambdaMethodName, lambdaMethod, targetMethod, JavaConstant.MethodType.ofLoaded(specializedLambdaMethodType)));
                } else if (factoryMethod.getReturnType().isAssignableTo(Serializable.class)) {
                    builder = builder.defineMethod("readObject", void.class, Visibility.PRIVATE).withParameters(ObjectInputStream.class).throwing(NotSerializableException.class).intercept(ExceptionMethod.throwing(NotSerializableException.class, "Non-serializable lambda")).defineMethod("writeObject", void.class, Visibility.PRIVATE).withParameters(ObjectOutputStream.class).throwing(NotSerializableException.class).intercept(ExceptionMethod.throwing(NotSerializableException.class, "Non-serializable lambda"));
                }
                for (Object additionalBridgeType : additionalBridges) {
                    JavaConstant.MethodType additionalBridge = JavaConstant.MethodType.ofLoaded(additionalBridgeType);
                    builder = builder.defineMethod(lambdaMethodName, additionalBridge.getReturnType(), MethodManifestation.BRIDGE, Visibility.PUBLIC).withParameters(additionalBridge.getParameterTypes()).intercept(new BridgeMethodImplementation(lambdaMethodName, lambdaMethod));
                }
                byte[] classFile = builder.make().getBytes();
                for (ClassFileTransformer classFileTransformer : classFileTransformers) {
                    try {
                        byte[] transformedClassFile = classFileTransformer.transform(targetType.getClassLoader(), lambdaClassName.replace('.', '/'), NOT_PREVIOUSLY_DEFINED, targetType.getProtectionDomain(), classFile);
                        classFile = transformedClassFile == null ? classFile : transformedClassFile;
                    } catch (Throwable ignored) {
                    }
                }
                return classFile;
            }
            protected enum ConstructorImplementation implements Implementation {
                INSTANCE;
                private final transient MethodDescription.InDefinedShape objectConstructor;
                ConstructorImplementation() {
                    objectConstructor = TypeDescription.ForLoadedType.of(Object.class).getDeclaredMethods().filter(isConstructor()).getOnly();
                }
                public ByteCodeAppender appender(Target implementationTarget) {
                    return new Appender(implementationTarget.getInstrumentedType().getDeclaredFields());
                }
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType;
                }
                protected static class Appender implements ByteCodeAppender {
                    private final List<FieldDescription.InDefinedShape> declaredFields;
                    protected Appender(List<FieldDescription.InDefinedShape> declaredFields) {
                        this.declaredFields = declaredFields;
                    }
                    public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
                        List<StackManipulation> fieldAssignments = new ArrayList<StackManipulation>(declaredFields.size() * 3);
                        for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {
                            fieldAssignments.add(MethodVariableAccess.loadThis());
                            fieldAssignments.add(MethodVariableAccess.load(parameterDescription));
                            fieldAssignments.add(FieldAccess.forField(declaredFields.get(parameterDescription.getIndex())).write());
                        }
                        return new Size(new StackManipulation.Compound(MethodVariableAccess.loadThis(), MethodInvocation.invoke(INSTANCE.objectConstructor), new StackManipulation.Compound(fieldAssignments), MethodReturn.VOID).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());
                    }
                }
            }
            protected enum FactoryImplementation implements Implementation {
                INSTANCE;
                public ByteCodeAppender appender(Target implementationTarget) {
                    return new Appender(implementationTarget.getInstrumentedType());
                }
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType;
                }
                protected static class Appender implements ByteCodeAppender {
                    private final TypeDescription instrumentedType;
                    protected Appender(TypeDescription instrumentedType) {
                        this.instrumentedType = instrumentedType;
                    }
                    public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
                        return new Size(new StackManipulation.Compound(TypeCreation.of(instrumentedType), Duplication.SINGLE, MethodVariableAccess.allArgumentsOf(instrumentedMethod), MethodInvocation.invoke(instrumentedType.getDeclaredMethods().filter(isConstructor()).getOnly()), MethodReturn.REFERENCE).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());
                    }
                }
            }
            protected static class LambdaMethodImplementation implements Implementation {
                private final TypeDescription targetType;
                private final JavaConstant.MethodHandle targetMethod;
                private final JavaConstant.MethodType specializedLambdaMethod;
                protected LambdaMethodImplementation(TypeDescription targetType, JavaConstant.MethodHandle targetMethod, JavaConstant.MethodType specializedLambdaMethod) {
                    this.targetType = targetType;
                    this.targetMethod = targetMethod;
                    this.specializedLambdaMethod = specializedLambdaMethod;
                }
                public ByteCodeAppender appender(Target implementationTarget) {
                    return Appender.of(targetMethod.getOwnerType().getDeclaredMethods().filter(hasMethodName(targetMethod.getName()).and(returns(targetMethod.getReturnType())).and(takesArguments(targetMethod.getParameterTypes()))).getOnly(), specializedLambdaMethod, implementationTarget.getInstrumentedType().getDeclaredFields(), targetMethod.getHandleType(), targetType);
                }
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType;
                }
                protected static class Appender implements ByteCodeAppender {
                    private static final Dispatcher LOOKUP_DATA_DISPATCHER = dispatcher();
                    private static Dispatcher dispatcher() {
                        try {
                            Class<?> type = Class.forName("java.lang.invoke.MethodHandles$Lookup", false, null);
                            type.getMethod("classData", type, String.class, Class.class);
                            return new Dispatcher.UsingMethodHandle(new MethodDescription.ForLoadedMethod(Class.forName("java.lang.invoke.MethodHandle", false, null).getMethod("invokeExact", Object[].class)));
                        } catch (Exception ignored) {
                            return Dispatcher.UsingDirectInvocation.INSTANCE;
                        }
                    }
                    private final MethodDescription targetMethod;
                    private final JavaConstant.MethodType specializedLambdaMethod;
                    private final List<FieldDescription.InDefinedShape> declaredFields;
                    private final Dispatcher dispatcher;
                    protected Appender(MethodDescription targetMethod, JavaConstant.MethodType specializedLambdaMethod, List<FieldDescription.InDefinedShape> declaredFields, Dispatcher dispatcher) {
                        this.targetMethod = targetMethod;
                        this.specializedLambdaMethod = specializedLambdaMethod;
                        this.declaredFields = declaredFields;
                        this.dispatcher = dispatcher;
                    }
                    protected static ByteCodeAppender of(MethodDescription targetMethod, JavaConstant.MethodType specializedLambdaMethod, List<FieldDescription.InDefinedShape> declaredFields, JavaConstant.MethodHandle.HandleType handleType, TypeDescription targetType) {
                        return new Appender(targetMethod, specializedLambdaMethod, declaredFields, handleType == JavaConstant.MethodHandle.HandleType.INVOKE_SPECIAL || !targetMethod.getDeclaringType().asErasure().isVisibleTo(targetType) ? LOOKUP_DATA_DISPATCHER : Dispatcher.UsingDirectInvocation.INSTANCE);
                    }
                    public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
                        List<StackManipulation> fieldAccess = new ArrayList<StackManipulation>(declaredFields.size() * 2 + 1);
                        for (FieldDescription.InDefinedShape fieldDescription : declaredFields) {
                            fieldAccess.add(MethodVariableAccess.loadThis());
                            fieldAccess.add(FieldAccess.forField(fieldDescription).read());
                        }
                        List<StackManipulation> parameterAccess = new ArrayList<StackManipulation>(instrumentedMethod.getParameters().size() * 2);
                        for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {
                            parameterAccess.add(MethodVariableAccess.load(parameterDescription));
                            parameterAccess.add(Assigner.DEFAULT.assign(parameterDescription.getType(), specializedLambdaMethod.getParameterTypes().get(parameterDescription.getIndex()).asGenericType(), Assigner.Typing.DYNAMIC));
                        }
                        return new Size(new StackManipulation.Compound(targetMethod.isConstructor() ? new StackManipulation.Compound(TypeCreation.of(targetMethod.getDeclaringType().asErasure()), Duplication.SINGLE) : StackManipulation.Trivial.INSTANCE, dispatcher.initialize(), new StackManipulation.Compound(fieldAccess), new StackManipulation.Compound(parameterAccess), dispatcher.invoke(targetMethod), Assigner.DEFAULT.assign(targetMethod.isConstructor() ? targetMethod.getDeclaringType().asGenericType() : targetMethod.getReturnType(), specializedLambdaMethod.getReturnType().asGenericType(), Assigner.Typing.DYNAMIC), MethodReturn.of(specializedLambdaMethod.getReturnType())).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());
                    }
                    protected interface Dispatcher {
                        StackManipulation initialize();
                        StackManipulation invoke(MethodDescription methodDescription);
                        enum UsingDirectInvocation implements Dispatcher {
                            INSTANCE;
                            public StackManipulation initialize() {
                                return StackManipulation.Trivial.INSTANCE;
                            }
                            public StackManipulation invoke(MethodDescription methodDescription) {
                                return MethodInvocation.invoke(methodDescription);
                            }
                        }
                        class UsingMethodHandle extends StackManipulation.AbstractBase implements Dispatcher {
                            private final MethodDescription.InDefinedShape invokeExact;
                            protected UsingMethodHandle(MethodDescription.InDefinedShape invokeExact) {
                                this.invokeExact = invokeExact;
                            }
                            public StackManipulation initialize() {
                                return this;
                            }
                            public StackManipulation invoke(MethodDescription methodDescription) {
                                return MethodInvocation.invoke(invokeExact);
                            }
                            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
                                methodVisitor.visitLdcInsn(new ConstantDynamic(JavaConstant.Dynamic.DEFAULT_NAME, "Ljava/lang/invoke/MethodHandle;", new Handle(Opcodes.H_INVOKESTATIC, "java/lang/invoke/MethodHandles", "classData", "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;", false)));
                                return new Size(1, 1);
                            }
                        }
                    }
                }
            }
            protected static class SerializationImplementation implements Implementation {
                private final TypeDescription targetType;
                private final TypeDescription lambdaType;
                private final String lambdaMethodName;
                private final JavaConstant.MethodType lambdaMethod;
                private final JavaConstant.MethodHandle targetMethod;
                private final JavaConstant.MethodType specializedMethod;
                protected SerializationImplementation(TypeDescription targetType, TypeDescription lambdaType, String lambdaMethodName, JavaConstant.MethodType lambdaMethod, JavaConstant.MethodHandle targetMethod, JavaConstant.MethodType specializedMethod) {
                    this.targetType = targetType;
                    this.lambdaType = lambdaType;
                    this.lambdaMethodName = lambdaMethodName;
                    this.lambdaMethod = lambdaMethod;
                    this.targetMethod = targetMethod;
                    this.specializedMethod = specializedMethod;
                }
                public ByteCodeAppender appender(Target implementationTarget) {
                    TypeDescription serializedLambda;
                    try {
                        serializedLambda = TypeDescription.ForLoadedType.of(Class.forName("java.lang.invoke.SerializedLambda"));
                    } catch (ClassNotFoundException exception) {
                        throw new IllegalStateException("Cannot find class for lambda serialization", exception);
                    }
                    List<StackManipulation> lambdaArguments = new ArrayList<StackManipulation>(implementationTarget.getInstrumentedType().getDeclaredFields().size());
                    for (FieldDescription.InDefinedShape fieldDescription : implementationTarget.getInstrumentedType().getDeclaredFields()) {
                        lambdaArguments.add(new StackManipulation.Compound(MethodVariableAccess.loadThis(), FieldAccess.forField(fieldDescription).read(), Assigner.DEFAULT.assign(fieldDescription.getType(), TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class), Assigner.Typing.STATIC)));
                    }
                    return new ByteCodeAppender.Simple(new StackManipulation.Compound(TypeCreation.of(serializedLambda), Duplication.SINGLE, ClassConstant.of(targetType), new TextConstant(lambdaType.getInternalName()), new TextConstant(lambdaMethodName), new TextConstant(lambdaMethod.getDescriptor()), IntegerConstant.forValue(targetMethod.getHandleType().getIdentifier()), new TextConstant(targetMethod.getOwnerType().getInternalName()), new TextConstant(targetMethod.getName()), new TextConstant(targetMethod.getDescriptor()), new TextConstant(specializedMethod.getDescriptor()), ArrayFactory.forType(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class)).withValues(lambdaArguments), MethodInvocation.invoke(serializedLambda.getDeclaredMethods().filter(isConstructor()).getOnly()), MethodReturn.REFERENCE));
                }
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType;
                }
            }
            protected static class BridgeMethodImplementation implements Implementation {
                private final String lambdaMethodName;
                private final JavaConstant.MethodType lambdaMethod;
                protected BridgeMethodImplementation(String lambdaMethodName, JavaConstant.MethodType lambdaMethod) {
                    this.lambdaMethodName = lambdaMethodName;
                    this.lambdaMethod = lambdaMethod;
                }
                public ByteCodeAppender appender(Target implementationTarget) {
                    return new Appender(implementationTarget.invokeSuper(new MethodDescription.SignatureToken(lambdaMethodName, lambdaMethod.getReturnType(), lambdaMethod.getParameterTypes())));
                }
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType;
                }
                protected static class Appender implements ByteCodeAppender {
                    private final SpecialMethodInvocation bridgeTargetInvocation;
                    protected Appender(SpecialMethodInvocation bridgeTargetInvocation) {
                        this.bridgeTargetInvocation = bridgeTargetInvocation;
                    }
                    public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
                        return new Compound(new Simple(MethodVariableAccess.allArgumentsOf(instrumentedMethod).asBridgeOf(bridgeTargetInvocation.getMethodDescription()).prependThisReference(), bridgeTargetInvocation, bridgeTargetInvocation.getMethodDescription().getReturnType().asErasure().isAssignableTo(instrumentedMethod.getReturnType().asErasure()) ? StackManipulation.Trivial.INSTANCE : TypeCasting.to(instrumentedMethod.getReturnType()), MethodReturn.of(instrumentedMethod.getReturnType()))).apply(methodVisitor, implementationContext, instrumentedMethod);
                    }
                }
            }
        }
    }
    enum PatchMode {
        GAP {
            @Override
            protected Handler toHandler(ResettableClassFileTransformer classFileTransformer) {
                return new Handler.ForPatchWithGap(classFileTransformer);
            }
        }
        , OVERLAP {
            @Override
            protected Handler toHandler(ResettableClassFileTransformer classFileTransformer) {
                return new Handler.ForPatchWithOverlap(classFileTransformer);
            }
        }
        , SUBSTITUTE {
            @Override
            protected Handler toHandler(ResettableClassFileTransformer classFileTransformer) {
                if (!(classFileTransformer instanceof ResettableClassFileTransformer.Substitutable)) {
                    throw new IllegalArgumentException("Original class file transformer is not substitutable: " + classFileTransformer);
                }
                return new Handler.ForPatchWithSubstitution((ResettableClassFileTransformer.Substitutable) classFileTransformer);
            }
        }
        ;
        protected static PatchMode of(ResettableClassFileTransformer classFileTransformer) {
            return classFileTransformer instanceof ResettableClassFileTransformer.Substitutable ? PatchMode.SUBSTITUTE : PatchMode.OVERLAP;
        }
        protected abstract Handler toHandler(ResettableClassFileTransformer classFileTransformer);
        protected interface Handler {
            void onBeforeRegistration(Instrumentation instrumentation);
            boolean onRegistration(ResettableClassFileTransformer classFileTransformer);
            void onAfterRegistration(Instrumentation instrumentation);
            enum NoOp implements Handler {
                INSTANCE;
                public void onBeforeRegistration(Instrumentation instrumentation) {
                }
                public boolean onRegistration(ResettableClassFileTransformer classFileTransformer) {
                    return true;
                }
                public void onAfterRegistration(Instrumentation instrumentation) {
                }
            }
            class ForPatchWithGap implements Handler {
                private final ResettableClassFileTransformer classFileTransformer;
                protected ForPatchWithGap(ResettableClassFileTransformer classFileTransformer) {
                    this.classFileTransformer = classFileTransformer;
                }
                public void onBeforeRegistration(Instrumentation instrumentation) {
                    if (!classFileTransformer.reset(instrumentation, RedefinitionStrategy.DISABLED)) {
                        throw new IllegalArgumentException("Failed to deregister patched class file transformer: " + classFileTransformer);
                    }
                }
                public boolean onRegistration(ResettableClassFileTransformer classFileTransformer) {
                    return true;
                }
                public void onAfterRegistration(Instrumentation instrumentation) {
                }
            }
            class ForPatchWithOverlap implements Handler {
                private final ResettableClassFileTransformer classFileTransformer;
                protected ForPatchWithOverlap(ResettableClassFileTransformer classFileTransformer) {
                    this.classFileTransformer = classFileTransformer;
                }
                public void onBeforeRegistration(Instrumentation instrumentation) {
                }
                public boolean onRegistration(ResettableClassFileTransformer classFileTransformer) {
                    return true;
                }
                public void onAfterRegistration(Instrumentation instrumentation) {
                    if (!classFileTransformer.reset(instrumentation, RedefinitionStrategy.DISABLED)) {
                        throw new IllegalArgumentException("Failed to deregister patched class file transformer: " + classFileTransformer);
                    }
                }
            }
            class ForPatchWithSubstitution implements Handler {
                private final ResettableClassFileTransformer.Substitutable classFileTransformer;
                protected ForPatchWithSubstitution(ResettableClassFileTransformer.Substitutable classFileTransformer) {
                    this.classFileTransformer = classFileTransformer;
                }
                public void onBeforeRegistration(Instrumentation instrumentation) {
                }
                public boolean onRegistration(ResettableClassFileTransformer classFileTransformer) {
                    this.classFileTransformer.substitute(classFileTransformer);
                    return false;
                }
                public void onAfterRegistration(Instrumentation instrumentation) {
                }
            }
        }
    }
    class Default implements AgentBuilder {
        private static final String INSTALLER_TYPE = "net.bytebuddy.agent.Installer";
        private static final String INSTALLER_GETTER = "getInstrumentation";
        private static final byte[] NO_TRANSFORMATION = null;
        private static final Class<?> NOT_PREVIOUSLY_DEFINED = null;
        private static final Dispatcher DISPATCHER = doPrivileged(JavaDispatcher.of(Dispatcher.class));
        private static final CircularityLock DEFAULT_LOCK = new CircularityLock.Default();
        protected final ByteBuddy byteBuddy;
        protected final Listener listener;
        protected final CircularityLock circularityLock;
        protected final PoolStrategy poolStrategy;
        protected final TypeStrategy typeStrategy;
        protected final LocationStrategy locationStrategy;
        protected final ClassFileLocator classFileLocator;
        protected final NativeMethodStrategy nativeMethodStrategy;
        protected final WarmupStrategy warmupStrategy;
        protected final TransformerDecorator transformerDecorator;
        protected final InitializationStrategy initializationStrategy;
        protected final RedefinitionStrategy redefinitionStrategy;
        protected final RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy;
        protected final RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator;
        protected final RedefinitionStrategy.Listener redefinitionListener;
        protected final RedefinitionStrategy.ResubmissionStrategy redefinitionResubmissionStrategy;
        protected final InjectionStrategy injectionStrategy;
        protected final LambdaInstrumentationStrategy lambdaInstrumentationStrategy;
        protected final DescriptionStrategy descriptionStrategy;
        protected final FallbackStrategy fallbackStrategy;
        protected final ClassFileBufferStrategy classFileBufferStrategy;
        protected final InstallationListener installationListener;
        protected final RawMatcher ignoreMatcher;
        protected final List<Transformation> transformations;
        public Default() {
            this(new ByteBuddy());
        }
        public Default(ByteBuddy byteBuddy) {
            this(byteBuddy, Listener.NoOp.INSTANCE, DEFAULT_LOCK, PoolStrategy.Default.FAST, TypeStrategy.Default.REBASE, LocationStrategy.ForClassLoader.STRONG, ClassFileLocator.NoOp.INSTANCE, NativeMethodStrategy.Disabled.INSTANCE, WarmupStrategy.NoOp.INSTANCE, TransformerDecorator.NoOp.INSTANCE, new InitializationStrategy.SelfInjection.Split(), RedefinitionStrategy.DISABLED, RedefinitionStrategy.DiscoveryStrategy.SinglePass.INSTANCE, RedefinitionStrategy.BatchAllocator.ForTotal.INSTANCE, RedefinitionStrategy.Listener.NoOp.INSTANCE, RedefinitionStrategy.ResubmissionStrategy.Disabled.INSTANCE, InjectionStrategy.UsingReflection.INSTANCE, LambdaInstrumentationStrategy.DISABLED, DescriptionStrategy.Default.HYBRID, FallbackStrategy.ByThrowableType.ofOptionalTypes(), ClassFileBufferStrategy.Default.RETAINING, InstallationListener.NoOp.INSTANCE, new RawMatcher.Disjunction(new RawMatcher.ForElementMatchers(any(), isBootstrapClassLoader().or(isExtensionClassLoader())), new RawMatcher.ForElementMatchers(nameStartsWith("net.bytebuddy.").and(not(ElementMatchers.nameStartsWith(NamingStrategy.BYTE_BUDDY_RENAME_PACKAGE + "."))).or(nameStartsWith("sun.reflect.").or(nameStartsWith("jdk.internal.reflect."))).<TypeDescription>or(isSynthetic()))), Collections.<Transformation>emptyList());
        }
        protected Default(ByteBuddy byteBuddy, Listener listener, CircularityLock circularityLock, PoolStrategy poolStrategy, TypeStrategy typeStrategy, LocationStrategy locationStrategy, ClassFileLocator classFileLocator, NativeMethodStrategy nativeMethodStrategy, WarmupStrategy warmupStrategy, TransformerDecorator transformerDecorator, InitializationStrategy initializationStrategy, RedefinitionStrategy redefinitionStrategy, RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy, RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator, RedefinitionStrategy.Listener redefinitionListener, RedefinitionStrategy.ResubmissionStrategy redefinitionResubmissionStrategy, InjectionStrategy injectionStrategy, LambdaInstrumentationStrategy lambdaInstrumentationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, ClassFileBufferStrategy classFileBufferStrategy, InstallationListener installationListener, RawMatcher ignoreMatcher, List<Transformation> transformations) {
            this.byteBuddy = byteBuddy;
            this.listener = listener;
            this.circularityLock = circularityLock;
            this.poolStrategy = poolStrategy;
            this.typeStrategy = typeStrategy;
            this.locationStrategy = locationStrategy;
            this.classFileLocator = classFileLocator;
            this.nativeMethodStrategy = nativeMethodStrategy;
            this.warmupStrategy = warmupStrategy;
            this.transformerDecorator = transformerDecorator;
            this.initializationStrategy = initializationStrategy;
            this.redefinitionStrategy = redefinitionStrategy;
            this.redefinitionDiscoveryStrategy = redefinitionDiscoveryStrategy;
            this.redefinitionBatchAllocator = redefinitionBatchAllocator;
            this.redefinitionListener = redefinitionListener;
            this.redefinitionResubmissionStrategy = redefinitionResubmissionStrategy;
            this.injectionStrategy = injectionStrategy;
            this.lambdaInstrumentationStrategy = lambdaInstrumentationStrategy;
            this.descriptionStrategy = descriptionStrategy;
            this.fallbackStrategy = fallbackStrategy;
            this.classFileBufferStrategy = classFileBufferStrategy;
            this.installationListener = installationListener;
            this.ignoreMatcher = ignoreMatcher;
            this.transformations = transformations;
        }
        private static <T> T doPrivileged(PrivilegedAction<T> action) {
            return action.run();
        }
        public static AgentBuilder of(Plugin... plugin) {
            return of(Arrays.asList(plugin));
        }
        public static AgentBuilder of(List<? extends Plugin> plugins) {
            return of(EntryPoint.Default.REBASE, plugins);
        }
        public static AgentBuilder of(EntryPoint entryPoint, Plugin... plugin) {
            return of(entryPoint, Arrays.asList(plugin));
        }
        public static AgentBuilder of(EntryPoint entryPoint, List<? extends Plugin> plugins) {
            return of(entryPoint, ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5), plugins);
        }
        public static AgentBuilder of(ClassFileVersion classFileVersion, Plugin... plugin) {
            return of(classFileVersion, Arrays.asList(plugin));
        }
        public static AgentBuilder of(ClassFileVersion classFileVersion, List<? extends Plugin> plugins) {
            return of(EntryPoint.Default.REBASE, classFileVersion, plugins);
        }
        public static AgentBuilder of(EntryPoint entryPoint, ClassFileVersion classFileVersion, Plugin... plugin) {
            return of(entryPoint, classFileVersion, Arrays.asList(plugin));
        }
        public static AgentBuilder of(EntryPoint entryPoint, ClassFileVersion classFileVersion, List<? extends Plugin> plugins) {
            AgentBuilder agentBuilder = new AgentBuilder.Default(entryPoint.byteBuddy(classFileVersion)).with(new TypeStrategy.ForBuildEntryPoint(entryPoint));
            for (Plugin plugin : plugins) {
                agentBuilder = agentBuilder.type(plugin).transform(new Transformer.ForBuildPlugin(plugin));
            }
            return agentBuilder;
        }
        public AgentBuilder with(ByteBuddy byteBuddy) {
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder with(Listener listener) {
            return new Default(byteBuddy, new Listener.Compound(this.listener, listener), circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder with(CircularityLock circularityLock) {
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder with(TypeStrategy typeStrategy) {
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder with(PoolStrategy poolStrategy) {
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder with(LocationStrategy locationStrategy) {
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder with(ClassFileLocator classFileLocator) {
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, new ClassFileLocator.Compound(this.classFileLocator, classFileLocator), nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder enableNativeMethodPrefix(String prefix) {
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, NativeMethodStrategy.ForPrefix.of(prefix), warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder disableNativeMethodPrefix() {
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, NativeMethodStrategy.Disabled.INSTANCE, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder warmUp(Class<?>... type) {
            return warmUp(Arrays.asList(type));
        }
        public AgentBuilder warmUp(Collection<Class<?>> types) {
            if (types.isEmpty()) {
                return this;
            }
            for (Class<?> type : types) {
                if (type.isPrimitive() || type.isArray()) {
                    throw new IllegalArgumentException("Cannot warm up primitive or array type: " + type);
                }
            }
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy.with(types), transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder with(TransformerDecorator transformerDecorator) {
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, new TransformerDecorator.Compound(this.transformerDecorator, transformerDecorator), initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public RedefinitionListenable.WithoutBatchStrategy with(RedefinitionStrategy redefinitionStrategy) {
            return new Redefining(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, RedefinitionStrategy.DiscoveryStrategy.SinglePass.INSTANCE, RedefinitionStrategy.BatchAllocator.ForTotal.INSTANCE, RedefinitionStrategy.Listener.NoOp.INSTANCE, RedefinitionStrategy.ResubmissionStrategy.Disabled.INSTANCE, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder with(InitializationStrategy initializationStrategy) {
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder with(LambdaInstrumentationStrategy lambdaInstrumentationStrategy) {
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder with(DescriptionStrategy descriptionStrategy) {
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder with(FallbackStrategy fallbackStrategy) {
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder with(ClassFileBufferStrategy classFileBufferStrategy) {
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder with(InstallationListener installationListener) {
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, new InstallationListener.Compound(this.installationListener, installationListener), ignoreMatcher, transformations);
        }
        public AgentBuilder with(InjectionStrategy injectionStrategy) {
            return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder disableClassFormatChanges() {
            return new Default(byteBuddy.with(Implementation.Context.Disabled.Factory.INSTANCE), listener, circularityLock, poolStrategy, typeStrategy == TypeStrategy.Default.DECORATE ? TypeStrategy.Default.DECORATE : TypeStrategy.Default.REDEFINE_FROZEN, locationStrategy, classFileLocator, NativeMethodStrategy.Disabled.INSTANCE, warmupStrategy, transformerDecorator, InitializationStrategy.NoOp.INSTANCE, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
        }
        public AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, Class<?>... type) {
            return JavaModule.isSupported() ? with(Listener.ModuleReadEdgeCompleting.of(instrumentation, false, type)) : this;
        }
        public AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, JavaModule... module) {
            return assureReadEdgeTo(instrumentation, Arrays.asList(module));
        }
        public AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, Collection<? extends JavaModule> modules) {
            return with(new Listener.ModuleReadEdgeCompleting(instrumentation, false, new HashSet<JavaModule>(modules)));
        }
        public AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, Class<?>... type) {
            return JavaModule.isSupported() ? with(Listener.ModuleReadEdgeCompleting.of(instrumentation, true, type)) : this;
        }
        public AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, JavaModule... module) {
            return assureReadEdgeFromAndTo(instrumentation, Arrays.asList(module));
        }
        public AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, Collection<? extends JavaModule> modules) {
            return with(new Listener.ModuleReadEdgeCompleting(instrumentation, true, new HashSet<JavaModule>(modules)));
        }
        public Identified.Narrowable type(RawMatcher matcher) {
            return new Transforming(matcher, Collections.<Transformer>emptyList(), false);
        }
        public Identified.Narrowable type(ElementMatcher<? super TypeDescription> typeMatcher) {
            return type(typeMatcher, any());
        }
        public Identified.Narrowable type(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher) {
            return type(typeMatcher, classLoaderMatcher, any());
        }
        public Identified.Narrowable type(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher) {
            return type(new RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, not(supportsModules()).or(moduleMatcher)));
        }
        public Ignored ignore(ElementMatcher<? super TypeDescription> typeMatcher) {
            return ignore(typeMatcher, any());
        }
        public Ignored ignore(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher) {
            return ignore(typeMatcher, classLoaderMatcher, any());
        }
        public Ignored ignore(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher) {
            return ignore(new RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, not(supportsModules()).or(moduleMatcher)));
        }
        public Ignored ignore(RawMatcher rawMatcher) {
            return new Ignoring(rawMatcher);
        }
        public ResettableClassFileTransformer makeRaw() {
            return makeRaw(listener, InstallationListener.NoOp.INSTANCE, RedefinitionStrategy.ResubmissionEnforcer.Disabled.INSTANCE);
        }
        private ResettableClassFileTransformer makeRaw(Listener listener, InstallationListener installationListener, RedefinitionStrategy.ResubmissionEnforcer resubmissionEnforcer) {
            return ExecutingTransformer.FACTORY.make(byteBuddy, listener, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, initializationStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, resubmissionEnforcer, transformations, circularityLock);
        }
        private static Instrumentation resolveByteBuddyAgentInstrumentation() {
            try {
                Class<?> installer = ClassLoader.getSystemClassLoader().loadClass(INSTALLER_TYPE);
                JavaModule source = JavaModule.ofType(AgentBuilder.class), target = JavaModule.ofType(installer);
                if (source != null && !source.canRead(target)) {
                    Class<?> module = Class.forName("java.lang.Module");
                    module.getMethod("addReads", module).invoke(source.unwrap(), target.unwrap());
                }
                return (Instrumentation) installer.getMethod(INSTALLER_GETTER).invoke(null);
            } catch (RuntimeException exception) {
                throw exception;
            } catch (Exception exception) {
                throw new IllegalStateException("The Byte Buddy agent is not installed or not accessible", exception);
            }
        }
        public ResettableClassFileTransformer installOn(Instrumentation instrumentation) {
            return doInstall(instrumentation, new Transformation.SimpleMatcher(ignoreMatcher, transformations), PatchMode.Handler.NoOp.INSTANCE);
        }
        public ResettableClassFileTransformer installOnByteBuddyAgent() {
            return installOn(resolveByteBuddyAgentInstrumentation());
        }
        public ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
            return patchOn(instrumentation, classFileTransformer, PatchMode.of(classFileTransformer));
        }
        public ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, RawMatcher differentialMatcher) {
            return patchOn(instrumentation, classFileTransformer, differentialMatcher, PatchMode.of(classFileTransformer));
        }
        public ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, PatchMode patchMode) {
            return patchOn(instrumentation, classFileTransformer, new Transformation.DifferentialMatcher(ignoreMatcher, transformations, classFileTransformer instanceof ResettableClassFileTransformer.Substitutable ? ((ResettableClassFileTransformer.Substitutable) classFileTransformer).unwrap() : classFileTransformer), patchMode);
        }
        public ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, RawMatcher differentialMatcher, PatchMode patchMode) {
            return doInstall(instrumentation, differentialMatcher, patchMode.toHandler(classFileTransformer));
        }
        public ResettableClassFileTransformer patchOnByteBuddyAgent(ResettableClassFileTransformer classFileTransformer) {
            return patchOn(resolveByteBuddyAgentInstrumentation(), classFileTransformer);
        }
        public ResettableClassFileTransformer patchOnByteBuddyAgent(ResettableClassFileTransformer classFileTransformer, PatchMode patchMode) {
            return patchOn(resolveByteBuddyAgentInstrumentation(), classFileTransformer, patchMode);
        }
        private ResettableClassFileTransformer doInstall(Instrumentation instrumentation, RawMatcher matcher, PatchMode.Handler handler) {
            if (!circularityLock.acquire()) {
                throw new IllegalStateException("Could not acquire the circularity lock upon installation.");
            }
            try {
                RedefinitionStrategy.ResubmissionStrategy.Installation installation = redefinitionResubmissionStrategy.apply(instrumentation, poolStrategy, locationStrategy, descriptionStrategy, fallbackStrategy, listener, installationListener, circularityLock, new Transformation.SimpleMatcher(ignoreMatcher, transformations), redefinitionStrategy, redefinitionBatchAllocator, redefinitionListener);
                ResettableClassFileTransformer classFileTransformer = transformerDecorator.decorate(makeRaw(installation.getListener(), installation.getInstallationListener(), installation.getResubmissionEnforcer()));
                installation.getInstallationListener().onBeforeInstall(instrumentation, classFileTransformer);
                try {
                    warmupStrategy.apply(classFileTransformer, locationStrategy, redefinitionStrategy, circularityLock, installation.getInstallationListener());
                    handler.onBeforeRegistration(instrumentation);
                    if (handler.onRegistration(classFileTransformer)) {
                        if (redefinitionStrategy.isRetransforming()) {
                            DISPATCHER.addTransformer(instrumentation, classFileTransformer, true);
                        } else {
                            instrumentation.addTransformer(classFileTransformer);
                        }
                    }
                    handler.onAfterRegistration(instrumentation);
                    nativeMethodStrategy.apply(instrumentation, classFileTransformer);
                    lambdaInstrumentationStrategy.apply(byteBuddy, instrumentation, classFileTransformer);
                    redefinitionStrategy.apply(instrumentation, poolStrategy, locationStrategy, descriptionStrategy, fallbackStrategy, redefinitionDiscoveryStrategy, lambdaInstrumentationStrategy, installation.getListener(), redefinitionListener, matcher, redefinitionBatchAllocator, circularityLock);
                } catch (@MaybeNull Throwable throwable) {
                    throwable = installation.getInstallationListener().onError(instrumentation, classFileTransformer, throwable);
                    if (throwable != null) {
                        instrumentation.removeTransformer(classFileTransformer);
                        throw new IllegalStateException("Could not install class file transformer", throwable);
                    }
                }
                installation.getInstallationListener().onInstall(instrumentation, classFileTransformer);
                return classFileTransformer;
            } finally {
                circularityLock.release();
            }
        }
        protected interface Dispatcher {
            boolean isNativeMethodPrefixSupported(Instrumentation instrumentation);
            void setNativeMethodPrefix(Instrumentation instrumentation, ClassFileTransformer classFileTransformer, String prefix);
            void addTransformer(Instrumentation instrumentation, ClassFileTransformer classFileTransformer, boolean canRetransform);
        }
        protected interface NativeMethodStrategy {
            MethodNameTransformer resolve();
            void apply(Instrumentation instrumentation, ClassFileTransformer classFileTransformer);
            enum Disabled implements NativeMethodStrategy {
                INSTANCE;
                public MethodNameTransformer resolve() {
                    return MethodNameTransformer.Suffixing.withRandomSuffix();
                }
                public void apply(Instrumentation instrumentation, ClassFileTransformer classFileTransformer) {
                }
            }
            class ForPrefix implements NativeMethodStrategy {
                private final String prefix;
                protected ForPrefix(String prefix) {
                    this.prefix = prefix;
                }
                protected static NativeMethodStrategy of(String prefix) {
                    if (prefix.length() == 0) {
                        throw new IllegalArgumentException("A method name prefix must not be the empty string");
                    }
                    return new ForPrefix(prefix);
                }
                public MethodNameTransformer resolve() {
                    return new MethodNameTransformer.Prefixing(prefix);
                }
                public void apply(Instrumentation instrumentation, ClassFileTransformer classFileTransformer) {
                    if (!DISPATCHER.isNativeMethodPrefixSupported(instrumentation)) {
                        throw new IllegalArgumentException("A prefix for native methods is not supported: " + instrumentation);
                    }
                    DISPATCHER.setNativeMethodPrefix(instrumentation, classFileTransformer, prefix);
                }
            }
        }
        protected interface WarmupStrategy {
            void apply(ResettableClassFileTransformer classFileTransformer, LocationStrategy locationStrategy, RedefinitionStrategy redefinitionStrategy, CircularityLock circularityLock, InstallationListener listener);
            WarmupStrategy with(Collection<Class<?>> types);
            enum NoOp implements WarmupStrategy {
                INSTANCE;
                public void apply(ResettableClassFileTransformer classFileTransformer, LocationStrategy locationStrategy, RedefinitionStrategy redefinitionStrategy, CircularityLock circularityLock, InstallationListener listener) {
                }
                public WarmupStrategy with(Collection<Class<?>> types) {
                    return new Enabled(new LinkedHashSet<Class<?>>(types));
                }
            }
            class Enabled implements WarmupStrategy {
                private static final Dispatcher DISPATCHER = Default.doPrivileged(JavaDispatcher.of(Dispatcher.class));
                private final Set<Class<?>> types;
                protected Enabled(Set<Class<?>> types) {
                    this.types = types;
                }
                public void apply(ResettableClassFileTransformer classFileTransformer, LocationStrategy locationStrategy, RedefinitionStrategy redefinitionStrategy, CircularityLock circularityLock, InstallationListener listener) {
                    listener.onBeforeWarmUp(types, classFileTransformer);
                    boolean transformed = false;
                    Map<Class<?>, byte[]> results = new LinkedHashMap<Class<?>, byte[]>();
                    for (Class<?> type : types) {
                        try {
                            JavaModule module = JavaModule.ofType(type);
                            byte[] binaryRepresentation = locationStrategy.classFileLocator(type.getClassLoader(), module).locate(type.getName()).resolve();
                            circularityLock.release();
                            try {
                                byte[] result;
                                if (module == null) {
                                    result = classFileTransformer.transform(type.getClassLoader(), Type.getInternalName(type), NOT_PREVIOUSLY_DEFINED, type.getProtectionDomain(), binaryRepresentation);
                                    transformed |= result != null;
                                    if (redefinitionStrategy.isEnabled()) {
                                        result = classFileTransformer.transform(type.getClassLoader(), Type.getInternalName(type), type, type.getProtectionDomain(), binaryRepresentation);
                                        transformed |= result != null;
                                    }
                                } else {
                                    result = DISPATCHER.transform(classFileTransformer, module.unwrap(), type.getClassLoader(), Type.getInternalName(type), NOT_PREVIOUSLY_DEFINED, type.getProtectionDomain(), binaryRepresentation);
                                    transformed |= result != null;
                                    if (redefinitionStrategy.isEnabled()) {
                                        result = DISPATCHER.transform(classFileTransformer, module.unwrap(), type.getClassLoader(), Type.getInternalName(type), type, type.getProtectionDomain(), binaryRepresentation);
                                        transformed |= result != null;
                                    }
                                }
                                results.put(type, result);
                            } finally {
                                circularityLock.acquire();
                            }
                        } catch (Throwable throwable) {
                            listener.onWarmUpError(type, classFileTransformer, throwable);
                            results.put(type, NO_TRANSFORMATION);
                        }
                    }
                    listener.onAfterWarmUp(results, classFileTransformer, transformed);
                }
                public WarmupStrategy with(Collection<Class<?>> types) {
                    Set<Class<?>> combined = new LinkedHashSet<Class<?>>(this.types);
                    combined.addAll(types);
                    return new Enabled(combined);
                }
                protected interface Dispatcher {
                    byte[] transform(ClassFileTransformer target, @MaybeNull @JavaDispatcher.Proxied("java.lang.Module") Object module, @MaybeNull ClassLoader classLoader, String name, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain, byte[] binaryRepresentation) throws IllegalClassFormatException;
                }
            }
        }
        protected static class Transformation {
            private static final byte[] NONE = null;
            private final RawMatcher matcher;
            private final List<Transformer> transformers;
            private final boolean terminal;
            protected Transformation(RawMatcher matcher, List<Transformer> transformers, boolean terminal) {
                this.matcher = matcher;
                this.transformers = transformers;
                this.terminal = terminal;
            }
            protected RawMatcher getMatcher() {
                return matcher;
            }
            protected List<Transformer> getTransformers() {
                return transformers;
            }
            protected boolean isTerminal() {
                return terminal;
            }
            protected static class SimpleMatcher implements RawMatcher {
                private final RawMatcher ignoreMatcher;
                private final List<Transformation> transformations;
                protected SimpleMatcher(RawMatcher ignoreMatcher, List<Transformation> transformations) {
                    this.ignoreMatcher = ignoreMatcher;
                    this.transformations = transformations;
                }
                public boolean matches(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain) {
                    if (ignoreMatcher.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {
                        return false;
                    }
                    for (Transformation transformation : transformations) {
                        if (transformation.getMatcher().matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {
                            return true;
                        }
                    }
                    return false;
                }
            }
            protected static class DifferentialMatcher implements RawMatcher {
                private final RawMatcher ignoreMatcher;
                private final List<Transformation> transformations;
                private final ResettableClassFileTransformer classFileTransformer;
                protected DifferentialMatcher(RawMatcher ignoreMatcher, List<Transformation> transformations, ResettableClassFileTransformer classFileTransformer) {
                    this.ignoreMatcher = ignoreMatcher;
                    this.transformations = transformations;
                    this.classFileTransformer = classFileTransformer;
                }
                public boolean matches(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain) {
                    Iterator<Transformer> iterator = classFileTransformer.iterator(typeDescription, classLoader, module, classBeingRedefined, protectionDomain);
                    if (ignoreMatcher.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {
                        return iterator.hasNext();
                    }
                    for (Transformation transformation : transformations) {
                        if (transformation.getMatcher().matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {
                            for (Transformer transformer : transformation.getTransformers()) {
                                if (!iterator.hasNext() || !iterator.next().equals(transformer)) {
                                    return true;
                                }
                            }
                        }
                    }
                    return iterator.hasNext();
                }
            }
            protected static class TransformerIterator implements Iterator<Transformer> {
                private final TypeDescription typeDescription;
                private final ClassLoader classLoader;
                private final JavaModule module;
                private final Class<?> classBeingRedefined;
                private final ProtectionDomain protectionDomain;
                private final Iterator<Transformation> transformations;
                private Iterator<Transformer> transformers;
                protected TransformerIterator(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain, List<Transformation> transformations) {
                    this.typeDescription = typeDescription;
                    this.classLoader = classLoader;
                    this.module = module;
                    this.classBeingRedefined = classBeingRedefined;
                    this.protectionDomain = protectionDomain;
                    this.transformations = transformations.iterator();
                    transformers = Collections.<Transformer>emptySet().iterator();
                    while (!transformers.hasNext() && this.transformations.hasNext()) {
                        Transformation transformation = this.transformations.next();
                        if (transformation.getMatcher().matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {
                            transformers = transformation.getTransformers().iterator();
                        }
                    }
                }
                public boolean hasNext() {
                    return transformers.hasNext();
                }
                public Transformer next() {
                    try {
                        return transformers.next();
                    } finally {
                        while (!transformers.hasNext() && transformations.hasNext()) {
                            Transformation transformation = transformations.next();
                            if (transformation.getMatcher().matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {
                                transformers = transformation.getTransformers().iterator();
                            }
                        }
                    }
                }
                public void remove() {
                    throw new UnsupportedOperationException("remove");
                }
            }
        }
        protected static class ExecutingTransformer extends ResettableClassFileTransformer.AbstractBase {
            protected static final Factory FACTORY = Default.doPrivileged(Factory.CreationAction.INSTANCE);
            private final ByteBuddy byteBuddy;
            private final PoolStrategy poolStrategy;
            private final TypeStrategy typeStrategy;
            private final Listener listener;
            private final NativeMethodStrategy nativeMethodStrategy;
            private final InitializationStrategy initializationStrategy;
            private final InjectionStrategy injectionStrategy;
            private final LambdaInstrumentationStrategy lambdaInstrumentationStrategy;
            private final DescriptionStrategy descriptionStrategy;
            private final LocationStrategy locationStrategy;
            private final ClassFileLocator classFileLocator;
            private final FallbackStrategy fallbackStrategy;
            private final ClassFileBufferStrategy classFileBufferStrategy;
            private final InstallationListener installationListener;
            private final RawMatcher ignoreMatcher;
            private final RedefinitionStrategy.ResubmissionEnforcer resubmissionEnforcer;
            private final List<Transformation> transformations;
            private final CircularityLock circularityLock;
            private final Object accessControlContext;
            public ExecutingTransformer(ByteBuddy byteBuddy, Listener listener, PoolStrategy poolStrategy, TypeStrategy typeStrategy, LocationStrategy locationStrategy, ClassFileLocator classFileLocator, NativeMethodStrategy nativeMethodStrategy, InitializationStrategy initializationStrategy, InjectionStrategy injectionStrategy, LambdaInstrumentationStrategy lambdaInstrumentationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, ClassFileBufferStrategy classFileBufferStrategy, InstallationListener installationListener, RawMatcher ignoreMatcher, RedefinitionStrategy.ResubmissionEnforcer resubmissionEnforcer, List<Transformation> transformations, CircularityLock circularityLock) {
                this.byteBuddy = byteBuddy;
                this.typeStrategy = typeStrategy;
                this.poolStrategy = poolStrategy;
                this.locationStrategy = locationStrategy;
                this.classFileLocator = classFileLocator;
                this.listener = listener;
                this.nativeMethodStrategy = nativeMethodStrategy;
                this.initializationStrategy = initializationStrategy;
                this.injectionStrategy = injectionStrategy;
                this.lambdaInstrumentationStrategy = lambdaInstrumentationStrategy;
                this.descriptionStrategy = descriptionStrategy;
                this.fallbackStrategy = fallbackStrategy;
                this.classFileBufferStrategy = classFileBufferStrategy;
                this.installationListener = installationListener;
                this.ignoreMatcher = ignoreMatcher;
                this.resubmissionEnforcer = resubmissionEnforcer;
                this.transformations = transformations;
                this.circularityLock = circularityLock;
                accessControlContext = getContext();
            }
            private static Object getContext() {
                return null;
            }
            private static <T> T doPrivileged(PrivilegedAction<T> action, @MaybeNull @SuppressWarnings("unused") Object context) {
                return action.run();
            }
            public byte[] transform(@MaybeNull ClassLoader classLoader, @MaybeNull String internalName, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain, byte[] binaryRepresentation) {
                if (circularityLock.acquire()) {
                    try {
                        return doPrivileged(new LegacyVmDispatcher(classLoader, internalName, classBeingRedefined, protectionDomain, binaryRepresentation), accessControlContext);
                    } finally {
                        circularityLock.release();
                    }
                } else {
                    return NO_TRANSFORMATION;
                }
            }
            protected byte[] transform(Object rawModule, @MaybeNull ClassLoader classLoader, @MaybeNull String internalName, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain, byte[] binaryRepresentation) {
                if (circularityLock.acquire()) {
                    try {
                        return doPrivileged(new Java9CapableVmDispatcher(rawModule, classLoader, internalName, classBeingRedefined, protectionDomain, binaryRepresentation), accessControlContext);
                    } finally {
                        circularityLock.release();
                    }
                } else {
                    return NO_TRANSFORMATION;
                }
            }
            private byte[] transform(@MaybeNull JavaModule module, @MaybeNull ClassLoader classLoader, @MaybeNull String internalName, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain, byte[] binaryRepresentation) {
                if (internalName == null || !lambdaInstrumentationStrategy.isInstrumented(classBeingRedefined)) {
                    return NO_TRANSFORMATION;
                }
                String name = internalName.replace('/', '.');
                try {
                    if (resubmissionEnforcer.isEnforced(name, classLoader, module, classBeingRedefined)) {
                        return NO_TRANSFORMATION;
                    }
                } catch (Throwable throwable) {
                    try {
                        listener.onDiscovery(name, classLoader, module, classBeingRedefined != null);
                    } finally {
                        listener.onError(name, classLoader, module, classBeingRedefined != null, throwable);
                    }
                    throw new IllegalStateException("Failed transformation of " + name, throwable);
                }
                try {
                    listener.onDiscovery(name, classLoader, module, classBeingRedefined != null);
                    ClassFileLocator classFileLocator = new ClassFileLocator.Compound(classFileBufferStrategy.resolve(name, binaryRepresentation, classLoader, module, protectionDomain), this.classFileLocator, locationStrategy.classFileLocator(classLoader, module));
                    TypePool typePool = classFileBufferStrategy.typePool(poolStrategy, classFileLocator, classLoader, name);
                    try {
                        return doTransform(module, classLoader, name, classBeingRedefined, classBeingRedefined != null, protectionDomain, typePool, classFileLocator);
                    } catch (Throwable throwable) {
                        if (classBeingRedefined != null && descriptionStrategy.isLoadedFirst() && fallbackStrategy.isFallback(classBeingRedefined, throwable)) {
                            return doTransform(module, classLoader, name, NOT_PREVIOUSLY_DEFINED, Listener.LOADED, protectionDomain, typePool, classFileLocator);
                        } else {
                            throw throwable;
                        }
                    }
                } catch (Throwable throwable) {
                    listener.onError(name, classLoader, module, classBeingRedefined != null, throwable);
                    throw new IllegalStateException("Failed transformation of " + name, throwable);
                } finally {
                    listener.onComplete(name, classLoader, module, classBeingRedefined != null);
                }
            }
            private byte[] doTransform(@MaybeNull JavaModule module, @MaybeNull ClassLoader classLoader, String name, @MaybeNull Class<?> classBeingRedefined, boolean loaded, @MaybeNull ProtectionDomain protectionDomain, TypePool typePool, ClassFileLocator classFileLocator) {
                TypeDescription typeDescription = descriptionStrategy.apply(name, classBeingRedefined, typePool, circularityLock, classLoader, module);
                List<Transformer> transformers = new ArrayList<Transformer>();
                if (!ignoreMatcher.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {
                    for (Transformation transformation : transformations) {
                        if (transformation.getMatcher().matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {
                            transformers.addAll(transformation.getTransformers());
                            if (transformation.isTerminal()) {
                                break;
                            }
                        }
                    }
                }
                if (transformers.isEmpty()) {
                    listener.onIgnored(typeDescription, classLoader, module, loaded);
                    return Transformation.NONE;
                }
                DynamicType.Builder<?> builder = typeStrategy.builder(typeDescription, byteBuddy, classFileLocator, nativeMethodStrategy.resolve(), classLoader, module, protectionDomain);
                InitializationStrategy.Dispatcher dispatcher = initializationStrategy.dispatcher();
                for (Transformer transformer : transformers) {
                    builder = transformer.transform(builder, typeDescription, classLoader, module, protectionDomain);
                }
                DynamicType.Unloaded<?> dynamicType = dispatcher.apply(builder).make(TypeResolutionStrategy.Disabled.INSTANCE, typePool);
                dispatcher.register(dynamicType, classLoader, protectionDomain, injectionStrategy);
                listener.onTransformation(typeDescription, classLoader, module, loaded, dynamicType);
                return dynamicType.getBytes();
            }
            public Iterator<Transformer> iterator(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain) {
                return ignoreMatcher.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain) ? Collections.<Transformer>emptySet().iterator() : new Transformation.TransformerIterator(typeDescription, classLoader, module, classBeingRedefined, protectionDomain, transformations);
            }
            public synchronized boolean reset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, RedefinitionStrategy redefinitionStrategy, RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy, RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator, RedefinitionStrategy.Listener redefinitionListener) {
                if (instrumentation.removeTransformer(classFileTransformer)) {
                    redefinitionStrategy.apply(instrumentation, poolStrategy, locationStrategy, descriptionStrategy, fallbackStrategy, redefinitionDiscoveryStrategy, lambdaInstrumentationStrategy, Listener.NoOp.INSTANCE, redefinitionListener, new Transformation.SimpleMatcher(ignoreMatcher, transformations), redefinitionBatchAllocator, CircularityLock.Inactive.INSTANCE);
                    installationListener.onReset(instrumentation, classFileTransformer);
                    return true;
                } else {
                    return false;
                }
            }
            protected interface Factory {
                ResettableClassFileTransformer make(ByteBuddy byteBuddy, Listener listener, PoolStrategy poolStrategy, TypeStrategy typeStrategy, LocationStrategy locationStrategy, ClassFileLocator classFileLocator, NativeMethodStrategy nativeMethodStrategy, InitializationStrategy initializationStrategy, InjectionStrategy injectionStrategy, LambdaInstrumentationStrategy lambdaInstrumentationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, ClassFileBufferStrategy classFileBufferStrategy, InstallationListener installationListener, RawMatcher ignoreMatcher, RedefinitionStrategy.ResubmissionEnforcer resubmissionEnforcer, List<Transformation> transformations, CircularityLock circularityLock);
                enum CreationAction implements PrivilegedAction<Factory> {
                    INSTANCE;
                    public Factory run() {
                        try {
                            return new Factory.ForJava9CapableVm(new ByteBuddy().with(TypeValidation.DISABLED).subclass(ExecutingTransformer.class).name(ExecutingTransformer.class.getName() + "$ByteBuddy$ModuleSupport").method(named("transform").and(takesArgument(0, JavaType.MODULE.load()))).intercept(MethodCall.invoke(ExecutingTransformer.class.getDeclaredMethod("transform", Object.class, ClassLoader.class, String.class, Class.class, ProtectionDomain.class, byte[].class)).onSuper().withAllArguments()).make().load(ExecutingTransformer.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER_PERSISTENT.with(ExecutingTransformer.class.getProtectionDomain())).getLoaded().getDeclaredConstructor(ByteBuddy.class, Listener.class, PoolStrategy.class, TypeStrategy.class, LocationStrategy.class, ClassFileLocator.class, NativeMethodStrategy.class, InitializationStrategy.class, InjectionStrategy.class, LambdaInstrumentationStrategy.class, DescriptionStrategy.class, FallbackStrategy.class, ClassFileBufferStrategy.class, InstallationListener.class, RawMatcher.class, RedefinitionStrategy.ResubmissionEnforcer.class, List.class, CircularityLock.class));
                        } catch (Exception ignored) {
                            return Factory.ForLegacyVm.INSTANCE;
                        }
                    }
                }
                class ForJava9CapableVm implements Factory {
                    private final Constructor<? extends ResettableClassFileTransformer> executingTransformer;
                    protected ForJava9CapableVm(Constructor<? extends ResettableClassFileTransformer> executingTransformer) {
                        this.executingTransformer = executingTransformer;
                    }
                    public ResettableClassFileTransformer make(ByteBuddy byteBuddy, Listener listener, PoolStrategy poolStrategy, TypeStrategy typeStrategy, LocationStrategy locationStrategy, ClassFileLocator classFileLocator, NativeMethodStrategy nativeMethodStrategy, InitializationStrategy initializationStrategy, InjectionStrategy injectionStrategy, LambdaInstrumentationStrategy lambdaInstrumentationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, ClassFileBufferStrategy classFileBufferStrategy, InstallationListener installationListener, RawMatcher ignoreMatcher, RedefinitionStrategy.ResubmissionEnforcer resubmissionEnforcer, List<Transformation> transformations, CircularityLock circularityLock) {
                        try {
                            return executingTransformer.newInstance(byteBuddy, listener, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, initializationStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, resubmissionEnforcer, transformations, circularityLock);
                        } catch (IllegalAccessException exception) {
                            throw new IllegalStateException("Cannot access " + executingTransformer, exception);
                        } catch (InstantiationException exception) {
                            throw new IllegalStateException("Cannot instantiate " + executingTransformer.getDeclaringClass(), exception);
                        } catch (InvocationTargetException exception) {
                            throw new IllegalStateException("Cannot invoke " + executingTransformer, exception.getTargetException());
                        }
                    }
                }
                enum ForLegacyVm implements Factory {
                    INSTANCE;
                    public ResettableClassFileTransformer make(ByteBuddy byteBuddy, Listener listener, PoolStrategy poolStrategy, TypeStrategy typeStrategy, LocationStrategy locationStrategy, ClassFileLocator classFileLocator, NativeMethodStrategy nativeMethodStrategy, InitializationStrategy initializationStrategy, InjectionStrategy injectionStrategy, LambdaInstrumentationStrategy lambdaInstrumentationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, ClassFileBufferStrategy classFileBufferStrategy, InstallationListener installationListener, RawMatcher ignoreMatcher, RedefinitionStrategy.ResubmissionEnforcer resubmissionEnforcer, List<Transformation> transformations, CircularityLock circularityLock) {
                        return new ExecutingTransformer(byteBuddy, listener, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, initializationStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, resubmissionEnforcer, transformations, circularityLock);
                    }
                }
            }
            protected class LegacyVmDispatcher implements PrivilegedAction<byte[]> {
                private final ClassLoader classLoader;
                private final String internalName;
                private final Class<?> classBeingRedefined;
                private final ProtectionDomain protectionDomain;
                private final byte[] binaryRepresentation;
                protected LegacyVmDispatcher(@MaybeNull ClassLoader classLoader, @MaybeNull String internalName, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain, byte[] binaryRepresentation) {
                    this.classLoader = classLoader;
                    this.internalName = internalName;
                    this.classBeingRedefined = classBeingRedefined;
                    this.protectionDomain = protectionDomain;
                    this.binaryRepresentation = binaryRepresentation;
                }
                public byte[] run() {
                    return transform(JavaModule.UNSUPPORTED, classLoader, internalName, classBeingRedefined, protectionDomain, binaryRepresentation);
                }
            }
            protected class Java9CapableVmDispatcher implements PrivilegedAction<byte[]> {
                private final Object rawModule;
                private final ClassLoader classLoader;
                private final String internalName;
                private final Class<?> classBeingRedefined;
                private final ProtectionDomain protectionDomain;
                private final byte[] binaryRepresentation;
                protected Java9CapableVmDispatcher(Object rawModule, @MaybeNull ClassLoader classLoader, @MaybeNull String internalName, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain, byte[] binaryRepresentation) {
                    this.rawModule = rawModule;
                    this.classLoader = classLoader;
                    this.internalName = internalName;
                    this.classBeingRedefined = classBeingRedefined;
                    this.protectionDomain = protectionDomain;
                    this.binaryRepresentation = binaryRepresentation;
                }
                public byte[] run() {
                    return transform(JavaModule.of(rawModule), classLoader, internalName, classBeingRedefined, protectionDomain, binaryRepresentation);
                }
            }
        }
        protected abstract static class Delegator implements AgentBuilder {
            protected abstract AgentBuilder materialize();
            public AgentBuilder with(ByteBuddy byteBuddy) {
                return materialize().with(byteBuddy);
            }
            public AgentBuilder with(Listener listener) {
                return materialize().with(listener);
            }
            public AgentBuilder with(CircularityLock circularityLock) {
                return materialize().with(circularityLock);
            }
            public AgentBuilder with(TypeStrategy typeStrategy) {
                return materialize().with(typeStrategy);
            }
            public AgentBuilder with(PoolStrategy poolStrategy) {
                return materialize().with(poolStrategy);
            }
            public AgentBuilder with(LocationStrategy locationStrategy) {
                return materialize().with(locationStrategy);
            }
            public AgentBuilder with(ClassFileLocator classFileLocator) {
                return materialize().with(classFileLocator);
            }
            public AgentBuilder with(InitializationStrategy initializationStrategy) {
                return materialize().with(initializationStrategy);
            }
            public RedefinitionListenable.WithoutBatchStrategy with(RedefinitionStrategy redefinitionStrategy) {
                return materialize().with(redefinitionStrategy);
            }
            public AgentBuilder with(LambdaInstrumentationStrategy lambdaInstrumentationStrategy) {
                return materialize().with(lambdaInstrumentationStrategy);
            }
            public AgentBuilder with(DescriptionStrategy descriptionStrategy) {
                return materialize().with(descriptionStrategy);
            }
            public AgentBuilder with(FallbackStrategy fallbackStrategy) {
                return materialize().with(fallbackStrategy);
            }
            public AgentBuilder with(ClassFileBufferStrategy classFileBufferStrategy) {
                return materialize().with(classFileBufferStrategy);
            }
            public AgentBuilder with(InstallationListener installationListener) {
                return materialize().with(installationListener);
            }
            public AgentBuilder with(InjectionStrategy injectionStrategy) {
                return materialize().with(injectionStrategy);
            }
            public AgentBuilder with(TransformerDecorator transformerDecorator) {
                return materialize().with(transformerDecorator);
            }
            public AgentBuilder enableNativeMethodPrefix(String prefix) {
                return materialize().enableNativeMethodPrefix(prefix);
            }
            public AgentBuilder disableNativeMethodPrefix() {
                return materialize().disableNativeMethodPrefix();
            }
            public AgentBuilder disableClassFormatChanges() {
                return materialize().disableClassFormatChanges();
            }
            public AgentBuilder warmUp(Class<?>... type) {
                return materialize().warmUp(type);
            }
            public AgentBuilder warmUp(Collection<Class<?>> types) {
                return materialize().warmUp(types);
            }
            public AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, Class<?>... type) {
                return materialize().assureReadEdgeTo(instrumentation, type);
            }
            public AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, JavaModule... module) {
                return materialize().assureReadEdgeTo(instrumentation, module);
            }
            public AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, Collection<? extends JavaModule> modules) {
                return materialize().assureReadEdgeTo(instrumentation, modules);
            }
            public AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, Class<?>... type) {
                return materialize().assureReadEdgeFromAndTo(instrumentation, type);
            }
            public AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, JavaModule... module) {
                return materialize().assureReadEdgeFromAndTo(instrumentation, module);
            }
            public AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, Collection<? extends JavaModule> modules) {
                return materialize().assureReadEdgeFromAndTo(instrumentation, modules);
            }
            public Identified.Narrowable type(ElementMatcher<? super TypeDescription> typeMatcher) {
                return materialize().type(typeMatcher);
            }
            public Identified.Narrowable type(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher) {
                return materialize().type(typeMatcher, classLoaderMatcher);
            }
            public Identified.Narrowable type(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher) {
                return materialize().type(typeMatcher, classLoaderMatcher, moduleMatcher);
            }
            public Identified.Narrowable type(RawMatcher matcher) {
                return materialize().type(matcher);
            }
            public Ignored ignore(ElementMatcher<? super TypeDescription> ignoredTypes) {
                return materialize().ignore(ignoredTypes);
            }
            public Ignored ignore(ElementMatcher<? super TypeDescription> ignoredTypes, ElementMatcher<? super ClassLoader> ignoredClassLoaders) {
                return materialize().ignore(ignoredTypes, ignoredClassLoaders);
            }
            public Ignored ignore(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher) {
                return materialize().ignore(typeMatcher, classLoaderMatcher, moduleMatcher);
            }
            public Ignored ignore(RawMatcher rawMatcher) {
                return materialize().ignore(rawMatcher);
            }
            public ClassFileTransformer makeRaw() {
                return materialize().makeRaw();
            }
            public ResettableClassFileTransformer installOn(Instrumentation instrumentation) {
                return materialize().installOn(instrumentation);
            }
            public ResettableClassFileTransformer installOnByteBuddyAgent() {
                return materialize().installOnByteBuddyAgent();
            }
            public ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
                return materialize().patchOn(instrumentation, classFileTransformer);
            }
            public ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, RawMatcher differentialMatcher) {
                return materialize().patchOn(instrumentation, classFileTransformer, differentialMatcher);
            }
            public ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, PatchMode patchMode) {
                return materialize().patchOn(instrumentation, classFileTransformer, patchMode);
            }
            public ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, RawMatcher differentialMatcher, PatchMode patchMode) {
                return materialize().patchOn(instrumentation, classFileTransformer, differentialMatcher, patchMode);
            }
            public ResettableClassFileTransformer patchOnByteBuddyAgent(ResettableClassFileTransformer classFileTransformer) {
                return materialize().patchOnByteBuddyAgent(classFileTransformer);
            }
            public ResettableClassFileTransformer patchOnByteBuddyAgent(ResettableClassFileTransformer classFileTransformer, PatchMode patchMode) {
                return materialize().patchOnByteBuddyAgent(classFileTransformer, patchMode);
            }
            protected abstract static class Matchable<S extends AgentBuilder.Matchable<S>> extends Delegator implements AgentBuilder.Matchable<S> {
                public S and(ElementMatcher<? super TypeDescription> typeMatcher) {
                    return and(typeMatcher, any());
                }
                public S and(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher) {
                    return and(typeMatcher, classLoaderMatcher, any());
                }
                public S and(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher) {
                    return and(new RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, moduleMatcher));
                }
                public S or(ElementMatcher<? super TypeDescription> typeMatcher) {
                    return or(typeMatcher, any());
                }
                public S or(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher) {
                    return or(typeMatcher, classLoaderMatcher, any());
                }
                public S or(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher) {
                    return or(new RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, moduleMatcher));
                }
            }
        }
        protected class Ignoring extends Delegator.Matchable<Ignored> implements Ignored {
            private final RawMatcher rawMatcher;
            protected Ignoring(RawMatcher rawMatcher) {
                this.rawMatcher = rawMatcher;
            }
            protected AgentBuilder materialize() {
                return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, rawMatcher, transformations);
            }
            public Ignored and(RawMatcher rawMatcher) {
                return new Ignoring(new RawMatcher.Conjunction(this.rawMatcher, rawMatcher));
            }
            public Ignored or(RawMatcher rawMatcher) {
                return new Ignoring(new RawMatcher.Disjunction(this.rawMatcher, rawMatcher));
            }
        }
        protected class Transforming extends Delegator.Matchable<Identified.Narrowable> implements Identified.Extendable, Identified.Narrowable {
            private final RawMatcher rawMatcher;
            private final List<Transformer> transformers;
            private final boolean terminal;
            protected Transforming(RawMatcher rawMatcher, List<Transformer> transformers, boolean terminal) {
                this.rawMatcher = rawMatcher;
                this.transformers = transformers;
                this.terminal = terminal;
            }
            protected AgentBuilder materialize() {
                return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, CompoundList.of(transformations, new Transformation(rawMatcher, transformers, terminal)));
            }
            public Identified.Extendable transform(Transformer transformer) {
                return new Transforming(rawMatcher, CompoundList.of(this.transformers, transformer), terminal);
            }
            public AgentBuilder asTerminalTransformation() {
                return new Transforming(rawMatcher, transformers, true);
            }
            public Narrowable and(RawMatcher rawMatcher) {
                return new Transforming(new RawMatcher.Conjunction(this.rawMatcher, rawMatcher), transformers, terminal);
            }
            public Narrowable or(RawMatcher rawMatcher) {
                return new Transforming(new RawMatcher.Disjunction(this.rawMatcher, rawMatcher), transformers, terminal);
            }
        }
        protected static class Redefining extends Default implements RedefinitionListenable.WithoutBatchStrategy {
            protected Redefining(ByteBuddy byteBuddy, Listener listener, CircularityLock circularityLock, PoolStrategy poolStrategy, TypeStrategy typeStrategy, LocationStrategy locationStrategy, ClassFileLocator classFileLocator, NativeMethodStrategy nativeMethodStrategy, WarmupStrategy warmupStrategy, TransformerDecorator transformerDecorator, InitializationStrategy initializationStrategy, RedefinitionStrategy redefinitionStrategy, RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy, RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator, RedefinitionStrategy.Listener redefinitionListener, RedefinitionStrategy.ResubmissionStrategy redefinitionResubmissionStrategy, InjectionStrategy injectionStrategy, LambdaInstrumentationStrategy lambdaInstrumentationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, ClassFileBufferStrategy classFileBufferStrategy, InstallationListener installationListener, RawMatcher ignoreMatcher, List<Transformation> transformations) {
                super(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
            }
            public WithImplicitDiscoveryStrategy with(RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator) {
                if (!redefinitionStrategy.isEnabled()) {
                    throw new IllegalStateException("Cannot set redefinition batch allocator when redefinition is disabled");
                }
                return new Redefining(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
            }
            public RedefinitionListenable redefineOnly(Class<?>... type) {
                return with(new RedefinitionStrategy.DiscoveryStrategy.Explicit(type));
            }
            public RedefinitionListenable with(RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy) {
                if (!redefinitionStrategy.isEnabled()) {
                    throw new IllegalStateException("Cannot set redefinition discovery strategy when redefinition is disabled");
                }
                return new Redefining(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
            }
            public RedefinitionListenable with(RedefinitionStrategy.Listener redefinitionListener) {
                if (!redefinitionStrategy.isEnabled()) {
                    throw new IllegalStateException("Cannot set redefinition listener when redefinition is disabled");
                }
                return new Redefining(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, new RedefinitionStrategy.Listener.Compound(this.redefinitionListener, redefinitionListener), redefinitionResubmissionStrategy, injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
            }
            public WithoutResubmissionSpecification withResubmission(RedefinitionStrategy.ResubmissionScheduler resubmissionScheduler) {
                if (!redefinitionStrategy.isEnabled()) {
                    throw new IllegalStateException("Cannot enable resubmission when redefinition is disabled");
                }
                return new WithResubmission(resubmissionScheduler, ResubmissionOnErrorMatcher.Trivial.NON_MATCHING, ResubmissionImmediateMatcher.Trivial.NON_MATCHING);
            }
            protected class WithResubmission extends Delegator implements WithResubmissionSpecification {
                private final RedefinitionStrategy.ResubmissionScheduler resubmissionScheduler;
                private final ResubmissionOnErrorMatcher resubmissionOnErrorMatcher;
                private final ResubmissionImmediateMatcher resubmissionImmediateMatcher;
                protected WithResubmission(RedefinitionStrategy.ResubmissionScheduler resubmissionScheduler, ResubmissionOnErrorMatcher resubmissionOnErrorMatcher, ResubmissionImmediateMatcher resubmissionImmediateMatcher) {
                    this.resubmissionScheduler = resubmissionScheduler;
                    this.resubmissionOnErrorMatcher = resubmissionOnErrorMatcher;
                    this.resubmissionImmediateMatcher = resubmissionImmediateMatcher;
                }
                protected AgentBuilder materialize() {
                    return new Default(byteBuddy, listener, circularityLock, poolStrategy, typeStrategy, locationStrategy, classFileLocator, nativeMethodStrategy, warmupStrategy, transformerDecorator, initializationStrategy, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener, new RedefinitionStrategy.ResubmissionStrategy.Enabled(resubmissionScheduler, resubmissionOnErrorMatcher, resubmissionImmediateMatcher), injectionStrategy, lambdaInstrumentationStrategy, descriptionStrategy, fallbackStrategy, classFileBufferStrategy, installationListener, ignoreMatcher, transformations);
                }
                public WithResubmissionSpecification resubmitOnError() {
                    return resubmitOnError(ElementMatchers.<Throwable>any());
                }
                public WithResubmissionSpecification resubmitOnError(ElementMatcher<? super Throwable> exceptionMatcher) {
                    return resubmitOnError(exceptionMatcher, ElementMatchers.<String>any());
                }
                public WithResubmissionSpecification resubmitOnError(ElementMatcher<? super Throwable> exceptionMatcher, ElementMatcher<String> typeNameMatcher) {
                    return resubmitOnError(exceptionMatcher, typeNameMatcher, ElementMatchers.<ClassLoader>any());
                }
                public WithResubmissionSpecification resubmitOnError(ElementMatcher<? super Throwable> exceptionMatcher, ElementMatcher<String> typeNameMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher) {
                    return resubmitOnError(exceptionMatcher, typeNameMatcher, classLoaderMatcher, ElementMatchers.<JavaModule>any());
                }
                public WithResubmissionSpecification resubmitOnError(ElementMatcher<? super Throwable> exceptionMatcher, ElementMatcher<String> typeNameMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher) {
                    return resubmitOnError(new ResubmissionOnErrorMatcher.ForElementMatchers(exceptionMatcher, typeNameMatcher, classLoaderMatcher, moduleMatcher));
                }
                public WithResubmissionSpecification resubmitOnError(ResubmissionOnErrorMatcher matcher) {
                    return new WithResubmission(resubmissionScheduler, new ResubmissionOnErrorMatcher.Disjunction(resubmissionOnErrorMatcher, matcher), resubmissionImmediateMatcher);
                }
                public WithResubmissionSpecification resubmitImmediate() {
                    return resubmitImmediate(ElementMatchers.<String>any());
                }
                public WithResubmissionSpecification resubmitImmediate(ElementMatcher<String> typeNameMatcher) {
                    return resubmitImmediate(typeNameMatcher, ElementMatchers.<ClassLoader>any());
                }
                public WithResubmissionSpecification resubmitImmediate(ElementMatcher<String> typeNameMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher) {
                    return resubmitImmediate(typeNameMatcher, classLoaderMatcher, ElementMatchers.<JavaModule>any());
                }
                public WithResubmissionSpecification resubmitImmediate(ElementMatcher<String> typeNameMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher, ElementMatcher<? super JavaModule> moduleMatcher) {
                    return resubmitImmediate(new ResubmissionImmediateMatcher.ForElementMatchers(typeNameMatcher, classLoaderMatcher, moduleMatcher));
                }
                public WithResubmissionSpecification resubmitImmediate(ResubmissionImmediateMatcher matcher) {
                    return new WithResubmission(resubmissionScheduler, resubmissionOnErrorMatcher, new ResubmissionImmediateMatcher.Disjunction(resubmissionImmediateMatcher, matcher));
                }
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```