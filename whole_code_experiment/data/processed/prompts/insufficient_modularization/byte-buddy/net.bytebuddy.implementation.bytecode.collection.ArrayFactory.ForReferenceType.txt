##CONTEXT_SIZE=1077
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.implementation.bytecode.collection;
public class ArrayFactory implements CollectionFactory {
    private final TypeDescription.Generic componentType;
    private final ArrayCreator arrayCreator;
    private final StackManipulation.Size sizeDecrease;
    protected ArrayFactory(TypeDescription.Generic componentType, ArrayCreator arrayCreator) {
        this.componentType = componentType;
        this.arrayCreator = arrayCreator;
        sizeDecrease = StackSize.DOUBLE.toDecreasingSize().aggregate(componentType.getStackSize().toDecreasingSize());
    }
    public static ArrayFactory forType(TypeDescription.Generic componentType) {
        return new ArrayFactory(componentType, makeArrayCreatorFor(componentType));
    }
    private static ArrayCreator makeArrayCreatorFor(TypeDefinition componentType) {
        if (!componentType.isPrimitive()) {
            return new ArrayCreator.ForReferenceType(componentType.asErasure());
        } else if (componentType.represents(boolean.class)) {
            return ArrayCreator.ForPrimitiveType.BOOLEAN;
        } else if (componentType.represents(byte.class)) {
            return ArrayCreator.ForPrimitiveType.BYTE;
        } else if (componentType.represents(short.class)) {
            return ArrayCreator.ForPrimitiveType.SHORT;
        } else if (componentType.represents(char.class)) {
            return ArrayCreator.ForPrimitiveType.CHARACTER;
        } else if (componentType.represents(int.class)) {
            return ArrayCreator.ForPrimitiveType.INTEGER;
        } else if (componentType.represents(long.class)) {
            return ArrayCreator.ForPrimitiveType.LONG;
        } else if (componentType.represents(float.class)) {
            return ArrayCreator.ForPrimitiveType.FLOAT;
        } else if (componentType.represents(double.class)) {
            return ArrayCreator.ForPrimitiveType.DOUBLE;
        } else {
            throw new IllegalArgumentException("Cannot create array of type " + componentType);
        }
    }
    public StackManipulation withValues(List<? extends StackManipulation> stackManipulations) {
        return new ArrayStackManipulation(stackManipulations);
    }
    public TypeDescription.Generic getComponentType() {
        return componentType;
    }
    protected interface ArrayCreator extends StackManipulation {
        StackManipulation.Size ARRAY_CREATION_SIZE_CHANGE = StackSize.ZERO.toDecreasingSize();
        int getStorageOpcode();
        enum ForPrimitiveType implements ArrayCreator {
            BOOLEAN(Opcodes.T_BOOLEAN, Opcodes.BASTORE),
            BYTE(Opcodes.T_BYTE, Opcodes.BASTORE),
            SHORT(Opcodes.T_SHORT, Opcodes.SASTORE),
            CHARACTER(Opcodes.T_CHAR, Opcodes.CASTORE),
            INTEGER(Opcodes.T_INT, Opcodes.IASTORE),
            LONG(Opcodes.T_LONG, Opcodes.LASTORE),
            FLOAT(Opcodes.T_FLOAT, Opcodes.FASTORE),
            DOUBLE(Opcodes.T_DOUBLE, Opcodes.DASTORE);
            private final int creationOpcode;
            private final int storageOpcode;
            ForPrimitiveType(int creationOpcode, int storageOpcode) {
                this.creationOpcode = creationOpcode;
                this.storageOpcode = storageOpcode;
            }
            public boolean isValid() {
                return true;
            }
            public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                methodVisitor.visitIntInsn(Opcodes.NEWARRAY, creationOpcode);
                return ARRAY_CREATION_SIZE_CHANGE;
            }
            public int getStorageOpcode() {
                return storageOpcode;
            }
        }
        class ForReferenceType extends StackManipulation.AbstractBase implements ArrayCreator {
            private final String internalTypeName;
            protected ForReferenceType(TypeDescription referenceType) {
                this.internalTypeName = referenceType.getInternalName();
            }
            public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, internalTypeName);
                return ARRAY_CREATION_SIZE_CHANGE;
            }
            public int getStorageOpcode() {
                return Opcodes.AASTORE;
            }
        }
    }
    protected class ArrayStackManipulation implements StackManipulation {
        private final List<? extends StackManipulation> stackManipulations;
        protected ArrayStackManipulation(List<? extends StackManipulation> stackManipulations) {
            this.stackManipulations = stackManipulations;
        }
        public boolean isValid() {
            for (StackManipulation stackManipulation : stackManipulations) {
                if (!stackManipulation.isValid()) {
                    return false;
                }
            }
            return arrayCreator.isValid();
        }
        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
            Size size = IntegerConstant.forValue(stackManipulations.size()).apply(methodVisitor, implementationContext);
            size = size.aggregate(arrayCreator.apply(methodVisitor, implementationContext));
            int index = 0;
            for (StackManipulation stackManipulation : stackManipulations) {
                methodVisitor.visitInsn(Opcodes.DUP);
                size = size.aggregate(StackSize.SINGLE.toIncreasingSize());
                size = size.aggregate(IntegerConstant.forValue(index++).apply(methodVisitor, implementationContext));
                size = size.aggregate(stackManipulation.apply(methodVisitor, implementationContext));
                methodVisitor.visitInsn(arrayCreator.getStorageOpcode());
                size = size.aggregate(sizeDecrease);
            }
            return size;
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```