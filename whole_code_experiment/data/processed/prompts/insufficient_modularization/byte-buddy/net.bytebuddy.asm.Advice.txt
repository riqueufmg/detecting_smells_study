##CONTEXT_SIZE=65182
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.asm;
public class Advice implements AsmVisitorWrapper.ForDeclaredMethods.MethodVisitorWrapper, Implementation {
    private static final AsmClassReader UNDEFINED = null;
    private static final MethodDescription.InDefinedShape SKIP_ON;
    private static final MethodDescription.InDefinedShape SKIP_ON_INDEX;
    private static final MethodDescription.InDefinedShape PREPEND_LINE_NUMBER;
    private static final MethodDescription.InDefinedShape INLINE_ENTER;
    private static final MethodDescription.InDefinedShape SUPPRESS_ENTER;
    private static final MethodDescription.InDefinedShape REPEAT_ON;
    private static final MethodDescription.InDefinedShape REPEAT_ON_INDEX;
    private static final MethodDescription.InDefinedShape ON_THROWABLE;
    private static final MethodDescription.InDefinedShape BACKUP_ARGUMENTS;
    private static final MethodDescription.InDefinedShape INLINE_EXIT;
    private static final MethodDescription.InDefinedShape SUPPRESS_EXIT;
    static {
        MethodList<MethodDescription.InDefinedShape> enter = TypeDescription.ForLoadedType.of(OnMethodEnter.class).getDeclaredMethods();
        SKIP_ON = enter.filter(named("skipOn")).getOnly();
        SKIP_ON_INDEX = enter.filter(named("skipOnIndex")).getOnly();
        PREPEND_LINE_NUMBER = enter.filter(named("prependLineNumber")).getOnly();
        INLINE_ENTER = enter.filter(named("inline")).getOnly();
        SUPPRESS_ENTER = enter.filter(named("suppress")).getOnly();
        MethodList<MethodDescription.InDefinedShape> exit = TypeDescription.ForLoadedType.of(OnMethodExit.class).getDeclaredMethods();
        REPEAT_ON = exit.filter(named("repeatOn")).getOnly();
        REPEAT_ON_INDEX = exit.filter(named("repeatOnIndex")).getOnly();
        ON_THROWABLE = exit.filter(named("onThrowable")).getOnly();
        BACKUP_ARGUMENTS = exit.filter(named("backupArguments")).getOnly();
        INLINE_EXIT = exit.filter(named("inline")).getOnly();
        SUPPRESS_EXIT = exit.filter(named("suppress")).getOnly();
    }
    private final Dispatcher.Resolved.ForMethodEnter methodEnter;
    private final Dispatcher.Resolved.ForMethodExit methodExit;
    private final Assigner assigner;
    private final ExceptionHandler exceptionHandler;
    private final Implementation delegate;
    protected Advice(Dispatcher.Resolved.ForMethodEnter methodEnter, Dispatcher.Resolved.ForMethodExit methodExit) {
        this(methodEnter, methodExit, Assigner.DEFAULT, ExceptionHandler.Default.SUPPRESSING, SuperMethodCall.INSTANCE);
    }
    private Advice(Dispatcher.Resolved.ForMethodEnter methodEnter, Dispatcher.Resolved.ForMethodExit methodExit, Assigner assigner, ExceptionHandler exceptionHandler, Implementation delegate) {
        this.methodEnter = methodEnter;
        this.methodExit = methodExit;
        this.assigner = assigner;
        this.exceptionHandler = exceptionHandler;
        this.delegate = delegate;
    }
    public static Advice to(Class<?> advice) {
        return to(advice, ClassFileLocator.ForClassLoader.of(advice.getClassLoader()));
    }
    public static Advice to(Class<?> advice, ClassFileLocator classFileLocator) {
        return to(TypeDescription.ForLoadedType.of(advice), classFileLocator);
    }
    public static Advice to(TypeDescription advice) {
        return to(advice, ClassFileLocator.NoOp.INSTANCE);
    }
    public static Advice to(TypeDescription advice, ClassFileLocator classFileLocator) {
        return to(advice, PostProcessor.NoOp.INSTANCE, classFileLocator, Collections.<OffsetMapping.Factory<?>>emptyList(), Delegator.ForRegularInvocation.Factory.INSTANCE, AsmClassReader.Factory.Default.IMPLICIT);
    }
    protected static Advice to(TypeDescription advice, PostProcessor.Factory postProcessorFactory, ClassFileLocator classFileLocator, List<? extends OffsetMapping.Factory<?>> userFactories, Delegator.Factory delegatorFactory, AsmClassReader.Factory classReaderFactory) {
        Dispatcher.Unresolved methodEnter = Dispatcher.Inactive.INSTANCE, methodExit = Dispatcher.Inactive.INSTANCE;
        for (MethodDescription.InDefinedShape methodDescription : advice.getDeclaredMethods()) {
            methodEnter = locate(OnMethodEnter.class, INLINE_ENTER, methodEnter, methodDescription, delegatorFactory);
            methodExit = locate(OnMethodExit.class, INLINE_EXIT, methodExit, methodDescription, delegatorFactory);
        }
        if (!methodEnter.isAlive() && !methodExit.isAlive()) {
            throw new IllegalArgumentException("No advice defined by " + advice);
        }
        try {
            AsmClassReader classReader = methodEnter.isBinary() || methodExit.isBinary() ? classReaderFactory.make(classFileLocator.locate(advice.getName()).resolve()) : UNDEFINED;
            return new Advice(methodEnter.asMethodEnter(userFactories, classReader, methodExit, postProcessorFactory), methodExit.asMethodExit(userFactories, classReader, methodEnter, postProcessorFactory));
        } catch (IOException exception) {
            throw new IllegalStateException("Error reading class file of " + advice, exception);
        }
    }
    public static Advice to(Class<?> enterAdvice, Class<?> exitAdvice) {
        ClassLoader enterLoader = enterAdvice.getClassLoader(), exitLoader = exitAdvice.getClassLoader();
        return to(enterAdvice, exitAdvice, enterLoader == exitLoader ? ClassFileLocator.ForClassLoader.of(enterLoader) : new ClassFileLocator.Compound(ClassFileLocator.ForClassLoader.of(enterLoader), ClassFileLocator.ForClassLoader.of(exitLoader)));
    }
    public static Advice to(Class<?> enterAdvice, Class<?> exitAdvice, ClassFileLocator classFileLocator) {
        return to(TypeDescription.ForLoadedType.of(enterAdvice), TypeDescription.ForLoadedType.of(exitAdvice), classFileLocator);
    }
    public static Advice to(TypeDescription enterAdvice, TypeDescription exitAdvice) {
        return to(enterAdvice, exitAdvice, ClassFileLocator.NoOp.INSTANCE);
    }
    public static Advice to(TypeDescription enterAdvice, TypeDescription exitAdvice, ClassFileLocator classFileLocator) {
        return to(enterAdvice, exitAdvice, PostProcessor.NoOp.INSTANCE, classFileLocator, Collections.<OffsetMapping.Factory<?>>emptyList(), Delegator.ForRegularInvocation.Factory.INSTANCE, AsmClassReader.Factory.Default.IMPLICIT);
    }
    protected static Advice to(TypeDescription enterAdvice, TypeDescription exitAdvice, PostProcessor.Factory postProcessorFactory, ClassFileLocator classFileLocator, List<? extends OffsetMapping.Factory<?>> userFactories, Delegator.Factory delegatorFactory, AsmClassReader.Factory classReaderFactory) {
        Dispatcher.Unresolved methodEnter = Dispatcher.Inactive.INSTANCE, methodExit = Dispatcher.Inactive.INSTANCE;
        for (MethodDescription.InDefinedShape methodDescription : enterAdvice.getDeclaredMethods()) {
            methodEnter = locate(OnMethodEnter.class, INLINE_ENTER, methodEnter, methodDescription, delegatorFactory);
        }
        if (!methodEnter.isAlive()) {
            throw new IllegalArgumentException("No enter advice defined by " + enterAdvice);
        }
        for (MethodDescription.InDefinedShape methodDescription : exitAdvice.getDeclaredMethods()) {
            methodExit = locate(OnMethodExit.class, INLINE_EXIT, methodExit, methodDescription, delegatorFactory);
        }
        if (!methodExit.isAlive()) {
            throw new IllegalArgumentException("No exit advice defined by " + exitAdvice);
        }
        try {
            return new Advice(methodEnter.asMethodEnter(userFactories, methodEnter.isBinary() ? classReaderFactory.make(classFileLocator.locate(enterAdvice.getName()).resolve()) : UNDEFINED, methodExit, postProcessorFactory), methodExit.asMethodExit(userFactories, methodExit.isBinary() ? classReaderFactory.make(classFileLocator.locate(exitAdvice.getName()).resolve()) : UNDEFINED, methodEnter, postProcessorFactory));
        } catch (IOException exception) {
            throw new IllegalStateException("Error reading class file of " + enterAdvice + " or " + exitAdvice, exception);
        }
    }
    private static Dispatcher.Unresolved locate(Class<? extends Annotation> type, MethodDescription.InDefinedShape property, Dispatcher.Unresolved dispatcher, MethodDescription.InDefinedShape methodDescription, Delegator.Factory delegatorFactory) {
        AnnotationDescription annotation = methodDescription.getDeclaredAnnotations().ofType(type);
        if (annotation == null) {
            return dispatcher;
        } else if (dispatcher.isAlive()) {
            throw new IllegalStateException("Duplicate advice for " + dispatcher + " and " + methodDescription);
        } else if (!methodDescription.isStatic()) {
            throw new IllegalStateException("Advice for " + methodDescription + " is not static");
        } else {
            return annotation.getValue(property).resolve(Boolean.class) ? new Dispatcher.Inlining(methodDescription) : new Dispatcher.Delegating(methodDescription, delegatorFactory);
        }
    }
    public static WithCustomMapping withCustomMapping() {
        return new WithCustomMapping();
    }
    public AsmVisitorWrapper.ForDeclaredMethods on(ElementMatcher<? super MethodDescription> matcher) {
        return new AsmVisitorWrapper.ForDeclaredMethods().invokable(matcher, this);
    }
    public MethodVisitor wrap(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, TypePool typePool, int writerFlags, int readerFlags) {
        return instrumentedMethod.isAbstract() || instrumentedMethod.isNative() ? methodVisitor : doWrap(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, writerFlags, readerFlags);
    }
    protected MethodVisitor doWrap(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, int writerFlags, int readerFlags) {
        if (methodEnter.isPrependLineNumber()) {
            methodVisitor = new LineNumberPrependingMethodVisitor(methodVisitor);
        }
        if (!methodExit.isAlive()) {
            return new AdviceVisitor.WithoutExitAdvice(methodVisitor, implementationContext, assigner, exceptionHandler.resolve(instrumentedMethod, instrumentedType), instrumentedType, instrumentedMethod, methodEnter, writerFlags, readerFlags);
        } else if (methodExit.getThrowable().represents(NoExceptionHandler.class)) {
            return new AdviceVisitor.WithExitAdvice.WithoutExceptionHandling(methodVisitor, implementationContext, assigner, exceptionHandler.resolve(instrumentedMethod, instrumentedType), instrumentedType, instrumentedMethod, methodEnter, methodExit, writerFlags, readerFlags);
        } else if (instrumentedMethod.isConstructor()) {
            throw new IllegalStateException("Cannot catch exception during constructor call for " + instrumentedMethod);
        } else {
            return new AdviceVisitor.WithExitAdvice.WithExceptionHandling(methodVisitor, implementationContext, assigner, exceptionHandler.resolve(instrumentedMethod, instrumentedType), instrumentedType, instrumentedMethod, methodEnter, methodExit, writerFlags, readerFlags, methodExit.getThrowable());
        }
    }
    public InstrumentedType prepare(InstrumentedType instrumentedType) {
        return delegate.prepare(instrumentedType);
    }
    public ByteCodeAppender appender(Target implementationTarget) {
        return new Appender(this, implementationTarget, delegate.appender(implementationTarget));
    }
    public Advice withAssigner(Assigner assigner) {
        return new Advice(methodEnter, methodExit, assigner, exceptionHandler, delegate);
    }
    public Advice withExceptionPrinting() {
        return withExceptionHandler(ExceptionHandler.Default.PRINTING);
    }
    public Advice withExceptionHandler(StackManipulation exceptionHandler) {
        return withExceptionHandler(new ExceptionHandler.Simple(exceptionHandler));
    }
    public Advice withExceptionHandler(ExceptionHandler exceptionHandler) {
        return new Advice(methodEnter, methodExit, assigner, exceptionHandler, delegate);
    }
    public Implementation wrap(Implementation implementation) {
        return new Advice(methodEnter, methodExit, assigner, exceptionHandler, implementation);
    }
    public interface OffsetMapping {
        Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort);
        interface Target {
            StackManipulation resolveRead();
            StackManipulation resolveWrite();
            StackManipulation resolveIncrement(int value);
            abstract class AbstractReadOnlyAdapter implements Target {
                public StackManipulation resolveWrite() {
                    throw new IllegalStateException("Cannot write to read-only value");
                }
                public StackManipulation resolveIncrement(int value) {
                    throw new IllegalStateException("Cannot write to read-only value");
                }
            }
            abstract class ForDefaultValue implements Target {
                protected final TypeDefinition typeDefinition;
                protected final StackManipulation readAssignment;
                protected ForDefaultValue(TypeDefinition typeDefinition, StackManipulation readAssignment) {
                    this.typeDefinition = typeDefinition;
                    this.readAssignment = readAssignment;
                }
                public StackManipulation resolveRead() {
                    return new StackManipulation.Compound(DefaultValue.of(typeDefinition), readAssignment);
                }
                public static class ReadOnly extends ForDefaultValue {
                    public ReadOnly(TypeDefinition typeDefinition) {
                        this(typeDefinition, StackManipulation.Trivial.INSTANCE);
                    }
                    public ReadOnly(TypeDefinition typeDefinition, StackManipulation readAssignment) {
                        super(typeDefinition, readAssignment);
                    }
                    public StackManipulation resolveWrite() {
                        throw new IllegalStateException("Cannot write to read-only default value");
                    }
                    public StackManipulation resolveIncrement(int value) {
                        throw new IllegalStateException("Cannot write to read-only default value");
                    }
                }
                public static class ReadWrite extends ForDefaultValue {
                    public ReadWrite(TypeDefinition typeDefinition) {
                        this(typeDefinition, StackManipulation.Trivial.INSTANCE);
                    }
                    public ReadWrite(TypeDefinition typeDefinition, StackManipulation readAssignment) {
                        super(typeDefinition, readAssignment);
                    }
                    public StackManipulation resolveWrite() {
                        return Removal.of(typeDefinition);
                    }
                    public StackManipulation resolveIncrement(int value) {
                        return StackManipulation.Trivial.INSTANCE;
                    }
                }
            }
            abstract class ForVariable implements Target {
                protected final TypeDefinition typeDefinition;
                protected final int offset;
                protected final StackManipulation readAssignment;
                protected ForVariable(TypeDefinition typeDefinition, int offset, StackManipulation readAssignment) {
                    this.typeDefinition = typeDefinition;
                    this.offset = offset;
                    this.readAssignment = readAssignment;
                }
                public StackManipulation resolveRead() {
                    return new StackManipulation.Compound(MethodVariableAccess.of(typeDefinition).loadFrom(offset), readAssignment);
                }
                public static class ReadOnly extends ForVariable {
                    public ReadOnly(TypeDefinition typeDefinition, int offset) {
                        this(typeDefinition, offset, StackManipulation.Trivial.INSTANCE);
                    }
                    public ReadOnly(TypeDefinition typeDefinition, int offset, StackManipulation readAssignment) {
                        super(typeDefinition, offset, readAssignment);
                    }
                    public StackManipulation resolveWrite() {
                        throw new IllegalStateException("Cannot write to read-only parameter " + typeDefinition + " at " + offset);
                    }
                    public StackManipulation resolveIncrement(int value) {
                        throw new IllegalStateException("Cannot write to read-only variable " + typeDefinition + " at " + offset);
                    }
                }
                public static class ReadWrite extends ForVariable {
                    private final StackManipulation writeAssignment;
                    public ReadWrite(TypeDefinition typeDefinition, int offset) {
                        this(typeDefinition, offset, StackManipulation.Trivial.INSTANCE, StackManipulation.Trivial.INSTANCE);
                    }
                    public ReadWrite(TypeDefinition typeDefinition, int offset, StackManipulation readAssignment, StackManipulation writeAssignment) {
                        super(typeDefinition, offset, readAssignment);
                        this.writeAssignment = writeAssignment;
                    }
                    public StackManipulation resolveWrite() {
                        return new StackManipulation.Compound(writeAssignment, MethodVariableAccess.of(typeDefinition).storeAt(offset));
                    }
                    public StackManipulation resolveIncrement(int value) {
                        return typeDefinition.represents(int.class) ? MethodVariableAccess.of(typeDefinition).increment(offset, value) : new StackManipulation.Compound(resolveRead(), IntegerConstant.forValue(1), Addition.INTEGER, resolveWrite());
                    }
                }
            }
            abstract class ForArray implements Target {
                protected final TypeDescription.Generic target;
                protected final List<? extends StackManipulation> valueReads;
                protected ForArray(TypeDescription.Generic target, List<? extends StackManipulation> valueReads) {
                    this.target = target;
                    this.valueReads = valueReads;
                }
                public StackManipulation resolveRead() {
                    return ArrayFactory.forType(target).withValues(valueReads);
                }
                public StackManipulation resolveIncrement(int value) {
                    throw new IllegalStateException("Cannot increment read-only array value");
                }
                public static class ReadOnly extends ForArray {
                    public ReadOnly(TypeDescription.Generic target, List<? extends StackManipulation> valueReads) {
                        super(target, valueReads);
                    }
                    public StackManipulation resolveWrite() {
                        throw new IllegalStateException("Cannot write to read-only array value");
                    }
                }
                public static class ReadWrite extends ForArray {
                    private final List<? extends StackManipulation> valueWrites;
                    public ReadWrite(TypeDescription.Generic target, List<? extends StackManipulation> valueReads, List<? extends StackManipulation> valueWrites) {
                        super(target, valueReads);
                        this.valueWrites = valueWrites;
                    }
                    public StackManipulation resolveWrite() {
                        return new StackManipulation.Compound(ArrayAccess.of(target).forEach(valueWrites), Removal.SINGLE);
                    }
                }
            }
            abstract class ForField implements Target {
                protected final FieldDescription fieldDescription;
                protected final StackManipulation readAssignment;
                protected ForField(FieldDescription fieldDescription, StackManipulation readAssignment) {
                    this.fieldDescription = fieldDescription;
                    this.readAssignment = readAssignment;
                }
                public StackManipulation resolveRead() {
                    return new StackManipulation.Compound(fieldDescription.isStatic() ? StackManipulation.Trivial.INSTANCE : MethodVariableAccess.loadThis(), FieldAccess.forField(fieldDescription).read(), readAssignment);
                }
                public static class ReadOnly extends ForField {
                    public ReadOnly(FieldDescription fieldDescription) {
                        this(fieldDescription, StackManipulation.Trivial.INSTANCE);
                    }
                    public ReadOnly(FieldDescription fieldDescription, StackManipulation readAssignment) {
                        super(fieldDescription, readAssignment);
                    }
                    public StackManipulation resolveWrite() {
                        throw new IllegalStateException("Cannot write to read-only field value");
                    }
                    public StackManipulation resolveIncrement(int value) {
                        throw new IllegalStateException("Cannot write to read-only field value");
                    }
                }
                public static class WriteOnly implements Target {
                    private final FieldDescription fieldDescription;
                    private final StackManipulation writeAssignment;
                    protected WriteOnly(FieldDescription fieldDescription, StackManipulation writeAssignment) {
                        this.fieldDescription = fieldDescription;
                        this.writeAssignment = writeAssignment;
                    }
                    public StackManipulation resolveRead() {
                        throw new IllegalStateException("Cannot read write-only field value");
                    }
                    public StackManipulation resolveWrite() {
                        StackManipulation preparation;
                        if (fieldDescription.isStatic()) {
                            preparation = StackManipulation.Trivial.INSTANCE;
                        } else {
                            preparation = new StackManipulation.Compound(MethodVariableAccess.loadThis(), Duplication.SINGLE.flipOver(fieldDescription.getType()), Removal.SINGLE);
                        }
                        return new StackManipulation.Compound(writeAssignment, preparation, FieldAccess.forField(fieldDescription).write());
                    }
                    public StackManipulation resolveIncrement(int value) {
                        throw new IllegalStateException("Cannot increment write-only field value");
                    }
                }
                public static class ReadWrite extends ForField {
                    private final StackManipulation writeAssignment;
                    public ReadWrite(FieldDescription fieldDescription) {
                        this(fieldDescription, StackManipulation.Trivial.INSTANCE, StackManipulation.Trivial.INSTANCE);
                    }
                    public ReadWrite(FieldDescription fieldDescription, StackManipulation readAssignment, StackManipulation writeAssignment) {
                        super(fieldDescription, readAssignment);
                        this.writeAssignment = writeAssignment;
                    }
                    public StackManipulation resolveWrite() {
                        StackManipulation preparation;
                        if (fieldDescription.isStatic()) {
                            preparation = StackManipulation.Trivial.INSTANCE;
                        } else {
                            preparation = new StackManipulation.Compound(MethodVariableAccess.loadThis(), Duplication.SINGLE.flipOver(fieldDescription.getType()), Removal.SINGLE);
                        }
                        return new StackManipulation.Compound(writeAssignment, preparation, FieldAccess.forField(fieldDescription).write());
                    }
                    public StackManipulation resolveIncrement(int value) {
                        return new StackManipulation.Compound(resolveRead(), IntegerConstant.forValue(value), Addition.INTEGER, resolveWrite());
                    }
                }
            }
            class ForStackManipulation implements Target {
                private final StackManipulation stackManipulation;
                public ForStackManipulation(StackManipulation stackManipulation) {
                    this.stackManipulation = stackManipulation;
                }
                public static Target of(MethodDescription.InDefinedShape methodDescription) {
                    return new ForStackManipulation(MethodConstant.of(methodDescription));
                }
                public static Target of(TypeDescription typeDescription) {
                    return new ForStackManipulation(ClassConstant.of(typeDescription));
                }
                public static Target of(@MaybeNull Object value) {
                    return new ForStackManipulation(value == null ? NullConstant.INSTANCE : ConstantValue.Simple.wrap(value).toStackManipulation());
                }
                public StackManipulation resolveRead() {
                    return stackManipulation;
                }
                public StackManipulation resolveWrite() {
                    throw new IllegalStateException("Cannot write to constant value: " + stackManipulation);
                }
                public StackManipulation resolveIncrement(int value) {
                    throw new IllegalStateException("Cannot write to constant value: " + stackManipulation);
                }
                public static class Writable implements Target {
                    private final StackManipulation read;
                    private final StackManipulation write;
                    public Writable(StackManipulation read, StackManipulation write) {
                        this.read = read;
                        this.write = write;
                    }
                    public StackManipulation resolveRead() {
                        return read;
                    }
                    public StackManipulation resolveWrite() {
                        return write;
                    }
                    public StackManipulation resolveIncrement(int value) {
                        throw new IllegalStateException("Cannot increment mutable constant value: " + write);
                    }
                }
            }
        }
        interface Factory<T extends Annotation> {
            Class<T> getAnnotationType();
            OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation, AdviceType adviceType);
            enum AdviceType {
                DELEGATION(true), INLINING(false);
                private final boolean delegation;
                AdviceType(boolean delegation) {
                    this.delegation = delegation;
                }
                public boolean isDelegation() {
                    return delegation;
                }
            }
            class Simple<T extends Annotation> implements Factory<T> {
                private final Class<T> annotationType;
                private final OffsetMapping offsetMapping;
                public Simple(Class<T> annotationType, OffsetMapping offsetMapping) {
                    this.annotationType = annotationType;
                    this.offsetMapping = offsetMapping;
                }
                public Class<T> getAnnotationType() {
                    return annotationType;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation, AdviceType adviceType) {
                    return offsetMapping;
                }
            }
            class Illegal<T extends Annotation> implements Factory<T> {
                private final Class<T> annotationType;
                public Illegal(Class<T> annotationType) {
                    this.annotationType = annotationType;
                }
                public Class<T> getAnnotationType() {
                    return annotationType;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation, AdviceType adviceType) {
                    throw new IllegalStateException("Usage of " + annotationType + " is not allowed on " + target);
                }
            }
        }
        enum Sort {
            ENTER {
                @Override
                public boolean isPremature(MethodDescription methodDescription) {
                    return methodDescription.isConstructor();
                }
            }
            , EXIT {
                @Override
                public boolean isPremature(MethodDescription methodDescription) {
                    return false;
                }
            }
            ;
            public abstract boolean isPremature(MethodDescription methodDescription);
        }
        abstract class ForArgument implements OffsetMapping {
            protected final TypeDescription.Generic target;
            protected final boolean readOnly;
            private final Assigner.Typing typing;
            protected ForArgument(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing) {
                this.target = target;
                this.readOnly = readOnly;
                this.typing = typing;
            }
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                ParameterDescription parameterDescription = resolve(instrumentedMethod);
                StackManipulation readAssignment = assigner.assign(parameterDescription.getType(), target, typing);
                if (!readAssignment.isValid()) {
                    throw new IllegalStateException("Cannot assign " + parameterDescription + " to " + target);
                } else if (readOnly) {
                    return new Target.ForVariable.ReadOnly(parameterDescription.getType(), argumentHandler.argument(parameterDescription.getOffset()), readAssignment);
                } else {
                    StackManipulation writeAssignment = assigner.assign(target, parameterDescription.getType(), typing);
                    if (!writeAssignment.isValid()) {
                        throw new IllegalStateException("Cannot assign " + parameterDescription + " to " + target);
                    }
                    return new Target.ForVariable.ReadWrite(parameterDescription.getType(), argumentHandler.argument(parameterDescription.getOffset()), readAssignment, writeAssignment);
                }
            }
            protected abstract ParameterDescription resolve(MethodDescription instrumentedMethod);
            public static class Unresolved extends ForArgument {
                private final int index;
                private final boolean optional;
                protected Unresolved(TypeDescription.Generic target, AnnotationDescription.Loadable<Argument> annotation) {
                    this(target, annotation.getValue(Factory.ARGUMENT_READ_ONLY).resolve(Boolean.class), annotation.getValue(Factory.ARGUMENT_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class), annotation.getValue(Factory.ARGUMENT_VALUE).resolve(Integer.class), annotation.getValue(Factory.ARGUMENT_OPTIONAL).resolve(Boolean.class));
                }
                protected Unresolved(ParameterDescription parameterDescription) {
                    this(parameterDescription.getType(), true, Assigner.Typing.STATIC, parameterDescription.getIndex());
                }
                public Unresolved(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, int index) {
                    this(target, readOnly, typing, index, false);
                }
                public Unresolved(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, int index, boolean optional) {
                    super(target, readOnly, typing);
                    this.index = index;
                    this.optional = optional;
                }
                protected ParameterDescription resolve(MethodDescription instrumentedMethod) {
                    ParameterList<?> parameters = instrumentedMethod.getParameters();
                    if (parameters.size() <= index) {
                        throw new IllegalStateException(instrumentedMethod + " does not define an index " + index);
                    } else {
                        return parameters.get(index);
                    }
                }
                public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                    if (optional && instrumentedMethod.getParameters().size() <= index) {
                        return readOnly ? new Target.ForDefaultValue.ReadOnly(target) : new Target.ForDefaultValue.ReadWrite(target);
                    }
                    return super.resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, sort);
                }
                protected enum Factory implements OffsetMapping.Factory<Argument> {
                    INSTANCE;
                    private static final MethodDescription.InDefinedShape ARGUMENT_VALUE;
                    private static final MethodDescription.InDefinedShape ARGUMENT_READ_ONLY;
                    private static final MethodDescription.InDefinedShape ARGUMENT_TYPING;
                    private static final MethodDescription.InDefinedShape ARGUMENT_OPTIONAL;
                    static {
                        MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(Argument.class).getDeclaredMethods();
                        ARGUMENT_VALUE = methods.filter(named("value")).getOnly();
                        ARGUMENT_READ_ONLY = methods.filter(named("readOnly")).getOnly();
                        ARGUMENT_TYPING = methods.filter(named("typing")).getOnly();
                        ARGUMENT_OPTIONAL = methods.filter(named("optional")).getOnly();
                    }
                    public Class<Argument> getAnnotationType() {
                        return Argument.class;
                    }
                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<Argument> annotation, AdviceType adviceType) {
                        if (adviceType.isDelegation() && !annotation.getValue(ARGUMENT_READ_ONLY).resolve(Boolean.class)) {
                            throw new IllegalStateException("Cannot define writable field access for " + target + " when using delegation");
                        } else {
                            return new ForArgument.Unresolved(target.getType(), annotation);
                        }
                    }
                }
            }
            public static class Resolved extends ForArgument {
                private final ParameterDescription parameterDescription;
                public Resolved(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, ParameterDescription parameterDescription) {
                    super(target, readOnly, typing);
                    this.parameterDescription = parameterDescription;
                }
                protected ParameterDescription resolve(MethodDescription instrumentedMethod) {
                    if (!parameterDescription.getDeclaringMethod().equals(instrumentedMethod)) {
                        throw new IllegalStateException(parameterDescription + " is not a parameter of " + instrumentedMethod);
                    }
                    return parameterDescription;
                }
                public static class Factory<T extends Annotation> implements OffsetMapping.Factory<T> {
                    private final Class<T> annotationType;
                    private final ParameterDescription parameterDescription;
                    private final boolean readOnly;
                    private final Assigner.Typing typing;
                    public Factory(Class<T> annotationType, ParameterDescription parameterDescription) {
                        this(annotationType, parameterDescription, true, Assigner.Typing.STATIC);
                    }
                    public Factory(Class<T> annotationType, ParameterDescription parameterDescription, boolean readOnly, Assigner.Typing typing) {
                        this.annotationType = annotationType;
                        this.parameterDescription = parameterDescription;
                        this.readOnly = readOnly;
                        this.typing = typing;
                    }
                    public Class<T> getAnnotationType() {
                        return annotationType;
                    }
                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation, AdviceType adviceType) {
                        return new Resolved(target.getType(), readOnly, typing, parameterDescription);
                    }
                }
            }
        }
        class ForThisReference implements OffsetMapping {
            private final TypeDescription.Generic target;
            private final boolean readOnly;
            private final Assigner.Typing typing;
            private final boolean optional;
            protected ForThisReference(TypeDescription.Generic target, AnnotationDescription.Loadable<This> annotation) {
                this(target, annotation.getValue(Factory.THIS_READ_ONLY).resolve(Boolean.class), annotation.getValue(Factory.THIS_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class), annotation.getValue(Factory.THIS_OPTIONAL).resolve(Boolean.class));
            }
            public ForThisReference(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, boolean optional) {
                this.target = target;
                this.readOnly = readOnly;
                this.typing = typing;
                this.optional = optional;
            }
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                if (instrumentedMethod.isStatic() || sort.isPremature(instrumentedMethod)) {
                    if (optional) {
                        return readOnly ? new Target.ForDefaultValue.ReadOnly(instrumentedType) : new Target.ForDefaultValue.ReadWrite(instrumentedType);
                    } else {
                        throw new IllegalStateException("Cannot map this reference for static method or constructor start: " + instrumentedMethod);
                    }
                }
                StackManipulation readAssignment = assigner.assign(instrumentedType.asGenericType(), target, typing);
                if (!readAssignment.isValid()) {
                    throw new IllegalStateException("Cannot assign " + instrumentedType + " to " + target);
                } else if (readOnly) {
                    return new Target.ForVariable.ReadOnly(instrumentedType.asGenericType(), argumentHandler.argument(ArgumentHandler.THIS_REFERENCE), readAssignment);
                } else {
                    StackManipulation writeAssignment = assigner.assign(target, instrumentedType.asGenericType(), typing);
                    if (!writeAssignment.isValid()) {
                        throw new IllegalStateException("Cannot assign " + target + " to " + instrumentedType);
                    }
                    return new Target.ForVariable.ReadWrite(instrumentedType.asGenericType(), argumentHandler.argument(ArgumentHandler.THIS_REFERENCE), readAssignment, writeAssignment);
                }
            }
            protected enum Factory implements OffsetMapping.Factory<This> {
                INSTANCE;
                private static final MethodDescription.InDefinedShape THIS_READ_ONLY;
                private static final MethodDescription.InDefinedShape THIS_TYPING;
                private static final MethodDescription.InDefinedShape THIS_OPTIONAL;
                static {
                    MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(This.class).getDeclaredMethods();
                    THIS_READ_ONLY = methods.filter(named("readOnly")).getOnly();
                    THIS_TYPING = methods.filter(named("typing")).getOnly();
                    THIS_OPTIONAL = methods.filter(named("optional")).getOnly();
                }
                public Class<This> getAnnotationType() {
                    return This.class;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<This> annotation, AdviceType adviceType) {
                    if (adviceType.isDelegation() && !annotation.getValue(THIS_READ_ONLY).resolve(Boolean.class)) {
                        throw new IllegalStateException("Cannot write to this reference for " + target + " in read-only context");
                    } else {
                        return new ForThisReference(target.getType(), annotation);
                    }
                }
            }
        }
        class ForAllArguments implements OffsetMapping {
            private final TypeDescription.Generic target;
            private final boolean readOnly;
            private final Assigner.Typing typing;
            private final boolean includeSelf;
            private final boolean nullIfEmpty;
            protected ForAllArguments(TypeDescription.Generic target, AnnotationDescription.Loadable<AllArguments> annotation) {
                this(target, annotation.getValue(Factory.ALL_ARGUMENTS_READ_ONLY).resolve(Boolean.class), annotation.getValue(Factory.ALL_ARGUMENTS_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class), annotation.getValue(Factory.ALL_ARGUMENTS_INCLUDE_SELF).resolve(Boolean.class), annotation.getValue(Factory.ALL_ARGUMENTS_NULL_IF_EMPTY).resolve(Boolean.class));
            }
            public ForAllArguments(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, boolean includeSelf, boolean nullIfEmpty) {
                this.target = target;
                this.readOnly = readOnly;
                this.typing = typing;
                this.includeSelf = includeSelf;
                this.nullIfEmpty = nullIfEmpty;
            }
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                if (nullIfEmpty && instrumentedMethod.getParameters().isEmpty() && (!includeSelf || instrumentedMethod.isStatic())) {
                    return readOnly ? new Target.ForStackManipulation(NullConstant.INSTANCE) : new Target.ForStackManipulation.Writable(NullConstant.INSTANCE, Removal.SINGLE);
                }
                List<StackManipulation> reads = new ArrayList<StackManipulation>((includeSelf && !instrumentedMethod.isStatic() ? 1 : 0) + instrumentedMethod.getParameters().size());
                if (includeSelf && !instrumentedMethod.isStatic()) {
                    if (sort.isPremature(instrumentedMethod) && instrumentedMethod.isConstructor()) {
                        throw new IllegalStateException("Cannot include self in all arguments array from " + instrumentedMethod);
                    }
                    StackManipulation assignment = assigner.assign(instrumentedMethod.getDeclaringType().asGenericType(), target, typing);
                    if (!assignment.isValid()) {
                        throw new IllegalStateException("Cannot assign " + instrumentedMethod.getDeclaringType() + " to " + target);
                    }
                    reads.add(new StackManipulation.Compound(MethodVariableAccess.REFERENCE.loadFrom(argumentHandler.argument(ArgumentHandler.THIS_REFERENCE)), assignment));
                }
                for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {
                    StackManipulation assignment = assigner.assign(parameterDescription.getType(), target, typing);
                    if (!assignment.isValid()) {
                        throw new IllegalStateException("Cannot assign " + parameterDescription + " to " + target);
                    }
                    reads.add(new StackManipulation.Compound(MethodVariableAccess.of(parameterDescription.getType()).loadFrom(argumentHandler.argument(parameterDescription.getOffset())), assignment));
                }
                if (readOnly) {
                    return new Target.ForArray.ReadOnly(target, reads);
                } else {
                    List<StackManipulation> writes = new ArrayList<StackManipulation>(2 * ((includeSelf && !instrumentedMethod.isStatic() ? 1 : 0) + instrumentedMethod.getParameters().size()));
                    if (includeSelf && !instrumentedMethod.isStatic()) {
                        StackManipulation assignment = assigner.assign(target, instrumentedMethod.getDeclaringType().asGenericType(), typing);
                        if (!assignment.isValid()) {
                            throw new IllegalStateException("Cannot assign " + target + " to " + instrumentedMethod.getDeclaringType());
                        }
                        writes.add(new StackManipulation.Compound(assignment, MethodVariableAccess.REFERENCE.storeAt(argumentHandler.argument(ArgumentHandler.THIS_REFERENCE))));
                    }
                    for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {
                        StackManipulation assignment = assigner.assign(target, parameterDescription.getType(), typing);
                        if (!assignment.isValid()) {
                            throw new IllegalStateException("Cannot assign " + target + " to " + parameterDescription);
                        }
                        writes.add(new StackManipulation.Compound(assignment, MethodVariableAccess.of(parameterDescription.getType()).storeAt(argumentHandler.argument(parameterDescription.getOffset()))));
                    }
                    return new Target.ForArray.ReadWrite(target, reads, writes);
                }
            }
            protected enum Factory implements OffsetMapping.Factory<AllArguments> {
                INSTANCE;
                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_READ_ONLY;
                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_TYPING;
                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_INCLUDE_SELF;
                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_NULL_IF_EMPTY;
                static {
                    MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(AllArguments.class).getDeclaredMethods();
                    ALL_ARGUMENTS_READ_ONLY = methods.filter(named("readOnly")).getOnly();
                    ALL_ARGUMENTS_TYPING = methods.filter(named("typing")).getOnly();
                    ALL_ARGUMENTS_INCLUDE_SELF = methods.filter(named("includeSelf")).getOnly();
                    ALL_ARGUMENTS_NULL_IF_EMPTY = methods.filter(named("nullIfEmpty")).getOnly();
                }
                public Class<AllArguments> getAnnotationType() {
                    return AllArguments.class;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<AllArguments> annotation, AdviceType adviceType) {
                    if (!target.getType().represents(Object.class) && !target.getType().isArray()) {
                        throw new IllegalStateException("Cannot use AllArguments annotation on a non-array type");
                    } else if (adviceType.isDelegation() && !annotation.getValue(ALL_ARGUMENTS_READ_ONLY).resolve(Boolean.class)) {
                        throw new IllegalStateException("Cannot define writable field access for " + target);
                    } else {
                        return new ForAllArguments(target.getType().represents(Object.class) ? TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class) : target.getType().getComponentType(), annotation);
                    }
                }
            }
        }
        enum ForInstrumentedType implements OffsetMapping {
            INSTANCE;
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                return Target.ForStackManipulation.of(instrumentedType);
            }
        }
        enum ForInstrumentedMethod implements OffsetMapping {
            METHOD {
                @Override
                protected boolean isRepresentable(MethodDescription instrumentedMethod) {
                    return instrumentedMethod.isMethod();
                }
                @Override
                protected Target resolve(MethodDescription.InDefinedShape methodDescription) {
                    return Target.ForStackManipulation.of(methodDescription);
                }
            }
            ,
            CONSTRUCTOR {
                @Override
                protected boolean isRepresentable(MethodDescription instrumentedMethod) {
                    return instrumentedMethod.isConstructor();
                }
                @Override
                protected Target resolve(MethodDescription.InDefinedShape methodDescription) {
                    return Target.ForStackManipulation.of(methodDescription);
                }
            }
            ,
            EXECUTABLE {
                @Override
                protected boolean isRepresentable(MethodDescription instrumentedMethod) {
                    return true;
                }
                @Override
                protected Target resolve(MethodDescription.InDefinedShape methodDescription) {
                    return Target.ForStackManipulation.of(methodDescription);
                }
            }
            ,
            MODIFIERS {
                @Override
                protected boolean isRepresentable(MethodDescription instrumentedMethod) {
                    return true;
                }
                @Override
                protected Target resolve(MethodDescription.InDefinedShape methodDescription) {
                    return Target.ForStackManipulation.of(methodDescription.getModifiers());
                }
            }
            ,
            METHOD_HANDLE {
                @Override
                protected boolean isRepresentable(MethodDescription instrumentedMethod) {
                    return true;
                }
                @Override
                protected Target resolve(MethodDescription.InDefinedShape methodDescription) {
                    return new Target.ForStackManipulation(JavaConstant.MethodHandle.of(methodDescription).toStackManipulation());
                }
            }
            ,
            METHOD_TYPE {
                @Override
                protected boolean isRepresentable(MethodDescription instrumentedMethod) {
                    return true;
                }
                @Override
                protected Target resolve(MethodDescription.InDefinedShape methodDescription) {
                    return new Target.ForStackManipulation(JavaConstant.MethodType.of(methodDescription).toStackManipulation());
                }
            }
            ;
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                if (!isRepresentable(instrumentedMethod)) {
                    throw new IllegalStateException("Cannot represent " + instrumentedMethod + " as the specified constant");
                }
                return resolve(instrumentedMethod.asDefined());
            }
            protected abstract boolean isRepresentable(MethodDescription instrumentedMethod);
            protected abstract Target resolve(MethodDescription.InDefinedShape methodDescription);
        }
        abstract class ForField implements OffsetMapping {
            private static final MethodDescription.InDefinedShape FIELD_VALUE;
            private static final MethodDescription.InDefinedShape FIELD_DECLARING_TYPE;
            private static final MethodDescription.InDefinedShape FIELD_READ_ONLY;
            private static final MethodDescription.InDefinedShape FIELD_TYPING;
            static {
                MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(FieldValue.class).getDeclaredMethods();
                FIELD_VALUE = methods.filter(named("value")).getOnly();
                FIELD_DECLARING_TYPE = methods.filter(named("declaringType")).getOnly();
                FIELD_READ_ONLY = methods.filter(named("readOnly")).getOnly();
                FIELD_TYPING = methods.filter(named("typing")).getOnly();
            }
            private final TypeDescription.Generic target;
            private final boolean readOnly;
            private final Assigner.Typing typing;
            protected ForField(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing) {
                this.target = target;
                this.readOnly = readOnly;
                this.typing = typing;
            }
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                FieldDescription fieldDescription = resolve(instrumentedType, instrumentedMethod);
                if (!fieldDescription.isStatic() && instrumentedMethod.isStatic()) {
                    throw new IllegalStateException("Cannot access non-static field " + fieldDescription + " from static method " + instrumentedMethod);
                }
                if (sort.isPremature(instrumentedMethod) && !fieldDescription.isStatic()) {
                    if (readOnly) {
                        throw new IllegalStateException("Cannot read " + fieldDescription + " before super constructor call");
                    } else {
                        StackManipulation writeAssignment = assigner.assign(target, fieldDescription.getType(), typing);
                        if (!writeAssignment.isValid()) {
                            throw new IllegalStateException("Cannot assign " + target + " to " + fieldDescription);
                        }
                        return new Target.ForField.WriteOnly(fieldDescription.asDefined(), writeAssignment);
                    }
                } else {
                    StackManipulation readAssignment = assigner.assign(fieldDescription.getType(), target, typing);
                    if (!readAssignment.isValid()) {
                        throw new IllegalStateException("Cannot assign " + fieldDescription + " to " + target);
                    } else if (readOnly) {
                        return new Target.ForField.ReadOnly(fieldDescription, readAssignment);
                    } else {
                        StackManipulation writeAssignment = assigner.assign(target, fieldDescription.getType(), typing);
                        if (!writeAssignment.isValid()) {
                            throw new IllegalStateException("Cannot assign " + target + " to " + fieldDescription);
                        }
                        return new Target.ForField.ReadWrite(fieldDescription.asDefined(), readAssignment, writeAssignment);
                    }
                }
            }
            protected abstract FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
            public abstract static class Unresolved extends ForField {
                protected static final String BEAN_PROPERTY = "";
                private final String name;
                protected Unresolved(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, String name) {
                    super(target, readOnly, typing);
                    this.name = name;
                }
                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                    FieldLocator locator = fieldLocator(instrumentedType);
                    FieldLocator.Resolution resolution = name.equals(BEAN_PROPERTY) ? FieldLocator.Resolution.Simple.ofBeanAccessor(locator, instrumentedMethod) : locator.locate(name);
                    if (!resolution.isResolved()) {
                        throw new IllegalStateException("Cannot locate field named " + name + " for " + instrumentedType);
                    } else {
                        return resolution.getField();
                    }
                }
                protected abstract FieldLocator fieldLocator(TypeDescription instrumentedType);
                public static class WithImplicitType extends Unresolved {
                    protected WithImplicitType(TypeDescription.Generic target, AnnotationDescription.Loadable<FieldValue> annotation) {
                        this(target, annotation.getValue(FIELD_READ_ONLY).resolve(Boolean.class), annotation.getValue(FIELD_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class), annotation.getValue(FIELD_VALUE).resolve(String.class));
                    }
                    public WithImplicitType(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, String name) {
                        super(target, readOnly, typing, name);
                    }
                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
                        return new FieldLocator.ForClassHierarchy(instrumentedType);
                    }
                }
                public static class WithExplicitType extends Unresolved {
                    private final TypeDescription declaringType;
                    protected WithExplicitType(TypeDescription.Generic target, AnnotationDescription.Loadable<FieldValue> annotation, TypeDescription declaringType) {
                        this(target, annotation.getValue(FIELD_READ_ONLY).resolve(Boolean.class), annotation.getValue(FIELD_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class), annotation.getValue(FIELD_VALUE).resolve(String.class), declaringType);
                    }
                    public WithExplicitType(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, String name, TypeDescription declaringType) {
                        super(target, readOnly, typing, name);
                        this.declaringType = declaringType;
                    }
                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
                        if (!declaringType.represents(TargetType.class) && !instrumentedType.isAssignableTo(declaringType)) {
                            throw new IllegalStateException(declaringType + " is no super type of " + instrumentedType);
                        }
                        return new FieldLocator.ForExactType(TargetType.resolve(declaringType, instrumentedType));
                    }
                }
                protected enum Factory implements OffsetMapping.Factory<FieldValue> {
                    INSTANCE;
                    public Class<FieldValue> getAnnotationType() {
                        return FieldValue.class;
                    }
                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<FieldValue> annotation, AdviceType adviceType) {
                        if (adviceType.isDelegation() && !annotation.getValue(ForField.FIELD_READ_ONLY).resolve(Boolean.class)) {
                            throw new IllegalStateException("Cannot write to field for " + target + " in read-only context");
                        } else {
                            TypeDescription declaringType = annotation.getValue(FIELD_DECLARING_TYPE).resolve(TypeDescription.class);
                            return declaringType.represents(void.class) ? new WithImplicitType(target.getType(), annotation) : new WithExplicitType(target.getType(), annotation, declaringType);
                        }
                    }
                }
            }
            public static class Resolved extends ForField {
                private final FieldDescription fieldDescription;
                public Resolved(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, FieldDescription fieldDescription) {
                    super(target, readOnly, typing);
                    this.fieldDescription = fieldDescription;
                }
                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                    if (!fieldDescription.isStatic() && !fieldDescription.getDeclaringType().asErasure().isAssignableFrom(instrumentedType)) {
                        throw new IllegalStateException(fieldDescription + " is no member of " + instrumentedType);
                    } else if (!fieldDescription.isVisibleTo(instrumentedType)) {
                        throw new IllegalStateException("Cannot access " + fieldDescription + " from " + instrumentedType);
                    }
                    return fieldDescription;
                }
                public static class Factory<T extends Annotation> implements OffsetMapping.Factory<T> {
                    private final Class<T> annotationType;
                    private final FieldDescription fieldDescription;
                    private final boolean readOnly;
                    private final Assigner.Typing typing;
                    public Factory(Class<T> annotationType, FieldDescription fieldDescription) {
                        this(annotationType, fieldDescription, true, Assigner.Typing.STATIC);
                    }
                    public Factory(Class<T> annotationType, FieldDescription fieldDescription, boolean readOnly, Assigner.Typing typing) {
                        this.annotationType = annotationType;
                        this.fieldDescription = fieldDescription;
                        this.readOnly = readOnly;
                        this.typing = typing;
                    }
                    public Class<T> getAnnotationType() {
                        return annotationType;
                    }
                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation, AdviceType adviceType) {
                        return new Resolved(target.getType(), readOnly, typing, fieldDescription);
                    }
                }
            }
        }
        abstract class ForFieldHandle implements OffsetMapping {
            private final Access access;
            protected ForFieldHandle(Access access) {
                this.access = access;
            }
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                FieldDescription fieldDescription = resolve(instrumentedType, instrumentedMethod);
                if (!fieldDescription.isStatic() && instrumentedMethod.isStatic()) {
                    throw new IllegalStateException("Cannot access non-static field " + fieldDescription + " from static method " + instrumentedMethod);
                }
                if (sort.isPremature(instrumentedMethod) && !fieldDescription.isStatic()) {
                    throw new IllegalStateException("Cannot access " + fieldDescription + " before super constructor call");
                } else if (fieldDescription.isStatic()) {
                    return new Target.ForStackManipulation(access.resolve(fieldDescription.asDefined()).toStackManipulation());
                } else {
                    return new Target.ForStackManipulation(new StackManipulation.Compound(access.resolve(fieldDescription.asDefined()).toStackManipulation(), MethodVariableAccess.REFERENCE.loadFrom(argumentHandler.argument(ArgumentHandler.THIS_REFERENCE)), MethodInvocation.invoke(new MethodDescription.Latent(JavaType.METHOD_HANDLE.getTypeStub(), new MethodDescription.Token("bindTo", Opcodes.ACC_PUBLIC, JavaType.METHOD_HANDLE.getTypeStub().asGenericType(), new TypeList.Generic.Explicit(TypeDefinition.Sort.describe(Object.class)))))));
                }
            }
            protected abstract FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
            public enum Access {
                GETTER {
                    @Override
                    protected JavaConstant.MethodHandle resolve(FieldDescription.InDefinedShape fieldDescription) {
                        return JavaConstant.MethodHandle.ofGetter(fieldDescription);
                    }
                }
                , SETTER {
                    @Override
                    protected JavaConstant.MethodHandle resolve(FieldDescription.InDefinedShape fieldDescription) {
                        return JavaConstant.MethodHandle.ofSetter(fieldDescription);
                    }
                }
                ;
                protected abstract JavaConstant.MethodHandle resolve(FieldDescription.InDefinedShape fieldDescription);
            }
            public abstract static class Unresolved extends ForFieldHandle {
                protected static final String BEAN_PROPERTY = "";
                private final String name;
                public Unresolved(Access access, String name) {
                    super(access);
                    this.name = name;
                }
                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                    FieldLocator locator = fieldLocator(instrumentedType);
                    FieldLocator.Resolution resolution = name.equals(BEAN_PROPERTY) ? FieldLocator.Resolution.Simple.ofBeanAccessor(locator, instrumentedMethod) : locator.locate(name);
                    if (!resolution.isResolved()) {
                        throw new IllegalStateException("Cannot locate field named " + name + " for " + instrumentedType);
                    } else {
                        return resolution.getField();
                    }
                }
                protected abstract FieldLocator fieldLocator(TypeDescription instrumentedType);
                public static class WithImplicitType extends Unresolved {
                    public WithImplicitType(Access access, String name) {
                        super(access, name);
                    }
                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
                        return new FieldLocator.ForClassHierarchy(instrumentedType);
                    }
                }
                public static class WithExplicitType extends Unresolved {
                    private final TypeDescription declaringType;
                    public WithExplicitType(Access access, String name, TypeDescription declaringType) {
                        super(access, name);
                        this.declaringType = declaringType;
                    }
                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
                        if (!declaringType.represents(TargetType.class) && !instrumentedType.isAssignableTo(declaringType)) {
                            throw new IllegalStateException(declaringType + " is no super type of " + instrumentedType);
                        }
                        return new FieldLocator.ForExactType(TargetType.resolve(declaringType, instrumentedType));
                    }
                }
                protected enum ReaderFactory implements OffsetMapping.Factory<FieldGetterHandle> {
                    INSTANCE;
                    private static final MethodDescription.InDefinedShape FIELD_GETTER_HANDLE_VALUE;
                    private static final MethodDescription.InDefinedShape FIELD_GETTER_HANDLE_DECLARING_TYPE;
                    static {
                        MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(FieldGetterHandle.class).getDeclaredMethods();
                        FIELD_GETTER_HANDLE_VALUE = methods.filter(named("value")).getOnly();
                        FIELD_GETTER_HANDLE_DECLARING_TYPE = methods.filter(named("declaringType")).getOnly();
                    }
                    public Class<FieldGetterHandle> getAnnotationType() {
                        return FieldGetterHandle.class;
                    }
                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<FieldGetterHandle> annotation, AdviceType adviceType) {
                        if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {
                            throw new IllegalStateException("Cannot assign method handle to " + target);
                        }
                        TypeDescription declaringType = annotation.getValue(FIELD_GETTER_HANDLE_DECLARING_TYPE).resolve(TypeDescription.class);
                        return declaringType.represents(void.class) ? new ForFieldHandle.Unresolved.WithImplicitType(Access.GETTER, annotation.getValue(FIELD_GETTER_HANDLE_VALUE).resolve(String.class)) : new ForFieldHandle.Unresolved.WithExplicitType(Access.GETTER, annotation.getValue(FIELD_GETTER_HANDLE_VALUE).resolve(String.class), declaringType);
                    }
                }
                protected enum WriterFactory implements OffsetMapping.Factory<FieldSetterHandle> {
                    INSTANCE;
                    private static final MethodDescription.InDefinedShape FIELD_SETTER_HANDLE_VALUE;
                    private static final MethodDescription.InDefinedShape FIELD_SETTER_HANDLE_DECLARING_TYPE;
                    static {
                        MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(FieldSetterHandle.class).getDeclaredMethods();
                        FIELD_SETTER_HANDLE_VALUE = methods.filter(named("value")).getOnly();
                        FIELD_SETTER_HANDLE_DECLARING_TYPE = methods.filter(named("declaringType")).getOnly();
                    }
                    public Class<FieldSetterHandle> getAnnotationType() {
                        return FieldSetterHandle.class;
                    }
                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<FieldSetterHandle> annotation, AdviceType adviceType) {
                        if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {
                            throw new IllegalStateException("Cannot assign method handle to " + target);
                        }
                        TypeDescription declaringType = annotation.getValue(FIELD_SETTER_HANDLE_DECLARING_TYPE).resolve(TypeDescription.class);
                        return declaringType.represents(void.class) ? new ForFieldHandle.Unresolved.WithImplicitType(Access.SETTER, annotation.getValue(FIELD_SETTER_HANDLE_VALUE).resolve(String.class)) : new ForFieldHandle.Unresolved.WithExplicitType(Access.SETTER, annotation.getValue(FIELD_SETTER_HANDLE_VALUE).resolve(String.class), declaringType);
                    }
                }
            }
            public static class Resolved extends ForFieldHandle {
                private final FieldDescription fieldDescription;
                public Resolved(Access access, FieldDescription fieldDescription) {
                    super(access);
                    this.fieldDescription = fieldDescription;
                }
                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                    if (!fieldDescription.isStatic() && !fieldDescription.getDeclaringType().asErasure().isAssignableFrom(instrumentedType)) {
                        throw new IllegalStateException(fieldDescription + " is no member of " + instrumentedType);
                    } else if (!fieldDescription.isVisibleTo(instrumentedType)) {
                        throw new IllegalStateException("Cannot access " + fieldDescription + " from " + instrumentedType);
                    }
                    return fieldDescription;
                }
                public static class Factory<T extends Annotation> implements OffsetMapping.Factory<T> {
                    private final Class<T> annotationType;
                    private final FieldDescription fieldDescription;
                    private final Access access;
                    public Factory(Class<T> annotationType, FieldDescription fieldDescription, Access access) {
                        this.annotationType = annotationType;
                        this.fieldDescription = fieldDescription;
                        this.access = access;
                    }
                    public Class<T> getAnnotationType() {
                        return annotationType;
                    }
                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation, AdviceType adviceType) {
                        if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {
                            throw new IllegalStateException("Cannot assign method handle to " + target);
                        }
                        return new Resolved(access, fieldDescription);
                    }
                }
            }
        }
        class ForOrigin implements OffsetMapping {
            private static final char DELIMITER = '#';
            private static final char ESCAPE = '\\';
            private final List<Renderer> renderers;
            public ForOrigin(List<Renderer> renderers) {
                this.renderers = renderers;
            }
            public static OffsetMapping parse(String pattern) {
                if (pattern.equals(Origin.DEFAULT)) {
                    return new ForOrigin(Collections.<Renderer>singletonList(Renderer.ForStringRepresentation.INSTANCE));
                } else {
                    List<Renderer> renderers = new ArrayList<Renderer>(pattern.length());
                    int from = 0;
                    for (int to = pattern.indexOf(DELIMITER); to != -1; to = pattern.indexOf(DELIMITER, from)) {
                        if (to != 0 && pattern.charAt(to - 1) == ESCAPE && (to == 1 || pattern.charAt(to - 2) != ESCAPE)) {
                            renderers.add(new Renderer.ForConstantValue(pattern.substring(from, Math.max(0, to - 1)) + DELIMITER));
                            from = to + 1;
                            continue;
                        } else if (pattern.length() == to + 1) {
                            throw new IllegalStateException("Missing sort descriptor for " + pattern + " at index " + to);
                        }
                        renderers.add(new Renderer.ForConstantValue(pattern.substring(from, to).replace("" + ESCAPE + ESCAPE, "" + ESCAPE)));
                        switch(pattern.charAt(to + 1)) {
                            case Renderer.ForMethodName.SYMBOL:
                                renderers.add(Renderer.ForMethodName.INSTANCE);
                                break;
                            case Renderer.ForTypeName.SYMBOL:
                                renderers.add(Renderer.ForTypeName.INSTANCE);
                                break;
                            case Renderer.ForDescriptor.SYMBOL:
                                renderers.add(Renderer.ForDescriptor.INSTANCE);
                                break;
                            case Renderer.ForReturnTypeName.SYMBOL:
                                renderers.add(Renderer.ForReturnTypeName.INSTANCE);
                                break;
                            case Renderer.ForJavaSignature.SYMBOL:
                                renderers.add(Renderer.ForJavaSignature.INSTANCE);
                                break;
                            case Renderer.ForPropertyName.SYMBOL:
                                renderers.add(Renderer.ForPropertyName.INSTANCE);
                                break;
                            default:
                                throw new IllegalStateException("Illegal sort descriptor " + pattern.charAt(to + 1) + " for " + pattern);
                        }
                        from = to + 2;
                    }
                    renderers.add(new Renderer.ForConstantValue(pattern.substring(from)));
                    return new ForOrigin(renderers);
                }
            }
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                StringBuilder stringBuilder = new StringBuilder();
                for (Renderer renderer : renderers) {
                    stringBuilder.append(renderer.apply(instrumentedType, instrumentedMethod));
                }
                return Target.ForStackManipulation.of(stringBuilder.toString());
            }
            public interface Renderer {
                String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
                enum ForMethodName implements Renderer {
                    INSTANCE;
                    public static final char SYMBOL = 'm';
                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                        return instrumentedMethod.getInternalName();
                    }
                }
                enum ForTypeName implements Renderer {
                    INSTANCE;
                    public static final char SYMBOL = 't';
                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                        return instrumentedType.getName();
                    }
                }
                enum ForDescriptor implements Renderer {
                    INSTANCE;
                    public static final char SYMBOL = 'd';
                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                        return instrumentedMethod.getDescriptor();
                    }
                }
                enum ForJavaSignature implements Renderer {
                    INSTANCE;
                    public static final char SYMBOL = 's';
                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                        StringBuilder stringBuilder = new StringBuilder("(");
                        boolean comma = false;
                        for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {
                            if (comma) {
                                stringBuilder.append(',');
                            } else {
                                comma = true;
                            }
                            stringBuilder.append(typeDescription.getName());
                        }
                        return stringBuilder.append(')').toString();
                    }
                }
                enum ForReturnTypeName implements Renderer {
                    INSTANCE;
                    public static final char SYMBOL = 'r';
                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                        return instrumentedMethod.getReturnType().asErasure().getName();
                    }
                }
                enum ForStringRepresentation implements Renderer {
                    INSTANCE;
                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                        return instrumentedMethod.toString();
                    }
                }
                class ForConstantValue implements Renderer {
                    private final String value;
                    public ForConstantValue(String value) {
                        this.value = value;
                    }
                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                        return value;
                    }
                }
                enum ForPropertyName implements Renderer {
                    INSTANCE;
                    public static final char SYMBOL = 'p';
                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                        return FieldAccessor.FieldNameExtractor.ForBeanProperty.INSTANCE.resolve(instrumentedMethod);
                    }
                }
            }
            protected enum Factory implements OffsetMapping.Factory<Origin> {
                INSTANCE;
                private static final MethodDescription.InDefinedShape ORIGIN_VALUE = TypeDescription.ForLoadedType.of(Origin.class).getDeclaredMethods().filter(named("value")).getOnly();
                public Class<Origin> getAnnotationType() {
                    return Origin.class;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<Origin> annotation, AdviceType adviceType) {
                    if (target.getType().asErasure().represents(Class.class)) {
                        return ForInstrumentedType.INSTANCE;
                    } else if (target.getType().asErasure().represents(Method.class)) {
                        return ForInstrumentedMethod.METHOD;
                    } else if (target.getType().asErasure().represents(Constructor.class)) {
                        return ForInstrumentedMethod.CONSTRUCTOR;
                    } else if (JavaType.EXECUTABLE.getTypeStub().equals(target.getType().asErasure())) {
                        return ForInstrumentedMethod.EXECUTABLE;
                    } else if (target.getType().asErasure().represents(int.class)) {
                        return ForInstrumentedMethod.MODIFIERS;
                    } else if (JavaType.METHOD_HANDLE.getTypeStub().equals(target.getType().asErasure())) {
                        return ForInstrumentedMethod.METHOD_HANDLE;
                    } else if (JavaType.METHOD_TYPE.getTypeStub().equals(target.getType().asErasure())) {
                        return ForInstrumentedMethod.METHOD_TYPE;
                    } else if (JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().equals(target.getType().asErasure())) {
                        return new OffsetMapping.ForStackManipulation(MethodInvocation.lookup(), JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().asGenericType(), target.getType(), Assigner.Typing.STATIC);
                    } else if (target.getType().asErasure().isAssignableFrom(String.class)) {
                        return ForOrigin.parse(annotation.getValue(ORIGIN_VALUE).resolve(String.class));
                    } else {
                        throw new IllegalStateException("Non-supported type " + target.getType() + " for @Origin annotation");
                    }
                }
            }
        }
        enum ForSelfCallHandle implements OffsetMapping {
            BOUND {
                @Override
                protected StackManipulation decorate(MethodDescription methodDescription, StackManipulation stackManipulation) {
                    List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(1 + (methodDescription.isStatic() ? 0 : 2) + methodDescription.getParameters().size() * 3);
                    stackManipulations.add(stackManipulation);
                    if (!methodDescription.isStatic()) {
                        stackManipulations.add(MethodVariableAccess.loadThis());
                        stackManipulations.add(MethodInvocation.invoke(new MethodDescription.Latent(JavaType.METHOD_HANDLE.getTypeStub(), new MethodDescription.Token("bindTo", Opcodes.ACC_PUBLIC, JavaType.METHOD_HANDLE.getTypeStub().asGenericType(), new TypeList.Generic.Explicit(TypeDefinition.Sort.describe(Object.class))))));
                    }
                    if (!methodDescription.getParameters().isEmpty()) {
                        List<StackManipulation> values = new ArrayList<StackManipulation>(methodDescription.getParameters().size());
                        for (ParameterDescription parameterDescription : methodDescription.getParameters()) {
                            values.add(parameterDescription.getType().isPrimitive() ? new StackManipulation.Compound(MethodVariableAccess.load(parameterDescription), Assigner.DEFAULT.assign(parameterDescription.getType(), parameterDescription.getType().asErasure().asBoxed().asGenericType(), Assigner.Typing.STATIC)) : MethodVariableAccess.load(parameterDescription));
                        }
                        stackManipulations.add(IntegerConstant.forValue(0));
                        stackManipulations.add(ArrayFactory.forType(TypeDescription.ForLoadedType.of(Object.class).asGenericType()).withValues(values));
                        stackManipulations.add(MethodInvocation.invoke(new MethodDescription.Latent(JavaType.METHOD_HANDLES.getTypeStub(), new MethodDescription.Token("insertArguments", Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, JavaType.METHOD_HANDLE.getTypeStub().asGenericType(), new TypeList.Generic.Explicit(JavaType.METHOD_HANDLE.getTypeStub(), TypeDefinition.Sort.describe(int.class), TypeDefinition.Sort.describe(Object[].class))))));
                    }
                    return new StackManipulation.Compound(stackManipulations);
                }
            }
            , UNBOUND {
                @Override
                protected StackManipulation decorate(MethodDescription methodDescription, StackManipulation stackManipulation) {
                    return stackManipulation;
                }
            }
            ;
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                if (!instrumentedMethod.isMethod()) {
                    throw new IllegalStateException();
                }
                StackManipulation stackManipulation = (instrumentedMethod.isStatic() ? JavaConstant.MethodHandle.of(instrumentedMethod.asDefined()) : JavaConstant.MethodHandle.ofSpecial(instrumentedMethod.asDefined(), instrumentedType)).toStackManipulation();
                return new Target.ForStackManipulation(decorate(instrumentedMethod, stackManipulation));
            }
            protected abstract StackManipulation decorate(MethodDescription methodDescription, StackManipulation stackManipulation);
            protected enum Factory implements OffsetMapping.Factory<SelfCallHandle> {
                INSTANCE;
                private static final MethodDescription.InDefinedShape SELF_CALL_HANDLE_BOUND = TypeDescription.ForLoadedType.of(SelfCallHandle.class).getDeclaredMethods().filter(named("bound")).getOnly();
                public Class<SelfCallHandle> getAnnotationType() {
                    return SelfCallHandle.class;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<SelfCallHandle> annotation, AdviceType adviceType) {
                    if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {
                        throw new IllegalStateException("Cannot assign a MethodHandle to " + target);
                    }
                    return annotation.getValue(SELF_CALL_HANDLE_BOUND).resolve(Boolean.class) ? ForSelfCallHandle.BOUND : ForSelfCallHandle.UNBOUND;
                }
            }
        }
        class ForHandle implements OffsetMapping {
            private final JavaConstant.MethodHandle.HandleType type;
            private final TypeDescription owner;
            private final String name;
            private final TypeDescription returnType;
            private final List<? extends TypeDescription> parameterTypes;
            protected ForHandle(JavaConstant.MethodHandle.HandleType type, TypeDescription owner, String name, TypeDescription returnType, List<? extends TypeDescription> parameterTypes) {
                this.type = type;
                this.owner = owner;
                this.name = name;
                this.returnType = returnType;
                this.parameterTypes = parameterTypes;
            }
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                return new Target.ForStackManipulation(new JavaConstantValue(new JavaConstant.MethodHandle(type, owner.represents(void.class) ? instrumentedType : owner, name, returnType, parameterTypes)));
            }
            protected enum Factory implements OffsetMapping.Factory<Handle> {
                INSTANCE;
                private static final MethodDescription.InDefinedShape TYPE;
                private static final MethodDescription.InDefinedShape OWNER;
                private static final MethodDescription.InDefinedShape NAME;
                private static final MethodDescription.InDefinedShape RETURN_TYPE;
                private static final MethodDescription.InDefinedShape PARAMETER_TYPES;
                static {
                    MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(Handle.class).getDeclaredMethods();
                    TYPE = methods.filter(named("type")).getOnly();
                    OWNER = methods.filter(named("owner")).getOnly();
                    NAME = methods.filter(named("name")).getOnly();
                    RETURN_TYPE = methods.filter(named("returnType")).getOnly();
                    PARAMETER_TYPES = methods.filter(named("parameterTypes")).getOnly();
                }
                public Class<Handle> getAnnotationType() {
                    return Handle.class;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<Handle> annotation, AdviceType adviceType) {
                    if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {
                        throw new IllegalStateException("Cannot assign a MethodHandle to " + target);
                    }
                    return new ForHandle(annotation.getValue(TYPE).resolve(EnumerationDescription.class).load(JavaConstant.MethodHandle.HandleType.class), annotation.getValue(OWNER).resolve(TypeDescription.class), annotation.getValue(NAME).resolve(String.class), annotation.getValue(RETURN_TYPE).resolve(TypeDescription.class), Arrays.asList(annotation.getValue(PARAMETER_TYPES).resolve(TypeDescription[].class)));
                }
            }
        }
        class ForDynamicConstant implements OffsetMapping {
            private final String name;
            private final TypeDescription typeDescription;
            private final JavaConstant.MethodHandle.HandleType bootstrapType;
            private final TypeDescription bootstrapOwner;
            private final String bootstrapName;
            private final TypeDescription bootstrapReturnType;
            private final List<? extends TypeDescription> bootstrapParameterTypes;
            private final List<JavaConstant> arguments;
            private final boolean invokedynamic;
            public ForDynamicConstant(String name, TypeDescription typeDescription, JavaConstant.MethodHandle.HandleType bootstrapType, TypeDescription bootstrapOwner, String bootstrapName, TypeDescription bootstrapReturnType, List<? extends TypeDescription> bootstrapParameterTypes, List<JavaConstant> arguments, boolean invokedynamic) {
                this.name = name;
                this.typeDescription = typeDescription;
                this.bootstrapType = bootstrapType;
                this.bootstrapOwner = bootstrapOwner;
                this.bootstrapName = bootstrapName;
                this.bootstrapReturnType = bootstrapReturnType;
                this.bootstrapParameterTypes = bootstrapParameterTypes;
                this.arguments = arguments;
                this.invokedynamic = invokedynamic;
            }
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                TypeDescription bootstrapOwner = this.bootstrapOwner.represents(void.class) ? instrumentedType : this.bootstrapOwner;
                if (invokedynamic) {
                    return new Target.ForStackManipulation(new Invokedynamic(name, JavaConstant.MethodType.of(typeDescription), new JavaConstant.MethodHandle(bootstrapType, bootstrapOwner, bootstrapName, bootstrapReturnType, bootstrapParameterTypes), arguments));
                } else {
                    return new Target.ForStackManipulation(new JavaConstantValue(new JavaConstant.Dynamic(name, typeDescription, new JavaConstant.MethodHandle(bootstrapType, bootstrapOwner, bootstrapName, bootstrapReturnType, bootstrapParameterTypes), arguments)));
                }
            }
            protected enum Factory implements OffsetMapping.Factory<DynamicConstant> {
                INSTANCE;
                private static final MethodDescription.InDefinedShape NAME;
                private static final MethodDescription.InDefinedShape BOOTSTRAP_TYPE;
                private static final MethodDescription.InDefinedShape BOOTSTRAP_OWNER;
                private static final MethodDescription.InDefinedShape BOOTSTRAP_NAME;
                private static final MethodDescription.InDefinedShape BOOTSTRAP_RETURN_TYPE;
                private static final MethodDescription.InDefinedShape BOOTSTRAP_PARAMETER_TYPES;
                private static final MethodDescription.InDefinedShape INVOKEDYNAMIC;
                static {
                    MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(DynamicConstant.class).getDeclaredMethods();
                    NAME = methods.filter(named("name")).getOnly();
                    BOOTSTRAP_TYPE = methods.filter(named("bootstrapType")).getOnly();
                    BOOTSTRAP_OWNER = methods.filter(named("bootstrapOwner")).getOnly();
                    BOOTSTRAP_NAME = methods.filter(named("bootstrapName")).getOnly();
                    BOOTSTRAP_RETURN_TYPE = methods.filter(named("bootstrapReturnType")).getOnly();
                    BOOTSTRAP_PARAMETER_TYPES = methods.filter(named("bootstrapParameterTypes")).getOnly();
                    INVOKEDYNAMIC = methods.filter(named("invokedynamic")).getOnly();
                }
                public Class<DynamicConstant> getAnnotationType() {
                    return DynamicConstant.class;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<DynamicConstant> annotation, AdviceType adviceType) {
                    return new ForDynamicConstant(annotation.getValue(NAME).resolve(String.class), target.getType().asErasure(), annotation.getValue(BOOTSTRAP_TYPE).resolve(EnumerationDescription.class).load(JavaConstant.MethodHandle.HandleType.class), annotation.getValue(BOOTSTRAP_OWNER).resolve(TypeDescription.class), annotation.getValue(BOOTSTRAP_NAME).resolve(String.class), annotation.getValue(BOOTSTRAP_RETURN_TYPE).resolve(TypeDescription.class), Arrays.asList(annotation.getValue(BOOTSTRAP_PARAMETER_TYPES).resolve(TypeDescription[].class)), Collections.<JavaConstant>emptyList(), annotation.getValue(INVOKEDYNAMIC).resolve(Boolean.class));
                }
            }
        }
        class ForUnusedValue implements OffsetMapping {
            private final TypeDefinition target;
            public ForUnusedValue(TypeDefinition target) {
                this.target = target;
            }
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                return new Target.ForDefaultValue.ReadWrite(target);
            }
            protected enum Factory implements OffsetMapping.Factory<Unused> {
                INSTANCE;
                public Class<Unused> getAnnotationType() {
                    return Unused.class;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<Unused> annotation, AdviceType adviceType) {
                    return new ForUnusedValue(target.getType());
                }
            }
        }
        enum ForStubValue implements OffsetMapping, Factory<StubValue> {
            INSTANCE;
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                return new Target.ForDefaultValue.ReadOnly(instrumentedMethod.getReturnType(), assigner.assign(instrumentedMethod.getReturnType(), TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class), Assigner.Typing.DYNAMIC));
            }
            public Class<StubValue> getAnnotationType() {
                return StubValue.class;
            }
            public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<StubValue> annotation, AdviceType adviceType) {
                if (!target.getType().represents(Object.class)) {
                    throw new IllegalStateException("Cannot use StubValue on non-Object parameter type " + target);
                } else {
                    return this;
                }
            }
        }
        class ForEnterValue implements OffsetMapping {
            private final TypeDescription.Generic target;
            private final TypeDescription.Generic enterType;
            private final boolean readOnly;
            private final Assigner.Typing typing;
            protected ForEnterValue(TypeDescription.Generic target, TypeDescription.Generic enterType, AnnotationDescription.Loadable<Enter> annotation) {
                this(target, enterType, annotation.getValue(Factory.ENTER_READ_ONLY).resolve(Boolean.class), annotation.getValue(Factory.ENTER_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class));
            }
            public ForEnterValue(TypeDescription.Generic target, TypeDescription.Generic enterType, boolean readOnly, Assigner.Typing typing) {
                this.target = target;
                this.enterType = enterType;
                this.readOnly = readOnly;
                this.typing = typing;
            }
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                StackManipulation readAssignment = assigner.assign(enterType, target, typing);
                if (!readAssignment.isValid()) {
                    throw new IllegalStateException("Cannot assign " + enterType + " to " + target);
                } else if (readOnly) {
                    return new Target.ForVariable.ReadOnly(target, argumentHandler.enter(), readAssignment);
                } else {
                    StackManipulation writeAssignment = assigner.assign(target, enterType, typing);
                    if (!writeAssignment.isValid()) {
                        throw new IllegalStateException("Cannot assign " + target + " to " + enterType);
                    }
                    return new Target.ForVariable.ReadWrite(target, argumentHandler.enter(), readAssignment, writeAssignment);
                }
            }
            protected static class Factory implements OffsetMapping.Factory<Enter> {
                private static final MethodDescription.InDefinedShape ENTER_READ_ONLY;
                private static final MethodDescription.InDefinedShape ENTER_TYPING;
                static {
                    MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(Enter.class).getDeclaredMethods();
                    ENTER_READ_ONLY = methods.filter(named("readOnly")).getOnly();
                    ENTER_TYPING = methods.filter(named("typing")).getOnly();
                }
                private final TypeDefinition enterType;
                protected Factory(TypeDefinition enterType) {
                    this.enterType = enterType;
                }
                protected static OffsetMapping.Factory<Enter> of(TypeDefinition typeDefinition) {
                    return typeDefinition.represents(void.class) ? new Illegal<Enter>(Enter.class) : new Factory(typeDefinition);
                }
                public Class<Enter> getAnnotationType() {
                    return Enter.class;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<Enter> annotation, AdviceType adviceType) {
                    if (adviceType.isDelegation() && !annotation.getValue(ENTER_READ_ONLY).resolve(Boolean.class)) {
                        throw new IllegalStateException("Cannot use writable " + target + " on read-only parameter");
                    } else {
                        return new ForEnterValue(target.getType(), enterType.asGenericType(), annotation);
                    }
                }
            }
        }
        class ForExitValue implements OffsetMapping {
            private final TypeDescription.Generic target;
            private final TypeDescription.Generic exitType;
            private final boolean readOnly;
            private final Assigner.Typing typing;
            protected ForExitValue(TypeDescription.Generic target, TypeDescription.Generic exitType, AnnotationDescription.Loadable<Exit> annotation) {
                this(target, exitType, annotation.getValue(Factory.EXIT_READ_ONLY).resolve(Boolean.class), annotation.getValue(Factory.EXIT_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class));
            }
            public ForExitValue(TypeDescription.Generic target, TypeDescription.Generic exitType, boolean readOnly, Assigner.Typing typing) {
                this.target = target;
                this.exitType = exitType;
                this.readOnly = readOnly;
                this.typing = typing;
            }
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                StackManipulation readAssignment = assigner.assign(exitType, target, typing);
                if (!readAssignment.isValid()) {
                    throw new IllegalStateException("Cannot assign " + exitType + " to " + target);
                } else if (readOnly) {
                    return new Target.ForVariable.ReadOnly(target, argumentHandler.exit(), readAssignment);
                } else {
                    StackManipulation writeAssignment = assigner.assign(target, exitType, typing);
                    if (!writeAssignment.isValid()) {
                        throw new IllegalStateException("Cannot assign " + target + " to " + exitType);
                    }
                    return new Target.ForVariable.ReadWrite(target, argumentHandler.exit(), readAssignment, writeAssignment);
                }
            }
            protected static class Factory implements OffsetMapping.Factory<Exit> {
                private static final MethodDescription.InDefinedShape EXIT_READ_ONLY;
                private static final MethodDescription.InDefinedShape EXIT_TYPING;
                static {
                    MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(Exit.class).getDeclaredMethods();
                    EXIT_READ_ONLY = methods.filter(named("readOnly")).getOnly();
                    EXIT_TYPING = methods.filter(named("typing")).getOnly();
                }
                private final TypeDefinition exitType;
                protected Factory(TypeDefinition exitType) {
                    this.exitType = exitType;
                }
                protected static OffsetMapping.Factory<Exit> of(TypeDefinition typeDefinition) {
                    return typeDefinition.represents(void.class) ? new Illegal<Exit>(Exit.class) : new Factory(typeDefinition);
                }
                public Class<Exit> getAnnotationType() {
                    return Exit.class;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<Exit> annotation, AdviceType adviceType) {
                    if (adviceType.isDelegation() && !annotation.getValue(EXIT_READ_ONLY).resolve(Boolean.class)) {
                        throw new IllegalStateException("Cannot use writable " + target + " on read-only parameter");
                    } else {
                        return new ForExitValue(target.getType(), exitType.asGenericType(), annotation);
                    }
                }
            }
        }
        class ForLocalValue implements OffsetMapping {
            private final TypeDescription.Generic target;
            private final TypeDescription.Generic localType;
            private final String name;
            public ForLocalValue(TypeDescription.Generic target, TypeDescription.Generic localType, String name) {
                this.target = target;
                this.localType = localType;
                this.name = name;
            }
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                StackManipulation readAssignment = assigner.assign(localType, target, Assigner.Typing.STATIC);
                StackManipulation writeAssignment = assigner.assign(target, localType, Assigner.Typing.STATIC);
                if (!readAssignment.isValid() || !writeAssignment.isValid()) {
                    throw new IllegalStateException("Cannot assign " + localType + " to " + target);
                } else {
                    return new Target.ForVariable.ReadWrite(target, argumentHandler.named(name), readAssignment, writeAssignment);
                }
            }
            protected static class Factory implements OffsetMapping.Factory<Local> {
                protected static final MethodDescription.InDefinedShape LOCAL_VALUE = TypeDescription.ForLoadedType.of(Local.class).getDeclaredMethods().filter(named("value")).getOnly();
                private final Map<String, TypeDefinition> namedTypes;
                protected Factory(Map<String, TypeDefinition> namedTypes) {
                    this.namedTypes = namedTypes;
                }
                public Class<Local> getAnnotationType() {
                    return Local.class;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<Local> annotation, AdviceType adviceType) {
                    String name = annotation.getValue(LOCAL_VALUE).resolve(String.class);
                    TypeDefinition namedType = namedTypes.get(name);
                    if (namedType == null) {
                        throw new IllegalStateException("Named local variable is unknown: " + name);
                    }
                    return new ForLocalValue(target.getType(), namedType.asGenericType(), name);
                }
            }
        }
        class ForReturnValue implements OffsetMapping {
            private final TypeDescription.Generic target;
            private final boolean readOnly;
            private final Assigner.Typing typing;
            protected ForReturnValue(TypeDescription.Generic target, AnnotationDescription.Loadable<Return> annotation) {
                this(target, annotation.getValue(Factory.RETURN_READ_ONLY).resolve(Boolean.class), annotation.getValue(Factory.RETURN_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class));
            }
            public ForReturnValue(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing) {
                this.target = target;
                this.readOnly = readOnly;
                this.typing = typing;
            }
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                StackManipulation readAssignment = assigner.assign(instrumentedMethod.getReturnType(), target, typing);
                if (!readAssignment.isValid()) {
                    throw new IllegalStateException("Cannot assign " + instrumentedMethod.getReturnType() + " to " + target);
                } else if (readOnly) {
                    return instrumentedMethod.getReturnType().represents(void.class) ? new Target.ForDefaultValue.ReadOnly(target) : new Target.ForVariable.ReadOnly(instrumentedMethod.getReturnType(), argumentHandler.returned(), readAssignment);
                } else {
                    StackManipulation writeAssignment = assigner.assign(target, instrumentedMethod.getReturnType(), typing);
                    if (!writeAssignment.isValid()) {
                        throw new IllegalStateException("Cannot assign " + target + " to " + instrumentedMethod.getReturnType());
                    }
                    return instrumentedMethod.getReturnType().represents(void.class) ? new Target.ForDefaultValue.ReadWrite(target) : new Target.ForVariable.ReadWrite(instrumentedMethod.getReturnType(), argumentHandler.returned(), readAssignment, writeAssignment);
                }
            }
            protected enum Factory implements OffsetMapping.Factory<Return> {
                INSTANCE;
                private static final MethodDescription.InDefinedShape RETURN_READ_ONLY;
                private static final MethodDescription.InDefinedShape RETURN_TYPING;
                static {
                    MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(Return.class).getDeclaredMethods();
                    RETURN_READ_ONLY = methods.filter(named("readOnly")).getOnly();
                    RETURN_TYPING = methods.filter(named("typing")).getOnly();
                }
                public Class<Return> getAnnotationType() {
                    return Return.class;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<Return> annotation, AdviceType adviceType) {
                    if (adviceType.isDelegation() && !annotation.getValue(RETURN_READ_ONLY).resolve(Boolean.class)) {
                        throw new IllegalStateException("Cannot write return value for " + target + " in read-only context");
                    } else {
                        return new ForReturnValue(target.getType(), annotation);
                    }
                }
            }
        }
        class ForThrowable implements OffsetMapping {
            private final TypeDescription.Generic target;
            private final boolean readOnly;
            private final Assigner.Typing typing;
            protected ForThrowable(TypeDescription.Generic target, AnnotationDescription.Loadable<Thrown> annotation) {
                this(target, annotation.getValue(Factory.THROWN_READ_ONLY).resolve(Boolean.class), annotation.getValue(Factory.THROWN_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class));
            }
            public ForThrowable(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing) {
                this.target = target;
                this.readOnly = readOnly;
                this.typing = typing;
            }
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                StackManipulation readAssignment = assigner.assign(TypeDescription.ForLoadedType.of(Throwable.class).asGenericType(), target, typing);
                if (!readAssignment.isValid()) {
                    throw new IllegalStateException("Cannot assign Throwable to " + target);
                } else if (readOnly) {
                    return new Target.ForVariable.ReadOnly(TypeDescription.ForLoadedType.of(Throwable.class), argumentHandler.thrown(), readAssignment);
                } else {
                    StackManipulation writeAssignment = assigner.assign(target, TypeDescription.ForLoadedType.of(Throwable.class).asGenericType(), typing);
                    if (!writeAssignment.isValid()) {
                        throw new IllegalStateException("Cannot assign " + target + " to Throwable");
                    }
                    return new Target.ForVariable.ReadWrite(TypeDescription.ForLoadedType.of(Throwable.class), argumentHandler.thrown(), readAssignment, writeAssignment);
                }
            }
            protected enum Factory implements OffsetMapping.Factory<Thrown> {
                INSTANCE;
                private static final MethodDescription.InDefinedShape THROWN_READ_ONLY;
                private static final MethodDescription.InDefinedShape THROWN_TYPING;
                static {
                    MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(Thrown.class).getDeclaredMethods();
                    THROWN_READ_ONLY = methods.filter(named("readOnly")).getOnly();
                    THROWN_TYPING = methods.filter(named("typing")).getOnly();
                }
                protected static OffsetMapping.Factory<?> of(MethodDescription.InDefinedShape adviceMethod) {
                    return adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(ON_THROWABLE).resolve(TypeDescription.class).represents(NoExceptionHandler.class) ? new OffsetMapping.Factory.Illegal<Thrown>(Thrown.class) : Factory.INSTANCE;
                }
                public Class<Thrown> getAnnotationType() {
                    return Thrown.class;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<Thrown> annotation, AdviceType adviceType) {
                    if (adviceType.isDelegation() && !annotation.getValue(THROWN_READ_ONLY).resolve(Boolean.class)) {
                        throw new IllegalStateException("Cannot use writable " + target + " on read-only parameter");
                    } else {
                        return new ForThrowable(target.getType(), annotation);
                    }
                }
            }
        }
        class ForStackManipulation implements OffsetMapping {
            private final StackManipulation stackManipulation;
            private final TypeDescription.Generic typeDescription;
            private final TypeDescription.Generic targetType;
            private final Assigner.Typing typing;
            public ForStackManipulation(StackManipulation stackManipulation, TypeDescription.Generic typeDescription, TypeDescription.Generic targetType, Assigner.Typing typing) {
                this.stackManipulation = stackManipulation;
                this.typeDescription = typeDescription;
                this.targetType = targetType;
                this.typing = typing;
            }
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                StackManipulation assignment = assigner.assign(typeDescription, targetType, typing);
                if (!assignment.isValid()) {
                    throw new IllegalStateException("Cannot assign " + typeDescription + " to " + targetType);
                }
                return new Target.ForStackManipulation(new StackManipulation.Compound(stackManipulation, assignment));
            }
            public static class Factory<T extends Annotation> implements OffsetMapping.Factory<T> {
                private final Class<T> annotationType;
                private final StackManipulation stackManipulation;
                private final TypeDescription.Generic typeDescription;
                public Factory(Class<T> annotationType, TypeDescription typeDescription) {
                    this(annotationType, ClassConstant.of(typeDescription), TypeDescription.ForLoadedType.of(Class.class).asGenericType());
                }
                public Factory(Class<T> annotationType, EnumerationDescription enumerationDescription) {
                    this(annotationType, FieldAccess.forEnumeration(enumerationDescription), enumerationDescription.getEnumerationType().asGenericType());
                }
                public Factory(Class<T> annotationType, ConstantValue constant) {
                    this(annotationType, constant.toStackManipulation(), constant.getTypeDescription().asGenericType());
                }
                public Factory(Class<T> annotationType, StackManipulation stackManipulation, TypeDescription.Generic typeDescription) {
                    this.annotationType = annotationType;
                    this.stackManipulation = stackManipulation;
                    this.typeDescription = typeDescription;
                }
                public static <S extends Annotation> OffsetMapping.Factory<S> of(Class<S> annotationType, @MaybeNull Object value) {
                    return value == null ? new OfDefaultValue<S>(annotationType) : new Factory<S>(annotationType, ConstantValue.Simple.wrap(value));
                }
                public Class<T> getAnnotationType() {
                    return annotationType;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation, AdviceType adviceType) {
                    return new ForStackManipulation(stackManipulation, typeDescription, target.getType(), Assigner.Typing.STATIC);
                }
            }
            public static class OfDefaultValue<T extends Annotation> implements OffsetMapping.Factory<T> {
                private final Class<T> annotationType;
                public OfDefaultValue(Class<T> annotationType) {
                    this.annotationType = annotationType;
                }
                public Class<T> getAnnotationType() {
                    return annotationType;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation, AdviceType adviceType) {
                    return new ForStackManipulation(DefaultValue.of(target.getType()), target.getType(), target.getType(), Assigner.Typing.STATIC);
                }
            }
            public static class OfAnnotationProperty<T extends Annotation> implements OffsetMapping.Factory<T> {
                private final Class<T> annotationType;
                private final MethodDescription.InDefinedShape property;
                protected OfAnnotationProperty(Class<T> annotationType, MethodDescription.InDefinedShape property) {
                    this.annotationType = annotationType;
                    this.property = property;
                }
                public static <S extends Annotation> OffsetMapping.Factory<S> of(Class<S> annotationType, String property) {
                    if (!annotationType.isAnnotation()) {
                        throw new IllegalArgumentException("Not an annotation type: " + annotationType);
                    }
                    try {
                        return new OfAnnotationProperty<S>(annotationType, new MethodDescription.ForLoadedMethod(annotationType.getMethod(property)));
                    } catch (NoSuchMethodException exception) {
                        throw new IllegalArgumentException("Cannot find a property " + property + " on " + annotationType, exception);
                    }
                }
                public Class<T> getAnnotationType() {
                    return annotationType;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation, AdviceType adviceType) {
                    ConstantValue value = ConstantValue.Simple.wrapOrNull(annotation.getValue(property).resolve());
                    if (value == null) {
                        throw new IllegalStateException("Property does not represent a constant value: " + property);
                    }
                    return new ForStackManipulation(value.toStackManipulation(), value.getTypeDescription().asGenericType(), target.getType(), Assigner.Typing.STATIC);
                }
            }
            public static class OfDynamicInvocation<T extends Annotation> implements OffsetMapping.Factory<T> {
                private final Class<T> annotationType;
                private final MethodDescription.InDefinedShape bootstrapMethod;
                private final List<? extends JavaConstant> arguments;
                public OfDynamicInvocation(Class<T> annotationType, MethodDescription.InDefinedShape bootstrapMethod, List<? extends JavaConstant> arguments) {
                    this.annotationType = annotationType;
                    this.bootstrapMethod = bootstrapMethod;
                    this.arguments = arguments;
                }
                public Class<T> getAnnotationType() {
                    return annotationType;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation, AdviceType adviceType) {
                    if (!target.getType().isInterface()) {
                        throw new IllegalArgumentException(target.getType() + " is not an interface");
                    } else if (!target.getType().getInterfaces().isEmpty()) {
                        throw new IllegalArgumentException(target.getType() + " must not extend other interfaces");
                    } else if (!target.getType().isPublic()) {
                        throw new IllegalArgumentException(target.getType() + " is mot public");
                    }
                    MethodList<?> methodCandidates = target.getType().getDeclaredMethods().filter(isAbstract());
                    if (methodCandidates.size() != 1) {
                        throw new IllegalArgumentException(target.getType() + " must declare exactly one abstract method");
                    }
                    return new ForStackManipulation(MethodInvocation.invoke(bootstrapMethod).dynamic(methodCandidates.getOnly().getInternalName(), target.getType().asErasure(), Collections.<TypeDescription>emptyList(), arguments), target.getType(), target.getType(), Assigner.Typing.STATIC);
                }
            }
        }
        class ForSerializedValue implements OffsetMapping {
            private final TypeDescription.Generic target;
            private final TypeDescription typeDescription;
            private final StackManipulation deserialization;
            public ForSerializedValue(TypeDescription.Generic target, TypeDescription typeDescription, StackManipulation deserialization) {
                this.target = target;
                this.typeDescription = typeDescription;
                this.deserialization = deserialization;
            }
            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
                StackManipulation assignment = assigner.assign(typeDescription.asGenericType(), target, Assigner.Typing.DYNAMIC);
                if (!assignment.isValid()) {
                    throw new IllegalStateException("Cannot assign " + typeDescription + " to " + target);
                }
                return new Target.ForStackManipulation(new StackManipulation.Compound(deserialization, assignment));
            }
            public static class Factory<T extends Annotation> implements OffsetMapping.Factory<T> {
                private final Class<T> annotationType;
                private final TypeDescription typeDescription;
                private final StackManipulation deserialization;
                protected Factory(Class<T> annotationType, TypeDescription typeDescription, StackManipulation deserialization) {
                    this.annotationType = annotationType;
                    this.typeDescription = typeDescription;
                    this.deserialization = deserialization;
                }
                public static <S extends Annotation, U extends Serializable> OffsetMapping.Factory<S> of(Class<S> annotationType, U target, Class<? super U> targetType) {
                    if (!targetType.isInstance(target)) {
                        throw new IllegalArgumentException(target + " is no instance of " + targetType);
                    }
                    return new Factory<S>(annotationType, TypeDescription.ForLoadedType.of(targetType), SerializedConstant.of(target));
                }
                public Class<T> getAnnotationType() {
                    return annotationType;
                }
                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation, AdviceType adviceType) {
                    return new ForSerializedValue(target.getType(), typeDescription, deserialization);
                }
            }
        }
    }
    public interface ArgumentHandler {
        int THIS_REFERENCE = 0;
        int argument(int offset);
        int exit();
        int enter();
        int named(String name);
        int returned();
        int thrown();
        interface ForInstrumentedMethod extends ArgumentHandler {
            int prepare(MethodVisitor methodVisitor);
            ForAdvice bindEnter(MethodDescription.TypeToken typeToken);
            ForAdvice bindExit(MethodDescription.TypeToken typeToken, boolean skipThrowable);
            boolean isCopyingArguments();
            List<TypeDescription> getNamedTypes();
            abstract class Default implements ForInstrumentedMethod {
                protected final MethodDescription instrumentedMethod;
                protected final TypeDefinition exitType;
                protected final SortedMap<String, TypeDefinition> namedTypes;
                protected final TypeDefinition enterType;
                protected Default(MethodDescription instrumentedMethod, TypeDefinition exitType, SortedMap<String, TypeDefinition> namedTypes, TypeDefinition enterType) {
                    this.instrumentedMethod = instrumentedMethod;
                    this.namedTypes = namedTypes;
                    this.exitType = exitType;
                    this.enterType = enterType;
                }
                public int exit() {
                    return instrumentedMethod.getStackSize();
                }
                public int named(String name) {
                    return instrumentedMethod.getStackSize() + exitType.getStackSize().getSize() + StackSize.of(namedTypes.headMap(name).values());
                }
                public int enter() {
                    return instrumentedMethod.getStackSize() + exitType.getStackSize().getSize() + StackSize.of(namedTypes.values());
                }
                public int returned() {
                    return instrumentedMethod.getStackSize() + exitType.getStackSize().getSize() + StackSize.of(namedTypes.values()) + enterType.getStackSize().getSize();
                }
                public int thrown() {
                    return instrumentedMethod.getStackSize() + exitType.getStackSize().getSize() + StackSize.of(namedTypes.values()) + enterType.getStackSize().getSize() + instrumentedMethod.getReturnType().getStackSize().getSize();
                }
                public ForAdvice bindEnter(MethodDescription.TypeToken typeToken) {
                    return new ForAdvice.Default.ForMethodEnter(instrumentedMethod, typeToken, exitType, namedTypes);
                }
                public ForAdvice bindExit(MethodDescription.TypeToken typeToken, boolean skipThrowable) {
                    return new ForAdvice.Default.ForMethodExit(instrumentedMethod, typeToken, exitType, namedTypes, enterType, skipThrowable ? StackSize.ZERO : StackSize.SINGLE);
                }
                public List<TypeDescription> getNamedTypes() {
                    List<TypeDescription> namedTypes = new ArrayList<TypeDescription>(this.namedTypes.size());
                    for (TypeDefinition typeDefinition : this.namedTypes.values()) {
                        namedTypes.add(typeDefinition.asErasure());
                    }
                    return namedTypes;
                }
                protected static class Simple extends Default {
                    protected Simple(MethodDescription instrumentedMethod, TypeDefinition exitType, SortedMap<String, TypeDefinition> namedTypes, TypeDefinition enterType) {
                        super(instrumentedMethod, exitType, namedTypes, enterType);
                    }
                    public int argument(int offset) {
                        return offset < instrumentedMethod.getStackSize() ? offset : offset + exitType.getStackSize().getSize() + StackSize.of(namedTypes.values()) + enterType.getStackSize().getSize();
                    }
                    public boolean isCopyingArguments() {
                        return false;
                    }
                    public int prepare(MethodVisitor methodVisitor) {
                        return 0;
                    }
                }
                protected static class Copying extends Default {
                    protected Copying(MethodDescription instrumentedMethod, TypeDefinition exitType, SortedMap<String, TypeDefinition> namedTypes, TypeDefinition enterType) {
                        super(instrumentedMethod, exitType, namedTypes, enterType);
                    }
                    public int argument(int offset) {
                        return instrumentedMethod.getStackSize() + exitType.getStackSize().getSize() + StackSize.of(namedTypes.values()) + enterType.getStackSize().getSize() + offset;
                    }
                    public boolean isCopyingArguments() {
                        return true;
                    }
                    public int prepare(MethodVisitor methodVisitor) {
                        StackSize stackSize;
                        if (!instrumentedMethod.isStatic()) {
                            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
                            methodVisitor.visitVarInsn(Opcodes.ASTORE, instrumentedMethod.getStackSize() + exitType.getStackSize().getSize() + StackSize.of(namedTypes.values()) + enterType.getStackSize().getSize());
                            stackSize = StackSize.SINGLE;
                        } else {
                            stackSize = StackSize.ZERO;
                        }
                        for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {
                            Type type = Type.getType(parameterDescription.getType().asErasure().getDescriptor());
                            methodVisitor.visitVarInsn(type.getOpcode(Opcodes.ILOAD), parameterDescription.getOffset());
                            methodVisitor.visitVarInsn(type.getOpcode(Opcodes.ISTORE), instrumentedMethod.getStackSize() + exitType.getStackSize().getSize() + StackSize.of(namedTypes.values()) + enterType.getStackSize().getSize() + parameterDescription.getOffset());
                            stackSize = stackSize.maximum(parameterDescription.getType().getStackSize());
                        }
                        return stackSize.getSize();
                    }
                }
            }
        }
        interface ForAdvice extends ArgumentHandler {
            int mapped(int offset);
            abstract class Default implements ForAdvice {
                protected final MethodDescription instrumentedMethod;
                protected final MethodDescription.TypeToken typeToken;
                protected final TypeDefinition exitType;
                protected final SortedMap<String, TypeDefinition> namedTypes;
                protected Default(MethodDescription instrumentedMethod, MethodDescription.TypeToken typeToken, TypeDefinition exitType, SortedMap<String, TypeDefinition> namedTypes) {
                    this.instrumentedMethod = instrumentedMethod;
                    this.typeToken = typeToken;
                    this.exitType = exitType;
                    this.namedTypes = namedTypes;
                }
                public int argument(int offset) {
                    return offset;
                }
                public int exit() {
                    return instrumentedMethod.getStackSize();
                }
                public int named(String name) {
                    return instrumentedMethod.getStackSize() + exitType.getStackSize().getSize() + StackSize.of(namedTypes.headMap(name).values());
                }
                public int enter() {
                    return instrumentedMethod.getStackSize() + exitType.getStackSize().getSize() + StackSize.of(namedTypes.values());
                }
                protected static class ForMethodEnter extends Default {
                    protected ForMethodEnter(MethodDescription instrumentedMethod, MethodDescription.TypeToken typeToken, TypeDefinition exitType, SortedMap<String, TypeDefinition> namedTypes) {
                        super(instrumentedMethod, typeToken, exitType, namedTypes);
                    }
                    public int returned() {
                        throw new IllegalStateException("Cannot resolve the return value offset during enter advice");
                    }
                    public int thrown() {
                        throw new IllegalStateException("Cannot resolve the thrown value offset during enter advice");
                    }
                    public int mapped(int offset) {
                        return instrumentedMethod.getStackSize() + exitType.getStackSize().getSize() + StackSize.of(namedTypes.values()) - StackSize.of(typeToken.getParameterTypes()) + offset;
                    }
                }
                protected static class ForMethodExit extends Default {
                    private final TypeDefinition enterType;
                    private final StackSize throwableSize;
                    protected ForMethodExit(MethodDescription instrumentedMethod, MethodDescription.TypeToken typeToken, TypeDefinition exitType, SortedMap<String, TypeDefinition> namedTypes, TypeDefinition enterType, StackSize throwableSize) {
                        super(instrumentedMethod, typeToken, exitType, namedTypes);
                        this.enterType = enterType;
                        this.throwableSize = throwableSize;
                    }
                    public int returned() {
                        return instrumentedMethod.getStackSize() + exitType.getStackSize().getSize() + StackSize.of(namedTypes.values()) + enterType.getStackSize().getSize();
                    }
                    public int thrown() {
                        return instrumentedMethod.getStackSize() + exitType.getStackSize().getSize() + StackSize.of(namedTypes.values()) + enterType.getStackSize().getSize() + instrumentedMethod.getReturnType().getStackSize().getSize();
                    }
                    public int mapped(int offset) {
                        return instrumentedMethod.getStackSize() + exitType.getStackSize().getSize() + StackSize.of(namedTypes.values()) + enterType.getStackSize().getSize() + instrumentedMethod.getReturnType().getStackSize().getSize() + throwableSize.getSize() - StackSize.of(typeToken.getParameterTypes()) + offset;
                    }
                }
            }
        }
        enum Factory {
            SIMPLE {
                @Override
                protected ForInstrumentedMethod resolve(MethodDescription instrumentedMethod, TypeDefinition enterType, TypeDefinition exitType, SortedMap<String, TypeDefinition> namedTypes) {
                    return new ForInstrumentedMethod.Default.Simple(instrumentedMethod, exitType, namedTypes, enterType);
                }
            }
            , COPYING {
                @Override
                protected ForInstrumentedMethod resolve(MethodDescription instrumentedMethod, TypeDefinition enterType, TypeDefinition exitType, SortedMap<String, TypeDefinition> namedTypes) {
                    return new ForInstrumentedMethod.Default.Copying(instrumentedMethod, exitType, namedTypes, enterType);
                }
            }
            ;
            protected abstract ForInstrumentedMethod resolve(MethodDescription instrumentedMethod, TypeDefinition enterType, TypeDefinition exitType, SortedMap<String, TypeDefinition> namedTypes);
        }
    }
    public interface PostProcessor {
        StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler, StackManipulation exceptionHandler);
        interface Factory {
            PostProcessor make(List<? extends AnnotationDescription> annotations, TypeDescription returnType, boolean exit);
            class Compound implements Factory {
                private final List<Factory> factories;
                public Compound(Factory... factory) {
                    this(Arrays.asList(factory));
                }
                public Compound(List<? extends Factory> factories) {
                    this.factories = new ArrayList<Factory>();
                    for (Factory factory : factories) {
                        if (factory instanceof Compound) {
                            this.factories.addAll(((Compound) factory).factories);
                        } else if (!(factory instanceof NoOp)) {
                            this.factories.add(factory);
                        }
                    }
                }
                public PostProcessor make(List<? extends AnnotationDescription> annotations, TypeDescription returnType, boolean exit) {
                    List<PostProcessor> postProcessors = new ArrayList<PostProcessor>(factories.size());
                    for (Factory factory : factories) {
                        postProcessors.add(factory.make(annotations, returnType, exit));
                    }
                    return new PostProcessor.Compound(postProcessors);
                }
            }
        }
        enum NoOp implements PostProcessor, Factory {
            INSTANCE;
            public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler, StackManipulation exceptionHandler) {
                return StackManipulation.Trivial.INSTANCE;
            }
            public PostProcessor make(List<? extends AnnotationDescription> annotations, TypeDescription returnType, boolean exit) {
                return this;
            }
        }
        class Compound implements PostProcessor {
            private final List<PostProcessor> postProcessors;
            protected Compound(List<PostProcessor> postProcessors) {
                this.postProcessors = postProcessors;
            }
            public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler, StackManipulation exceptionHandler) {
                List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(postProcessors.size());
                for (PostProcessor postProcessor : postProcessors) {
                    stackManipulations.add(postProcessor.resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, stackMapFrameHandler, exceptionHandler));
                }
                return new StackManipulation.Compound(stackManipulations);
            }
        }
    }
    protected interface Delegator {
        StackManipulation apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
        MethodDescription.TypeToken getTypeToken();
        void assertVisibility(TypeDescription instrumentedType);
        interface Factory {
            Delegator make(MethodDescription.InDefinedShape adviceMethod, boolean exit);
        }
        class ForRegularInvocation implements Delegator {
            private final MethodDescription.InDefinedShape adviceMethod;
            protected ForRegularInvocation(MethodDescription.InDefinedShape adviceMethod) {
                this.adviceMethod = adviceMethod;
            }
            public StackManipulation apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                return MethodInvocation.invoke(adviceMethod);
            }
            public MethodDescription.TypeToken getTypeToken() {
                return adviceMethod.asTypeToken();
            }
            public void assertVisibility(TypeDescription instrumentedType) {
                if (!adviceMethod.isVisibleTo(instrumentedType)) {
                    throw new IllegalStateException(adviceMethod + " is not visible to " + instrumentedType);
                }
            }
            protected enum Factory implements Delegator.Factory {
                INSTANCE;
                public Delegator make(MethodDescription.InDefinedShape adviceMethod, boolean exit) {
                    return new ForRegularInvocation(adviceMethod);
                }
            }
        }
        class ForDynamicInvocation implements Delegator {
            private final MethodDescription.InDefinedShape bootstrapMethod;
            private final MethodDescription.SignatureToken signatureToken;
            private final BootstrapArgumentResolver resolver;
            protected ForDynamicInvocation(MethodDescription.InDefinedShape bootstrapMethod, MethodDescription.SignatureToken signatureToken, BootstrapArgumentResolver resolver) {
                this.bootstrapMethod = bootstrapMethod;
                this.signatureToken = signatureToken;
                this.resolver = resolver;
            }
            protected static Delegator.Factory of(MethodDescription.InDefinedShape bootstrapMethod, BootstrapArgumentResolver.Factory resolverFactory, TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
                if (!bootstrapMethod.isInvokeBootstrap()) {
                    throw new IllegalArgumentException("Not a suitable bootstrap target: " + bootstrapMethod);
                }
                return new Factory(bootstrapMethod, resolverFactory, visitor);
            }
            public StackManipulation apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                List<JavaConstant> constants = resolver.resolve(instrumentedType, instrumentedMethod);
                if (!bootstrapMethod.isInvokeBootstrap(TypeList.Explicit.of(constants))) {
                    throw new IllegalStateException("Cannot invoke " + bootstrapMethod + " with arguments: " + constants);
                }
                return MethodInvocation.invoke(bootstrapMethod).dynamic(signatureToken.getName(), signatureToken.getReturnType(), signatureToken.getParameterTypes(), constants);
            }
            public MethodDescription.TypeToken getTypeToken() {
                return signatureToken.asTypeToken();
            }
            public void assertVisibility(TypeDescription instrumentedType) {
                if (!bootstrapMethod.isVisibleTo(instrumentedType)) {
                    throw new IllegalStateException(bootstrapMethod + " is not visible to " + instrumentedType);
                }
            }
            protected static class Factory implements Delegator.Factory {
                private final MethodDescription.InDefinedShape bootstrapMethod;
                private final BootstrapArgumentResolver.Factory resolverFactory;
                private final TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor;
                protected Factory(MethodDescription.InDefinedShape bootstrapMethod, BootstrapArgumentResolver.Factory resolverFactory, TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
                    this.bootstrapMethod = bootstrapMethod;
                    this.resolverFactory = resolverFactory;
                    this.visitor = visitor;
                }
                public Delegator make(MethodDescription.InDefinedShape adviceMethod, boolean exit) {
                    return new ForDynamicInvocation(bootstrapMethod, new MethodDescription.SignatureToken(adviceMethod.getInternalName(), adviceMethod.getReturnType().accept(visitor).asErasure(), adviceMethod.getParameters().asTypeList().accept(visitor).asErasures()), resolverFactory.resolve(adviceMethod, exit));
                }
            }
        }
    }
    public interface BootstrapArgumentResolver {
        List<JavaConstant> resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
        interface Factory {
            BootstrapArgumentResolver resolve(MethodDescription.InDefinedShape adviceMethod, boolean exit);
        }
        class ForDefaultValues implements BootstrapArgumentResolver {
            private final MethodDescription.InDefinedShape adviceMethod;
            private final boolean exit;
            protected ForDefaultValues(MethodDescription.InDefinedShape adviceMethod, boolean exit) {
                this.adviceMethod = adviceMethod;
                this.exit = exit;
            }
            public List<JavaConstant> resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                if (instrumentedMethod.isTypeInitializer()) {
                    return Arrays.asList(JavaConstant.Simple.ofLoaded(adviceMethod.getDeclaringType().getName()), JavaConstant.Simple.ofLoaded(exit ? 1 : 0), JavaConstant.Simple.of(instrumentedType), JavaConstant.Simple.ofLoaded(instrumentedMethod.getInternalName()));
                } else {
                    return Arrays.asList(JavaConstant.Simple.ofLoaded(adviceMethod.getDeclaringType().getName()), JavaConstant.Simple.ofLoaded(exit ? 1 : 0), JavaConstant.Simple.of(instrumentedType), JavaConstant.Simple.ofLoaded(instrumentedMethod.getInternalName()), JavaConstant.MethodHandle.of(instrumentedMethod.asDefined()));
                }
            }
            public enum Factory implements BootstrapArgumentResolver.Factory {
                INSTANCE;
                public BootstrapArgumentResolver resolve(MethodDescription.InDefinedShape adviceMethod, boolean exit) {
                    return new ForDefaultValues(adviceMethod, exit);
                }
            }
        }
    }
    protected interface MethodSizeHandler {
        int UNDEFINED_SIZE = Short.MAX_VALUE;
        void requireStackSize(int stackSize);
        void requireLocalVariableLength(int localVariableLength);
        interface ForInstrumentedMethod extends MethodSizeHandler {
            ForAdvice bindEnter(MethodDescription.TypeToken typeToken);
            ForAdvice bindExit(MethodDescription.TypeToken typeToken);
            int compoundStackSize(int stackSize);
            int compoundLocalVariableLength(int localVariableLength);
        }
        interface ForAdvice extends MethodSizeHandler {
            void requireStackSizePadding(int stackSizePadding);
            void requireLocalVariableLengthPadding(int localVariableLengthPadding);
            void recordMaxima(int stackSize, int localVariableLength);
        }
        enum NoOp implements ForInstrumentedMethod, ForAdvice {
            INSTANCE;
            public ForAdvice bindEnter(MethodDescription.TypeToken typeToken) {
                return this;
            }
            public ForAdvice bindExit(MethodDescription.TypeToken typeToken) {
                return this;
            }
            public int compoundStackSize(int stackSize) {
                return UNDEFINED_SIZE;
            }
            public int compoundLocalVariableLength(int localVariableLength) {
                return UNDEFINED_SIZE;
            }
            public void requireStackSize(int stackSize) {
            }
            public void requireLocalVariableLength(int localVariableLength) {
            }
            public void requireStackSizePadding(int stackSizePadding) {
            }
            public void requireLocalVariableLengthPadding(int localVariableLengthPadding) {
            }
            public void recordMaxima(int stackSize, int localVariableLength) {
            }
        }
        abstract class Default implements MethodSizeHandler.ForInstrumentedMethod {
            protected final MethodDescription instrumentedMethod;
            protected final List<? extends TypeDescription> initialTypes;
            protected final List<? extends TypeDescription> preMethodTypes;
            protected final List<? extends TypeDescription> postMethodTypes;
            protected int stackSize;
            protected int localVariableLength;
            protected Default(MethodDescription instrumentedMethod, List<? extends TypeDescription> initialTypes, List<? extends TypeDescription> preMethodTypes, List<? extends TypeDescription> postMethodTypes) {
                this.instrumentedMethod = instrumentedMethod;
                this.initialTypes = initialTypes;
                this.preMethodTypes = preMethodTypes;
                this.postMethodTypes = postMethodTypes;
            }
            protected static MethodSizeHandler.ForInstrumentedMethod of(MethodDescription instrumentedMethod, List<? extends TypeDescription> initialTypes, List<? extends TypeDescription> preMethodTypes, List<? extends TypeDescription> postMethodTypes, boolean copyArguments, int writerFlags) {
                if ((writerFlags & (ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES)) != 0) {
                    return NoOp.INSTANCE;
                } else if (copyArguments) {
                    return new WithCopiedArguments(instrumentedMethod, initialTypes, preMethodTypes, postMethodTypes);
                } else {
                    return new WithRetainedArguments(instrumentedMethod, initialTypes, preMethodTypes, postMethodTypes);
                }
            }
            public MethodSizeHandler.ForAdvice bindEnter(MethodDescription.TypeToken typeToken) {
                return new ForAdvice(typeToken, instrumentedMethod.getStackSize() + StackSize.of(initialTypes));
            }
            public void requireStackSize(int stackSize) {
                Default.this.stackSize = Math.max(this.stackSize, stackSize);
            }
            public void requireLocalVariableLength(int localVariableLength) {
                this.localVariableLength = Math.max(this.localVariableLength, localVariableLength);
            }
            public int compoundStackSize(int stackSize) {
                return Math.max(this.stackSize, stackSize);
            }
            public int compoundLocalVariableLength(int localVariableLength) {
                return Math.max(this.localVariableLength, localVariableLength + StackSize.of(postMethodTypes) + StackSize.of(initialTypes) + StackSize.of(preMethodTypes));
            }
            protected static class WithRetainedArguments extends Default {
                protected WithRetainedArguments(MethodDescription instrumentedMethod, List<? extends TypeDescription> initialTypes, List<? extends TypeDescription> preMethodTypes, List<? extends TypeDescription> postMethodTypes) {
                    super(instrumentedMethod, initialTypes, preMethodTypes, postMethodTypes);
                }
                public MethodSizeHandler.ForAdvice bindExit(MethodDescription.TypeToken typeToken) {
                    return new ForAdvice(typeToken, instrumentedMethod.getStackSize() + StackSize.of(postMethodTypes) + StackSize.of(initialTypes) + StackSize.of(preMethodTypes));
                }
                public int compoundLocalVariableLength(int localVariableLength) {
                    return Math.max(this.localVariableLength, localVariableLength + StackSize.of(postMethodTypes) + StackSize.of(initialTypes) + StackSize.of(preMethodTypes));
                }
            }
            protected static class WithCopiedArguments extends Default {
                protected WithCopiedArguments(MethodDescription instrumentedMethod, List<? extends TypeDescription> initialTypes, List<? extends TypeDescription> preMethodTypes, List<? extends TypeDescription> postMethodTypes) {
                    super(instrumentedMethod, initialTypes, preMethodTypes, postMethodTypes);
                }
                public MethodSizeHandler.ForAdvice bindExit(MethodDescription.TypeToken typeToken) {
                    return new ForAdvice(typeToken, 2 * instrumentedMethod.getStackSize() + StackSize.of(initialTypes) + StackSize.of(preMethodTypes) + StackSize.of(postMethodTypes));
                }
                public int compoundLocalVariableLength(int localVariableLength) {
                    return Math.max(this.localVariableLength, localVariableLength + instrumentedMethod.getStackSize() + StackSize.of(postMethodTypes) + StackSize.of(initialTypes) + StackSize.of(preMethodTypes));
                }
            }
            protected class ForAdvice implements MethodSizeHandler.ForAdvice {
                private final MethodDescription.TypeToken typeToken;
                private final int baseLocalVariableLength;
                private int stackSizePadding;
                private int localVariableLengthPadding;
                protected ForAdvice(MethodDescription.TypeToken typeToken, int baseLocalVariableLength) {
                    this.typeToken = typeToken;
                    this.baseLocalVariableLength = baseLocalVariableLength;
                }
                public void requireStackSize(int stackSize) {
                    Default.this.requireStackSize(stackSize);
                }
                public void requireLocalVariableLength(int localVariableLength) {
                    Default.this.requireLocalVariableLength(localVariableLength);
                }
                public void requireStackSizePadding(int stackSizePadding) {
                    this.stackSizePadding = Math.max(this.stackSizePadding, stackSizePadding);
                }
                public void requireLocalVariableLengthPadding(int localVariableLengthPadding) {
                    this.localVariableLengthPadding = Math.max(this.localVariableLengthPadding, localVariableLengthPadding);
                }
                public void recordMaxima(int stackSize, int localVariableLength) {
                    Default.this.requireStackSize(stackSize + stackSizePadding);
                    Default.this.requireLocalVariableLength(localVariableLength - StackSize.of(typeToken.getParameterTypes()) + baseLocalVariableLength + localVariableLengthPadding);
                }
            }
        }
    }
    public interface StackMapFrameHandler {
        void translateFrame(MethodVisitor methodVisitor, int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack);
        void injectReturnFrame(MethodVisitor methodVisitor);
        void injectExceptionFrame(MethodVisitor methodVisitor);
        void injectCompletionFrame(MethodVisitor methodVisitor);
        interface ForPostProcessor {
            void injectIntermediateFrame(MethodVisitor methodVisitor, List<? extends TypeDescription> stack);
        }
        interface ForInstrumentedMethod extends StackMapFrameHandler {
            ForAdvice bindEnter(MethodDescription.TypeToken typeToken);
            ForAdvice bindExit(MethodDescription.TypeToken typeToken);
            int getReaderHint();
            void injectInitializationFrame(MethodVisitor methodVisitor);
            void injectStartFrame(MethodVisitor methodVisitor);
            void injectPostCompletionFrame(MethodVisitor methodVisitor);
        }
        interface ForAdvice extends StackMapFrameHandler, ForPostProcessor {
        }
        enum NoOp implements ForInstrumentedMethod, ForAdvice {
            INSTANCE;
            public StackMapFrameHandler.ForAdvice bindEnter(MethodDescription.TypeToken typeToken) {
                return this;
            }
            public StackMapFrameHandler.ForAdvice bindExit(MethodDescription.TypeToken typeToken) {
                return this;
            }
            public int getReaderHint() {
                return ClassReader.SKIP_FRAMES;
            }
            public void translateFrame(MethodVisitor methodVisitor, int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
            }
            public void injectReturnFrame(MethodVisitor methodVisitor) {
            }
            public void injectExceptionFrame(MethodVisitor methodVisitor) {
            }
            public void injectCompletionFrame(MethodVisitor methodVisitor) {
            }
            public void injectInitializationFrame(MethodVisitor methodVisitor) {
            }
            public void injectStartFrame(MethodVisitor methodVisitor) {
            }
            public void injectPostCompletionFrame(MethodVisitor methodVisitor) {
            }
            public void injectIntermediateFrame(MethodVisitor methodVisitor, List<? extends TypeDescription> stack) {
            }
        }
        abstract class Default implements ForInstrumentedMethod {
            protected static final Object[] EMPTY = new Object[0];
            protected final TypeDescription instrumentedType;
            protected final MethodDescription instrumentedMethod;
            protected final List<? extends TypeDescription> initialTypes;
            protected final List<? extends TypeDescription> latentTypes;
            protected final List<? extends TypeDescription> preMethodTypes;
            protected final List<? extends TypeDescription> postMethodTypes;
            protected final boolean expandFrames;
            protected int currentFrameDivergence;
            protected Default(TypeDescription instrumentedType, MethodDescription instrumentedMethod, List<? extends TypeDescription> initialTypes, List<? extends TypeDescription> latentTypes, List<? extends TypeDescription> preMethodTypes, List<? extends TypeDescription> postMethodTypes, boolean expandFrames) {
                this.instrumentedType = instrumentedType;
                this.instrumentedMethod = instrumentedMethod;
                this.initialTypes = initialTypes;
                this.latentTypes = latentTypes;
                this.preMethodTypes = preMethodTypes;
                this.postMethodTypes = postMethodTypes;
                this.expandFrames = expandFrames;
            }
            protected static ForInstrumentedMethod of(TypeDescription instrumentedType, MethodDescription instrumentedMethod, List<? extends TypeDescription> initialTypes, List<? extends TypeDescription> latentTypes, List<? extends TypeDescription> preMethodTypes, List<? extends TypeDescription> postMethodTypes, boolean exitAdvice, boolean copyArguments, ClassFileVersion classFileVersion, int writerFlags, int readerFlags) {
                if ((writerFlags & ClassWriter.COMPUTE_FRAMES) != 0 || classFileVersion.isLessThan(ClassFileVersion.JAVA_V6)) {
                    return NoOp.INSTANCE;
                } else if (!exitAdvice && initialTypes.isEmpty()) {
                    return new Trivial(instrumentedType, instrumentedMethod, latentTypes, (readerFlags & ClassReader.EXPAND_FRAMES) != 0);
                } else if (copyArguments) {
                    return new WithPreservedArguments.WithArgumentCopy(instrumentedType, instrumentedMethod, initialTypes, latentTypes, preMethodTypes, postMethodTypes, (readerFlags & ClassReader.EXPAND_FRAMES) != 0);
                } else {
                    return new WithPreservedArguments.WithoutArgumentCopy(instrumentedType, instrumentedMethod, initialTypes, latentTypes, preMethodTypes, postMethodTypes, (readerFlags & ClassReader.EXPAND_FRAMES) != 0, !instrumentedMethod.isConstructor());
                }
            }
            public StackMapFrameHandler.ForAdvice bindEnter(MethodDescription.TypeToken typeToken) {
                return new ForAdvice(typeToken, initialTypes, latentTypes, preMethodTypes, TranslationMode.ENTER, instrumentedMethod.isConstructor() ? Initialization.UNITIALIZED : Initialization.INITIALIZED);
            }
            public int getReaderHint() {
                return expandFrames ? ClassReader.EXPAND_FRAMES : AsmVisitorWrapper.NO_FLAGS;
            }
            protected void translateFrame(MethodVisitor methodVisitor, TranslationMode translationMode, boolean isStatic, MethodDescription.TypeToken typeToken, List<? extends TypeDescription> additionalTypes, int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
                switch(type) {
                    case Opcodes.F_SAME:
                    case Opcodes.F_SAME1:
                        break;
                    case Opcodes.F_APPEND:
                        currentFrameDivergence += localVariableLength;
                        break;
                    case Opcodes.F_CHOP:
                        currentFrameDivergence -= localVariableLength;
                        if (currentFrameDivergence < 0) {
                            throw new IllegalStateException(typeToken + " dropped " + Math.abs(currentFrameDivergence) + " implicit frames");
                        }
                        break;
                    case Opcodes.F_FULL:
                    case Opcodes.F_NEW:
                        if (typeToken.getParameterTypes().size() + (isStatic ? 0 : 1) > localVariableLength) {
                            throw new IllegalStateException("Inconsistent frame length for " + typeToken + ": " + localVariableLength);
                        }
                        int offset;
                        if (isStatic) {
                            offset = 0;
                        } else {
                            if (!translationMode.isPossibleThisFrameValue(instrumentedType, instrumentedMethod, localVariable[0])) {
                                throw new IllegalStateException(typeToken + " is inconsistent for 'this' reference: " + localVariable[0]);
                            }
                            offset = 1;
                        }
                        for (int index = 0; index < typeToken.getParameterTypes().size(); index++) {
                            if (!Initialization.INITIALIZED.toFrame(typeToken.getParameterTypes().get(index)).equals(localVariable[index + offset])) {
                                throw new IllegalStateException(typeToken + " is inconsistent at " + index + ": " + localVariable[index + offset]);
                            }
                        }
                        Object[] translated = new Object[localVariableLength - (isStatic ? 0 : 1) - typeToken.getParameterTypes().size() + (instrumentedMethod.isStatic() ? 0 : 1) + instrumentedMethod.getParameters().size() + additionalTypes.size()];
                        int index = translationMode.copy(instrumentedType, instrumentedMethod, localVariable, translated);
                        for (TypeDescription typeDescription : additionalTypes) {
                            translated[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                        }
                        if (translated.length != index) {
                            System.arraycopy(localVariable, typeToken.getParameterTypes().size() + (isStatic ? 0 : 1), translated, index, translated.length - index);
                        }
                        localVariableLength = translated.length;
                        localVariable = translated;
                        currentFrameDivergence = translated.length - index;
                        break;
                    default:
                        throw new IllegalArgumentException("Unexpected frame type: " + type);
                }
                methodVisitor.visitFrame(type, localVariableLength, localVariable, stackSize, stack);
            }
            protected void injectFullFrame(MethodVisitor methodVisitor, Initialization initialization, List<? extends TypeDescription> typesInArray, List<? extends TypeDescription> typesOnStack) {
                Object[] localVariable = new Object[instrumentedMethod.getParameters().size() + (instrumentedMethod.isStatic() ? 0 : 1) + typesInArray.size()];
                int index = 0;
                if (!instrumentedMethod.isStatic()) {
                    localVariable[index++] = initialization.toFrame(instrumentedType);
                }
                for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {
                    localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                }
                for (TypeDescription typeDescription : typesInArray) {
                    localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                }
                index = 0;
                Object[] stackType = new Object[typesOnStack.size()];
                for (TypeDescription typeDescription : typesOnStack) {
                    stackType[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                }
                methodVisitor.visitFrame(expandFrames ? Opcodes.F_NEW : Opcodes.F_FULL, localVariable.length, localVariable, stackType.length, stackType);
                currentFrameDivergence = 0;
            }
            protected enum TranslationMode {
                COPY {
                    @Override
                    protected int copy(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Object[] localVariable, Object[] translated) {
                        int length = instrumentedMethod.getParameters().size() + (instrumentedMethod.isStatic() ? 0 : 1);
                        System.arraycopy(localVariable, 0, translated, 0, length);
                        return length;
                    }
                    @Override
                    protected boolean isPossibleThisFrameValue(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Object frame) {
                        return instrumentedMethod.isConstructor() && Opcodes.UNINITIALIZED_THIS.equals(frame) || Initialization.INITIALIZED.toFrame(instrumentedType).equals(frame);
                    }
                }
                , ENTER {
                    @Override
                    protected int copy(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Object[] localVariable, Object[] translated) {
                        int index = 0;
                        if (!instrumentedMethod.isStatic()) {
                            translated[index++] = instrumentedMethod.isConstructor() ? Opcodes.UNINITIALIZED_THIS : Initialization.INITIALIZED.toFrame(instrumentedType);
                        }
                        for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {
                            translated[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                        }
                        return index;
                    }
                    @Override
                    protected boolean isPossibleThisFrameValue(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Object frame) {
                        return instrumentedMethod.isConstructor() ? Opcodes.UNINITIALIZED_THIS.equals(frame) : Initialization.INITIALIZED.toFrame(instrumentedType).equals(frame);
                    }
                }
                , EXIT {
                    @Override
                    protected int copy(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Object[] localVariable, Object[] translated) {
                        int index = 0;
                        if (!instrumentedMethod.isStatic()) {
                            translated[index++] = Initialization.INITIALIZED.toFrame(instrumentedType);
                        }
                        for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {
                            translated[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                        }
                        return index;
                    }
                    @Override
                    protected boolean isPossibleThisFrameValue(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Object frame) {
                        return Initialization.INITIALIZED.toFrame(instrumentedType).equals(frame);
                    }
                }
                ;
                protected abstract int copy(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Object[] localVariable, Object[] translated);
                protected abstract boolean isPossibleThisFrameValue(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Object frame);
            }
            protected enum Initialization {
                UNITIALIZED {
                    protected Object toFrame(TypeDescription typeDescription) {
                        if (typeDescription.isPrimitive()) {
                            throw new IllegalArgumentException("Cannot assume primitive uninitialized value: " + typeDescription);
                        }
                        return Opcodes.UNINITIALIZED_THIS;
                    }
                }
                , INITIALIZED {
                    protected Object toFrame(TypeDescription typeDescription) {
                        if (typeDescription.represents(boolean.class) || typeDescription.represents(byte.class) || typeDescription.represents(short.class) || typeDescription.represents(char.class) || typeDescription.represents(int.class)) {
                            return Opcodes.INTEGER;
                        } else if (typeDescription.represents(long.class)) {
                            return Opcodes.LONG;
                        } else if (typeDescription.represents(float.class)) {
                            return Opcodes.FLOAT;
                        } else if (typeDescription.represents(double.class)) {
                            return Opcodes.DOUBLE;
                        } else {
                            return typeDescription.getInternalName();
                        }
                    }
                }
                ;
                protected abstract Object toFrame(TypeDescription typeDescription);
            }
            protected static class Trivial extends Default {
                protected Trivial(TypeDescription instrumentedType, MethodDescription instrumentedMethod, List<? extends TypeDescription> latentTypes, boolean expandFrames) {
                    super(instrumentedType, instrumentedMethod, Collections.<TypeDescription>emptyList(), latentTypes, Collections.<TypeDescription>emptyList(), Collections.<TypeDescription>emptyList(), expandFrames);
                }
                public void translateFrame(MethodVisitor methodVisitor, int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
                    methodVisitor.visitFrame(type, localVariableLength, localVariable, stackSize, stack);
                }
                public StackMapFrameHandler.ForAdvice bindExit(MethodDescription.TypeToken typeToken) {
                    throw new IllegalStateException("Did not expect exit advice " + typeToken + " for " + instrumentedMethod);
                }
                public void injectReturnFrame(MethodVisitor methodVisitor) {
                    throw new IllegalStateException("Did not expect return frame for " + instrumentedMethod);
                }
                public void injectExceptionFrame(MethodVisitor methodVisitor) {
                    throw new IllegalStateException("Did not expect exception frame for " + instrumentedMethod);
                }
                public void injectCompletionFrame(MethodVisitor methodVisitor) {
                    throw new IllegalStateException("Did not expect completion frame for " + instrumentedMethod);
                }
                public void injectPostCompletionFrame(MethodVisitor methodVisitor) {
                    throw new IllegalStateException("Did not expect post completion frame for " + instrumentedMethod);
                }
                public void injectInitializationFrame(MethodVisitor methodVisitor) {
                }
                public void injectStartFrame(MethodVisitor methodVisitor) {
                }
            }
            protected abstract static class WithPreservedArguments extends Default {
                protected boolean allowCompactCompletionFrame;
                protected WithPreservedArguments(TypeDescription instrumentedType, MethodDescription instrumentedMethod, List<? extends TypeDescription> initialTypes, List<? extends TypeDescription> latentTypes, List<? extends TypeDescription> preMethodTypes, List<? extends TypeDescription> postMethodTypes, boolean expandFrames, boolean allowCompactCompletionFrame) {
                    super(instrumentedType, instrumentedMethod, initialTypes, latentTypes, preMethodTypes, postMethodTypes, expandFrames);
                    this.allowCompactCompletionFrame = allowCompactCompletionFrame;
                }
                protected void translateFrame(MethodVisitor methodVisitor, TranslationMode translationMode, boolean isStatic, MethodDescription.TypeToken typeToken, List<? extends TypeDescription> additionalTypes, int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
                    if (type == Opcodes.F_FULL && localVariableLength > 0 && localVariable[0] != Opcodes.UNINITIALIZED_THIS) {
                        allowCompactCompletionFrame = true;
                    }
                    super.translateFrame(methodVisitor, translationMode, isStatic, typeToken, additionalTypes, type, localVariableLength, localVariable, stackSize, stack);
                }
                public StackMapFrameHandler.ForAdvice bindExit(MethodDescription.TypeToken typeToken) {
                    return new ForAdvice(typeToken, CompoundList.of(initialTypes, preMethodTypes, postMethodTypes), Collections.<TypeDescription>emptyList(), Collections.<TypeDescription>emptyList(), TranslationMode.EXIT, Initialization.INITIALIZED);
                }
                public void injectReturnFrame(MethodVisitor methodVisitor) {
                    if (!expandFrames && currentFrameDivergence == 0) {
                        if (instrumentedMethod.getReturnType().represents(void.class)) {
                            methodVisitor.visitFrame(Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY);
                        } else {
                            methodVisitor.visitFrame(Opcodes.F_SAME1, EMPTY.length, EMPTY, 1, new Object[] { Initialization.INITIALIZED.toFrame(instrumentedMethod.getReturnType().asErasure()) });
                        }
                    } else {
                        injectFullFrame(methodVisitor, Initialization.INITIALIZED, CompoundList.of(initialTypes, preMethodTypes), instrumentedMethod.getReturnType().represents(void.class) ? Collections.<TypeDescription>emptyList() : Collections.singletonList(instrumentedMethod.getReturnType().asErasure()));
                    }
                }
                public void injectExceptionFrame(MethodVisitor methodVisitor) {
                    if (!expandFrames && currentFrameDivergence == 0) {
                        methodVisitor.visitFrame(Opcodes.F_SAME1, EMPTY.length, EMPTY, 1, new Object[] { Type.getInternalName(Throwable.class) });
                    } else {
                        injectFullFrame(methodVisitor, Initialization.INITIALIZED, CompoundList.of(initialTypes, preMethodTypes), Collections.singletonList(TypeDescription.ForLoadedType.of(Throwable.class)));
                    }
                }
                public void injectCompletionFrame(MethodVisitor methodVisitor) {
                    if (allowCompactCompletionFrame && !expandFrames && currentFrameDivergence == 0 && postMethodTypes.size() < 4) {
                        if (postMethodTypes.isEmpty()) {
                            methodVisitor.visitFrame(Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY);
                        } else {
                            Object[] local = new Object[postMethodTypes.size()];
                            int index = 0;
                            for (TypeDescription typeDescription : postMethodTypes) {
                                local[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                            }
                            methodVisitor.visitFrame(Opcodes.F_APPEND, local.length, local, EMPTY.length, EMPTY);
                        }
                    } else {
                        injectFullFrame(methodVisitor, Initialization.INITIALIZED, CompoundList.of(initialTypes, preMethodTypes, postMethodTypes), Collections.<TypeDescription>emptyList());
                    }
                }
                public void injectPostCompletionFrame(MethodVisitor methodVisitor) {
                    if (!expandFrames && currentFrameDivergence == 0) {
                        methodVisitor.visitFrame(Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY);
                    } else {
                        injectFullFrame(methodVisitor, Initialization.INITIALIZED, CompoundList.of(initialTypes, preMethodTypes, postMethodTypes), Collections.<TypeDescription>emptyList());
                    }
                }
                public void injectInitializationFrame(MethodVisitor methodVisitor) {
                    if (!initialTypes.isEmpty()) {
                        if (!expandFrames && initialTypes.size() < 4) {
                            Object[] localVariable = new Object[initialTypes.size()];
                            int index = 0;
                            for (TypeDescription typeDescription : initialTypes) {
                                localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                            }
                            methodVisitor.visitFrame(Opcodes.F_APPEND, localVariable.length, localVariable, EMPTY.length, EMPTY);
                        } else {
                            Object[] localVariable = new Object[(instrumentedMethod.isStatic() ? 0 : 1) + instrumentedMethod.getParameters().size() + initialTypes.size()];
                            int index = 0;
                            if (instrumentedMethod.isConstructor()) {
                                localVariable[index++] = Opcodes.UNINITIALIZED_THIS;
                            } else if (!instrumentedMethod.isStatic()) {
                                localVariable[index++] = Initialization.INITIALIZED.toFrame(instrumentedType);
                            }
                            for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {
                                localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                            }
                            for (TypeDescription typeDescription : initialTypes) {
                                localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                            }
                            methodVisitor.visitFrame(expandFrames ? Opcodes.F_NEW : Opcodes.F_FULL, localVariable.length, localVariable, EMPTY.length, EMPTY);
                        }
                    }
                }
                protected static class WithoutArgumentCopy extends WithPreservedArguments {
                    protected WithoutArgumentCopy(TypeDescription instrumentedType, MethodDescription instrumentedMethod, List<? extends TypeDescription> initialTypes, List<? extends TypeDescription> latentTypes, List<? extends TypeDescription> preMethodTypes, List<? extends TypeDescription> postMethodTypes, boolean expandFrames, boolean allowCompactCompletionFrame) {
                        super(instrumentedType, instrumentedMethod, initialTypes, latentTypes, preMethodTypes, postMethodTypes, expandFrames, allowCompactCompletionFrame);
                    }
                    public void injectStartFrame(MethodVisitor methodVisitor) {
                    }
                    public void translateFrame(MethodVisitor methodVisitor, int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
                        translateFrame(methodVisitor, TranslationMode.COPY, instrumentedMethod.isStatic(), instrumentedMethod.asTypeToken(), CompoundList.of(initialTypes, preMethodTypes), type, localVariableLength, localVariable, stackSize, stack);
                    }
                }
                protected static class WithArgumentCopy extends WithPreservedArguments {
                    protected WithArgumentCopy(TypeDescription instrumentedType, MethodDescription instrumentedMethod, List<? extends TypeDescription> initialTypes, List<? extends TypeDescription> latentTypes, List<? extends TypeDescription> preMethodTypes, List<? extends TypeDescription> postMethodTypes, boolean expandFrames) {
                        super(instrumentedType, instrumentedMethod, initialTypes, latentTypes, preMethodTypes, postMethodTypes, expandFrames, true);
                    }
                    public void injectStartFrame(MethodVisitor methodVisitor) {
                        if (!instrumentedMethod.isStatic() || !instrumentedMethod.getParameters().isEmpty()) {
                            if (!expandFrames && (instrumentedMethod.isStatic() ? 0 : 1) + instrumentedMethod.getParameters().size() < 4) {
                                Object[] localVariable = new Object[(instrumentedMethod.isStatic() ? 0 : 1) + instrumentedMethod.getParameters().size()];
                                int index = 0;
                                if (instrumentedMethod.isConstructor()) {
                                    localVariable[index++] = Opcodes.UNINITIALIZED_THIS;
                                } else if (!instrumentedMethod.isStatic()) {
                                    localVariable[index++] = Initialization.INITIALIZED.toFrame(instrumentedType);
                                }
                                for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {
                                    localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                                }
                                methodVisitor.visitFrame(Opcodes.F_APPEND, localVariable.length, localVariable, EMPTY.length, EMPTY);
                            } else {
                                Object[] localVariable = new Object[(instrumentedMethod.isStatic() ? 0 : 2) + instrumentedMethod.getParameters().size() * 2 + initialTypes.size() + preMethodTypes.size()];
                                int index = 0;
                                if (instrumentedMethod.isConstructor()) {
                                    localVariable[index++] = Opcodes.UNINITIALIZED_THIS;
                                } else if (!instrumentedMethod.isStatic()) {
                                    localVariable[index++] = Initialization.INITIALIZED.toFrame(instrumentedType);
                                }
                                for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {
                                    localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                                }
                                for (TypeDescription typeDescription : initialTypes) {
                                    localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                                }
                                for (TypeDescription typeDescription : preMethodTypes) {
                                    localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                                }
                                if (instrumentedMethod.isConstructor()) {
                                    localVariable[index++] = Opcodes.UNINITIALIZED_THIS;
                                } else if (!instrumentedMethod.isStatic()) {
                                    localVariable[index++] = Initialization.INITIALIZED.toFrame(instrumentedType);
                                }
                                for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {
                                    localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                                }
                                methodVisitor.visitFrame(expandFrames ? Opcodes.F_NEW : Opcodes.F_FULL, localVariable.length, localVariable, EMPTY.length, EMPTY);
                            }
                        }
                        currentFrameDivergence = (instrumentedMethod.isStatic() ? 0 : 1) + instrumentedMethod.getParameters().size();
                    }
                    public void translateFrame(MethodVisitor methodVisitor, int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
                        switch(type) {
                            case Opcodes.F_SAME:
                            case Opcodes.F_SAME1:
                                break;
                            case Opcodes.F_APPEND:
                                currentFrameDivergence += localVariableLength;
                                break;
                            case Opcodes.F_CHOP:
                                currentFrameDivergence -= localVariableLength;
                                break;
                            case Opcodes.F_FULL:
                            case Opcodes.F_NEW:
                                Object[] translated = new Object[localVariableLength + (instrumentedMethod.isStatic() ? 0 : 1) + instrumentedMethod.getParameters().size() + initialTypes.size() + preMethodTypes.size()];
                                int index = 0;
                                if (instrumentedMethod.isConstructor()) {
                                    Initialization initialization = Initialization.INITIALIZED;
                                    for (int variableIndex = 0; variableIndex < localVariableLength; variableIndex++) {
                                        if (localVariable[variableIndex] == Opcodes.UNINITIALIZED_THIS) {
                                            initialization = Initialization.UNITIALIZED;
                                            break;
                                        }
                                    }
                                    translated[index++] = initialization.toFrame(instrumentedType);
                                } else if (!instrumentedMethod.isStatic()) {
                                    translated[index++] = Initialization.INITIALIZED.toFrame(instrumentedType);
                                }
                                for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {
                                    translated[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                                }
                                for (TypeDescription typeDescription : initialTypes) {
                                    translated[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                                }
                                for (TypeDescription typeDescription : preMethodTypes) {
                                    translated[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                                }
                                if (localVariableLength > 0) {
                                    System.arraycopy(localVariable, 0, translated, index, localVariableLength);
                                }
                                localVariableLength = translated.length;
                                localVariable = translated;
                                currentFrameDivergence = localVariableLength;
                                break;
                            default:
                                throw new IllegalArgumentException("Unexpected frame type: " + type);
                        }
                        if (instrumentedMethod.isConstructor() && currentFrameDivergence < instrumentedMethod.getStackSize()) {
                            throw new IllegalStateException(instrumentedMethod + " dropped implicit 'this' frame");
                        }
                        methodVisitor.visitFrame(type, localVariableLength, localVariable, stackSize, stack);
                    }
                }
            }
            protected class ForAdvice implements StackMapFrameHandler.ForAdvice {
                protected final MethodDescription.TypeToken typeToken;
                protected final List<? extends TypeDescription> startTypes;
                private final List<? extends TypeDescription> intermediateTypes;
                protected final List<? extends TypeDescription> endTypes;
                protected final TranslationMode translationMode;
                private final Initialization initialization;
                private boolean intermediate;
                protected ForAdvice(MethodDescription.TypeToken typeToken, List<? extends TypeDescription> startTypes, List<? extends TypeDescription> intermediateTypes, List<? extends TypeDescription> endTypes, TranslationMode translationMode, Initialization initialization) {
                    this.typeToken = typeToken;
                    this.startTypes = startTypes;
                    this.intermediateTypes = intermediateTypes;
                    this.endTypes = endTypes;
                    this.translationMode = translationMode;
                    this.initialization = initialization;
                    intermediate = false;
                }
                public void translateFrame(MethodVisitor methodVisitor, int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
                    Default.this.translateFrame(methodVisitor, translationMode, true, typeToken, startTypes, type, localVariableLength, localVariable, stackSize, stack);
                }
                public void injectReturnFrame(MethodVisitor methodVisitor) {
                    if (!expandFrames && currentFrameDivergence == 0) {
                        if (typeToken.getReturnType().represents(void.class)) {
                            methodVisitor.visitFrame(Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY);
                        } else {
                            methodVisitor.visitFrame(Opcodes.F_SAME1, EMPTY.length, EMPTY, 1, new Object[] { Initialization.INITIALIZED.toFrame(typeToken.getReturnType()) });
                        }
                    } else {
                        injectFullFrame(methodVisitor, initialization, startTypes, typeToken.getReturnType().represents(void.class) ? Collections.<TypeDescription>emptyList() : Collections.singletonList(typeToken.getReturnType()));
                    }
                }
                public void injectExceptionFrame(MethodVisitor methodVisitor) {
                    if (!expandFrames && currentFrameDivergence == 0) {
                        methodVisitor.visitFrame(Opcodes.F_SAME1, EMPTY.length, EMPTY, 1, new Object[] { Type.getInternalName(Throwable.class) });
                    } else {
                        injectFullFrame(methodVisitor, initialization, startTypes, Collections.singletonList(TypeDescription.ForLoadedType.of(Throwable.class)));
                    }
                }
                public void injectCompletionFrame(MethodVisitor methodVisitor) {
                    if (expandFrames) {
                        injectFullFrame(methodVisitor, initialization, CompoundList.of(startTypes, endTypes), Collections.<TypeDescription>emptyList());
                    } else if (currentFrameDivergence == 0 && (intermediate || endTypes.size() < 4)) {
                        if (intermediate || endTypes.isEmpty()) {
                            methodVisitor.visitFrame(Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY);
                        } else {
                            Object[] local = new Object[endTypes.size()];
                            int index = 0;
                            for (TypeDescription typeDescription : endTypes) {
                                local[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                            }
                            methodVisitor.visitFrame(Opcodes.F_APPEND, local.length, local, EMPTY.length, EMPTY);
                        }
                    } else if (currentFrameDivergence < 3 && endTypes.isEmpty()) {
                        methodVisitor.visitFrame(Opcodes.F_CHOP, currentFrameDivergence, EMPTY, EMPTY.length, EMPTY);
                        currentFrameDivergence = 0;
                    } else {
                        injectFullFrame(methodVisitor, initialization, CompoundList.of(startTypes, endTypes), Collections.<TypeDescription>emptyList());
                    }
                }
                public void injectIntermediateFrame(MethodVisitor methodVisitor, List<? extends TypeDescription> stack) {
                    if (expandFrames) {
                        injectFullFrame(methodVisitor, initialization, CompoundList.of(startTypes, intermediateTypes), stack);
                    } else if (intermediate && stack.size() < 2) {
                        if (stack.isEmpty()) {
                            methodVisitor.visitFrame(Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY);
                        } else {
                            methodVisitor.visitFrame(Opcodes.F_SAME1, EMPTY.length, EMPTY, 1, new Object[] { Initialization.INITIALIZED.toFrame(stack.get(0)) });
                        }
                    } else if (currentFrameDivergence == 0 && intermediateTypes.size() < 4 && (stack.isEmpty() || stack.size() < 2 && intermediateTypes.isEmpty())) {
                        if (intermediateTypes.isEmpty()) {
                            if (stack.isEmpty()) {
                                methodVisitor.visitFrame(Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY);
                            } else {
                                methodVisitor.visitFrame(Opcodes.F_SAME1, EMPTY.length, EMPTY, 1, new Object[] { Initialization.INITIALIZED.toFrame(stack.get(0)) });
                            }
                        } else {
                            Object[] local = new Object[intermediateTypes.size()];
                            int index = 0;
                            for (TypeDescription typeDescription : intermediateTypes) {
                                local[index++] = Initialization.INITIALIZED.toFrame(typeDescription);
                            }
                            methodVisitor.visitFrame(Opcodes.F_APPEND, local.length, local, EMPTY.length, EMPTY);
                        }
                    } else if (currentFrameDivergence < 3 && intermediateTypes.isEmpty() && stack.isEmpty()) {
                        methodVisitor.visitFrame(Opcodes.F_CHOP, currentFrameDivergence, EMPTY, EMPTY.length, EMPTY);
                    } else {
                        injectFullFrame(methodVisitor, initialization, CompoundList.of(startTypes, intermediateTypes), stack);
                    }
                    currentFrameDivergence = intermediateTypes.size() - endTypes.size();
                    intermediate = true;
                }
            }
        }
    }
    public interface ExceptionHandler {
        StackManipulation resolve(MethodDescription instrumentedMethod, TypeDescription instrumentedType);
        enum Default implements ExceptionHandler {
            SUPPRESSING {
                public StackManipulation resolve(MethodDescription instrumentedMethod, TypeDescription instrumentedType) {
                    return Removal.SINGLE;
                }
            }
            , PRINTING {
                public StackManipulation resolve(MethodDescription instrumentedMethod, TypeDescription instrumentedType) {
                    try {
                        return MethodInvocation.invoke(new MethodDescription.ForLoadedMethod(Throwable.class.getMethod("printStackTrace")));
                    } catch (NoSuchMethodException exception) {
                        throw new IllegalStateException("Cannot locate Throwable::printStackTrace");
                    }
                }
            }
            , RETHROWING {
                public StackManipulation resolve(MethodDescription instrumentedMethod, TypeDescription instrumentedType) {
                    return Throw.INSTANCE;
                }
            }
        }
        class Simple implements ExceptionHandler {
            private final StackManipulation stackManipulation;
            public Simple(StackManipulation stackManipulation) {
                this.stackManipulation = stackManipulation;
            }
            public StackManipulation resolve(MethodDescription instrumentedMethod, TypeDescription instrumentedType) {
                return stackManipulation;
            }
        }
    }
    protected interface Dispatcher {
        MethodVisitor IGNORE_METHOD = null;
        AnnotationVisitor IGNORE_ANNOTATION = null;
        boolean isAlive();
        TypeDefinition getAdviceType();
        interface Unresolved extends Dispatcher {
            boolean isBinary();
            Map<String, TypeDefinition> getNamedTypes();
            Resolved.ForMethodEnter asMethodEnter(List<? extends OffsetMapping.Factory<?>> userFactories, @MaybeNull AsmClassReader classReader, Unresolved methodExit, PostProcessor.Factory postProcessorFactory);
            Resolved.ForMethodExit asMethodExit(List<? extends OffsetMapping.Factory<?>> userFactories, @MaybeNull AsmClassReader classReader, Unresolved methodEnter, PostProcessor.Factory postProcessorFactory);
        }
        interface SuppressionHandler {
            Bound bind(StackManipulation exceptionHandler);
            interface Bound {
                void onPrepare(MethodVisitor methodVisitor);
                void onStart(MethodVisitor methodVisitor);
                void onEnd(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDefinition returnType);
                void onEndWithSkip(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDefinition returnType);
            }
            enum NoOp implements SuppressionHandler, Bound {
                INSTANCE;
                public Bound bind(StackManipulation exceptionHandler) {
                    return this;
                }
                public void onPrepare(MethodVisitor methodVisitor) {
                }
                public void onStart(MethodVisitor methodVisitor) {
                }
                public void onEnd(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDefinition returnType) {
                }
                public void onEndWithSkip(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDefinition returnType) {
                }
            }
            class Suppressing implements SuppressionHandler {
                private final TypeDescription suppressedType;
                protected Suppressing(TypeDescription suppressedType) {
                    this.suppressedType = suppressedType;
                }
                protected static SuppressionHandler of(TypeDescription suppressedType) {
                    return suppressedType.represents(NoExceptionHandler.class) ? NoOp.INSTANCE : new Suppressing(suppressedType);
                }
                public SuppressionHandler.Bound bind(StackManipulation exceptionHandler) {
                    return new Bound(suppressedType, exceptionHandler);
                }
                protected static class Bound implements SuppressionHandler.Bound {
                    private final TypeDescription suppressedType;
                    private final StackManipulation exceptionHandler;
                    private final Label startOfMethod;
                    private final Label endOfMethod;
                    protected Bound(TypeDescription suppressedType, StackManipulation exceptionHandler) {
                        this.suppressedType = suppressedType;
                        this.exceptionHandler = exceptionHandler;
                        startOfMethod = new Label();
                        endOfMethod = new Label();
                    }
                    public void onPrepare(MethodVisitor methodVisitor) {
                        methodVisitor.visitTryCatchBlock(startOfMethod, endOfMethod, endOfMethod, suppressedType.getInternalName());
                    }
                    public void onStart(MethodVisitor methodVisitor) {
                        methodVisitor.visitLabel(startOfMethod);
                    }
                    public void onEnd(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDefinition returnType) {
                        methodVisitor.visitLabel(endOfMethod);
                        stackMapFrameHandler.injectExceptionFrame(methodVisitor);
                        methodSizeHandler.requireStackSize(1 + exceptionHandler.apply(methodVisitor, implementationContext).getMaximalSize());
                        if (returnType.represents(boolean.class) || returnType.represents(byte.class) || returnType.represents(short.class) || returnType.represents(char.class) || returnType.represents(int.class)) {
                            methodVisitor.visitInsn(Opcodes.ICONST_0);
                        } else if (returnType.represents(long.class)) {
                            methodVisitor.visitInsn(Opcodes.LCONST_0);
                        } else if (returnType.represents(float.class)) {
                            methodVisitor.visitInsn(Opcodes.FCONST_0);
                        } else if (returnType.represents(double.class)) {
                            methodVisitor.visitInsn(Opcodes.DCONST_0);
                        } else if (!returnType.represents(void.class)) {
                            methodVisitor.visitInsn(Opcodes.ACONST_NULL);
                        }
                    }
                    public void onEndWithSkip(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDefinition returnType) {
                        Label skipExceptionHandler = new Label();
                        methodVisitor.visitJumpInsn(Opcodes.GOTO, skipExceptionHandler);
                        onEnd(methodVisitor, implementationContext, methodSizeHandler, stackMapFrameHandler, returnType);
                        methodVisitor.visitLabel(skipExceptionHandler);
                        stackMapFrameHandler.injectReturnFrame(methodVisitor);
                    }
                }
            }
        }
        interface RelocationHandler {
            Bound bind(MethodDescription instrumentedMethod, Relocation relocation);
            interface Relocation {
                void apply(MethodVisitor methodVisitor);
                class ForLabel implements Relocation {
                    private final Label label;
                    public ForLabel(Label label) {
                        this.label = label;
                    }
                    public void apply(MethodVisitor methodVisitor) {
                        methodVisitor.visitJumpInsn(Opcodes.GOTO, label);
                    }
                }
            }
            interface Bound {
                int NO_REQUIRED_SIZE = 0;
                int apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, int offset);
            }
            enum Disabled implements RelocationHandler, Bound {
                INSTANCE;
                public Bound bind(MethodDescription instrumentedMethod, Relocation relocation) {
                    return this;
                }
                public int apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, int offset) {
                    return NO_REQUIRED_SIZE;
                }
            }
            enum ForValue {
                BOOLEAN(Opcodes.ILOAD, Opcodes.BALOAD, Opcodes.IFNE, Opcodes.IFEQ, 0) {
                    @Override
                    protected void convertValue(MethodVisitor methodVisitor) {
                    }
                }
                ,
                BYTE(Opcodes.ILOAD, Opcodes.BALOAD, Opcodes.IFNE, Opcodes.IFEQ, 0) {
                    @Override
                    protected void convertValue(MethodVisitor methodVisitor) {
                    }
                }
                ,
                SHORT(Opcodes.ILOAD, Opcodes.SALOAD, Opcodes.IFNE, Opcodes.IFEQ, 0) {
                    @Override
                    protected void convertValue(MethodVisitor methodVisitor) {
                    }
                }
                ,
                CHARACTER(Opcodes.ILOAD, Opcodes.CALOAD, Opcodes.IFNE, Opcodes.IFEQ, 0) {
                    @Override
                    protected void convertValue(MethodVisitor methodVisitor) {
                    }
                }
                ,
                INTEGER(Opcodes.ILOAD, Opcodes.IALOAD, Opcodes.IFNE, Opcodes.IFEQ, 0) {
                    @Override
                    protected void convertValue(MethodVisitor methodVisitor) {
                    }
                }
                ,
                LONG(Opcodes.LLOAD, Opcodes.LALOAD, Opcodes.IFNE, Opcodes.IFEQ, 0) {
                    @Override
                    protected void convertValue(MethodVisitor methodVisitor) {
                        methodVisitor.visitInsn(Opcodes.L2I);
                    }
                }
                ,
                FLOAT(Opcodes.FLOAD, Opcodes.FALOAD, Opcodes.IFNE, Opcodes.IFEQ, 2) {
                    @Override
                    protected void convertValue(MethodVisitor methodVisitor) {
                        methodVisitor.visitInsn(Opcodes.FCONST_0);
                        methodVisitor.visitInsn(Opcodes.FCMPL);
                    }
                }
                ,
                DOUBLE(Opcodes.DLOAD, Opcodes.DALOAD, Opcodes.IFNE, Opcodes.IFEQ, 4) {
                    @Override
                    protected void convertValue(MethodVisitor methodVisitor) {
                        methodVisitor.visitInsn(Opcodes.DCONST_0);
                        methodVisitor.visitInsn(Opcodes.DCMPL);
                    }
                }
                ,
                REFERENCE(Opcodes.ALOAD, Opcodes.AALOAD, Opcodes.IFNONNULL, Opcodes.IFNULL, 0) {
                    @Override
                    protected void convertValue(MethodVisitor methodVisitor) {
                    }
                }
                ;
                private final int load;
                private final int arrayLoad;
                private final int defaultJump;
                private final int nonDefaultJump;
                private final int requiredSize;
                ForValue(int load, int arrayLoad, int defaultJump, int nonDefaultJump, int requiredSize) {
                    this.load = load;
                    this.arrayLoad = arrayLoad;
                    this.defaultJump = defaultJump;
                    this.nonDefaultJump = nonDefaultJump;
                    this.requiredSize = requiredSize;
                }
                protected static RelocationHandler of(TypeDefinition typeDefinition, int index, boolean inverted) {
                    ForValue skipDispatcher;
                    if (typeDefinition.represents(boolean.class)) {
                        skipDispatcher = BOOLEAN;
                    } else if (typeDefinition.represents(byte.class)) {
                        skipDispatcher = BYTE;
                    } else if (typeDefinition.represents(short.class)) {
                        skipDispatcher = SHORT;
                    } else if (typeDefinition.represents(char.class)) {
                        skipDispatcher = CHARACTER;
                    } else if (typeDefinition.represents(int.class)) {
                        skipDispatcher = INTEGER;
                    } else if (typeDefinition.represents(long.class)) {
                        skipDispatcher = LONG;
                    } else if (typeDefinition.represents(float.class)) {
                        skipDispatcher = FLOAT;
                    } else if (typeDefinition.represents(double.class)) {
                        skipDispatcher = DOUBLE;
                    } else if (typeDefinition.represents(void.class)) {
                        throw new IllegalStateException("Cannot skip on default value for void return type");
                    } else {
                        skipDispatcher = REFERENCE;
                    }
                    return inverted ? skipDispatcher.new OfNonDefault(index) : skipDispatcher.new OfDefault(index);
                }
                protected abstract void convertValue(MethodVisitor methodVisitor);
                protected class OfDefault implements RelocationHandler {
                    private final int index;
                    public OfDefault(int index) {
                        this.index = index;
                    }
                    public Bound bind(MethodDescription instrumentedMethod, Relocation relocation) {
                        return new ForValue.Bound(instrumentedMethod, relocation, index, false);
                    }
                }
                protected class OfNonDefault implements RelocationHandler {
                    private final int index;
                    protected OfNonDefault(int index) {
                        this.index = index;
                    }
                    public Bound bind(MethodDescription instrumentedMethod, Relocation relocation) {
                        return new ForValue.Bound(instrumentedMethod, relocation, index, true);
                    }
                }
                protected class Bound implements RelocationHandler.Bound {
                    private final MethodDescription instrumentedMethod;
                    private final Relocation relocation;
                    private final int index;
                    private final boolean inverted;
                    protected Bound(MethodDescription instrumentedMethod, Relocation relocation, int index, boolean inverted) {
                        this.instrumentedMethod = instrumentedMethod;
                        this.relocation = relocation;
                        this.index = index;
                        this.inverted = inverted;
                    }
                    public int apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, int offset) {
                        if (instrumentedMethod.isConstructor()) {
                            throw new IllegalStateException("Cannot skip code execution from constructor: " + instrumentedMethod);
                        }
                        Label noSkip = new Label();
                        int size;
                        if (index < 0) {
                            size = requiredSize;
                            methodVisitor.visitVarInsn(load, offset);
                        } else {
                            methodVisitor.visitVarInsn(Opcodes.ALOAD, offset);
                            methodVisitor.visitJumpInsn(Opcodes.IFNULL, noSkip);
                            methodVisitor.visitVarInsn(Opcodes.ALOAD, offset);
                            size = Math.max(requiredSize, IntegerConstant.forValue(index).apply(methodVisitor, implementationContext).getMaximalSize() + 1);
                            methodVisitor.visitInsn(arrayLoad);
                        }
                        convertValue(methodVisitor);
                        methodVisitor.visitJumpInsn(inverted ? nonDefaultJump : defaultJump, noSkip);
                        relocation.apply(methodVisitor);
                        methodVisitor.visitLabel(noSkip);
                        return size;
                    }
                }
            }
            class ForType implements RelocationHandler {
                private final TypeDescription typeDescription;
                private final int index;
                protected ForType(TypeDescription typeDescription, int index) {
                    this.typeDescription = typeDescription;
                    this.index = index;
                }
                protected static RelocationHandler of(TypeDescription typeDescription, int index, TypeDefinition returnedType) {
                    TypeDefinition targetType;
                    if (index < 0) {
                        targetType = returnedType;
                    } else if (returnedType.isArray()) {
                        targetType = returnedType.getComponentType();
                    } else {
                        throw new IllegalStateException(returnedType + " is not an array type but an index for a relocation is defined");
                    }
                    if (typeDescription.represents(void.class)) {
                        return Disabled.INSTANCE;
                    } else if (typeDescription.represents(OnDefaultValue.class)) {
                        return ForValue.of(targetType, index, false);
                    } else if (typeDescription.represents(OnNonDefaultValue.class)) {
                        return ForValue.of(targetType, index, true);
                    } else if (typeDescription.isPrimitive() || targetType.isPrimitive()) {
                        throw new IllegalStateException("Cannot relocate execution by instance type for primitive type");
                    } else {
                        return new ForType(typeDescription, index);
                    }
                }
                public RelocationHandler.Bound bind(MethodDescription instrumentedMethod, Relocation relocation) {
                    return new Bound(instrumentedMethod, relocation);
                }
                protected class Bound implements RelocationHandler.Bound {
                    private final MethodDescription instrumentedMethod;
                    private final Relocation relocation;
                    protected Bound(MethodDescription instrumentedMethod, Relocation relocation) {
                        this.instrumentedMethod = instrumentedMethod;
                        this.relocation = relocation;
                    }
                    public int apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, int offset) {
                        if (instrumentedMethod.isConstructor()) {
                            throw new IllegalStateException("Cannot skip code execution from constructor: " + instrumentedMethod);
                        }
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, offset);
                        Label noSkip = new Label();
                        int size;
                        if (index < 0) {
                            size = NO_REQUIRED_SIZE;
                        } else {
                            methodVisitor.visitJumpInsn(Opcodes.IFNULL, noSkip);
                            methodVisitor.visitVarInsn(Opcodes.ALOAD, offset);
                            size = IntegerConstant.forValue(index).apply(methodVisitor, implementationContext).getMaximalSize() + 1;
                            methodVisitor.visitInsn(Opcodes.AALOAD);
                        }
                        methodVisitor.visitTypeInsn(Opcodes.INSTANCEOF, typeDescription.getInternalName());
                        methodVisitor.visitJumpInsn(Opcodes.IFEQ, noSkip);
                        relocation.apply(methodVisitor);
                        methodVisitor.visitLabel(noSkip);
                        return size;
                    }
                }
            }
        }
        interface Resolved extends Dispatcher {
            Map<String, TypeDefinition> getNamedTypes();
            Bound bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, StackManipulation exceptionHandler, RelocationHandler.Relocation relocation);
            interface ForMethodEnter extends Resolved {
                boolean isPrependLineNumber();
                TypeDefinition getActualAdviceType();
            }
            interface ForMethodExit extends Resolved {
                TypeDescription getThrowable();
                ArgumentHandler.Factory getArgumentHandlerFactory();
            }
            abstract class AbstractBase implements Resolved {
                protected final PostProcessor postProcessor;
                protected final Map<Integer, OffsetMapping> offsetMappings;
                protected final SuppressionHandler suppressionHandler;
                protected final RelocationHandler relocationHandler;
                protected AbstractBase(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, List<? extends OffsetMapping.Factory<?>> factories, TypeDescription throwableType, TypeDescription relocatableType, int relocatableIndex, OffsetMapping.Factory.AdviceType adviceType) {
                    this.postProcessor = postProcessor;
                    Map<TypeDescription, OffsetMapping.Factory<?>> offsetMappings = new HashMap<TypeDescription, OffsetMapping.Factory<?>>();
                    for (OffsetMapping.Factory<?> factory : factories) {
                        offsetMappings.put(TypeDescription.ForLoadedType.of(factory.getAnnotationType()), factory);
                    }
                    this.offsetMappings = new LinkedHashMap<Integer, OffsetMapping>();
                    for (ParameterDescription.InDefinedShape parameterDescription : adviceMethod.getParameters()) {
                        OffsetMapping offsetMapping = null;
                        for (AnnotationDescription annotationDescription : parameterDescription.getDeclaredAnnotations()) {
                            OffsetMapping.Factory<?> factory = offsetMappings.get(annotationDescription.getAnnotationType());
                            if (factory != null) {
                                @SuppressWarnings("unchecked")
                                OffsetMapping current = factory.make(parameterDescription, (AnnotationDescription.Loadable) annotationDescription.prepare(factory.getAnnotationType()), adviceType);
                                if (offsetMapping == null) {
                                    offsetMapping = current;
                                } else {
                                    throw new IllegalStateException(parameterDescription + " is bound to both " + current + " and " + offsetMapping);
                                }
                            }
                        }
                        this.offsetMappings.put(parameterDescription.getOffset(), offsetMapping == null ? new OffsetMapping.ForArgument.Unresolved(parameterDescription) : offsetMapping);
                    }
                    suppressionHandler = SuppressionHandler.Suppressing.of(throwableType);
                    relocationHandler = RelocationHandler.ForType.of(relocatableType, relocatableIndex, adviceMethod.getReturnType());
                }
                public boolean isAlive() {
                    return true;
                }
            }
        }
        interface Bound {
            void prepare();
            void initialize();
            void apply();
        }
        enum Inactive implements Dispatcher.Unresolved, Resolved.ForMethodEnter, Resolved.ForMethodExit, Bound {
            INSTANCE;
            public boolean isAlive() {
                return false;
            }
            public boolean isBinary() {
                return false;
            }
            public TypeDescription getAdviceType() {
                return TypeDescription.ForLoadedType.of(void.class);
            }
            public boolean isPrependLineNumber() {
                return false;
            }
            public TypeDefinition getActualAdviceType() {
                return TypeDescription.ForLoadedType.of(void.class);
            }
            public Map<String, TypeDefinition> getNamedTypes() {
                return Collections.emptyMap();
            }
            public TypeDescription getThrowable() {
                return NoExceptionHandler.DESCRIPTION;
            }
            public ArgumentHandler.Factory getArgumentHandlerFactory() {
                return ArgumentHandler.Factory.SIMPLE;
            }
            public Resolved.ForMethodEnter asMethodEnter(List<? extends OffsetMapping.Factory<?>> userFactories, @MaybeNull AsmClassReader classReader, Unresolved methodExit, PostProcessor.Factory postProcessorFactory) {
                return this;
            }
            public Resolved.ForMethodExit asMethodExit(List<? extends OffsetMapping.Factory<?>> userFactories, @MaybeNull AsmClassReader classReader, Unresolved methodEnter, PostProcessor.Factory postProcessorFactory) {
                return this;
            }
            public void prepare() {
            }
            public void initialize() {
            }
            public void apply() {
            }
            public Bound bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, StackManipulation exceptionHandler, RelocationHandler.Relocation relocation) {
                return this;
            }
        }
        class Inlining implements Unresolved {
            protected final MethodDescription.InDefinedShape adviceMethod;
            private final Map<String, TypeDefinition> namedTypes;
            protected Inlining(MethodDescription.InDefinedShape adviceMethod) {
                this.adviceMethod = adviceMethod;
                namedTypes = new HashMap<String, TypeDefinition>();
                for (ParameterDescription parameterDescription : adviceMethod.getParameters()) {
                    AnnotationDescription.Loadable<Local> annotationDescription = parameterDescription.getDeclaredAnnotations().ofType(Local.class);
                    if (annotationDescription != null) {
                        String name = annotationDescription.getValue(OffsetMapping.ForLocalValue.Factory.LOCAL_VALUE).resolve(String.class);
                        TypeDefinition previous = namedTypes.put(name, parameterDescription.getType());
                        if (previous != null && !previous.equals(parameterDescription.getType())) {
                            throw new IllegalStateException("Local variable for " + name + " is defined with inconsistent types");
                        }
                    }
                }
            }
            public boolean isAlive() {
                return true;
            }
            public boolean isBinary() {
                return true;
            }
            public TypeDescription getAdviceType() {
                return adviceMethod.getReturnType().asErasure();
            }
            public Map<String, TypeDefinition> getNamedTypes() {
                return namedTypes;
            }
            public Dispatcher.Resolved.ForMethodEnter asMethodEnter(List<? extends OffsetMapping.Factory<?>> userFactories, @MaybeNull AsmClassReader classReader, Unresolved methodExit, PostProcessor.Factory postProcessorFactory) {
                if (classReader == null) {
                    throw new IllegalStateException("Class reader not expected null");
                }
                return Resolved.ForMethodEnter.of(adviceMethod, postProcessorFactory.make(adviceMethod.getDeclaredAnnotations(), adviceMethod.getReturnType().asErasure(), false), namedTypes, userFactories, methodExit.getAdviceType(), classReader, methodExit.isAlive());
            }
            public Dispatcher.Resolved.ForMethodExit asMethodExit(List<? extends OffsetMapping.Factory<?>> userFactories, @MaybeNull AsmClassReader classReader, Unresolved methodEnter, PostProcessor.Factory postProcessorFactory) {
                Map<String, TypeDefinition> namedTypes = new HashMap<String, TypeDefinition>(methodEnter.getNamedTypes()), uninitializedNamedTypes = new HashMap<String, TypeDefinition>();
                for (Map.Entry<String, TypeDefinition> entry : this.namedTypes.entrySet()) {
                    TypeDefinition typeDefinition = namedTypes.get(entry.getKey()), uninitializedTypeDefinition = uninitializedNamedTypes.get(entry.getKey());
                    if (typeDefinition == null && uninitializedTypeDefinition == null) {
                        namedTypes.put(entry.getKey(), entry.getValue());
                        uninitializedNamedTypes.put(entry.getKey(), entry.getValue());
                    } else if (!(typeDefinition == null ? uninitializedTypeDefinition : typeDefinition).equals(entry.getValue())) {
                        throw new IllegalStateException("Local variable for " + entry.getKey() + " is defined with inconsistent types");
                    }
                }
                return Resolved.ForMethodExit.of(adviceMethod, postProcessorFactory.make(adviceMethod.getDeclaredAnnotations(), adviceMethod.getReturnType().asErasure(), true), namedTypes, uninitializedNamedTypes, userFactories, classReader, methodEnter.getAdviceType());
            }
            public String toString() {
                return "Delegate to " + adviceMethod;
            }
            protected abstract static class Resolved extends Dispatcher.Resolved.AbstractBase {
                protected final MethodDescription.InDefinedShape adviceMethod;
                protected final AsmClassReader classReader;
                protected Resolved(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, List<? extends OffsetMapping.Factory<?>> factories, TypeDescription throwableType, TypeDescription relocatableType, int relocatableIndex, AsmClassReader classReader) {
                    super(adviceMethod, postProcessor, factories, throwableType, relocatableType, relocatableIndex, OffsetMapping.Factory.AdviceType.INLINING);
                    this.adviceMethod = adviceMethod;
                    this.classReader = classReader;
                }
                protected abstract Map<Integer, TypeDefinition> resolveInitializationTypes(ArgumentHandler argumentHandler);
                protected abstract MethodVisitor apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler);
                protected class AdviceMethodInliner extends ClassVisitor implements Bound {
                    protected final TypeDescription instrumentedType;
                    protected final MethodDescription instrumentedMethod;
                    protected final MethodVisitor methodVisitor;
                    protected final Implementation.Context implementationContext;
                    protected final Assigner assigner;
                    protected final ArgumentHandler.ForInstrumentedMethod argumentHandler;
                    protected final MethodSizeHandler.ForInstrumentedMethod methodSizeHandler;
                    protected final StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler;
                    protected final SuppressionHandler.Bound suppressionHandler;
                    protected final RelocationHandler.Bound relocationHandler;
                    protected final StackManipulation exceptionHandler;
                    protected final AsmClassReader classReader;
                    protected final List<Label> labels;
                    protected AdviceMethodInliner(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler, AsmClassReader classReader) {
                        super(OpenedClassReader.ASM_API);
                        this.instrumentedType = instrumentedType;
                        this.instrumentedMethod = instrumentedMethod;
                        this.methodVisitor = methodVisitor;
                        this.implementationContext = implementationContext;
                        this.assigner = assigner;
                        this.argumentHandler = argumentHandler;
                        this.methodSizeHandler = methodSizeHandler;
                        this.stackMapFrameHandler = stackMapFrameHandler;
                        this.suppressionHandler = suppressionHandler;
                        this.relocationHandler = relocationHandler;
                        this.exceptionHandler = exceptionHandler;
                        this.classReader = classReader;
                        labels = new ArrayList<Label>();
                    }
                    public void prepare() {
                        classReader.accept(new ExceptionTableExtractor(), ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG);
                        suppressionHandler.onPrepare(methodVisitor);
                    }
                    public void initialize() {
                        for (Map.Entry<Integer, TypeDefinition> typeDefinition : resolveInitializationTypes(argumentHandler).entrySet()) {
                            if (typeDefinition.getValue().represents(boolean.class) || typeDefinition.getValue().represents(byte.class) || typeDefinition.getValue().represents(short.class) || typeDefinition.getValue().represents(char.class) || typeDefinition.getValue().represents(int.class)) {
                                methodVisitor.visitInsn(Opcodes.ICONST_0);
                                methodVisitor.visitVarInsn(Opcodes.ISTORE, typeDefinition.getKey());
                            } else if (typeDefinition.getValue().represents(long.class)) {
                                methodVisitor.visitInsn(Opcodes.LCONST_0);
                                methodVisitor.visitVarInsn(Opcodes.LSTORE, typeDefinition.getKey());
                            } else if (typeDefinition.getValue().represents(float.class)) {
                                methodVisitor.visitInsn(Opcodes.FCONST_0);
                                methodVisitor.visitVarInsn(Opcodes.FSTORE, typeDefinition.getKey());
                            } else if (typeDefinition.getValue().represents(double.class)) {
                                methodVisitor.visitInsn(Opcodes.DCONST_0);
                                methodVisitor.visitVarInsn(Opcodes.DSTORE, typeDefinition.getKey());
                            } else {
                                methodVisitor.visitInsn(Opcodes.ACONST_NULL);
                                methodVisitor.visitVarInsn(Opcodes.ASTORE, typeDefinition.getKey());
                            }
                            methodSizeHandler.requireStackSize(typeDefinition.getValue().getStackSize().getSize());
                        }
                    }
                    public void apply() {
                        classReader.accept(this, ClassReader.SKIP_DEBUG | stackMapFrameHandler.getReaderHint());
                    }
                    public MethodVisitor visitMethod(int modifiers, String internalName, String descriptor, @MaybeNull String signature, @MaybeNull String[] exception) {
                        return adviceMethod.getInternalName().equals(internalName) && adviceMethod.getDescriptor().equals(descriptor) ? new ExceptionTableSubstitutor(Inlining.Resolved.this.apply(methodVisitor, implementationContext, assigner, argumentHandler, methodSizeHandler, stackMapFrameHandler, instrumentedType, instrumentedMethod, suppressionHandler, relocationHandler, exceptionHandler)) : IGNORE_METHOD;
                    }
                    protected class ExceptionTableExtractor extends ClassVisitor {
                        protected ExceptionTableExtractor() {
                            super(OpenedClassReader.ASM_API);
                        }
                        public MethodVisitor visitMethod(int modifiers, String internalName, String descriptor, @MaybeNull String signature, @MaybeNull String[] exception) {
                            return adviceMethod.getInternalName().equals(internalName) && adviceMethod.getDescriptor().equals(descriptor) ? new ExceptionTableCollector(methodVisitor) : IGNORE_METHOD;
                        }
                    }
                    protected class ExceptionTableCollector extends MethodVisitor {
                        private final MethodVisitor methodVisitor;
                        protected ExceptionTableCollector(MethodVisitor methodVisitor) {
                            super(OpenedClassReader.ASM_API);
                            this.methodVisitor = methodVisitor;
                        }
                        public void visitTryCatchBlock(Label start, Label end, Label handler, @MaybeNull String type) {
                            methodVisitor.visitTryCatchBlock(start, end, handler, type);
                            labels.addAll(Arrays.asList(start, end, handler));
                        }
                        public AnnotationVisitor visitTryCatchAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
                            return methodVisitor.visitTryCatchAnnotation(typeReference, typePath, descriptor, visible);
                        }
                    }
                    protected class ExceptionTableSubstitutor extends MethodVisitor {
                        private final Map<Label, Label> substitutions;
                        private int index;
                        protected ExceptionTableSubstitutor(MethodVisitor methodVisitor) {
                            super(OpenedClassReader.ASM_API, methodVisitor);
                            substitutions = new IdentityHashMap<Label, Label>();
                        }
                        public void visitTryCatchBlock(Label start, Label end, Label handler, String type) {
                            substitutions.put(start, labels.get(index++));
                            substitutions.put(end, labels.get(index++));
                            Label actualHandler = labels.get(index++);
                            substitutions.put(handler, actualHandler);
                            ((CodeTranslationVisitor) mv).propagateHandler(actualHandler);
                        }
                        public AnnotationVisitor visitTryCatchAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
                            return IGNORE_ANNOTATION;
                        }
                        public void visitLabel(Label label) {
                            super.visitLabel(resolve(label));
                        }
                        public void visitJumpInsn(int opcode, Label label) {
                            super.visitJumpInsn(opcode, resolve(label));
                        }
                        public void visitTableSwitchInsn(int minimum, int maximum, Label defaultOption, Label... label) {
                            super.visitTableSwitchInsn(minimum, maximum, defaultOption, resolve(label));
                        }
                        public void visitLookupSwitchInsn(Label defaultOption, int[] keys, Label[] label) {
                            super.visitLookupSwitchInsn(resolve(defaultOption), keys, resolve(label));
                        }
                        private Label[] resolve(Label[] label) {
                            Label[] resolved = new Label[label.length];
                            int index = 0;
                            for (Label aLabel : label) {
                                resolved[index++] = resolve(aLabel);
                            }
                            return resolved;
                        }
                        private Label resolve(Label label) {
                            Label substitution = substitutions.get(label);
                            return substitution == null ? label : substitution;
                        }
                    }
                }
                protected abstract static class ForMethodEnter extends Inlining.Resolved implements Dispatcher.Resolved.ForMethodEnter {
                    private final Map<String, TypeDefinition> namedTypes;
                    private final boolean prependLineNumber;
                    @SuppressWarnings("unchecked")
                    @SuppressFBWarnings(value = "NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE", justification = "Assuming annotation for exit advice.")
                    protected ForMethodEnter(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map<String, TypeDefinition> namedTypes, List<? extends OffsetMapping.Factory<?>> userFactories, TypeDefinition exitType, AsmClassReader classReader) {
                        super(adviceMethod, postProcessor, CompoundList.of(Arrays.asList(OffsetMapping.ForArgument.Unresolved.Factory.INSTANCE, OffsetMapping.ForAllArguments.Factory.INSTANCE, OffsetMapping.ForThisReference.Factory.INSTANCE, OffsetMapping.ForField.Unresolved.Factory.INSTANCE, OffsetMapping.ForFieldHandle.Unresolved.ReaderFactory.INSTANCE, OffsetMapping.ForFieldHandle.Unresolved.WriterFactory.INSTANCE, OffsetMapping.ForOrigin.Factory.INSTANCE, OffsetMapping.ForSelfCallHandle.Factory.INSTANCE, OffsetMapping.ForHandle.Factory.INSTANCE, OffsetMapping.ForDynamicConstant.Factory.INSTANCE, OffsetMapping.ForUnusedValue.Factory.INSTANCE, OffsetMapping.ForStubValue.INSTANCE, OffsetMapping.ForThrowable.Factory.INSTANCE, OffsetMapping.ForExitValue.Factory.of(exitType), new OffsetMapping.ForLocalValue.Factory(namedTypes), new OffsetMapping.Factory.Illegal<Thrown>(Thrown.class), new OffsetMapping.Factory.Illegal<Enter>(Enter.class), new OffsetMapping.Factory.Illegal<Return>(Return.class)), userFactories), adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(SUPPRESS_ENTER).resolve(TypeDescription.class), adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(SKIP_ON).resolve(TypeDescription.class), adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(SKIP_ON_INDEX).resolve(Integer.class), classReader);
                        this.namedTypes = namedTypes;
                        prependLineNumber = adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(PREPEND_LINE_NUMBER).resolve(Boolean.class);
                    }
                    protected static Resolved.ForMethodEnter of(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map<String, TypeDefinition> namedTypes, List<? extends OffsetMapping.Factory<?>> userFactories, TypeDefinition exitType, AsmClassReader classReader, boolean methodExit) {
                        return methodExit ? new WithRetainedEnterType(adviceMethod, postProcessor, namedTypes, userFactories, exitType, classReader) : new WithDiscardedEnterType(adviceMethod, postProcessor, namedTypes, userFactories, exitType, classReader);
                    }
                    protected Map<Integer, TypeDefinition> resolveInitializationTypes(ArgumentHandler argumentHandler) {
                        SortedMap<Integer, TypeDefinition> resolved = new TreeMap<Integer, TypeDefinition>();
                        for (Map.Entry<String, TypeDefinition> entry : namedTypes.entrySet()) {
                            resolved.put(argumentHandler.named(entry.getKey()), entry.getValue());
                        }
                        return resolved;
                    }
                    public Bound bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, StackManipulation exceptionHandler, RelocationHandler.Relocation relocation) {
                        return new AdviceMethodInliner(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, assigner, argumentHandler, methodSizeHandler, stackMapFrameHandler, suppressionHandler.bind(exceptionHandler), relocationHandler.bind(instrumentedMethod, relocation), exceptionHandler, classReader);
                    }
                    public boolean isPrependLineNumber() {
                        return prependLineNumber;
                    }
                    public TypeDefinition getActualAdviceType() {
                        return adviceMethod.getReturnType();
                    }
                    public Map<String, TypeDefinition> getNamedTypes() {
                        return namedTypes;
                    }
                    protected MethodVisitor apply(MethodVisitor methodVisitor, Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler) {
                        MethodDescription.TypeToken typeToken = adviceMethod.asTypeToken();
                        return doApply(methodVisitor, implementationContext, assigner, argumentHandler.bindEnter(typeToken), methodSizeHandler.bindEnter(typeToken), stackMapFrameHandler.bindEnter(typeToken), instrumentedType, instrumentedMethod, suppressionHandler, relocationHandler, exceptionHandler);
                    }
                    protected MethodVisitor doApply(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler) {
                        Map<Integer, OffsetMapping.Target> offsetMappings = new HashMap<Integer, OffsetMapping.Target>();
                        for (Map.Entry<Integer, OffsetMapping> entry : this.offsetMappings.entrySet()) {
                            offsetMappings.put(entry.getKey(), entry.getValue().resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, OffsetMapping.Sort.ENTER));
                        }
                        return new CodeTranslationVisitor(methodVisitor, implementationContext, argumentHandler, methodSizeHandler, stackMapFrameHandler, instrumentedType, instrumentedMethod, assigner, adviceMethod, offsetMappings, suppressionHandler, relocationHandler, exceptionHandler, postProcessor, false);
                    }
                    protected static class WithRetainedEnterType extends Inlining.Resolved.ForMethodEnter {
                        protected WithRetainedEnterType(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map<String, TypeDefinition> namedTypes, List<? extends OffsetMapping.Factory<?>> userFactories, TypeDefinition exitType, AsmClassReader classReader) {
                            super(adviceMethod, postProcessor, namedTypes, userFactories, exitType, classReader);
                        }
                        public TypeDefinition getAdviceType() {
                            return adviceMethod.getReturnType();
                        }
                    }
                    protected static class WithDiscardedEnterType extends Inlining.Resolved.ForMethodEnter {
                        protected WithDiscardedEnterType(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map<String, TypeDefinition> namedTypes, List<? extends OffsetMapping.Factory<?>> userFactories, TypeDefinition exitType, AsmClassReader classReader) {
                            super(adviceMethod, postProcessor, namedTypes, userFactories, exitType, classReader);
                        }
                        public TypeDefinition getAdviceType() {
                            return TypeDescription.ForLoadedType.of(void.class);
                        }
                        protected MethodVisitor doApply(MethodVisitor methodVisitor, Context implementationContext, Assigner assigner, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler) {
                            methodSizeHandler.requireLocalVariableLengthPadding(adviceMethod.getReturnType().getStackSize().getSize());
                            return super.doApply(methodVisitor, implementationContext, assigner, argumentHandler, methodSizeHandler, stackMapFrameHandler, instrumentedType, instrumentedMethod, suppressionHandler, relocationHandler, exceptionHandler);
                        }
                    }
                }
                protected abstract static class ForMethodExit extends Inlining.Resolved implements Dispatcher.Resolved.ForMethodExit {
                    private final Map<String, TypeDefinition> uninitializedNamedTypes;
                    private final boolean backupArguments;
                    @SuppressWarnings("unchecked")
                    @SuppressFBWarnings(value = "NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE", justification = "Assuming annotation for exit advice.")
                    protected ForMethodExit(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map<String, TypeDefinition> namedTypes, Map<String, TypeDefinition> uninitializedNamedTypes, List<? extends OffsetMapping.Factory<?>> userFactories, AsmClassReader classReader, TypeDefinition enterType) {
                        super(adviceMethod, postProcessor, CompoundList.of(Arrays.asList(OffsetMapping.ForArgument.Unresolved.Factory.INSTANCE, OffsetMapping.ForAllArguments.Factory.INSTANCE, OffsetMapping.ForThisReference.Factory.INSTANCE, OffsetMapping.ForField.Unresolved.Factory.INSTANCE, OffsetMapping.ForFieldHandle.Unresolved.ReaderFactory.INSTANCE, OffsetMapping.ForFieldHandle.Unresolved.WriterFactory.INSTANCE, OffsetMapping.ForOrigin.Factory.INSTANCE, OffsetMapping.ForSelfCallHandle.Factory.INSTANCE, OffsetMapping.ForHandle.Factory.INSTANCE, OffsetMapping.ForDynamicConstant.Factory.INSTANCE, OffsetMapping.ForUnusedValue.Factory.INSTANCE, OffsetMapping.ForStubValue.INSTANCE, OffsetMapping.ForEnterValue.Factory.of(enterType), OffsetMapping.ForExitValue.Factory.of(adviceMethod.getReturnType()), new OffsetMapping.ForLocalValue.Factory(namedTypes), OffsetMapping.ForReturnValue.Factory.INSTANCE, OffsetMapping.ForThrowable.Factory.of(adviceMethod)), userFactories), adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(SUPPRESS_EXIT).resolve(TypeDescription.class), adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(REPEAT_ON).resolve(TypeDescription.class), adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(REPEAT_ON_INDEX).resolve(Integer.class), classReader);
                        this.uninitializedNamedTypes = uninitializedNamedTypes;
                        backupArguments = adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(BACKUP_ARGUMENTS).resolve(Boolean.class);
                    }
                    protected static Resolved.ForMethodExit of(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map<String, TypeDefinition> namedTypes, Map<String, TypeDefinition> uninitializedNamedTypes, List<? extends OffsetMapping.Factory<?>> userFactories, AsmClassReader classReader, TypeDefinition enterType) {
                        TypeDescription throwable = adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(ON_THROWABLE).resolve(TypeDescription.class);
                        return throwable.represents(NoExceptionHandler.class) ? new WithoutExceptionHandler(adviceMethod, postProcessor, namedTypes, uninitializedNamedTypes, userFactories, classReader, enterType) : new WithExceptionHandler(adviceMethod, postProcessor, namedTypes, uninitializedNamedTypes, userFactories, classReader, enterType, throwable);
                    }
                    public Map<String, TypeDefinition> getNamedTypes() {
                        return uninitializedNamedTypes;
                    }
                    protected Map<Integer, TypeDefinition> resolveInitializationTypes(ArgumentHandler argumentHandler) {
                        SortedMap<Integer, TypeDefinition> resolved = new TreeMap<Integer, TypeDefinition>();
                        for (Map.Entry<String, TypeDefinition> entry : uninitializedNamedTypes.entrySet()) {
                            resolved.put(argumentHandler.named(entry.getKey()), entry.getValue());
                        }
                        if (!adviceMethod.getReturnType().represents(void.class)) {
                            resolved.put(argumentHandler.exit(), adviceMethod.getReturnType());
                        }
                        return resolved;
                    }
                    protected MethodVisitor apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler) {
                        MethodDescription.TypeToken typeToken = adviceMethod.asTypeToken();
                        return doApply(methodVisitor, implementationContext, assigner, argumentHandler.bindExit(typeToken, getThrowable().represents(NoExceptionHandler.class)), methodSizeHandler.bindExit(typeToken), stackMapFrameHandler.bindExit(typeToken), instrumentedType, instrumentedMethod, suppressionHandler, relocationHandler, exceptionHandler);
                    }
                    private MethodVisitor doApply(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler) {
                        Map<Integer, OffsetMapping.Target> offsetMappings = new HashMap<Integer, OffsetMapping.Target>();
                        for (Map.Entry<Integer, OffsetMapping> entry : this.offsetMappings.entrySet()) {
                            offsetMappings.put(entry.getKey(), entry.getValue().resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, OffsetMapping.Sort.EXIT));
                        }
                        return new CodeTranslationVisitor(methodVisitor, implementationContext, argumentHandler, methodSizeHandler, stackMapFrameHandler, instrumentedType, instrumentedMethod, assigner, adviceMethod, offsetMappings, suppressionHandler, relocationHandler, exceptionHandler, postProcessor, true);
                    }
                    public ArgumentHandler.Factory getArgumentHandlerFactory() {
                        return backupArguments ? ArgumentHandler.Factory.COPYING : ArgumentHandler.Factory.SIMPLE;
                    }
                    public TypeDefinition getAdviceType() {
                        return adviceMethod.getReturnType();
                    }
                    public Bound bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, StackManipulation exceptionHandler, RelocationHandler.Relocation relocation) {
                        return new AdviceMethodInliner(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, assigner, argumentHandler, methodSizeHandler, stackMapFrameHandler, suppressionHandler.bind(exceptionHandler), relocationHandler.bind(instrumentedMethod, relocation), exceptionHandler, classReader);
                    }
                    protected static class WithExceptionHandler extends Inlining.Resolved.ForMethodExit {
                        private final TypeDescription throwable;
                        protected WithExceptionHandler(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map<String, TypeDefinition> namedTypes, Map<String, TypeDefinition> uninitializedNamedTypes, List<? extends OffsetMapping.Factory<?>> userFactories, AsmClassReader classReader, TypeDefinition enterType, TypeDescription throwable) {
                            super(adviceMethod, postProcessor, namedTypes, uninitializedNamedTypes, userFactories, classReader, enterType);
                            this.throwable = throwable;
                        }
                        public TypeDescription getThrowable() {
                            return throwable;
                        }
                    }
                    protected static class WithoutExceptionHandler extends Inlining.Resolved.ForMethodExit {
                        protected WithoutExceptionHandler(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map<String, TypeDefinition> namedTypes, Map<String, TypeDefinition> uninitializedNamedTypes, List<? extends OffsetMapping.Factory<?>> userFactories, AsmClassReader classReader, TypeDefinition enterType) {
                            super(adviceMethod, postProcessor, namedTypes, uninitializedNamedTypes, userFactories, classReader, enterType);
                        }
                        public TypeDescription getThrowable() {
                            return NoExceptionHandler.DESCRIPTION;
                        }
                    }
                }
            }
            protected static class CodeTranslationVisitor extends MethodVisitor {
                protected final MethodVisitor methodVisitor;
                protected final Context implementationContext;
                protected final ArgumentHandler.ForAdvice argumentHandler;
                protected final MethodSizeHandler.ForAdvice methodSizeHandler;
                protected final StackMapFrameHandler.ForAdvice stackMapFrameHandler;
                private final TypeDescription instrumentedType;
                private final MethodDescription instrumentedMethod;
                private final Assigner assigner;
                protected final MethodDescription.InDefinedShape adviceMethod;
                private final Map<Integer, OffsetMapping.Target> offsetMappings;
                private final SuppressionHandler.Bound suppressionHandler;
                private final RelocationHandler.Bound relocationHandler;
                private final StackManipulation exceptionHandler;
                private final PostProcessor postProcessor;
                private final boolean exit;
                protected final Label endOfMethod;
                protected CodeTranslationVisitor(MethodVisitor methodVisitor, Context implementationContext, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, MethodDescription.InDefinedShape adviceMethod, Map<Integer, OffsetMapping.Target> offsetMappings, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler, PostProcessor postProcessor, boolean exit) {
                    super(OpenedClassReader.ASM_API, StackAwareMethodVisitor.of(methodVisitor, instrumentedMethod));
                    this.methodVisitor = methodVisitor;
                    this.implementationContext = implementationContext;
                    this.argumentHandler = argumentHandler;
                    this.methodSizeHandler = methodSizeHandler;
                    this.stackMapFrameHandler = stackMapFrameHandler;
                    this.instrumentedType = instrumentedType;
                    this.instrumentedMethod = instrumentedMethod;
                    this.assigner = assigner;
                    this.adviceMethod = adviceMethod;
                    this.offsetMappings = offsetMappings;
                    this.suppressionHandler = suppressionHandler;
                    this.relocationHandler = relocationHandler;
                    this.exceptionHandler = exceptionHandler;
                    this.postProcessor = postProcessor;
                    this.exit = exit;
                    endOfMethod = new Label();
                }
                protected void propagateHandler(Label label) {
                    ((StackAwareMethodVisitor) mv).register(label, Collections.singletonList(StackSize.SINGLE));
                }
                public void visitParameter(@MaybeNull String name, int modifiers) {
                }
                public void visitAnnotableParameterCount(int count, boolean visible) {
                }
                public AnnotationVisitor visitAnnotationDefault() {
                    return IGNORE_ANNOTATION;
                }
                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
                    return IGNORE_ANNOTATION;
                }
                public AnnotationVisitor visitTypeAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
                    return IGNORE_ANNOTATION;
                }
                public AnnotationVisitor visitParameterAnnotation(int index, String descriptor, boolean visible) {
                    return IGNORE_ANNOTATION;
                }
                public void visitAttribute(Attribute attribute) {
                }
                public void visitCode() {
                    suppressionHandler.onStart(methodVisitor);
                }
                public void visitFrame(int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
                    stackMapFrameHandler.translateFrame(methodVisitor, type, localVariableLength, localVariable, stackSize, stack);
                }
                public void visitVarInsn(int opcode, int offset) {
                    OffsetMapping.Target target = offsetMappings.get(offset);
                    if (target != null) {
                        StackManipulation stackManipulation;
                        StackSize expectedGrowth;
                        switch(opcode) {
                            case Opcodes.ILOAD:
                            case Opcodes.FLOAD:
                            case Opcodes.ALOAD:
                                stackManipulation = target.resolveRead();
                                expectedGrowth = StackSize.SINGLE;
                                break;
                            case Opcodes.DLOAD:
                            case Opcodes.LLOAD:
                                stackManipulation = target.resolveRead();
                                expectedGrowth = StackSize.DOUBLE;
                                break;
                            case Opcodes.ISTORE:
                            case Opcodes.FSTORE:
                            case Opcodes.ASTORE:
                            case Opcodes.LSTORE:
                            case Opcodes.DSTORE:
                                stackManipulation = target.resolveWrite();
                                expectedGrowth = StackSize.ZERO;
                                break;
                            default:
                                throw new IllegalStateException("Unexpected opcode: " + opcode);
                        }
                        methodSizeHandler.requireStackSizePadding(stackManipulation.apply(mv, implementationContext).getMaximalSize() - expectedGrowth.getSize());
                    } else {
                        mv.visitVarInsn(opcode, argumentHandler.mapped(offset));
                    }
                }
                public void visitIincInsn(int offset, int value) {
                    OffsetMapping.Target target = offsetMappings.get(offset);
                    if (target != null) {
                        methodSizeHandler.requireStackSizePadding(target.resolveIncrement(value).apply(mv, implementationContext).getMaximalSize());
                    } else {
                        mv.visitIincInsn(argumentHandler.mapped(offset), value);
                    }
                }
                public void visitInsn(int opcode) {
                    switch(opcode) {
                        case Opcodes.RETURN:
                            ((StackAwareMethodVisitor) mv).drainStack();
                            break;
                        case Opcodes.IRETURN:
                            methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor) mv).drainStack(Opcodes.ISTORE, Opcodes.ILOAD, StackSize.SINGLE));
                            break;
                        case Opcodes.ARETURN:
                            methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor) mv).drainStack(Opcodes.ASTORE, Opcodes.ALOAD, StackSize.SINGLE));
                            break;
                        case Opcodes.FRETURN:
                            methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor) mv).drainStack(Opcodes.FSTORE, Opcodes.FLOAD, StackSize.SINGLE));
                            break;
                        case Opcodes.LRETURN:
                            methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor) mv).drainStack(Opcodes.LSTORE, Opcodes.LLOAD, StackSize.DOUBLE));
                            break;
                        case Opcodes.DRETURN:
                            methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor) mv).drainStack(Opcodes.DSTORE, Opcodes.DLOAD, StackSize.DOUBLE));
                            break;
                        default:
                            mv.visitInsn(opcode);
                            return;
                    }
                    mv.visitJumpInsn(Opcodes.GOTO, endOfMethod);
                }
                public void visitEnd() {
                    suppressionHandler.onEnd(methodVisitor, implementationContext, methodSizeHandler, stackMapFrameHandler, adviceMethod.getReturnType());
                    methodVisitor.visitLabel(endOfMethod);
                    if (adviceMethod.getReturnType().represents(boolean.class) || adviceMethod.getReturnType().represents(byte.class) || adviceMethod.getReturnType().represents(short.class) || adviceMethod.getReturnType().represents(char.class) || adviceMethod.getReturnType().represents(int.class)) {
                        stackMapFrameHandler.injectReturnFrame(methodVisitor);
                        methodVisitor.visitVarInsn(Opcodes.ISTORE, exit ? argumentHandler.exit() : argumentHandler.enter());
                    } else if (adviceMethod.getReturnType().represents(long.class)) {
                        stackMapFrameHandler.injectReturnFrame(methodVisitor);
                        methodVisitor.visitVarInsn(Opcodes.LSTORE, exit ? argumentHandler.exit() : argumentHandler.enter());
                    } else if (adviceMethod.getReturnType().represents(float.class)) {
                        stackMapFrameHandler.injectReturnFrame(methodVisitor);
                        methodVisitor.visitVarInsn(Opcodes.FSTORE, exit ? argumentHandler.exit() : argumentHandler.enter());
                    } else if (adviceMethod.getReturnType().represents(double.class)) {
                        stackMapFrameHandler.injectReturnFrame(methodVisitor);
                        methodVisitor.visitVarInsn(Opcodes.DSTORE, exit ? argumentHandler.exit() : argumentHandler.enter());
                    } else if (!adviceMethod.getReturnType().represents(void.class)) {
                        stackMapFrameHandler.injectReturnFrame(methodVisitor);
                        methodVisitor.visitVarInsn(Opcodes.ASTORE, exit ? argumentHandler.exit() : argumentHandler.enter());
                    }
                    methodSizeHandler.requireStackSize(postProcessor.resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, stackMapFrameHandler, exceptionHandler).apply(methodVisitor, implementationContext).getMaximalSize());
                    methodSizeHandler.requireStackSize(relocationHandler.apply(methodVisitor, implementationContext, exit ? argumentHandler.exit() : argumentHandler.enter()));
                    stackMapFrameHandler.injectCompletionFrame(methodVisitor);
                }
                public void visitMaxs(int stackSize, int localVariableLength) {
                    methodSizeHandler.recordMaxima(stackSize, localVariableLength);
                }
            }
        }
        class Delegating implements Unresolved {
            protected final MethodDescription.InDefinedShape adviceMethod;
            protected final Delegator.Factory delegatorFactory;
            protected Delegating(MethodDescription.InDefinedShape adviceMethod, Delegator.Factory delegatorFactory) {
                this.adviceMethod = adviceMethod;
                this.delegatorFactory = delegatorFactory;
            }
            public boolean isAlive() {
                return true;
            }
            public boolean isBinary() {
                return false;
            }
            public TypeDefinition getAdviceType() {
                return adviceMethod.getReturnType();
            }
            public Map<String, TypeDefinition> getNamedTypes() {
                return Collections.emptyMap();
            }
            public Dispatcher.Resolved.ForMethodEnter asMethodEnter(List<? extends OffsetMapping.Factory<?>> userFactories, @MaybeNull AsmClassReader classReader, Unresolved methodExit, PostProcessor.Factory postProcessorFactory) {
                Delegator delegator = delegatorFactory.make(adviceMethod, false);
                return Resolved.ForMethodEnter.of(adviceMethod, postProcessorFactory.make(adviceMethod.getDeclaredAnnotations(), delegator.getTypeToken().getReturnType(), false), delegator, userFactories, methodExit.getAdviceType(), methodExit.isAlive());
            }
            public Dispatcher.Resolved.ForMethodExit asMethodExit(List<? extends OffsetMapping.Factory<?>> userFactories, @MaybeNull AsmClassReader classReader, Unresolved methodEnter, PostProcessor.Factory postProcessorFactory) {
                Map<String, TypeDefinition> namedTypes = methodEnter.getNamedTypes();
                for (ParameterDescription parameterDescription : adviceMethod.getParameters()) {
                    AnnotationDescription.Loadable<Local> annotationDescription = parameterDescription.getDeclaredAnnotations().ofType(Local.class);
                    if (annotationDescription != null) {
                        String name = annotationDescription.getValue(OffsetMapping.ForLocalValue.Factory.LOCAL_VALUE).resolve(String.class);
                        TypeDefinition typeDefinition = namedTypes.get(name);
                        if (typeDefinition == null) {
                            throw new IllegalStateException(adviceMethod + " attempts use of undeclared local variable " + name);
                        } else if (!typeDefinition.equals(parameterDescription.getType())) {
                            throw new IllegalStateException(adviceMethod + " does not read variable " + name + " as " + typeDefinition);
                        }
                    }
                }
                Delegator delegator = delegatorFactory.make(adviceMethod, true);
                return Resolved.ForMethodExit.of(adviceMethod, postProcessorFactory.make(adviceMethod.getDeclaredAnnotations(), delegator.getTypeToken().getReturnType(), true), delegator, namedTypes, userFactories, methodEnter.getAdviceType());
            }
            public String toString() {
                return "Delegate to " + adviceMethod;
            }
            protected abstract static class Resolved extends Dispatcher.Resolved.AbstractBase {
                protected final Delegator delegator;
                protected Resolved(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, List<? extends OffsetMapping.Factory<?>> factories, TypeDescription throwableType, TypeDescription relocatableType, int relocatableIndex, Delegator delegator) {
                    super(adviceMethod, postProcessor, factories, throwableType, relocatableType, relocatableIndex, OffsetMapping.Factory.AdviceType.DELEGATION);
                    this.delegator = delegator;
                }
                public Map<String, TypeDefinition> getNamedTypes() {
                    return Collections.emptyMap();
                }
                public Bound bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, StackManipulation exceptionHandler, RelocationHandler.Relocation relocation) {
                    delegator.assertVisibility(instrumentedType);
                    return resolve(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, assigner, argumentHandler, methodSizeHandler, stackMapFrameHandler, exceptionHandler, relocation);
                }
                protected abstract Bound resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, StackManipulation exceptionHandler, RelocationHandler.Relocation relocation);
                protected abstract static class AdviceMethodWriter implements Bound {
                    protected final MethodDescription.TypeToken typeToken;
                    private final TypeDescription instrumentedType;
                    private final MethodDescription instrumentedMethod;
                    private final Assigner assigner;
                    private final List<OffsetMapping.Target> offsetMappings;
                    protected final MethodVisitor methodVisitor;
                    protected final Implementation.Context implementationContext;
                    protected final ArgumentHandler.ForAdvice argumentHandler;
                    protected final MethodSizeHandler.ForAdvice methodSizeHandler;
                    protected final StackMapFrameHandler.ForAdvice stackMapFrameHandler;
                    private final SuppressionHandler.Bound suppressionHandler;
                    private final RelocationHandler.Bound relocationHandler;
                    private final StackManipulation exceptionHandler;
                    private final PostProcessor postProcessor;
                    private final Delegator delegator;
                    protected AdviceMethodWriter(MethodDescription.TypeToken typeToken, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, PostProcessor postProcessor, List<OffsetMapping.Target> offsetMappings, MethodVisitor methodVisitor, Context implementationContext, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler, Delegator delegator) {
                        this.typeToken = typeToken;
                        this.instrumentedType = instrumentedType;
                        this.instrumentedMethod = instrumentedMethod;
                        this.assigner = assigner;
                        this.postProcessor = postProcessor;
                        this.offsetMappings = offsetMappings;
                        this.methodVisitor = methodVisitor;
                        this.implementationContext = implementationContext;
                        this.argumentHandler = argumentHandler;
                        this.methodSizeHandler = methodSizeHandler;
                        this.stackMapFrameHandler = stackMapFrameHandler;
                        this.suppressionHandler = suppressionHandler;
                        this.relocationHandler = relocationHandler;
                        this.exceptionHandler = exceptionHandler;
                        this.delegator = delegator;
                    }
                    public void prepare() {
                        suppressionHandler.onPrepare(methodVisitor);
                    }
                    public void apply() {
                        suppressionHandler.onStart(methodVisitor);
                        int index = 0, currentStackSize = 0, maximumStackSize = 0;
                        for (OffsetMapping.Target offsetMapping : offsetMappings) {
                            currentStackSize += typeToken.getParameterTypes().get(index++).getStackSize().getSize();
                            maximumStackSize = Math.max(maximumStackSize, currentStackSize + offsetMapping.resolveRead().apply(methodVisitor, implementationContext).getMaximalSize());
                        }
                        maximumStackSize = Math.max(maximumStackSize, delegator.apply(instrumentedType, instrumentedMethod).apply(methodVisitor, implementationContext).getMaximalSize());
                        suppressionHandler.onEndWithSkip(methodVisitor, implementationContext, methodSizeHandler, stackMapFrameHandler, typeToken.getReturnType());
                        if (typeToken.getReturnType().represents(boolean.class) || typeToken.getReturnType().represents(byte.class) || typeToken.getReturnType().represents(short.class) || typeToken.getReturnType().represents(char.class) || typeToken.getReturnType().represents(int.class)) {
                            methodVisitor.visitVarInsn(Opcodes.ISTORE, isExitAdvice() ? argumentHandler.exit() : argumentHandler.enter());
                        } else if (typeToken.getReturnType().represents(long.class)) {
                            methodVisitor.visitVarInsn(Opcodes.LSTORE, isExitAdvice() ? argumentHandler.exit() : argumentHandler.enter());
                        } else if (typeToken.getReturnType().represents(float.class)) {
                            methodVisitor.visitVarInsn(Opcodes.FSTORE, isExitAdvice() ? argumentHandler.exit() : argumentHandler.enter());
                        } else if (typeToken.getReturnType().represents(double.class)) {
                            methodVisitor.visitVarInsn(Opcodes.DSTORE, isExitAdvice() ? argumentHandler.exit() : argumentHandler.enter());
                        } else if (typeToken.getReturnType().represents(void.class)) {
                            methodVisitor.visitInsn(Opcodes.NOP);
                        } else {
                            methodVisitor.visitVarInsn(Opcodes.ASTORE, isExitAdvice() ? argumentHandler.exit() : argumentHandler.enter());
                        }
                        methodSizeHandler.requireStackSize(postProcessor.resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, stackMapFrameHandler, exceptionHandler).apply(methodVisitor, implementationContext).getMaximalSize());
                        methodSizeHandler.requireStackSize(relocationHandler.apply(methodVisitor, implementationContext, isExitAdvice() ? argumentHandler.exit() : argumentHandler.enter()));
                        stackMapFrameHandler.injectCompletionFrame(methodVisitor);
                        methodSizeHandler.requireStackSize(Math.max(maximumStackSize, typeToken.getReturnType().getStackSize().getSize()));
                        methodSizeHandler.requireLocalVariableLength(instrumentedMethod.getStackSize() + typeToken.getReturnType().getStackSize().getSize());
                    }
                    protected abstract boolean isExitAdvice();
                    protected static class ForMethodEnter extends AdviceMethodWriter {
                        protected ForMethodEnter(MethodDescription.TypeToken typeToken, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, PostProcessor postProcessor, List<OffsetMapping.Target> offsetMappings, MethodVisitor methodVisitor, Implementation.Context implementationContext, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler, Delegator delegator) {
                            super(typeToken, instrumentedType, instrumentedMethod, assigner, postProcessor, offsetMappings, methodVisitor, implementationContext, argumentHandler, methodSizeHandler, stackMapFrameHandler, suppressionHandler, relocationHandler, exceptionHandler, delegator);
                        }
                        public void initialize() {
                        }
                        protected boolean isExitAdvice() {
                            return false;
                        }
                    }
                    protected static class ForMethodExit extends AdviceMethodWriter {
                        protected ForMethodExit(MethodDescription.TypeToken typeToken, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, PostProcessor postProcessor, List<OffsetMapping.Target> offsetMappings, MethodVisitor methodVisitor, Implementation.Context implementationContext, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler, Delegator delegator) {
                            super(typeToken, instrumentedType, instrumentedMethod, assigner, postProcessor, offsetMappings, methodVisitor, implementationContext, argumentHandler, methodSizeHandler, stackMapFrameHandler, suppressionHandler, relocationHandler, exceptionHandler, delegator);
                        }
                        public void initialize() {
                            if (typeToken.getReturnType().represents(boolean.class) || typeToken.getReturnType().represents(byte.class) || typeToken.getReturnType().represents(short.class) || typeToken.getReturnType().represents(char.class) || typeToken.getReturnType().represents(int.class)) {
                                methodVisitor.visitInsn(Opcodes.ICONST_0);
                                methodVisitor.visitVarInsn(Opcodes.ISTORE, argumentHandler.exit());
                            } else if (typeToken.getReturnType().represents(long.class)) {
                                methodVisitor.visitInsn(Opcodes.LCONST_0);
                                methodVisitor.visitVarInsn(Opcodes.LSTORE, argumentHandler.exit());
                            } else if (typeToken.getReturnType().represents(float.class)) {
                                methodVisitor.visitInsn(Opcodes.FCONST_0);
                                methodVisitor.visitVarInsn(Opcodes.FSTORE, argumentHandler.exit());
                            } else if (typeToken.getReturnType().represents(double.class)) {
                                methodVisitor.visitInsn(Opcodes.DCONST_0);
                                methodVisitor.visitVarInsn(Opcodes.DSTORE, argumentHandler.exit());
                            } else if (!typeToken.getReturnType().represents(void.class)) {
                                methodVisitor.visitInsn(Opcodes.ACONST_NULL);
                                methodVisitor.visitVarInsn(Opcodes.ASTORE, argumentHandler.exit());
                            }
                            methodSizeHandler.requireStackSize(typeToken.getReturnType().getStackSize().getSize());
                        }
                        protected boolean isExitAdvice() {
                            return true;
                        }
                    }
                }
                protected abstract static class ForMethodEnter extends Delegating.Resolved implements Dispatcher.Resolved.ForMethodEnter {
                    private final boolean prependLineNumber;
                    @SuppressWarnings("unchecked")
                    @SuppressFBWarnings(value = "NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE", justification = "Assuming annotation for exit advice.")
                    protected ForMethodEnter(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, List<? extends OffsetMapping.Factory<?>> userFactories, TypeDefinition exitType, Delegator delegator) {
                        super(adviceMethod, postProcessor, CompoundList.of(Arrays.asList(OffsetMapping.ForArgument.Unresolved.Factory.INSTANCE, OffsetMapping.ForAllArguments.Factory.INSTANCE, OffsetMapping.ForThisReference.Factory.INSTANCE, OffsetMapping.ForField.Unresolved.Factory.INSTANCE, OffsetMapping.ForFieldHandle.Unresolved.ReaderFactory.INSTANCE, OffsetMapping.ForFieldHandle.Unresolved.WriterFactory.INSTANCE, OffsetMapping.ForOrigin.Factory.INSTANCE, OffsetMapping.ForSelfCallHandle.Factory.INSTANCE, OffsetMapping.ForHandle.Factory.INSTANCE, OffsetMapping.ForDynamicConstant.Factory.INSTANCE, OffsetMapping.ForUnusedValue.Factory.INSTANCE, OffsetMapping.ForStubValue.INSTANCE, OffsetMapping.ForExitValue.Factory.of(exitType), new OffsetMapping.Factory.Illegal<Thrown>(Thrown.class), new OffsetMapping.Factory.Illegal<Enter>(Enter.class), new OffsetMapping.Factory.Illegal<Local>(Local.class), new OffsetMapping.Factory.Illegal<Return>(Return.class)), userFactories), adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(SUPPRESS_ENTER).resolve(TypeDescription.class), adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(SKIP_ON).resolve(TypeDescription.class), adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(SKIP_ON_INDEX).resolve(Integer.class), delegator);
                        prependLineNumber = adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(PREPEND_LINE_NUMBER).resolve(Boolean.class);
                    }
                    protected static Resolved.ForMethodEnter of(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Delegator delegator, List<? extends OffsetMapping.Factory<?>> userFactories, TypeDefinition exitType, boolean methodExit) {
                        return methodExit ? new WithRetainedEnterType(adviceMethod, postProcessor, userFactories, exitType, delegator) : new WithDiscardedEnterType(adviceMethod, postProcessor, userFactories, exitType, delegator);
                    }
                    public boolean isPrependLineNumber() {
                        return prependLineNumber;
                    }
                    public TypeDefinition getActualAdviceType() {
                        return delegator.getTypeToken().getReturnType();
                    }
                    protected Bound resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, StackManipulation exceptionHandler, RelocationHandler.Relocation relocation) {
                        return doResolve(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, assigner, argumentHandler.bindEnter(delegator.getTypeToken()), methodSizeHandler.bindEnter(delegator.getTypeToken()), stackMapFrameHandler.bindEnter(delegator.getTypeToken()), suppressionHandler.bind(exceptionHandler), relocationHandler.bind(instrumentedMethod, relocation), exceptionHandler);
                    }
                    protected Bound doResolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler) {
                        List<OffsetMapping.Target> offsetMappings = new ArrayList<OffsetMapping.Target>(this.offsetMappings.size());
                        for (OffsetMapping offsetMapping : this.offsetMappings.values()) {
                            offsetMappings.add(offsetMapping.resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, OffsetMapping.Sort.ENTER));
                        }
                        return new AdviceMethodWriter.ForMethodEnter(delegator.getTypeToken(), instrumentedType, instrumentedMethod, assigner, postProcessor, offsetMappings, methodVisitor, implementationContext, argumentHandler, methodSizeHandler, stackMapFrameHandler, suppressionHandler, relocationHandler, exceptionHandler, delegator);
                    }
                    protected static class WithRetainedEnterType extends Delegating.Resolved.ForMethodEnter {
                        protected WithRetainedEnterType(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, List<? extends OffsetMapping.Factory<?>> userFactories, TypeDefinition exitType, Delegator delegator) {
                            super(adviceMethod, postProcessor, userFactories, exitType, delegator);
                        }
                        public TypeDefinition getAdviceType() {
                            return delegator.getTypeToken().getReturnType();
                        }
                    }
                    protected static class WithDiscardedEnterType extends Delegating.Resolved.ForMethodEnter {
                        protected WithDiscardedEnterType(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, List<? extends OffsetMapping.Factory<?>> userFactories, TypeDefinition exitType, Delegator delegator) {
                            super(adviceMethod, postProcessor, userFactories, exitType, delegator);
                        }
                        public TypeDefinition getAdviceType() {
                            return TypeDescription.ForLoadedType.of(void.class);
                        }
                        protected Bound doResolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Context implementationContext, Assigner assigner, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler) {
                            methodSizeHandler.requireLocalVariableLengthPadding(delegator.getTypeToken().getReturnType().getStackSize().getSize());
                            return super.doResolve(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, assigner, argumentHandler, methodSizeHandler, stackMapFrameHandler, suppressionHandler, relocationHandler, exceptionHandler);
                        }
                    }
                }
                protected abstract static class ForMethodExit extends Delegating.Resolved implements Dispatcher.Resolved.ForMethodExit {
                    private final boolean backupArguments;
                    @SuppressWarnings("unchecked")
                    @SuppressFBWarnings(value = "NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE", justification = "Assuming annotation for exit advice.")
                    protected ForMethodExit(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map<String, TypeDefinition> namedTypes, List<? extends OffsetMapping.Factory<?>> userFactories, TypeDefinition enterType, Delegator delegator) {
                        super(adviceMethod, postProcessor, CompoundList.of(Arrays.asList(OffsetMapping.ForArgument.Unresolved.Factory.INSTANCE, OffsetMapping.ForAllArguments.Factory.INSTANCE, OffsetMapping.ForThisReference.Factory.INSTANCE, OffsetMapping.ForField.Unresolved.Factory.INSTANCE, OffsetMapping.ForFieldHandle.Unresolved.ReaderFactory.INSTANCE, OffsetMapping.ForFieldHandle.Unresolved.WriterFactory.INSTANCE, OffsetMapping.ForOrigin.Factory.INSTANCE, OffsetMapping.ForSelfCallHandle.Factory.INSTANCE, OffsetMapping.ForHandle.Factory.INSTANCE, OffsetMapping.ForDynamicConstant.Factory.INSTANCE, OffsetMapping.ForUnusedValue.Factory.INSTANCE, OffsetMapping.ForStubValue.INSTANCE, OffsetMapping.ForEnterValue.Factory.of(enterType), OffsetMapping.ForExitValue.Factory.of(adviceMethod.getReturnType()), new OffsetMapping.ForLocalValue.Factory(namedTypes), OffsetMapping.ForReturnValue.Factory.INSTANCE, OffsetMapping.ForThrowable.Factory.of(adviceMethod)), userFactories), adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(SUPPRESS_EXIT).resolve(TypeDescription.class), adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(REPEAT_ON).resolve(TypeDescription.class), adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(REPEAT_ON_INDEX).resolve(Integer.class), delegator);
                        backupArguments = adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(BACKUP_ARGUMENTS).resolve(Boolean.class);
                    }
                    protected static Resolved.ForMethodExit of(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Delegator delegator, Map<String, TypeDefinition> namedTypes, List<? extends OffsetMapping.Factory<?>> userFactories, TypeDefinition enterType) {
                        TypeDescription throwable = adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(ON_THROWABLE).resolve(TypeDescription.class);
                        return throwable.represents(NoExceptionHandler.class) ? new WithoutExceptionHandler(adviceMethod, postProcessor, namedTypes, userFactories, enterType, delegator) : new WithExceptionHandler(adviceMethod, postProcessor, namedTypes, userFactories, enterType, throwable, delegator);
                    }
                    protected Bound resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, StackManipulation exceptionHandler, RelocationHandler.Relocation relocation) {
                        return doResolve(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, assigner, argumentHandler.bindExit(delegator.getTypeToken(), getThrowable().represents(NoExceptionHandler.class)), methodSizeHandler.bindExit(delegator.getTypeToken()), stackMapFrameHandler.bindExit(delegator.getTypeToken()), suppressionHandler.bind(exceptionHandler), relocationHandler.bind(instrumentedMethod, relocation), exceptionHandler);
                    }
                    private Bound doResolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler) {
                        List<OffsetMapping.Target> offsetMappings = new ArrayList<OffsetMapping.Target>(this.offsetMappings.size());
                        for (OffsetMapping offsetMapping : this.offsetMappings.values()) {
                            offsetMappings.add(offsetMapping.resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, OffsetMapping.Sort.EXIT));
                        }
                        return new AdviceMethodWriter.ForMethodExit(delegator.getTypeToken(), instrumentedType, instrumentedMethod, assigner, postProcessor, offsetMappings, methodVisitor, implementationContext, argumentHandler, methodSizeHandler, stackMapFrameHandler, suppressionHandler, relocationHandler, exceptionHandler, delegator);
                    }
                    public ArgumentHandler.Factory getArgumentHandlerFactory() {
                        return backupArguments ? ArgumentHandler.Factory.COPYING : ArgumentHandler.Factory.SIMPLE;
                    }
                    public TypeDefinition getAdviceType() {
                        return delegator.getTypeToken().getReturnType();
                    }
                    protected static class WithExceptionHandler extends Delegating.Resolved.ForMethodExit {
                        private final TypeDescription throwable;
                        protected WithExceptionHandler(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map<String, TypeDefinition> namedTypes, List<? extends OffsetMapping.Factory<?>> userFactories, TypeDefinition enterType, TypeDescription throwable, Delegator delegator) {
                            super(adviceMethod, postProcessor, namedTypes, userFactories, enterType, delegator);
                            this.throwable = throwable;
                        }
                        public TypeDescription getThrowable() {
                            return throwable;
                        }
                    }
                    protected static class WithoutExceptionHandler extends Delegating.Resolved.ForMethodExit {
                        protected WithoutExceptionHandler(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map<String, TypeDefinition> namedTypes, List<? extends OffsetMapping.Factory<?>> userFactories, TypeDefinition enterType, Delegator delegator) {
                            super(adviceMethod, postProcessor, namedTypes, userFactories, enterType, delegator);
                        }
                        public TypeDescription getThrowable() {
                            return NoExceptionHandler.DESCRIPTION;
                        }
                    }
                }
            }
        }
    }
    protected abstract static class AdviceVisitor extends ExceptionTableSensitiveMethodVisitor implements Dispatcher.RelocationHandler.Relocation {
        private static final int THIS_VARIABLE_INDEX = 0;
        private static final String THIS_VARIABLE_NAME = "this";
        protected final MethodDescription instrumentedMethod;
        private final Label preparationStart;
        private final Dispatcher.Bound methodEnter;
        protected final Dispatcher.Bound methodExit;
        protected final ArgumentHandler.ForInstrumentedMethod argumentHandler;
        protected final MethodSizeHandler.ForInstrumentedMethod methodSizeHandler;
        protected final StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler;
        @SuppressFBWarnings(value = "MC_OVERRIDABLE_METHOD_CALL_IN_CONSTRUCTOR", justification = "Self reference is not used before constructor completion.")
        protected AdviceVisitor(MethodVisitor methodVisitor, Context implementationContext, Assigner assigner, StackManipulation exceptionHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Dispatcher.Resolved.ForMethodEnter methodEnter, Dispatcher.Resolved.ForMethodExit methodExit, List<? extends TypeDescription> postMethodTypes, int writerFlags, int readerFlags) {
            super(OpenedClassReader.ASM_API, methodVisitor);
            this.instrumentedMethod = instrumentedMethod;
            preparationStart = new Label();
            SortedMap<String, TypeDefinition> namedTypes = new TreeMap<String, TypeDefinition>();
            namedTypes.putAll(methodEnter.getNamedTypes());
            namedTypes.putAll(methodExit.getNamedTypes());
            argumentHandler = methodExit.getArgumentHandlerFactory().resolve(instrumentedMethod, methodEnter.getAdviceType(), methodExit.getAdviceType(), namedTypes);
            List<TypeDescription> initialTypes = CompoundList.of(methodExit.getAdviceType().represents(void.class) ? Collections.<TypeDescription>emptyList() : Collections.singletonList(methodExit.getAdviceType().asErasure()), argumentHandler.getNamedTypes());
            List<TypeDescription> latentTypes = methodEnter.getActualAdviceType().represents(void.class) ? Collections.<TypeDescription>emptyList() : Collections.singletonList(methodEnter.getActualAdviceType().asErasure());
            List<TypeDescription> preMethodTypes = methodEnter.getAdviceType().represents(void.class) ? Collections.<TypeDescription>emptyList() : Collections.singletonList(methodEnter.getAdviceType().asErasure());
            methodSizeHandler = MethodSizeHandler.Default.of(instrumentedMethod, initialTypes, preMethodTypes, postMethodTypes, argumentHandler.isCopyingArguments(), writerFlags);
            stackMapFrameHandler = StackMapFrameHandler.Default.of(instrumentedType, instrumentedMethod, initialTypes, latentTypes, preMethodTypes, postMethodTypes, methodExit.isAlive(), argumentHandler.isCopyingArguments(), implementationContext.getClassFileVersion(), writerFlags, readerFlags);
            this.methodEnter = methodEnter.bind(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, assigner, argumentHandler, methodSizeHandler, stackMapFrameHandler, exceptionHandler, this);
            this.methodExit = methodExit.bind(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, assigner, argumentHandler, methodSizeHandler, stackMapFrameHandler, exceptionHandler, new ForLabel(preparationStart));
        }
        protected void onAfterExceptionTable() {
            methodEnter.prepare();
            onUserPrepare();
            methodExit.prepare();
            methodEnter.initialize();
            methodExit.initialize();
            stackMapFrameHandler.injectInitializationFrame(mv);
            methodEnter.apply();
            mv.visitLabel(preparationStart);
            methodSizeHandler.requireStackSize(argumentHandler.prepare(mv));
            stackMapFrameHandler.injectStartFrame(mv);
            mv.visitInsn(Opcodes.NOP);
            onUserStart();
        }
        protected abstract void onUserPrepare();
        protected abstract void onUserStart();
        protected void onVisitVarInsn(int opcode, int offset) {
            mv.visitVarInsn(opcode, argumentHandler.argument(offset));
        }
        protected void onVisitIincInsn(int offset, int increment) {
            mv.visitIincInsn(argumentHandler.argument(offset), increment);
        }
        public void onVisitFrame(int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
            stackMapFrameHandler.translateFrame(mv, type, localVariableLength, localVariable, stackSize, stack);
        }
        public void visitMaxs(int stackSize, int localVariableLength) {
            onUserEnd();
            mv.visitMaxs(methodSizeHandler.compoundStackSize(stackSize), methodSizeHandler.compoundLocalVariableLength(localVariableLength));
        }
        public void visitLocalVariable(String name, String descriptor, String signature, Label start, Label end, int offset) {
            mv.visitLocalVariable(name, descriptor, signature, start, end, offset == THIS_VARIABLE_INDEX && THIS_VARIABLE_NAME.equals(name) ? offset : argumentHandler.argument(offset));
        }
        public AnnotationVisitor visitLocalVariableAnnotation(int typeReference, TypePath typePath, Label[] start, Label[] end, int[] offset, String descriptor, boolean visible) {
            int[] translated = new int[offset.length];
            for (int index = 0; index < offset.length; index++) {
                translated[index] = argumentHandler.argument(offset[index]);
            }
            return mv.visitLocalVariableAnnotation(typeReference, typePath, start, end, translated, descriptor, visible);
        }
        protected abstract void onUserEnd();
        protected static class WithoutExitAdvice extends AdviceVisitor {
            protected WithoutExitAdvice(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, StackManipulation exceptionHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Dispatcher.Resolved.ForMethodEnter methodEnter, int writerFlags, int readerFlags) {
                super(methodVisitor, implementationContext, assigner, exceptionHandler, instrumentedType, instrumentedMethod, methodEnter, Dispatcher.Inactive.INSTANCE, Collections.<TypeDescription>emptyList(), writerFlags, readerFlags);
            }
            public void apply(MethodVisitor methodVisitor) {
                if (instrumentedMethod.getReturnType().represents(boolean.class) || instrumentedMethod.getReturnType().represents(byte.class) || instrumentedMethod.getReturnType().represents(short.class) || instrumentedMethod.getReturnType().represents(char.class) || instrumentedMethod.getReturnType().represents(int.class)) {
                    methodVisitor.visitInsn(Opcodes.ICONST_0);
                    methodVisitor.visitInsn(Opcodes.IRETURN);
                } else if (instrumentedMethod.getReturnType().represents(long.class)) {
                    methodVisitor.visitInsn(Opcodes.LCONST_0);
                    methodVisitor.visitInsn(Opcodes.LRETURN);
                } else if (instrumentedMethod.getReturnType().represents(float.class)) {
                    methodVisitor.visitInsn(Opcodes.FCONST_0);
                    methodVisitor.visitInsn(Opcodes.FRETURN);
                } else if (instrumentedMethod.getReturnType().represents(double.class)) {
                    methodVisitor.visitInsn(Opcodes.DCONST_0);
                    methodVisitor.visitInsn(Opcodes.DRETURN);
                } else if (instrumentedMethod.getReturnType().represents(void.class)) {
                    methodVisitor.visitInsn(Opcodes.RETURN);
                } else {
                    methodVisitor.visitInsn(Opcodes.ACONST_NULL);
                    methodVisitor.visitInsn(Opcodes.ARETURN);
                }
            }
            protected void onUserPrepare() {
            }
            protected void onUserStart() {
            }
            protected void onUserEnd() {
            }
        }
        protected abstract static class WithExitAdvice extends AdviceVisitor {
            protected final Label returnHandler;
            protected WithExitAdvice(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, StackManipulation exceptionHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Dispatcher.Resolved.ForMethodEnter methodEnter, Dispatcher.Resolved.ForMethodExit methodExit, List<? extends TypeDescription> postMethodTypes, int writerFlags, int readerFlags) {
                super(StackAwareMethodVisitor.of(methodVisitor, instrumentedMethod), implementationContext, assigner, exceptionHandler, instrumentedType, instrumentedMethod, methodEnter, methodExit, postMethodTypes, writerFlags, readerFlags);
                returnHandler = new Label();
            }
            public void apply(MethodVisitor methodVisitor) {
                if (instrumentedMethod.getReturnType().represents(boolean.class) || instrumentedMethod.getReturnType().represents(byte.class) || instrumentedMethod.getReturnType().represents(short.class) || instrumentedMethod.getReturnType().represents(char.class) || instrumentedMethod.getReturnType().represents(int.class)) {
                    methodVisitor.visitInsn(Opcodes.ICONST_0);
                } else if (instrumentedMethod.getReturnType().represents(long.class)) {
                    methodVisitor.visitInsn(Opcodes.LCONST_0);
                } else if (instrumentedMethod.getReturnType().represents(float.class)) {
                    methodVisitor.visitInsn(Opcodes.FCONST_0);
                } else if (instrumentedMethod.getReturnType().represents(double.class)) {
                    methodVisitor.visitInsn(Opcodes.DCONST_0);
                } else if (!instrumentedMethod.getReturnType().represents(void.class)) {
                    methodVisitor.visitInsn(Opcodes.ACONST_NULL);
                }
                methodVisitor.visitJumpInsn(Opcodes.GOTO, returnHandler);
            }
            protected void onVisitInsn(int opcode) {
                switch(opcode) {
                    case Opcodes.RETURN:
                        ((StackAwareMethodVisitor) mv).drainStack();
                        break;
                    case Opcodes.IRETURN:
                        methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor) mv).drainStack(Opcodes.ISTORE, Opcodes.ILOAD, StackSize.SINGLE));
                        break;
                    case Opcodes.FRETURN:
                        methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor) mv).drainStack(Opcodes.FSTORE, Opcodes.FLOAD, StackSize.SINGLE));
                        break;
                    case Opcodes.DRETURN:
                        methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor) mv).drainStack(Opcodes.DSTORE, Opcodes.DLOAD, StackSize.DOUBLE));
                        break;
                    case Opcodes.LRETURN:
                        methodSizeHandler.requireLocalVariableLength((((StackAwareMethodVisitor) mv).drainStack(Opcodes.LSTORE, Opcodes.LLOAD, StackSize.DOUBLE)));
                        break;
                    case Opcodes.ARETURN:
                        methodSizeHandler.requireLocalVariableLength((((StackAwareMethodVisitor) mv).drainStack(Opcodes.ASTORE, Opcodes.ALOAD, StackSize.SINGLE)));
                        break;
                    default:
                        mv.visitInsn(opcode);
                        return;
                }
                mv.visitJumpInsn(Opcodes.GOTO, returnHandler);
            }
            protected void onUserEnd() {
                mv.visitLabel(returnHandler);
                onUserReturn();
                stackMapFrameHandler.injectCompletionFrame(mv);
                methodExit.apply();
                onExitAdviceReturn();
                if (instrumentedMethod.getReturnType().represents(boolean.class) || instrumentedMethod.getReturnType().represents(byte.class) || instrumentedMethod.getReturnType().represents(short.class) || instrumentedMethod.getReturnType().represents(char.class) || instrumentedMethod.getReturnType().represents(int.class)) {
                    mv.visitVarInsn(Opcodes.ILOAD, argumentHandler.returned());
                    mv.visitInsn(Opcodes.IRETURN);
                } else if (instrumentedMethod.getReturnType().represents(long.class)) {
                    mv.visitVarInsn(Opcodes.LLOAD, argumentHandler.returned());
                    mv.visitInsn(Opcodes.LRETURN);
                } else if (instrumentedMethod.getReturnType().represents(float.class)) {
                    mv.visitVarInsn(Opcodes.FLOAD, argumentHandler.returned());
                    mv.visitInsn(Opcodes.FRETURN);
                } else if (instrumentedMethod.getReturnType().represents(double.class)) {
                    mv.visitVarInsn(Opcodes.DLOAD, argumentHandler.returned());
                    mv.visitInsn(Opcodes.DRETURN);
                } else if (!instrumentedMethod.getReturnType().represents(void.class)) {
                    mv.visitVarInsn(Opcodes.ALOAD, argumentHandler.returned());
                    mv.visitInsn(Opcodes.ARETURN);
                } else {
                    mv.visitInsn(Opcodes.RETURN);
                }
                methodSizeHandler.requireStackSize(instrumentedMethod.getReturnType().getStackSize().getSize());
            }
            protected abstract void onUserReturn();
            protected abstract void onExitAdviceReturn();
            protected static class WithoutExceptionHandling extends WithExitAdvice {
                protected WithoutExceptionHandling(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, StackManipulation exceptionHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Dispatcher.Resolved.ForMethodEnter methodEnter, Dispatcher.Resolved.ForMethodExit methodExit, int writerFlags, int readerFlags) {
                    super(methodVisitor, implementationContext, assigner, exceptionHandler, instrumentedType, instrumentedMethod, methodEnter, methodExit, instrumentedMethod.getReturnType().represents(void.class) ? Collections.<TypeDescription>emptyList() : Collections.singletonList(instrumentedMethod.getReturnType().asErasure()), writerFlags, readerFlags);
                }
                protected void onUserPrepare() {
                }
                protected void onUserStart() {
                }
                protected void onUserReturn() {
                    if (instrumentedMethod.getReturnType().represents(boolean.class) || instrumentedMethod.getReturnType().represents(byte.class) || instrumentedMethod.getReturnType().represents(short.class) || instrumentedMethod.getReturnType().represents(char.class) || instrumentedMethod.getReturnType().represents(int.class)) {
                        stackMapFrameHandler.injectReturnFrame(mv);
                        mv.visitVarInsn(Opcodes.ISTORE, argumentHandler.returned());
                    } else if (instrumentedMethod.getReturnType().represents(long.class)) {
                        stackMapFrameHandler.injectReturnFrame(mv);
                        mv.visitVarInsn(Opcodes.LSTORE, argumentHandler.returned());
                    } else if (instrumentedMethod.getReturnType().represents(float.class)) {
                        stackMapFrameHandler.injectReturnFrame(mv);
                        mv.visitVarInsn(Opcodes.FSTORE, argumentHandler.returned());
                    } else if (instrumentedMethod.getReturnType().represents(double.class)) {
                        stackMapFrameHandler.injectReturnFrame(mv);
                        mv.visitVarInsn(Opcodes.DSTORE, argumentHandler.returned());
                    } else if (!instrumentedMethod.getReturnType().represents(void.class)) {
                        stackMapFrameHandler.injectReturnFrame(mv);
                        mv.visitVarInsn(Opcodes.ASTORE, argumentHandler.returned());
                    }
                }
                protected void onExitAdviceReturn() {
                }
            }
            protected static class WithExceptionHandling extends WithExitAdvice {
                private final TypeDescription throwable;
                private final Label exceptionHandler;
                protected final Label userStart;
                protected WithExceptionHandling(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, StackManipulation exceptionHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Dispatcher.Resolved.ForMethodEnter methodEnter, Dispatcher.Resolved.ForMethodExit methodExit, int writerFlags, int readerFlags, TypeDescription throwable) {
                    super(methodVisitor, implementationContext, assigner, exceptionHandler, instrumentedType, instrumentedMethod, methodEnter, methodExit, instrumentedMethod.getReturnType().represents(void.class) ? Collections.singletonList(TypeDescription.ForLoadedType.of(Throwable.class)) : Arrays.asList(instrumentedMethod.getReturnType().asErasure(), TypeDescription.ForLoadedType.of(Throwable.class)), writerFlags, readerFlags);
                    this.throwable = throwable;
                    this.exceptionHandler = new Label();
                    userStart = new Label();
                }
                protected void onUserPrepare() {
                    mv.visitTryCatchBlock(userStart, returnHandler, exceptionHandler, throwable.getInternalName());
                }
                protected void onUserStart() {
                    mv.visitLabel(userStart);
                }
                protected void onUserReturn() {
                    stackMapFrameHandler.injectReturnFrame(mv);
                    if (instrumentedMethod.getReturnType().represents(boolean.class) || instrumentedMethod.getReturnType().represents(byte.class) || instrumentedMethod.getReturnType().represents(short.class) || instrumentedMethod.getReturnType().represents(char.class) || instrumentedMethod.getReturnType().represents(int.class)) {
                        mv.visitVarInsn(Opcodes.ISTORE, argumentHandler.returned());
                    } else if (instrumentedMethod.getReturnType().represents(long.class)) {
                        mv.visitVarInsn(Opcodes.LSTORE, argumentHandler.returned());
                    } else if (instrumentedMethod.getReturnType().represents(float.class)) {
                        mv.visitVarInsn(Opcodes.FSTORE, argumentHandler.returned());
                    } else if (instrumentedMethod.getReturnType().represents(double.class)) {
                        mv.visitVarInsn(Opcodes.DSTORE, argumentHandler.returned());
                    } else if (!instrumentedMethod.getReturnType().represents(void.class)) {
                        mv.visitVarInsn(Opcodes.ASTORE, argumentHandler.returned());
                    }
                    mv.visitInsn(Opcodes.ACONST_NULL);
                    mv.visitVarInsn(Opcodes.ASTORE, argumentHandler.thrown());
                    Label endOfHandler = new Label();
                    mv.visitJumpInsn(Opcodes.GOTO, endOfHandler);
                    mv.visitLabel(exceptionHandler);
                    stackMapFrameHandler.injectExceptionFrame(mv);
                    mv.visitVarInsn(Opcodes.ASTORE, argumentHandler.thrown());
                    if (instrumentedMethod.getReturnType().represents(boolean.class) || instrumentedMethod.getReturnType().represents(byte.class) || instrumentedMethod.getReturnType().represents(short.class) || instrumentedMethod.getReturnType().represents(char.class) || instrumentedMethod.getReturnType().represents(int.class)) {
                        mv.visitInsn(Opcodes.ICONST_0);
                        mv.visitVarInsn(Opcodes.ISTORE, argumentHandler.returned());
                    } else if (instrumentedMethod.getReturnType().represents(long.class)) {
                        mv.visitInsn(Opcodes.LCONST_0);
                        mv.visitVarInsn(Opcodes.LSTORE, argumentHandler.returned());
                    } else if (instrumentedMethod.getReturnType().represents(float.class)) {
                        mv.visitInsn(Opcodes.FCONST_0);
                        mv.visitVarInsn(Opcodes.FSTORE, argumentHandler.returned());
                    } else if (instrumentedMethod.getReturnType().represents(double.class)) {
                        mv.visitInsn(Opcodes.DCONST_0);
                        mv.visitVarInsn(Opcodes.DSTORE, argumentHandler.returned());
                    } else if (!instrumentedMethod.getReturnType().represents(void.class)) {
                        mv.visitInsn(Opcodes.ACONST_NULL);
                        mv.visitVarInsn(Opcodes.ASTORE, argumentHandler.returned());
                    }
                    mv.visitLabel(endOfHandler);
                    methodSizeHandler.requireStackSize(StackSize.SINGLE.getSize());
                }
                protected void onExitAdviceReturn() {
                    mv.visitVarInsn(Opcodes.ALOAD, argumentHandler.thrown());
                    Label endOfHandler = new Label();
                    mv.visitJumpInsn(Opcodes.IFNULL, endOfHandler);
                    mv.visitVarInsn(Opcodes.ALOAD, argumentHandler.thrown());
                    mv.visitInsn(Opcodes.ATHROW);
                    mv.visitLabel(endOfHandler);
                    stackMapFrameHandler.injectPostCompletionFrame(mv);
                }
            }
        }
    }
    protected static class Appender implements ByteCodeAppender {
        private final Advice advice;
        private final Implementation.Target implementationTarget;
        private final ByteCodeAppender delegate;
        protected Appender(Advice advice, Target implementationTarget, ByteCodeAppender delegate) {
            this.advice = advice;
            this.implementationTarget = implementationTarget;
            this.delegate = delegate;
        }
        public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
            EmulatingMethodVisitor emulatingMethodVisitor = new EmulatingMethodVisitor(methodVisitor, delegate);
            methodVisitor = advice.doWrap(implementationTarget.getInstrumentedType(), instrumentedMethod, emulatingMethodVisitor, implementationContext, AsmVisitorWrapper.NO_FLAGS, AsmVisitorWrapper.NO_FLAGS);
            return emulatingMethodVisitor.resolve(methodVisitor, implementationContext, instrumentedMethod);
        }
        protected static class EmulatingMethodVisitor extends MethodVisitor {
            private final ByteCodeAppender delegate;
            private int stackSize;
            private int localVariableLength;
            protected EmulatingMethodVisitor(MethodVisitor methodVisitor, ByteCodeAppender delegate) {
                super(OpenedClassReader.ASM_API, methodVisitor);
                this.delegate = delegate;
            }
            protected ByteCodeAppender.Size resolve(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
                methodVisitor.visitCode();
                Size size = delegate.apply(methodVisitor, implementationContext, instrumentedMethod);
                methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());
                methodVisitor.visitEnd();
                return new ByteCodeAppender.Size(stackSize, localVariableLength);
            }
            public void visitCode() {
            }
            public void visitMaxs(int stackSize, int localVariableLength) {
                this.stackSize = stackSize;
                this.localVariableLength = localVariableLength;
            }
            public void visitEnd() {
            }
        }
    }
    public @interface OnMethodEnter {
        Class<?> skipOn() default void.class;
        int skipOnIndex() default -1;
        boolean prependLineNumber() default true;
        boolean inline() default true;
        Class<? extends Throwable> suppress() default NoExceptionHandler.class;
    }
    public @interface OnMethodExit {
        Class<?> repeatOn() default void.class;
        int repeatOnIndex() default -1;
        Class<? extends Throwable> onThrowable() default NoExceptionHandler.class;
        boolean backupArguments() default true;
        boolean inline() default true;
        Class<? extends Throwable> suppress() default NoExceptionHandler.class;
    }
    public @interface This {
        boolean readOnly() default true;
        Assigner.Typing typing() default Assigner.Typing.STATIC;
        boolean optional() default false;
    }
    public @interface Argument {
        int value();
        boolean readOnly() default true;
        Assigner.Typing typing() default Assigner.Typing.STATIC;
        boolean optional() default false;
    }
    public @interface AllArguments {
        boolean readOnly() default true;
        Assigner.Typing typing() default Assigner.Typing.STATIC;
        boolean includeSelf() default false;
        boolean nullIfEmpty() default false;
    }
    public @interface Return {
        boolean readOnly() default true;
        Assigner.Typing typing() default Assigner.Typing.STATIC;
    }
    public @interface Thrown {
        boolean readOnly() default true;
        Assigner.Typing typing() default Assigner.Typing.DYNAMIC;
    }
    public @interface SelfCallHandle {
        boolean bound() default true;
    }
    public @interface Handle {
        JavaConstant.MethodHandle.HandleType type();
        Class<?> owner() default void.class;
        String name();
        Class<?> returnType();
        Class<?>[] parameterTypes();
    }
    public @interface DynamicConstant {
        String name() default JavaConstant.Dynamic.DEFAULT_NAME;
        JavaConstant.MethodHandle.HandleType bootstrapType();
        Class<?> bootstrapOwner() default void.class;
        String bootstrapName();
        Class<?> bootstrapReturnType();
        Class<?>[] bootstrapParameterTypes();
        boolean invokedynamic() default false;
    }
    public @interface FieldValue {
        String value() default OffsetMapping.ForField.Unresolved.BEAN_PROPERTY;
        Class<?> declaringType() default void.class;
        boolean readOnly() default true;
        Assigner.Typing typing() default Assigner.Typing.STATIC;
    }
    public @interface FieldGetterHandle {
        String value() default OffsetMapping.ForFieldHandle.Unresolved.BEAN_PROPERTY;
        Class<?> declaringType() default void.class;
    }
    public @interface FieldSetterHandle {
        String value() default OffsetMapping.ForFieldHandle.Unresolved.BEAN_PROPERTY;
        Class<?> declaringType() default void.class;
    }
    public @interface Origin {
        String DEFAULT = "";
        String value() default DEFAULT;
    }
    public @interface Enter {
        boolean readOnly() default true;
        Assigner.Typing typing() default Assigner.Typing.STATIC;
    }
    public @interface Exit {
        boolean readOnly() default true;
        Assigner.Typing typing() default Assigner.Typing.STATIC;
    }
    public @interface Local {
        String value();
    }
    public @interface StubValue {
    }
    public @interface Unused {
    }
    public abstract static class AssignReturned implements PostProcessor {
        public static final int NO_INDEX = -1;
        protected final TypeDescription typeDescription;
        protected final ExceptionHandler.Factory exceptionHandlerFactory;
        protected final boolean exit;
        protected final boolean skipOnDefaultValue;
        protected AssignReturned(TypeDescription typeDescription, ExceptionHandler.Factory exceptionHandlerFactory, boolean exit, boolean skipOnDefaultValue) {
            this.typeDescription = typeDescription;
            this.exceptionHandlerFactory = exceptionHandlerFactory;
            this.exit = exit;
            this.skipOnDefaultValue = skipOnDefaultValue;
        }
        public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler, StackManipulation exceptionHandler) {
            List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(getHandlers().size());
            for (Handler handler : getHandlers()) {
                stackManipulations.add(handler.resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, getType(), toLoadInstruction(handler, exit ? argumentHandler.exit() : argumentHandler.enter())));
            }
            StackManipulation stackManipulation = exceptionHandlerFactory.wrap(new StackManipulation.Compound(stackManipulations), exceptionHandler, stackMapFrameHandler);
            return skipOnDefaultValue ? DefaultValueSkip.of(stackManipulation, stackMapFrameHandler, exit ? argumentHandler.exit() : argumentHandler.enter(), typeDescription) : stackManipulation;
        }
        protected abstract TypeDescription getType();
        protected abstract Collection<Handler> getHandlers();
        protected abstract StackManipulation toLoadInstruction(Handler handler, int offset);
        public @interface AsScalar {
            boolean skipOnDefaultValue() default true;
        }
        public @interface ToArguments {
            ToArgument[] value();
            @interface ToArgument {
                int value();
                int index() default NO_INDEX;
                Assigner.Typing typing() default Assigner.Typing.STATIC;
            }
            class Handler implements AssignReturned.Handler {
                private final int value;
                private final int index;
                private final Assigner.Typing typing;
                protected Handler(int value, int index, Assigner.Typing typing) {
                    this.value = value;
                    this.index = index;
                    this.typing = typing;
                }
                public int getIndex() {
                    return index;
                }
                public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, TypeDescription type, StackManipulation value) {
                    if (instrumentedMethod.getParameters().size() < this.value) {
                        throw new IllegalStateException(instrumentedMethod + " declares less then " + this.value + " parameters");
                    }
                    StackManipulation assignment = assigner.assign(type.asGenericType(), instrumentedMethod.getParameters().get(this.value).getType(), typing);
                    if (!assignment.isValid()) {
                        throw new IllegalStateException("Cannot assign " + type + " to " + instrumentedMethod.getParameters().get(this.value).getType());
                    }
                    return new StackManipulation.Compound(value, assignment, MethodVariableAccess.of(instrumentedMethod.getParameters().get(this.value).getType()).storeAt(argumentHandler.argument(instrumentedMethod.getParameters().get(this.value).getOffset())));
                }
                public enum Factory implements AssignReturned.Handler.Factory<ToArguments> {
                    INSTANCE;
                    private static final MethodDescription.InDefinedShape TO_ARGUMENTS_VALUE;
                    private static final MethodDescription.InDefinedShape TO_ARGUMENT_VALUE;
                    private static final MethodDescription.InDefinedShape TO_ARGUMENT_INDEX;
                    private static final MethodDescription.InDefinedShape TO_ARGUMENT_TYPING;
                    static {
                        TO_ARGUMENTS_VALUE = TypeDescription.ForLoadedType.of(ToArguments.class).getDeclaredMethods().filter(named("value")).getOnly();
                        MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(ToArgument.class).getDeclaredMethods();
                        TO_ARGUMENT_VALUE = methods.filter(named("value")).getOnly();
                        TO_ARGUMENT_INDEX = methods.filter(named("index")).getOnly();
                        TO_ARGUMENT_TYPING = methods.filter(named("typing")).getOnly();
                    }
                    public Class<ToArguments> getAnnotationType() {
                        return ToArguments.class;
                    }
                    public List<AssignReturned.Handler> make(TypeDescription returnType, boolean exit, AnnotationDescription.Loadable<? extends ToArguments> annotation) {
                        List<AssignReturned.Handler> handlers = new ArrayList<AssignReturned.Handler>();
                        for (AnnotationDescription argument : annotation.getValue(TO_ARGUMENTS_VALUE).resolve(AnnotationDescription[].class)) {
                            int value = argument.getValue(TO_ARGUMENT_VALUE).resolve(Integer.class);
                            if (value < 0) {
                                throw new IllegalStateException("An argument cannot have a negative index for " + returnType);
                            }
                            handlers.add(new Handler(value, argument.getValue(TO_ARGUMENT_INDEX).resolve(Integer.class), argument.getValue(TO_ARGUMENT_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class)));
                        }
                        return handlers;
                    }
                }
            }
        }
        public @interface ToAllArguments {
            int index() default NO_INDEX;
            Assigner.Typing typing() default Assigner.Typing.STATIC;
            class Handler implements AssignReturned.Handler {
                private final int index;
                private final Assigner.Typing typing;
                protected Handler(int index, Assigner.Typing typing) {
                    this.index = index;
                    this.typing = typing;
                }
                public int getIndex() {
                    return index;
                }
                public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, TypeDescription type, StackManipulation value) {
                    List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(instrumentedMethod.getParameters().size());
                    if (!type.isArray()) {
                        StackManipulation assignment = assigner.assign(type.asGenericType(), TypeDefinition.Sort.describe(Object[].class), typing);
                        if (!assignment.isValid()) {
                            throw new IllegalStateException("Cannot assign " + type + " to " + Object[].class);
                        }
                        type = TypeDescription.ForLoadedType.of(Object[].class);
                        value = new StackManipulation.Compound(value, assignment);
                    }
                    for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {
                        StackManipulation assignment = assigner.assign(type.getComponentType().asGenericType(), parameterDescription.getType(), typing);
                        if (!assignment.isValid()) {
                            throw new IllegalStateException("Cannot assign " + type.getComponentType() + " to " + parameterDescription);
                        }
                        stackManipulations.add(new StackManipulation.Compound(assignment, MethodVariableAccess.of(parameterDescription.getType()).storeAt(argumentHandler.argument(parameterDescription.getOffset()))));
                    }
                    return new StackManipulation.Compound(value, ArrayAccess.of(type.getComponentType()).forEach(stackManipulations), Removal.SINGLE);
                }
                public enum Factory implements AssignReturned.Handler.Factory<ToAllArguments> {
                    INSTANCE;
                    private static final MethodDescription.InDefinedShape TO_ALL_ARGUMENTS_INDEX;
                    private static final MethodDescription.InDefinedShape TO_ALL_ARGUMENTS_TYPING;
                    static {
                        MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(ToAllArguments.class).getDeclaredMethods();
                        TO_ALL_ARGUMENTS_INDEX = methods.filter(named("index")).getOnly();
                        TO_ALL_ARGUMENTS_TYPING = methods.filter(named("typing")).getOnly();
                    }
                    public Class<ToAllArguments> getAnnotationType() {
                        return ToAllArguments.class;
                    }
                    public List<AssignReturned.Handler> make(TypeDescription typeDescription, boolean exit, AnnotationDescription.Loadable<? extends ToAllArguments> annotation) {
                        return Collections.<AssignReturned.Handler>singletonList(new Handler(annotation.getValue(TO_ALL_ARGUMENTS_INDEX).resolve(Integer.class), annotation.getValue(TO_ALL_ARGUMENTS_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class)));
                    }
                }
            }
        }
        public @interface ToThis {
            int index() default NO_INDEX;
            Assigner.Typing typing() default Assigner.Typing.STATIC;
            class Handler implements AssignReturned.Handler {
                private final int index;
                private final Assigner.Typing typing;
                private final boolean exit;
                protected Handler(int index, Assigner.Typing typing, boolean exit) {
                    this.index = index;
                    this.typing = typing;
                    this.exit = exit;
                }
                public int getIndex() {
                    return index;
                }
                public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, TypeDescription type, StackManipulation value) {
                    if (instrumentedMethod.isStatic()) {
                        throw new IllegalStateException("Cannot assign this reference for static method " + instrumentedMethod);
                    } else if (!exit && instrumentedMethod.isConstructor()) {
                        throw new IllegalStateException("Cannot assign this reference in constructor prior to initialization for " + instrumentedMethod);
                    }
                    StackManipulation assignment = assigner.assign(type.asGenericType(), instrumentedType.asGenericType(), typing);
                    if (!assignment.isValid()) {
                        throw new IllegalStateException("Cannot assign " + type + " to " + instrumentedType);
                    }
                    return new StackManipulation.Compound(value, assignment, MethodVariableAccess.REFERENCE.storeAt(argumentHandler.argument(0)));
                }
                public enum Factory implements AssignReturned.Handler.Factory<ToThis> {
                    INSTANCE;
                    private static final MethodDescription.InDefinedShape TO_THIS_INDEX;
                    private static final MethodDescription.InDefinedShape TO_THIS_TYPING;
                    static {
                        MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(ToThis.class).getDeclaredMethods();
                        TO_THIS_INDEX = methods.filter(named("index")).getOnly();
                        TO_THIS_TYPING = methods.filter(named("typing")).getOnly();
                    }
                    public Class<ToThis> getAnnotationType() {
                        return ToThis.class;
                    }
                    public List<AssignReturned.Handler> make(TypeDescription returnType, boolean exit, AnnotationDescription.Loadable<? extends ToThis> annotation) {
                        return Collections.<AssignReturned.Handler>singletonList(new Handler(annotation.getValue(TO_THIS_INDEX).resolve(Integer.class), annotation.getValue(TO_THIS_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class), exit));
                    }
                }
            }
        }
        public @interface ToFields {
            ToField[] value();
            @interface ToField {
                String value() default OffsetMapping.ForField.Unresolved.BEAN_PROPERTY;
                Class<?> declaringType() default void.class;
                int index() default NO_INDEX;
                Assigner.Typing typing() default Assigner.Typing.STATIC;
            }
            class Handler implements AssignReturned.Handler {
                private final int index;
                private final String name;
                private final TypeDescription declaringType;
                private final Assigner.Typing typing;
                protected Handler(int index, String name, TypeDescription declaringType, Assigner.Typing typing) {
                    this.index = index;
                    this.name = name;
                    this.declaringType = declaringType;
                    this.typing = typing;
                }
                public int getIndex() {
                    return index;
                }
                public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, TypeDescription type, StackManipulation value) {
                    FieldLocator locator = declaringType.represents(void.class) ? new FieldLocator.ForClassHierarchy(instrumentedType) : new FieldLocator.ForExactType(declaringType);
                    FieldLocator.Resolution resolution = name.equals(OffsetMapping.ForField.Unresolved.BEAN_PROPERTY) ? FieldLocator.Resolution.Simple.ofBeanAccessor(locator, instrumentedMethod) : locator.locate(name);
                    StackManipulation stackManipulation;
                    if (!resolution.isResolved()) {
                        throw new IllegalStateException("Cannot resolve field " + name + " for " + instrumentedType);
                    } else if (!resolution.getField().isVisibleTo(instrumentedType)) {
                        throw new IllegalStateException(resolution.getField() + " is not visible to " + instrumentedType);
                    } else if (resolution.getField().isStatic()) {
                        stackManipulation = StackManipulation.Trivial.INSTANCE;
                    } else if (instrumentedMethod.isStatic()) {
                        throw new IllegalStateException("Cannot access member field " + resolution.getField() + " from static " + instrumentedMethod);
                    } else if (!instrumentedType.isAssignableTo(resolution.getField().getDeclaringType().asErasure())) {
                        throw new IllegalStateException(instrumentedType + " does not define " + resolution.getField());
                    } else {
                        stackManipulation = MethodVariableAccess.loadThis();
                    }
                    StackManipulation assignment = assigner.assign(type.asGenericType(), resolution.getField().getType(), typing);
                    if (!assignment.isValid()) {
                        throw new IllegalStateException("Cannot assign " + type + " to " + resolution.getField());
                    }
                    return new StackManipulation.Compound(stackManipulation, value, assignment, FieldAccess.forField(resolution.getField()).write());
                }
                public enum Factory implements AssignReturned.Handler.Factory<ToFields> {
                    INSTANCE;
                    private static final MethodDescription.InDefinedShape TO_FIELDS_VALUE;
                    private static final MethodDescription.InDefinedShape TO_FIELD_VALUE;
                    private static final MethodDescription.InDefinedShape TO_FIELD_INDEX;
                    private static final MethodDescription.InDefinedShape TO_FIELD_DECLARING_TYPE;
                    private static final MethodDescription.InDefinedShape TO_FIELD_TYPING;
                    static {
                        TO_FIELDS_VALUE = TypeDescription.ForLoadedType.of(ToFields.class).getDeclaredMethods().filter(named("value")).getOnly();
                        MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(ToField.class).getDeclaredMethods();
                        TO_FIELD_VALUE = methods.filter(named("value")).getOnly();
                        TO_FIELD_INDEX = methods.filter(named("index")).getOnly();
                        TO_FIELD_DECLARING_TYPE = methods.filter(named("declaringType")).getOnly();
                        TO_FIELD_TYPING = methods.filter(named("typing")).getOnly();
                    }
                    public Class<ToFields> getAnnotationType() {
                        return ToFields.class;
                    }
                    public List<AssignReturned.Handler> make(TypeDescription returnType, boolean exit, AnnotationDescription.Loadable<? extends ToFields> annotation) {
                        List<AssignReturned.Handler> handlers = new ArrayList<AssignReturned.Handler>();
                        for (AnnotationDescription field : annotation.getValue(TO_FIELDS_VALUE).resolve(AnnotationDescription[].class)) {
                            handlers.add(new Handler(field.getValue(TO_FIELD_INDEX).resolve(Integer.class), field.getValue(TO_FIELD_VALUE).resolve(String.class), field.getValue(TO_FIELD_DECLARING_TYPE).resolve(TypeDescription.class), field.getValue(TO_FIELD_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class)));
                        }
                        return handlers;
                    }
                }
            }
        }
        public @interface ToReturned {
            int index() default NO_INDEX;
            Assigner.Typing typing() default Assigner.Typing.STATIC;
            class Handler implements AssignReturned.Handler {
                private final int index;
                private final Assigner.Typing typing;
                protected Handler(int index, Assigner.Typing typing) {
                    this.index = index;
                    this.typing = typing;
                }
                public int getIndex() {
                    return index;
                }
                public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, TypeDescription type, StackManipulation value) {
                    if (instrumentedMethod.getReturnType().represents(void.class)) {
                        return StackManipulation.Trivial.INSTANCE;
                    }
                    StackManipulation assignment = assigner.assign(type.asGenericType(), instrumentedMethod.getReturnType(), typing);
                    if (!assignment.isValid()) {
                        throw new IllegalStateException("Cannot assign " + type + " to " + instrumentedMethod.getReturnType());
                    }
                    return new StackManipulation.Compound(value, assignment, MethodVariableAccess.of(instrumentedMethod.getReturnType()).storeAt(argumentHandler.returned()));
                }
                public enum Factory implements AssignReturned.Handler.Factory<ToReturned> {
                    INSTANCE;
                    private static final MethodDescription.InDefinedShape TO_RETURNED_INDEX;
                    private static final MethodDescription.InDefinedShape TO_RETURNED_TYPING;
                    static {
                        MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(ToReturned.class).getDeclaredMethods();
                        TO_RETURNED_INDEX = methods.filter(named("index")).getOnly();
                        TO_RETURNED_TYPING = methods.filter(named("typing")).getOnly();
                    }
                    public Class<ToReturned> getAnnotationType() {
                        return ToReturned.class;
                    }
                    public List<AssignReturned.Handler> make(TypeDescription returnType, boolean exit, AnnotationDescription.Loadable<? extends ToReturned> annotation) {
                        if (!exit) {
                            throw new IllegalStateException("Cannot write returned value from enter advice for " + returnType);
                        }
                        return Collections.<AssignReturned.Handler>singletonList(new ToReturned.Handler(annotation.getValue(TO_RETURNED_INDEX).resolve(Integer.class), annotation.getValue(TO_RETURNED_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class)));
                    }
                }
            }
        }
        public @interface ToThrown {
            int index() default NO_INDEX;
            Assigner.Typing typing() default Assigner.Typing.STATIC;
            class Handler implements AssignReturned.Handler {
                private final int index;
                private final Assigner.Typing typing;
                protected Handler(int index, Assigner.Typing typing) {
                    this.index = index;
                    this.typing = typing;
                }
                public int getIndex() {
                    return index;
                }
                public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, TypeDescription type, StackManipulation value) {
                    StackManipulation assignment = assigner.assign(type.asGenericType(), TypeDefinition.Sort.describe(Throwable.class), typing);
                    if (!assignment.isValid()) {
                        throw new IllegalStateException("Cannot assign " + type + " to " + Throwable.class.getName());
                    }
                    return new StackManipulation.Compound(value, assignment, MethodVariableAccess.REFERENCE.storeAt(argumentHandler.thrown()));
                }
                public enum Factory implements AssignReturned.Handler.Factory<ToThrown> {
                    INSTANCE;
                    private static final MethodDescription.InDefinedShape TO_THROWN_INDEX;
                    private static final MethodDescription.InDefinedShape TO_THROWN_TYPING;
                    static {
                        MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(ToThrown.class).getDeclaredMethods();
                        TO_THROWN_INDEX = methods.filter(named("index")).getOnly();
                        TO_THROWN_TYPING = methods.filter(named("typing")).getOnly();
                    }
                    public Class<ToThrown> getAnnotationType() {
                        return ToThrown.class;
                    }
                    public List<AssignReturned.Handler> make(TypeDescription returnType, boolean exit, AnnotationDescription.Loadable<? extends ToThrown> annotation) {
                        if (!exit) {
                            throw new IllegalStateException("Cannot assign thrown value from enter advice for " + returnType);
                        }
                        return Collections.<AssignReturned.Handler>singletonList(new ToThrown.Handler(annotation.getValue(TO_THROWN_INDEX).resolve(Integer.class), annotation.getValue(TO_THROWN_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class)));
                    }
                }
            }
        }
        protected static class ForArray extends AssignReturned {
            private final Map<Handler, Integer> handlers;
            protected ForArray(TypeDescription typeDescription, ExceptionHandler.Factory exceptionHandlerFactory, boolean exit, Collection<List<Handler>> handlers) {
                super(typeDescription, exceptionHandlerFactory, exit, true);
                this.handlers = new LinkedHashMap<Handler, Integer>();
                for (List<Handler> collection : handlers) {
                    for (Handler handler : collection) {
                        int index = handler.getIndex();
                        if (index <= NO_INDEX) {
                            throw new IllegalStateException("Handler on array requires positive index for " + handler);
                        }
                        this.handlers.put(handler, index);
                    }
                }
            }
            protected TypeDescription getType() {
                return typeDescription.getComponentType();
            }
            protected Collection<Handler> getHandlers() {
                return handlers.keySet();
            }
            protected StackManipulation toLoadInstruction(Handler handler, int offset) {
                return new StackManipulation.Compound(MethodVariableAccess.REFERENCE.loadFrom(offset), IntegerConstant.forValue(handlers.get(handler)), ArrayAccess.of(typeDescription.getComponentType()).load());
            }
        }
        protected static class ForScalar extends AssignReturned {
            private final List<Handler> handlers;
            protected ForScalar(TypeDescription typeDescription, ExceptionHandler.Factory exceptionHandlerFactory, boolean exit, boolean skipOnDefaultValue, Collection<List<Handler>> handlers) {
                super(typeDescription, exceptionHandlerFactory, exit, skipOnDefaultValue);
                this.handlers = new ArrayList<Handler>();
                for (List<Handler> collection : handlers) {
                    for (Handler handler : collection) {
                        int index = handler.getIndex();
                        if (index > NO_INDEX) {
                            throw new IllegalStateException("Handler on array requires negative index for " + handler);
                        }
                        this.handlers.add(handler);
                    }
                }
            }
            protected TypeDescription getType() {
                return typeDescription;
            }
            protected Collection<Handler> getHandlers() {
                return handlers;
            }
            protected StackManipulation toLoadInstruction(Handler handler, int offset) {
                return MethodVariableAccess.of(typeDescription).loadFrom(offset);
            }
        }
        protected static class DefaultValueSkip implements StackManipulation {
            private final StackManipulation stackManipulation;
            private final StackMapFrameHandler.ForPostProcessor stackMapFrameHandler;
            private final int offset;
            private final Dispatcher dispatcher;
            protected DefaultValueSkip(StackManipulation stackManipulation, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler, int offset, Dispatcher dispatcher) {
                this.stackManipulation = stackManipulation;
                this.stackMapFrameHandler = stackMapFrameHandler;
                this.offset = offset;
                this.dispatcher = dispatcher;
            }
            protected static StackManipulation of(StackManipulation stackManipulation, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler, int offset, TypeDefinition typeDefinition) {
                Dispatcher dispatcher;
                if (typeDefinition.isPrimitive()) {
                    if (typeDefinition.represents(boolean.class) || typeDefinition.represents(byte.class) || typeDefinition.represents(short.class) || typeDefinition.represents(char.class) || typeDefinition.represents(int.class)) {
                        dispatcher = Dispatcher.INTEGER;
                    } else if (typeDefinition.represents(long.class)) {
                        dispatcher = Dispatcher.LONG;
                    } else if (typeDefinition.represents(float.class)) {
                        dispatcher = Dispatcher.FLOAT;
                    } else if (typeDefinition.represents(double.class)) {
                        dispatcher = Dispatcher.DOUBLE;
                    } else {
                        throw new IllegalArgumentException("Cannot apply skip for " + typeDefinition);
                    }
                } else {
                    dispatcher = Dispatcher.REFERENCE;
                }
                return new DefaultValueSkip(stackManipulation, stackMapFrameHandler, offset, dispatcher);
            }
            public boolean isValid() {
                return stackManipulation.isValid();
            }
            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
                Label label = new Label();
                Size size = dispatcher.apply(methodVisitor, offset, label).aggregate(stackManipulation.apply(methodVisitor, implementationContext));
                methodVisitor.visitInsn(Opcodes.NOP);
                methodVisitor.visitLabel(label);
                stackMapFrameHandler.injectIntermediateFrame(methodVisitor, Collections.<TypeDescription>emptyList());
                methodVisitor.visitInsn(Opcodes.NOP);
                return size;
            }
            protected enum Dispatcher {
                INTEGER {
                    @Override
                    protected Size apply(MethodVisitor methodVisitor, int offset, Label label) {
                        methodVisitor.visitVarInsn(Opcodes.ILOAD, offset);
                        methodVisitor.visitJumpInsn(Opcodes.IFEQ, label);
                        return new Size(0, 1);
                    }
                }
                , LONG {
                    @Override
                    protected Size apply(MethodVisitor methodVisitor, int offset, Label label) {
                        methodVisitor.visitVarInsn(Opcodes.LLOAD, offset);
                        methodVisitor.visitInsn(Opcodes.LCONST_0);
                        methodVisitor.visitInsn(Opcodes.LCMP);
                        methodVisitor.visitJumpInsn(Opcodes.IFEQ, label);
                        return new Size(0, 4);
                    }
                }
                , FLOAT {
                    @Override
                    protected Size apply(MethodVisitor methodVisitor, int offset, Label label) {
                        methodVisitor.visitVarInsn(Opcodes.FLOAD, offset);
                        methodVisitor.visitInsn(Opcodes.FCONST_0);
                        methodVisitor.visitInsn(Opcodes.FCMPL);
                        methodVisitor.visitJumpInsn(Opcodes.IFEQ, label);
                        return new Size(0, 2);
                    }
                }
                , DOUBLE {
                    @Override
                    protected Size apply(MethodVisitor methodVisitor, int offset, Label label) {
                        methodVisitor.visitVarInsn(Opcodes.DLOAD, offset);
                        methodVisitor.visitInsn(Opcodes.DCONST_0);
                        methodVisitor.visitInsn(Opcodes.DCMPL);
                        methodVisitor.visitJumpInsn(Opcodes.IFEQ, label);
                        return new Size(0, 4);
                    }
                }
                , REFERENCE {
                    @Override
                    protected Size apply(MethodVisitor methodVisitor, int offset, Label label) {
                        methodVisitor.visitVarInsn(Opcodes.ALOAD, offset);
                        methodVisitor.visitJumpInsn(Opcodes.IFNULL, label);
                        return new Size(0, 2);
                    }
                }
                ;
                protected abstract Size apply(MethodVisitor methodVisitor, int offset, Label label);
            }
        }
        protected static class ExceptionHandler implements StackManipulation {
            private final StackManipulation stackManipulation;
            private final StackManipulation exceptionHandler;
            private final TypeDescription exceptionType;
            private final StackMapFrameHandler.ForPostProcessor stackMapFrameHandler;
            protected ExceptionHandler(StackManipulation stackManipulation, StackManipulation exceptionHandler, TypeDescription exceptionType, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler) {
                this.stackManipulation = stackManipulation;
                this.exceptionHandler = exceptionHandler;
                this.exceptionType = exceptionType;
                this.stackMapFrameHandler = stackMapFrameHandler;
            }
            public boolean isValid() {
                return stackManipulation.isValid() && exceptionHandler.isValid();
            }
            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
                Label start = new Label(), handler = new Label(), end = new Label();
                methodVisitor.visitTryCatchBlock(start, handler, handler, exceptionType.getInternalName());
                methodVisitor.visitLabel(start);
                Size size = stackManipulation.apply(methodVisitor, implementationContext);
                methodVisitor.visitJumpInsn(Opcodes.GOTO, end);
                methodVisitor.visitLabel(handler);
                stackMapFrameHandler.injectIntermediateFrame(methodVisitor, Collections.singletonList(exceptionType));
                size = exceptionHandler.apply(methodVisitor, implementationContext).aggregate(size);
                methodVisitor.visitLabel(end);
                stackMapFrameHandler.injectIntermediateFrame(methodVisitor, Collections.<TypeDescription>emptyList());
                return size;
            }
            public interface Factory {
                StackManipulation wrap(StackManipulation stackManipulation, StackManipulation exceptionHandler, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler);
                enum NoOp implements Factory {
                    INSTANCE;
                    public StackManipulation wrap(StackManipulation stackManipulation, StackManipulation exceptionHandler, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler) {
                        return stackManipulation;
                    }
                }
                class Enabled implements Factory {
                    private final TypeDescription exceptionType;
                    protected Enabled(TypeDescription exceptionType) {
                        this.exceptionType = exceptionType;
                    }
                    public StackManipulation wrap(StackManipulation stackManipulation, StackManipulation exceptionHandler, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler) {
                        return new ExceptionHandler(stackManipulation, exceptionHandler, exceptionType, stackMapFrameHandler);
                    }
                }
            }
        }
        public interface Handler {
            int getIndex();
            StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, TypeDescription type, StackManipulation value);
            interface Factory<T extends Annotation> {
                Class<T> getAnnotationType();
                List<Handler> make(TypeDescription returnType, boolean exit, AnnotationDescription.Loadable<? extends T> annotation);
                class Simple<S extends Annotation> implements Factory<S> {
                    private final Class<S> type;
                    private final List<Handler> handlers;
                    public Simple(Class<S> type, List<Handler> handlers) {
                        this.type = type;
                        this.handlers = handlers;
                    }
                    public Class<S> getAnnotationType() {
                        return type;
                    }
                    public List<Handler> make(TypeDescription returnType, boolean exit, AnnotationDescription.Loadable<? extends S> annotation) {
                        return handlers;
                    }
                }
            }
        }
        public static class Factory implements PostProcessor.Factory {
            private static final MethodDescription.InDefinedShape SKIP_ON_DEFAULT_VALUE = TypeDescription.ForLoadedType.of(AsScalar.class).getDeclaredMethods().filter(named("skipOnDefaultValue")).getOnly();
            private final List<? extends Handler.Factory<?>> factories;
            private final ExceptionHandler.Factory exceptionHandlerFactory;
            @SuppressWarnings("unchecked")
            public Factory() {
                this(Arrays.asList(ToArguments.Handler.Factory.INSTANCE, ToAllArguments.Handler.Factory.INSTANCE, ToThis.Handler.Factory.INSTANCE, ToFields.Handler.Factory.INSTANCE, ToReturned.Handler.Factory.INSTANCE, ToThrown.Handler.Factory.INSTANCE), ExceptionHandler.Factory.NoOp.INSTANCE);
            }
            protected Factory(List<? extends Handler.Factory<?>> factories, ExceptionHandler.Factory exceptionHandlerFactory) {
                this.factories = factories;
                this.exceptionHandlerFactory = exceptionHandlerFactory;
            }
            public Factory with(Class<? extends Annotation> type, Handler... handler) {
                return with(type, Arrays.asList(handler));
            }
            public Factory with(Class<? extends Annotation> type, List<Handler> handlers) {
                return with(new Handler.Factory.Simple(type, handlers));
            }
            public Factory with(Handler.Factory<?> factory) {
                return new Factory(CompoundList.of(factories, factory), exceptionHandlerFactory);
            }
            public PostProcessor.Factory withSuppressed(Class<? extends Throwable> exceptionType) {
                return withSuppressed(TypeDescription.ForLoadedType.of(exceptionType));
            }
            public PostProcessor.Factory withSuppressed(TypeDescription exceptionType) {
                if (!exceptionType.isAssignableTo(Throwable.class)) {
                    throw new IllegalArgumentException(exceptionType + " is not a throwable type");
                }
                return new Factory(factories, new ExceptionHandler.Factory.Enabled(exceptionType));
            }
            public PostProcessor make(List<? extends AnnotationDescription> annotations, TypeDescription returnType, boolean exit) {
                if (returnType.represents(void.class)) {
                    return NoOp.INSTANCE;
                }
                Map<String, Handler.Factory<?>> factories = new HashMap<String, Handler.Factory<?>>();
                for (Handler.Factory<?> factory : this.factories) {
                    if (factories.put(factory.getAnnotationType().getName(), factory) != null) {
                        throw new IllegalStateException("Duplicate registration of handler for " + factory.getAnnotationType());
                    }
                }
                Map<Class<?>, List<Handler>> handlers = new LinkedHashMap<Class<?>, List<Handler>>();
                boolean scalar = false, skipOnDefaultValue = true;
                for (AnnotationDescription annotation : annotations) {
                    if (annotation.getAnnotationType().represents(AsScalar.class)) {
                        scalar = true;
                        skipOnDefaultValue = annotation.getValue(SKIP_ON_DEFAULT_VALUE).resolve(Boolean.class);
                        continue;
                    }
                    Handler.Factory<?> factory = factories.get(annotation.getAnnotationType().getName());
                    if (factory != null) {
                        if (handlers.put(factory.getAnnotationType(), factory.make(returnType, exit, (AnnotationDescription.Loadable) annotation.prepare(factory.getAnnotationType()))) != null) {
                            throw new IllegalStateException("Duplicate handler registration for " + annotation.getAnnotationType());
                        }
                    }
                }
                if (handlers.isEmpty()) {
                    return NoOp.INSTANCE;
                } else {
                    return !scalar && returnType.isArray() ? new ForArray(returnType, exceptionHandlerFactory, exit, handlers.values()) : new ForScalar(returnType, exceptionHandlerFactory, exit, skipOnDefaultValue, handlers.values());
                }
            }
        }
    }
    public static class WithCustomMapping {
        private final PostProcessor.Factory postProcessorFactory;
        private final Delegator.Factory delegatorFactory;
        private final AsmClassReader.Factory classReaderFactory;
        private final Map<Class<? extends Annotation>, OffsetMapping.Factory<?>> offsetMappings;
        protected WithCustomMapping() {
            this(PostProcessor.NoOp.INSTANCE, Collections.<Class<? extends Annotation>, OffsetMapping.Factory<?>>emptyMap(), Delegator.ForRegularInvocation.Factory.INSTANCE, AsmClassReader.Factory.Default.IMPLICIT);
        }
        protected WithCustomMapping(PostProcessor.Factory postProcessorFactory, Map<Class<? extends Annotation>, OffsetMapping.Factory<?>> offsetMappings, Delegator.Factory delegatorFactory, AsmClassReader.Factory classReaderFactory) {
            this.postProcessorFactory = postProcessorFactory;
            this.offsetMappings = offsetMappings;
            this.delegatorFactory = delegatorFactory;
            this.classReaderFactory = classReaderFactory;
        }
        public <T extends Annotation> WithCustomMapping bind(Class<T> type, @MaybeNull Object value) {
            return bind(OffsetMapping.ForStackManipulation.Factory.of(type, value));
        }
        public <T extends Annotation> WithCustomMapping bind(Class<T> type, Field field) {
            return bind(type, new FieldDescription.ForLoadedField(field));
        }
        public <T extends Annotation> WithCustomMapping bind(Class<T> type, FieldDescription fieldDescription) {
            return bind(new OffsetMapping.ForField.Resolved.Factory<T>(type, fieldDescription));
        }
        public <T extends Annotation> WithCustomMapping bind(Class<T> type, Method method, int index) {
            if (index < 0) {
                throw new IllegalArgumentException("A parameter cannot be negative: " + index);
            } else if (method.getParameterTypes().length <= index) {
                throw new IllegalArgumentException(method + " does not declare a parameter with index " + index);
            }
            return bind(type, new MethodDescription.ForLoadedMethod(method).getParameters().get(index));
        }
        public <T extends Annotation> WithCustomMapping bind(Class<T> type, Constructor<?> constructor, int index) {
            if (index < 0) {
                throw new IllegalArgumentException("A parameter cannot be negative: " + index);
            } else if (constructor.getParameterTypes().length <= index) {
                throw new IllegalArgumentException(constructor + " does not declare a parameter with index " + index);
            }
            return bind(type, new MethodDescription.ForLoadedConstructor(constructor).getParameters().get(index));
        }
        public <T extends Annotation> WithCustomMapping bind(Class<T> type, ParameterDescription parameterDescription) {
            return bind(new OffsetMapping.ForArgument.Resolved.Factory<T>(type, parameterDescription));
        }
        public <T extends Annotation> WithCustomMapping bind(Class<T> type, Class<?> value) {
            return bind(type, TypeDescription.ForLoadedType.of(value));
        }
        public <T extends Annotation> WithCustomMapping bind(Class<T> type, TypeDescription value) {
            return bind(new OffsetMapping.ForStackManipulation.Factory<T>(type, value));
        }
        public <T extends Annotation> WithCustomMapping bind(Class<T> type, Enum<?> value) {
            return bind(type, new EnumerationDescription.ForLoadedEnumeration(value));
        }
        public <T extends Annotation> WithCustomMapping bind(Class<T> type, EnumerationDescription value) {
            return bind(new OffsetMapping.ForStackManipulation.Factory<T>(type, value));
        }
        public <T extends Annotation> WithCustomMapping bindSerialized(Class<T> type, Serializable value) {
            return bindSerialized(type, value, (Class<Serializable>) value.getClass());
        }
        public <T extends Annotation, S extends Serializable> WithCustomMapping bindSerialized(Class<T> type, S value, Class<? super S> targetType) {
            return bind(OffsetMapping.ForSerializedValue.Factory.of(type, value, targetType));
        }
        public <T extends Annotation> WithCustomMapping bindProperty(Class<T> type, String property) {
            return bind(OffsetMapping.ForStackManipulation.OfAnnotationProperty.of(type, property));
        }
        public <T extends Annotation> WithCustomMapping bind(Class<T> type, JavaConstant constant) {
            return bind(type, (ConstantValue) constant);
        }
        public <T extends Annotation> WithCustomMapping bind(Class<T> type, ConstantValue constant) {
            return bind(new OffsetMapping.ForStackManipulation.Factory<T>(type, constant.toStackManipulation(), constant.getTypeDescription().asGenericType()));
        }
        public <T extends Annotation> WithCustomMapping bind(Class<T> type, StackManipulation stackManipulation, java.lang.reflect.Type targetType) {
            return bind(type, stackManipulation, TypeDefinition.Sort.describe(targetType));
        }
        public <T extends Annotation> WithCustomMapping bind(Class<T> type, StackManipulation stackManipulation, TypeDescription.Generic targetType) {
            return bind(new OffsetMapping.ForStackManipulation.Factory<T>(type, stackManipulation, targetType));
        }
        public <T extends Annotation> WithCustomMapping bindLambda(Class<T> type, Constructor<?> constructor, Class<?> functionalInterface) {
            return bindLambda(type, new MethodDescription.ForLoadedConstructor(constructor), TypeDescription.ForLoadedType.of(functionalInterface));
        }
        public <T extends Annotation> WithCustomMapping bindLambda(Class<T> type, Constructor<?> constructor, Class<?> functionalInterface, MethodGraph.Compiler methodGraphCompiler) {
            return bindLambda(type, new MethodDescription.ForLoadedConstructor(constructor), TypeDescription.ForLoadedType.of(functionalInterface), methodGraphCompiler);
        }
        public <T extends Annotation> WithCustomMapping bindLambda(Class<T> type, Method method, Class<?> functionalInterface) {
            return bindLambda(type, new MethodDescription.ForLoadedMethod(method), TypeDescription.ForLoadedType.of(functionalInterface));
        }
        public <T extends Annotation> WithCustomMapping bindLambda(Class<T> type, Method method, Class<?> functionalInterface, MethodGraph.Compiler methodGraphCompiler) {
            return bindLambda(type, new MethodDescription.ForLoadedMethod(method), TypeDescription.ForLoadedType.of(functionalInterface), methodGraphCompiler);
        }
        public <T extends Annotation> WithCustomMapping bindLambda(Class<T> type, MethodDescription.InDefinedShape methodDescription, TypeDescription functionalInterface) {
            return bindLambda(type, methodDescription, functionalInterface, MethodGraph.Compiler.DEFAULT);
        }
        public <T extends Annotation> WithCustomMapping bindLambda(Class<T> type, MethodDescription.InDefinedShape methodDescription, TypeDescription functionalInterface, MethodGraph.Compiler methodGraphCompiler) {
            if (!functionalInterface.isInterface()) {
                throw new IllegalArgumentException(functionalInterface + " is not an interface type");
            }
            MethodList<?> methods = methodGraphCompiler.compile((TypeDefinition) functionalInterface).listNodes().asMethodList().filter(isAbstract());
            if (methods.size() != 1) {
                throw new IllegalArgumentException(functionalInterface + " does not define exactly one abstract method: " + methods);
            }
            return bindDynamic(type, new MethodDescription.Latent(new TypeDescription.Latent("java.lang.invoke.LambdaMetafactory", Opcodes.ACC_PUBLIC, TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class)), "metafactory", Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, Collections.<TypeVariableToken>emptyList(), JavaType.CALL_SITE.getTypeStub().asGenericType(), Arrays.asList(new ParameterDescription.Token(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().asGenericType()), new ParameterDescription.Token(TypeDescription.ForLoadedType.of(String.class).asGenericType()), new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType()), new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType()), new ParameterDescription.Token(JavaType.METHOD_HANDLE.getTypeStub().asGenericType()), new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType())), Collections.<TypeDescription.Generic>emptyList(), Collections.<AnnotationDescription>emptyList(), AnnotationValue.UNDEFINED, TypeDescription.Generic.UNDEFINED), JavaConstant.MethodType.ofSignature(methods.asDefined().getOnly()), JavaConstant.MethodHandle.of(methodDescription), JavaConstant.MethodType.ofSignature(methods.asDefined().getOnly()));
        }
        public <T extends Annotation> WithCustomMapping bindDynamic(Class<T> type, Method bootstrapMethod, Object... constant) {
            return bindDynamic(type, bootstrapMethod, Arrays.asList(constant));
        }
        public <T extends Annotation> WithCustomMapping bindDynamic(Class<T> type, Method bootstrapMethod, List<?> constants) {
            return bindDynamic(type, new MethodDescription.ForLoadedMethod(bootstrapMethod), constants);
        }
        public <T extends Annotation> WithCustomMapping bindDynamic(Class<T> type, Constructor<?> bootstrapMethod, Object... constant) {
            return bindDynamic(type, bootstrapMethod, Arrays.asList(constant));
        }
        public <T extends Annotation> WithCustomMapping bindDynamic(Class<T> type, Constructor<?> bootstrapMethod, List<?> constants) {
            return bindDynamic(type, new MethodDescription.ForLoadedConstructor(bootstrapMethod), constants);
        }
        public <T extends Annotation> WithCustomMapping bindDynamic(Class<T> type, MethodDescription.InDefinedShape bootstrapMethod, Object... constant) {
            return bindDynamic(type, bootstrapMethod, Arrays.asList(constant));
        }
        public <T extends Annotation> WithCustomMapping bindDynamic(Class<T> type, MethodDescription.InDefinedShape bootstrapMethod, List<?> constants) {
            List<JavaConstant> arguments = JavaConstant.Simple.wrap(constants);
            if (!bootstrapMethod.isInvokeBootstrap(TypeList.Explicit.of(arguments))) {
                throw new IllegalArgumentException("Not a valid bootstrap method " + bootstrapMethod + " for " + arguments);
            }
            return bind(new OffsetMapping.ForStackManipulation.OfDynamicInvocation<T>(type, bootstrapMethod, arguments));
        }
        public <T extends Annotation> WithCustomMapping bind(Class<T> type, OffsetMapping offsetMapping) {
            return bind(new OffsetMapping.Factory.Simple<T>(type, offsetMapping));
        }
        public WithCustomMapping bind(OffsetMapping.Factory<?> offsetMapping) {
            Map<Class<? extends Annotation>, OffsetMapping.Factory<?>> offsetMappings = new LinkedHashMap<Class<? extends Annotation>, OffsetMapping.Factory<?>>(this.offsetMappings);
            if (!offsetMapping.getAnnotationType().isAnnotation()) {
                throw new IllegalArgumentException("Not an annotation type: " + offsetMapping.getAnnotationType());
            } else if (offsetMappings.put(offsetMapping.getAnnotationType(), offsetMapping) != null) {
                throw new IllegalArgumentException("Annotation type already mapped: " + offsetMapping.getAnnotationType());
            }
            return new WithCustomMapping(postProcessorFactory, offsetMappings, delegatorFactory, classReaderFactory);
        }
        public WithCustomMapping bootstrap(Constructor<?> constructor) {
            return bootstrap(new MethodDescription.ForLoadedConstructor(constructor));
        }
        public WithCustomMapping bootstrap(Constructor<?> constructor, BootstrapArgumentResolver.Factory resolverFactory) {
            return bootstrap(new MethodDescription.ForLoadedConstructor(constructor), resolverFactory);
        }
        public WithCustomMapping bootstrap(Method method) {
            return bootstrap(new MethodDescription.ForLoadedMethod(method));
        }
        public WithCustomMapping bootstrap(Method method, BootstrapArgumentResolver.Factory resolver) {
            return bootstrap(new MethodDescription.ForLoadedMethod(method), resolver);
        }
        public WithCustomMapping bootstrap(Method method, BootstrapArgumentResolver.Factory resolver, TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
            return bootstrap(new MethodDescription.ForLoadedMethod(method), resolver, visitor);
        }
        public WithCustomMapping bootstrap(MethodDescription.InDefinedShape bootstrap) {
            return bootstrap(bootstrap, BootstrapArgumentResolver.ForDefaultValues.Factory.INSTANCE);
        }
        public WithCustomMapping bootstrap(MethodDescription.InDefinedShape bootstrap, BootstrapArgumentResolver.Factory resolverFactory) {
            return bootstrap(bootstrap, resolverFactory, TypeDescription.Generic.Visitor.NoOp.INSTANCE);
        }
        public WithCustomMapping bootstrap(MethodDescription.InDefinedShape bootstrap, BootstrapArgumentResolver.Factory resolverFactory, TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
            return new WithCustomMapping(postProcessorFactory, offsetMappings, Delegator.ForDynamicInvocation.of(bootstrap, resolverFactory, visitor), classReaderFactory);
        }
        public WithCustomMapping with(PostProcessor.Factory postProcessorFactory) {
            return new WithCustomMapping(new PostProcessor.Factory.Compound(this.postProcessorFactory, postProcessorFactory), offsetMappings, delegatorFactory, classReaderFactory);
        }
        public WithCustomMapping with(AsmClassReader.Factory classReaderFactory) {
            return new WithCustomMapping(postProcessorFactory, offsetMappings, delegatorFactory, classReaderFactory);
        }
        public Advice to(Class<?> advice) {
            return to(advice, ClassFileLocator.ForClassLoader.of(advice.getClassLoader()));
        }
        public Advice to(Class<?> advice, ClassFileLocator classFileLocator) {
            return to(TypeDescription.ForLoadedType.of(advice), classFileLocator);
        }
        public Advice to(TypeDescription advice, ClassFileLocator classFileLocator) {
            return Advice.to(advice, postProcessorFactory, classFileLocator, new ArrayList<OffsetMapping.Factory<?>>(offsetMappings.values()), delegatorFactory, classReaderFactory);
        }
        public Advice to(Class<?> enterAdvice, Class<?> exitAdvice) {
            ClassLoader enterLoader = enterAdvice.getClassLoader(), exitLoader = exitAdvice.getClassLoader();
            return to(enterAdvice, exitAdvice, enterLoader == exitLoader ? ClassFileLocator.ForClassLoader.of(enterLoader) : new ClassFileLocator.Compound(ClassFileLocator.ForClassLoader.of(enterLoader), ClassFileLocator.ForClassLoader.of(exitLoader)));
        }
        public Advice to(Class<?> enterAdvice, Class<?> exitAdvice, ClassFileLocator classFileLocator) {
            return to(TypeDescription.ForLoadedType.of(enterAdvice), TypeDescription.ForLoadedType.of(exitAdvice), classFileLocator);
        }
        public Advice to(TypeDescription enterAdvice, TypeDescription exitAdvice) {
            return to(enterAdvice, exitAdvice, ClassFileLocator.NoOp.INSTANCE);
        }
        public Advice to(TypeDescription enterAdvice, TypeDescription exitAdvice, ClassFileLocator classFileLocator) {
            return Advice.to(enterAdvice, exitAdvice, postProcessorFactory, classFileLocator, new ArrayList<OffsetMapping.Factory<?>>(offsetMappings.values()), delegatorFactory, classReaderFactory);
        }
    }
    private static class NoExceptionHandler extends Throwable {
        private static final long serialVersionUID = 1L;
        private static final TypeDescription DESCRIPTION = TypeDescription.ForLoadedType.of(NoExceptionHandler.class);
        private NoExceptionHandler() {
            throw new UnsupportedOperationException("This class only serves as a marker type and should not be instantiated");
        }
    }
    public static final class OnDefaultValue {
        private OnDefaultValue() {
            throw new UnsupportedOperationException("This class only serves as a marker type and should not be instantiated");
        }
    }
    public static final class OnNonDefaultValue {
        private OnNonDefaultValue() {
            throw new UnsupportedOperationException("This class only serves as a marker type and should not be instantiated");
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```