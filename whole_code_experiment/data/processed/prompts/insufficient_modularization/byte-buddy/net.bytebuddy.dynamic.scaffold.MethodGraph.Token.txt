##CONTEXT_SIZE=7090
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.dynamic.scaffold;
public interface MethodGraph {
    Node locate(MethodDescription.SignatureToken token);
    NodeList listNodes();
    enum Empty implements MethodGraph.Linked, MethodGraph.Compiler {
        INSTANCE;
        public Node locate(MethodDescription.SignatureToken token) {
            return Node.Unresolved.INSTANCE;
        }
        public NodeList listNodes() {
            return new NodeList(Collections.<Node>emptyList());
        }
        public MethodGraph getSuperClassGraph() {
            return this;
        }
        public MethodGraph getInterfaceGraph(TypeDescription typeDescription) {
            return this;
        }
        public Linked compile(TypeDefinition typeDefinition) {
            return this;
        }
        public Linked compile(TypeDescription typeDescription) {
            return this;
        }
        public Linked compile(TypeDefinition typeDefinition, TypeDescription viewPoint) {
            return this;
        }
        public Linked compile(TypeDescription typeDefinition, TypeDescription viewPoint) {
            return this;
        }
    }
    interface Linked extends MethodGraph {
        MethodGraph getSuperClassGraph();
        MethodGraph getInterfaceGraph(TypeDescription typeDescription);
        class Delegation implements Linked {
            private final MethodGraph methodGraph;
            private final MethodGraph superClassGraph;
            private final Map<TypeDescription, MethodGraph> interfaceGraphs;
            public Delegation(MethodGraph methodGraph, MethodGraph superClassGraph, Map<TypeDescription, MethodGraph> interfaceGraphs) {
                this.methodGraph = methodGraph;
                this.superClassGraph = superClassGraph;
                this.interfaceGraphs = interfaceGraphs;
            }
            public MethodGraph getSuperClassGraph() {
                return superClassGraph;
            }
            public MethodGraph getInterfaceGraph(TypeDescription typeDescription) {
                MethodGraph interfaceGraph = interfaceGraphs.get(typeDescription);
                return interfaceGraph == null ? Empty.INSTANCE : interfaceGraph;
            }
            public Node locate(MethodDescription.SignatureToken token) {
                return methodGraph.locate(token);
            }
            public NodeList listNodes() {
                return methodGraph.listNodes();
            }
        }
    }
    interface Node {
        Sort getSort();
        MethodDescription getRepresentative();
        Set<MethodDescription.TypeToken> getMethodTypes();
        Visibility getVisibility();
        enum Sort {
            VISIBLE(true, true, true), RESOLVED(true, true, false), AMBIGUOUS(true, false, false), UNRESOLVED(false, false, false);
            private final boolean resolved;
            private final boolean unique;
            private final boolean madeVisible;
            Sort(boolean resolved, boolean unique, boolean madeVisible) {
                this.resolved = resolved;
                this.unique = unique;
                this.madeVisible = madeVisible;
            }
            public boolean isResolved() {
                return resolved;
            }
            public boolean isUnique() {
                return unique;
            }
            public boolean isMadeVisible() {
                return madeVisible;
            }
        }
        enum Unresolved implements Node {
            INSTANCE;
            public Sort getSort() {
                return Sort.UNRESOLVED;
            }
            public MethodDescription getRepresentative() {
                throw new IllegalStateException("Cannot resolve the method of an illegal node");
            }
            public Set<MethodDescription.TypeToken> getMethodTypes() {
                throw new IllegalStateException("Cannot resolve bridge method of an illegal node");
            }
            public Visibility getVisibility() {
                throw new IllegalStateException("Cannot resolve visibility of an illegal node");
            }
        }
        class Simple implements Node {
            private final MethodDescription methodDescription;
            public Simple(MethodDescription methodDescription) {
                this.methodDescription = methodDescription;
            }
            public Sort getSort() {
                return Sort.RESOLVED;
            }
            public MethodDescription getRepresentative() {
                return methodDescription;
            }
            public Set<MethodDescription.TypeToken> getMethodTypes() {
                return Collections.emptySet();
            }
            public Visibility getVisibility() {
                return methodDescription.getVisibility();
            }
        }
    }
    interface Compiler {
        Compiler DEFAULT = MethodGraph.Compiler.Default.forJavaHierarchy();
        MethodGraph.Linked compile(TypeDefinition typeDefinition);
        MethodGraph.Linked compile(TypeDescription typeDescription);
        MethodGraph.Linked compile(TypeDefinition typeDefinition, TypeDescription viewPoint);
        MethodGraph.Linked compile(TypeDescription typeDefinition, TypeDescription viewPoint);
        enum ForDeclaredMethods implements Compiler {
            INSTANCE;
            public Linked compile(TypeDefinition typeDefinition) {
                return compile(typeDefinition, typeDefinition.asErasure());
            }
            public Linked compile(TypeDescription typeDescription) {
                return compile((TypeDefinition) typeDescription, typeDescription);
            }
            public Linked compile(TypeDefinition typeDefinition, TypeDescription viewPoint) {
                LinkedHashMap<MethodDescription.SignatureToken, Node> nodes = new LinkedHashMap<MethodDescription.SignatureToken, Node>();
                for (MethodDescription methodDescription : typeDefinition.getDeclaredMethods().filter(isVirtual().and(not(isBridge())).and(isVisibleTo(viewPoint)))) {
                    nodes.put(methodDescription.asSignatureToken(), new Node.Simple(methodDescription));
                }
                return new Linked.Delegation(new MethodGraph.Simple(nodes), Empty.INSTANCE, Collections.<TypeDescription, MethodGraph>emptyMap());
            }
            public Linked compile(TypeDescription typeDefinition, TypeDescription viewPoint) {
                return compile((TypeDefinition) typeDefinition, viewPoint);
            }
        }
        abstract class AbstractBase implements Compiler {
            public Linked compile(TypeDefinition typeDefinition) {
                return compile(typeDefinition, typeDefinition.asErasure());
            }
            public Linked compile(TypeDescription typeDescription) {
                return compile((TypeDefinition) typeDescription, typeDescription);
            }
            public Linked compile(TypeDescription typeDefinition, TypeDescription viewPoint) {
                return compile((TypeDefinition) typeDefinition, viewPoint);
            }
        }
        class Default<T> extends AbstractBase {
            private final Harmonizer<T> harmonizer;
            private final Merger merger;
            private final TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor;
            private final ElementMatcher<? super MethodDescription> matcher;
            protected Default(Harmonizer<T> harmonizer, Merger merger, TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
                this(harmonizer, merger, visitor, any());
            }
            public Default(Harmonizer<T> harmonizer, Merger merger, TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor, ElementMatcher<? super MethodDescription> matcher) {
                this.harmonizer = harmonizer;
                this.merger = merger;
                this.visitor = visitor;
                this.matcher = matcher;
            }
            public static <S> Compiler of(Harmonizer<S> harmonizer, Merger merger) {
                return new Default<S>(harmonizer, merger, TypeDescription.Generic.Visitor.Reifying.INITIATING);
            }
            public static <S> Compiler of(Harmonizer<S> harmonizer, Merger merger, ElementMatcher<? super MethodDescription> matcher) {
                return new Default<S>(harmonizer, merger, TypeDescription.Generic.Visitor.Reifying.INITIATING, matcher);
            }
            public static <S> Compiler of(Harmonizer<S> harmonizer, Merger merger, TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
                return new Default<S>(harmonizer, merger, visitor);
            }
            public static Compiler forJavaHierarchy() {
                return of(Harmonizer.ForJavaMethod.INSTANCE, Merger.Directional.LEFT);
            }
            public static Compiler forJVMHierarchy() {
                return of(Harmonizer.ForJVMMethod.INSTANCE, Merger.Directional.LEFT);
            }
            public MethodGraph.Linked compile(TypeDefinition typeDefinition, TypeDescription viewPoint) {
                Map<TypeDefinition, Key.Store<T>> snapshots = new HashMap<TypeDefinition, Key.Store<T>>();
                Key.Store<?> rootStore = doAnalyze(typeDefinition, snapshots, isVirtual().and(isVisibleTo(viewPoint)).and(matcher));
                TypeDescription.Generic superClass = typeDefinition.getSuperClass();
                List<TypeDescription.Generic> interfaceTypes = typeDefinition.getInterfaces();
                Map<TypeDescription, MethodGraph> interfaceGraphs = new HashMap<TypeDescription, MethodGraph>();
                for (TypeDescription.Generic interfaceType : interfaceTypes) {
                    Key.Store<T> store = snapshots.get(interfaceType);
                    if (store == null) {
                        throw new IllegalStateException("Failed to resolve interface type " + interfaceType + " from " + snapshots.keySet());
                    }
                    interfaceGraphs.put(interfaceType.asErasure(), store.asGraph(merger));
                }
                Key.Store<T> store;
                if (superClass == null) {
                    store = null;
                } else {
                    store = snapshots.get(superClass);
                    if (store == null) {
                        throw new IllegalStateException("Failed to resolve super class " + superClass + " from " + snapshots.keySet());
                    }
                }
                return new Linked.Delegation(rootStore.asGraph(merger), store == null ? Empty.INSTANCE : store.asGraph(merger), interfaceGraphs);
            }
            protected Key.Store<T> analyze(TypeDefinition typeDefinition, TypeDefinition key, Map<TypeDefinition, Key.Store<T>> snapshots, ElementMatcher<? super MethodDescription> relevanceMatcher) {
                Key.Store<T> store = snapshots.get(key);
                if (store == null) {
                    store = doAnalyze(typeDefinition, snapshots, relevanceMatcher);
                    snapshots.put(key, store);
                }
                return store;
            }
            protected Key.Store<T> analyzeNullable(@MaybeNull TypeDescription.Generic typeDescription, Map<TypeDefinition, Key.Store<T>> snapshots, ElementMatcher<? super MethodDescription> relevanceMatcher) {
                return typeDescription == null ? new Key.Store<T>() : analyze(typeDescription.accept(visitor), typeDescription, snapshots, relevanceMatcher);
            }
            protected Key.Store<T> doAnalyze(TypeDefinition typeDefinition, Map<TypeDefinition, Key.Store<T>> snapshots, ElementMatcher<? super MethodDescription> relevanceMatcher) {
                Key.Store<T> store = analyzeNullable(typeDefinition.getSuperClass(), snapshots, relevanceMatcher);
                Key.Store<T> interfaceStore = new Key.Store<T>();
                for (TypeDescription.Generic interfaceType : typeDefinition.getInterfaces()) {
                    interfaceStore = interfaceStore.combineWith(analyze(interfaceType.accept(visitor), interfaceType, snapshots, relevanceMatcher));
                }
                return store.inject(interfaceStore).registerTopLevel(typeDefinition.getDeclaredMethods().filter(relevanceMatcher), harmonizer);
            }
            public interface Harmonizer<S> {
                S harmonize(MethodDescription.TypeToken typeToken);
                enum ForJavaMethod implements Harmonizer<ForJavaMethod.Token> {
                    INSTANCE;
                    public Token harmonize(MethodDescription.TypeToken typeToken) {
                        return new Token(typeToken);
                    }
                    protected static class Token {
                        private final MethodDescription.TypeToken typeToken;
                        private final int hashCode;
                        protected Token(MethodDescription.TypeToken typeToken) {
                            this.typeToken = typeToken;
                            hashCode = typeToken.getParameterTypes().hashCode();
                        }
                        public int hashCode() {
                            return hashCode;
                        }
                        public boolean equals(@MaybeNull Object other) {
                            return this == other || other instanceof Token && typeToken.getParameterTypes().equals(((Token) other).typeToken.getParameterTypes());
                        }
                        public String toString() {
                            return typeToken.getParameterTypes().toString();
                        }
                    }
                }
                enum ForJVMMethod implements Harmonizer<ForJVMMethod.Token> {
                    INSTANCE;
                    public Token harmonize(MethodDescription.TypeToken typeToken) {
                        return new Token(typeToken);
                    }
                    protected static class Token {
                        private final MethodDescription.TypeToken typeToken;
                        private final int hashCode;
                        public Token(MethodDescription.TypeToken typeToken) {
                            this.typeToken = typeToken;
                            hashCode = typeToken.getReturnType().hashCode() + 31 * typeToken.getParameterTypes().hashCode();
                        }
                        public int hashCode() {
                            return hashCode;
                        }
                        public boolean equals(@MaybeNull Object other) {
                            if (this == other) {
                                return true;
                            } else if (!(other instanceof Token)) {
                                return false;
                            }
                            Token token = (Token) other;
                            return typeToken.getReturnType().equals(token.typeToken.getReturnType()) && typeToken.getParameterTypes().equals(token.typeToken.getParameterTypes());
                        }
                        public String toString() {
                            return typeToken.toString();
                        }
                    }
                }
            }
            public interface Merger {
                MethodDescription merge(MethodDescription left, MethodDescription right);
                enum Directional implements Merger {
                    LEFT(true), RIGHT(false);
                    private final boolean left;
                    Directional(boolean left) {
                        this.left = left;
                    }
                    public MethodDescription merge(MethodDescription left, MethodDescription right) {
                        return this.left ? left : right;
                    }
                }
            }
            protected abstract static class Key<S> {
                protected final String internalName;
                protected final int parameterCount;
                protected Key(String internalName, int parameterCount) {
                    this.internalName = internalName;
                    this.parameterCount = parameterCount;
                }
                protected abstract Set<S> getIdentifiers();
                public int hashCode() {
                    return internalName.hashCode() + 31 * parameterCount;
                }
                public boolean equals(@MaybeNull Object other) {
                    if (this == other) {
                        return true;
                    } else if (!(other instanceof Key)) {
                        return false;
                    }
                    Key<?> key = (Key<?>) other;
                    return internalName.equals(key.internalName) && parameterCount == key.parameterCount && !Collections.disjoint(getIdentifiers(), key.getIdentifiers());
                }
                protected static class Harmonized<V> extends Key<V> {
                    private final Map<V, Set<MethodDescription.TypeToken>> identifiers;
                    protected Harmonized(String internalName, int parameterCount, Map<V, Set<MethodDescription.TypeToken>> identifiers) {
                        super(internalName, parameterCount);
                        this.identifiers = identifiers;
                    }
                    protected static <Q> Harmonized<Q> of(MethodDescription methodDescription, Harmonizer<Q> harmonizer) {
                        MethodDescription.TypeToken typeToken = methodDescription.asTypeToken();
                        return new Harmonized<Q>(methodDescription.getInternalName(), methodDescription.getParameters().size(), Collections.singletonMap(harmonizer.harmonize(typeToken), Collections.<MethodDescription.TypeToken>emptySet()));
                    }
                    protected Detached detach(MethodDescription.TypeToken typeToken) {
                        Set<MethodDescription.TypeToken> identifiers = new HashSet<MethodDescription.TypeToken>();
                        for (Set<MethodDescription.TypeToken> typeTokens : this.identifiers.values()) {
                            identifiers.addAll(typeTokens);
                        }
                        identifiers.add(typeToken);
                        return new Detached(internalName, parameterCount, identifiers);
                    }
                    protected Harmonized<V> combineWith(Harmonized<V> key) {
                        Map<V, Set<MethodDescription.TypeToken>> identifiers = new HashMap<V, Set<MethodDescription.TypeToken>>(this.identifiers);
                        for (Map.Entry<V, Set<MethodDescription.TypeToken>> entry : key.identifiers.entrySet()) {
                            Set<MethodDescription.TypeToken> typeTokens = identifiers.get(entry.getKey());
                            if (typeTokens == null) {
                                identifiers.put(entry.getKey(), entry.getValue());
                            } else {
                                typeTokens = new HashSet<MethodDescription.TypeToken>(typeTokens);
                                typeTokens.addAll(entry.getValue());
                                identifiers.put(entry.getKey(), typeTokens);
                            }
                        }
                        return new Harmonized<V>(internalName, parameterCount, identifiers);
                    }
                    protected Harmonized<V> extend(MethodDescription.InDefinedShape methodDescription, Harmonizer<V> harmonizer) {
                        Map<V, Set<MethodDescription.TypeToken>> identifiers = new HashMap<V, Set<MethodDescription.TypeToken>>(this.identifiers);
                        MethodDescription.TypeToken typeToken = methodDescription.asTypeToken();
                        V identifier = harmonizer.harmonize(typeToken);
                        Set<MethodDescription.TypeToken> typeTokens = identifiers.get(identifier);
                        if (typeTokens == null) {
                            identifiers.put(identifier, Collections.singleton(typeToken));
                        } else {
                            typeTokens = new HashSet<MethodDescription.TypeToken>(typeTokens);
                            typeTokens.add(typeToken);
                            identifiers.put(identifier, typeTokens);
                        }
                        return new Harmonized<V>(internalName, parameterCount, identifiers);
                    }
                    protected Set<V> getIdentifiers() {
                        return identifiers.keySet();
                    }
                }
                protected static class Detached extends Key<MethodDescription.TypeToken> {
                    private final Set<MethodDescription.TypeToken> identifiers;
                    protected Detached(String internalName, int parameterCount, Set<MethodDescription.TypeToken> identifiers) {
                        super(internalName, parameterCount);
                        this.identifiers = identifiers;
                    }
                    protected static Detached of(MethodDescription.SignatureToken token) {
                        return new Detached(token.getName(), token.getParameterTypes().size(), Collections.singleton(token.asTypeToken()));
                    }
                    protected Set<MethodDescription.TypeToken> getIdentifiers() {
                        return identifiers;
                    }
                }
                protected static class Store<V> {
                    private final LinkedHashMap<Harmonized<V>, Entry<V>> entries;
                    protected Store() {
                        this(new LinkedHashMap<Harmonized<V>, Entry<V>>());
                    }
                    private Store(LinkedHashMap<Harmonized<V>, Entry<V>> entries) {
                        this.entries = entries;
                    }
                    private static <W> Entry<W> combine(Entry<W> left, Entry<W> right) {
                        Set<MethodDescription> leftMethods = left.getCandidates(), rightMethods = right.getCandidates();
                        LinkedHashSet<MethodDescription> combined = new LinkedHashSet<MethodDescription>();
                        combined.addAll(leftMethods);
                        combined.addAll(rightMethods);
                        for (MethodDescription leftMethod : leftMethods) {
                            TypeDescription leftType = leftMethod.getDeclaringType().asErasure();
                            for (MethodDescription rightMethod : rightMethods) {
                                TypeDescription rightType = rightMethod.getDeclaringType().asErasure();
                                if (leftType.equals(rightType)) {
                                    break;
                                } else if (leftType.isAssignableTo(rightType)) {
                                    combined.remove(rightMethod);
                                    break;
                                } else if (leftType.isAssignableFrom(rightType)) {
                                    combined.remove(leftMethod);
                                    break;
                                }
                            }
                        }
                        Key.Harmonized<W> key = left.getKey().combineWith(right.getKey());
                        Visibility visibility = left.getVisibility().expandTo(right.getVisibility());
                        return combined.size() == 1 ? new Entry.Resolved<W>(key, combined.iterator().next(), visibility, Entry.Resolved.NOT_MADE_VISIBLE) : new Entry.Ambiguous<W>(key, combined, visibility);
                    }
                    protected Store<V> registerTopLevel(List<? extends MethodDescription> methodDescriptions, Harmonizer<V> harmonizer) {
                        if (methodDescriptions.isEmpty()) {
                            return this;
                        }
                        LinkedHashMap<Harmonized<V>, Entry<V>> entries = new LinkedHashMap<Harmonized<V>, Entry<V>>(this.entries);
                        for (MethodDescription methodDescription : methodDescriptions) {
                            Harmonized<V> key = Harmonized.of(methodDescription, harmonizer);
                            Entry<V> currentEntry = entries.remove(key), extendedEntry = (currentEntry == null ? new Entry.Initial<V>(key) : currentEntry).extendBy(methodDescription, harmonizer);
                            entries.put(extendedEntry.getKey(), extendedEntry);
                        }
                        return new Store<V>(entries);
                    }
                    protected Store<V> combineWith(Store<V> store) {
                        if (entries.isEmpty()) {
                            return store;
                        } else if (store.entries.isEmpty()) {
                            return this;
                        }
                        LinkedHashMap<Harmonized<V>, Entry<V>> entries = new LinkedHashMap<Harmonized<V>, Entry<V>>(this.entries);
                        for (Entry<V> entry : store.entries.values()) {
                            Entry<V> previousEntry = entries.remove(entry.getKey()), injectedEntry = previousEntry == null ? entry : combine(previousEntry, entry);
                            entries.put(injectedEntry.getKey(), injectedEntry);
                        }
                        return new Store<V>(entries);
                    }
                    protected Store<V> inject(Store<V> store) {
                        if (entries.isEmpty()) {
                            return store;
                        } else if (store.entries.isEmpty()) {
                            return this;
                        }
                        LinkedHashMap<Harmonized<V>, Entry<V>> entries = new LinkedHashMap<Harmonized<V>, Entry<V>>(this.entries);
                        for (Entry<V> entry : store.entries.values()) {
                            Entry<V> previous = entries.remove(entry.getKey()), injectedEntry = previous == null ? entry : previous.inject(entry);
                            entries.put(injectedEntry.getKey(), injectedEntry);
                        }
                        return new Store<V>(entries);
                    }
                    protected MethodGraph asGraph(Merger merger) {
                        LinkedHashMap<Key<MethodDescription.TypeToken>, Node> entries = new LinkedHashMap<Key<MethodDescription.TypeToken>, Node>();
                        for (Entry<V> entry : this.entries.values()) {
                            Node node = entry.asNode(merger);
                            entries.put(entry.getKey().detach(node.getRepresentative().asTypeToken()), node);
                        }
                        return new Graph(entries);
                    }
                    protected interface Entry<W> {
                        Harmonized<W> getKey();
                        Set<MethodDescription> getCandidates();
                        Visibility getVisibility();
                        Entry<W> extendBy(MethodDescription methodDescription, Harmonizer<W> harmonizer);
                        Entry<W> inject(Entry<W> entry);
                        Node asNode(Merger merger);
                        class Initial<U> implements Entry<U> {
                            private final Harmonized<U> key;
                            protected Initial(Harmonized<U> key) {
                                this.key = key;
                            }
                            public Harmonized<U> getKey() {
                                throw new IllegalStateException("Cannot extract key from initial entry:" + this);
                            }
                            public Set<MethodDescription> getCandidates() {
                                throw new IllegalStateException("Cannot extract method from initial entry:" + this);
                            }
                            public Visibility getVisibility() {
                                throw new IllegalStateException("Cannot extract visibility from initial entry:" + this);
                            }
                            public Entry<U> extendBy(MethodDescription methodDescription, Harmonizer<U> harmonizer) {
                                return new Resolved<U>(key.extend(methodDescription.asDefined(), harmonizer), methodDescription, methodDescription.getVisibility(), Resolved.NOT_MADE_VISIBLE);
                            }
                            public Entry<U> inject(Entry<U> entry) {
                                throw new IllegalStateException("Cannot inject into initial entry without a registered method: " + this);
                            }
                            public Node asNode(Merger merger) {
                                throw new IllegalStateException("Cannot transform initial entry without a registered method: " + this);
                            }
                            public int hashCode() {
                                return key.hashCode();
                            }
                            public boolean equals(@MaybeNull Object other) {
                                if (this == other) {
                                    return true;
                                } else if (other == null || getClass() != other.getClass()) {
                                    return false;
                                }
                                Initial<?> initial = (Initial<?>) other;
                                return key.equals(initial.key);
                            }
                        }
                        class Resolved<U> implements Entry<U> {
                            private static final int MADE_VISIBLE = Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED;
                            private static final boolean NOT_MADE_VISIBLE = false;
                            private final Harmonized<U> key;
                            private final MethodDescription methodDescription;
                            private final Visibility visibility;
                            private final boolean madeVisible;
                            protected Resolved(Harmonized<U> key, MethodDescription methodDescription, Visibility visibility) {
                                this(key, methodDescription, visibility, NOT_MADE_VISIBLE);
                            }
                            protected Resolved(Harmonized<U> key, MethodDescription methodDescription, Visibility visibility, boolean madeVisible) {
                                this.key = key;
                                this.methodDescription = methodDescription;
                                this.visibility = visibility;
                                this.madeVisible = madeVisible;
                            }
                            private static <V> Entry<V> of(Harmonized<V> key, MethodDescription override, MethodDescription original, Visibility visibility) {
                                visibility = visibility.expandTo(original.getVisibility()).expandTo(override.getVisibility());
                                return override.isBridge() ? new Resolved<V>(key, original, visibility, (original.getDeclaringType().getModifiers() & MADE_VISIBLE) == 0) : new Resolved<V>(key, override, visibility, NOT_MADE_VISIBLE);
                            }
                            public Harmonized<U> getKey() {
                                return key;
                            }
                            public Set<MethodDescription> getCandidates() {
                                return Collections.singleton(methodDescription);
                            }
                            public Visibility getVisibility() {
                                return visibility;
                            }
                            public Entry<U> extendBy(MethodDescription methodDescription, Harmonizer<U> harmonizer) {
                                Harmonized<U> key = this.key.extend(methodDescription.asDefined(), harmonizer);
                                Visibility visibility = this.visibility.expandTo(methodDescription.getVisibility());
                                return methodDescription.getDeclaringType().equals(this.methodDescription.getDeclaringType()) ? Ambiguous.of(key, methodDescription, this.methodDescription, visibility) : Resolved.of(key, methodDescription, this.methodDescription, visibility);
                            }
                            public Entry<U> inject(Entry<U> entry) {
                                if (methodDescription.getDeclaringType().isInterface()) {
                                    LinkedHashSet<MethodDescription> candidates = new LinkedHashSet<MethodDescription>();
                                    candidates.add(methodDescription);
                                    TypeDescription target = methodDescription.getDeclaringType().asErasure();
                                    for (MethodDescription methodDescription : entry.getCandidates()) {
                                        if (methodDescription.getDeclaringType().asErasure().isAssignableTo(target)) {
                                            candidates.remove(this.methodDescription);
                                            candidates.add(methodDescription);
                                        } else if (!methodDescription.getDeclaringType().asErasure().isAssignableFrom(target)) {
                                            candidates.add(methodDescription);
                                        }
                                    }
                                    return candidates.size() == 1 ? new Resolved<U>(key.combineWith(entry.getKey()), candidates.iterator().next(), visibility.expandTo(entry.getVisibility()), madeVisible) : new Ambiguous<U>(key.combineWith(entry.getKey()), candidates, visibility.expandTo(entry.getVisibility()));
                                } else {
                                    return new Resolved<U>(key.combineWith(entry.getKey()), methodDescription, visibility.expandTo(entry.getVisibility()), madeVisible);
                                }
                            }
                            public MethodGraph.Node asNode(Merger merger) {
                                return new Node(key.detach(methodDescription.asTypeToken()), methodDescription, visibility, madeVisible);
                            }
                            protected static class Node implements MethodGraph.Node {
                                private final Detached key;
                                private final MethodDescription methodDescription;
                                private final Visibility visibility;
                                private final boolean visible;
                                protected Node(Detached key, MethodDescription methodDescription, Visibility visibility, boolean visible) {
                                    this.key = key;
                                    this.methodDescription = methodDescription;
                                    this.visibility = visibility;
                                    this.visible = visible;
                                }
                                public Sort getSort() {
                                    return visible ? Sort.VISIBLE : Sort.RESOLVED;
                                }
                                public MethodDescription getRepresentative() {
                                    return methodDescription;
                                }
                                public Set<MethodDescription.TypeToken> getMethodTypes() {
                                    return key.getIdentifiers();
                                }
                                public Visibility getVisibility() {
                                    return visibility;
                                }
                            }
                        }
                        class Ambiguous<U> implements Entry<U> {
                            private final Harmonized<U> key;
                            private final LinkedHashSet<MethodDescription> methodDescriptions;
                            private final Visibility visibility;
                            protected Ambiguous(Harmonized<U> key, LinkedHashSet<MethodDescription> methodDescriptions, Visibility visibility) {
                                this.key = key;
                                this.methodDescriptions = methodDescriptions;
                                this.visibility = visibility;
                            }
                            protected static <Q> Entry<Q> of(Harmonized<Q> key, MethodDescription left, MethodDescription right, Visibility visibility) {
                                visibility = visibility.expandTo(left.getVisibility()).expandTo(right.getVisibility());
                                return left.isBridge() ^ right.isBridge() ? new Resolved<Q>(key, left.isBridge() ? right : left, visibility, Resolved.NOT_MADE_VISIBLE) : new Ambiguous<Q>(key, new LinkedHashSet<MethodDescription>(Arrays.asList(left, right)), visibility);
                            }
                            public Harmonized<U> getKey() {
                                return key;
                            }
                            public Set<MethodDescription> getCandidates() {
                                return methodDescriptions;
                            }
                            public Visibility getVisibility() {
                                return visibility;
                            }
                            public Entry<U> extendBy(MethodDescription methodDescription, Harmonizer<U> harmonizer) {
                                Harmonized<U> key = this.key.extend(methodDescription.asDefined(), harmonizer);
                                LinkedHashSet<MethodDescription> methodDescriptions = new LinkedHashSet<MethodDescription>();
                                TypeDescription declaringType = methodDescription.getDeclaringType().asErasure();
                                boolean bridge = methodDescription.isBridge();
                                Visibility visibility = this.visibility;
                                for (MethodDescription extendedMethod : this.methodDescriptions) {
                                    if (extendedMethod.getDeclaringType().asErasure().equals(declaringType)) {
                                        if (extendedMethod.isBridge() ^ bridge) {
                                            methodDescriptions.add(bridge ? extendedMethod : methodDescription);
                                        } else {
                                            methodDescriptions.add(methodDescription);
                                            methodDescriptions.add(extendedMethod);
                                        }
                                    }
                                    visibility = visibility.expandTo(extendedMethod.getVisibility());
                                }
                                if (methodDescriptions.isEmpty()) {
                                    return new Resolved<U>(key, methodDescription, visibility, bridge);
                                } else if (methodDescriptions.size() == 1) {
                                    return new Resolved<U>(key, methodDescriptions.iterator().next(), visibility, Resolved.NOT_MADE_VISIBLE);
                                } else {
                                    return new Ambiguous<U>(key, methodDescriptions, visibility);
                                }
                            }
                            public Entry<U> inject(Entry<U> entry) {
                                LinkedHashSet<MethodDescription> methodDescriptions = new LinkedHashSet<MethodDescription>();
                                outer: for (MethodDescription methodDescription : this.methodDescriptions) {
                                    TypeDescription target = methodDescription.getDeclaringType().asErasure();
                                    for (MethodDescription candidate : entry.getCandidates()) {
                                        TypeDescription typeDescription = candidate.getDeclaringType().asErasure();
                                        if (!typeDescription.equals(target) && typeDescription.isAssignableTo(target)) {
                                            continue outer;
                                        }
                                    }
                                    methodDescriptions.add(methodDescription);
                                }
                                outer: for (MethodDescription candidate : entry.getCandidates()) {
                                    TypeDescription target = candidate.getDeclaringType().asErasure();
                                    for (MethodDescription methodDescription : this.methodDescriptions) {
                                        if (methodDescription.getDeclaringType().asErasure().isAssignableTo(target)) {
                                            continue outer;
                                        }
                                    }
                                    methodDescriptions.add(candidate);
                                }
                                return methodDescriptions.size() == 1 ? new Resolved<U>(key.combineWith(entry.getKey()), methodDescriptions.iterator().next(), visibility.expandTo(entry.getVisibility())) : new Ambiguous<U>(key.combineWith(entry.getKey()), methodDescriptions, visibility.expandTo(entry.getVisibility()));
                            }
                            public MethodGraph.Node asNode(Merger merger) {
                                Iterator<MethodDescription> iterator = methodDescriptions.iterator();
                                MethodDescription methodDescription = iterator.next();
                                while (iterator.hasNext()) {
                                    methodDescription = merger.merge(methodDescription, iterator.next());
                                }
                                return new Node(key.detach(methodDescription.asTypeToken()), methodDescription, visibility);
                            }
                            protected static class Node implements MethodGraph.Node {
                                private final Detached key;
                                private final MethodDescription methodDescription;
                                private final Visibility visibility;
                                protected Node(Detached key, MethodDescription methodDescription, Visibility visibility) {
                                    this.key = key;
                                    this.methodDescription = methodDescription;
                                    this.visibility = visibility;
                                }
                                public Sort getSort() {
                                    return Sort.AMBIGUOUS;
                                }
                                public MethodDescription getRepresentative() {
                                    return methodDescription;
                                }
                                public Set<MethodDescription.TypeToken> getMethodTypes() {
                                    return key.getIdentifiers();
                                }
                                public Visibility getVisibility() {
                                    return visibility;
                                }
                            }
                        }
                    }
                    protected static class Graph implements MethodGraph {
                        private final LinkedHashMap<Key<MethodDescription.TypeToken>, Node> entries;
                        protected Graph(LinkedHashMap<Key<MethodDescription.TypeToken>, Node> entries) {
                            this.entries = entries;
                        }
                        public Node locate(MethodDescription.SignatureToken token) {
                            Node node = entries.get(Detached.of(token));
                            return node == null ? Node.Unresolved.INSTANCE : node;
                        }
                        public NodeList listNodes() {
                            return new NodeList(new ArrayList<Node>(entries.values()));
                        }
                    }
                }
            }
        }
    }
    class NodeList extends FilterableList.AbstractBase<Node, NodeList> {
        private final List<? extends Node> nodes;
        public NodeList(List<? extends Node> nodes) {
            this.nodes = nodes;
        }
        public Node get(int index) {
            return nodes.get(index);
        }
        public int size() {
            return nodes.size();
        }
        protected NodeList wrap(List<Node> values) {
            return new NodeList(values);
        }
        public MethodList<?> asMethodList() {
            List<MethodDescription> methodDescriptions = new ArrayList<MethodDescription>(size());
            for (Node node : nodes) {
                methodDescriptions.add(node.getRepresentative());
            }
            return new MethodList.Explicit<MethodDescription>(methodDescriptions);
        }
    }
    class Simple implements MethodGraph {
        private final LinkedHashMap<MethodDescription.SignatureToken, Node> nodes;
        public Simple(LinkedHashMap<MethodDescription.SignatureToken, Node> nodes) {
            this.nodes = nodes;
        }
        public static MethodGraph of(List<? extends MethodDescription> methodDescriptions) {
            LinkedHashMap<MethodDescription.SignatureToken, Node> nodes = new LinkedHashMap<MethodDescription.SignatureToken, Node>();
            for (MethodDescription methodDescription : methodDescriptions) {
                nodes.put(methodDescription.asSignatureToken(), new Node.Simple(methodDescription));
            }
            return new Simple(nodes);
        }
        public Node locate(MethodDescription.SignatureToken token) {
            Node node = nodes.get(token);
            return node == null ? Node.Unresolved.INSTANCE : node;
        }
        public NodeList listNodes() {
            return new NodeList(new ArrayList<Node>(nodes.values()));
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```