##CONTEXT_SIZE=1768
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.benchmark;
public class StubInvocationBenchmark {
    private String stringValue = "foo";
    private boolean booleanValue = true;
    private byte byteValue = 42;
    private short shortValue = 42;
    private char charValue = '@';
    private int intValue = 42;
    private long longValue = 42L;
    private float floatValue = 42f;
    private double doubleValue = 42d;
    private ExampleInterface baselineInstance;
    private ExampleInterface byteBuddyInstance;
    private ExampleInterface cglibInstance;
    private ExampleInterface javassistInstance;
    private ExampleInterface jdkProxyInstance;
    public void setUp() throws Exception {
        ClassByImplementationBenchmark classByImplementationBenchmark = new ClassByImplementationBenchmark();
        baselineInstance = classByImplementationBenchmark.baseline();
        byteBuddyInstance = classByImplementationBenchmark.benchmarkByteBuddy();
        cglibInstance = classByImplementationBenchmark.benchmarkCglib();
        javassistInstance = classByImplementationBenchmark.benchmarkJavassist();
        jdkProxyInstance = classByImplementationBenchmark.benchmarkJdkProxy();
    }
    public void baseline(Blackhole blackHole) {
        blackHole.consume(baselineInstance.method(booleanValue));
        blackHole.consume(baselineInstance.method(byteValue));
        blackHole.consume(baselineInstance.method(shortValue));
        blackHole.consume(baselineInstance.method(intValue));
        blackHole.consume(baselineInstance.method(charValue));
        blackHole.consume(baselineInstance.method(intValue));
        blackHole.consume(baselineInstance.method(longValue));
        blackHole.consume(baselineInstance.method(floatValue));
        blackHole.consume(baselineInstance.method(doubleValue));
        blackHole.consume(baselineInstance.method(stringValue));
        blackHole.consume(baselineInstance.method(booleanValue, booleanValue, booleanValue));
        blackHole.consume(baselineInstance.method(byteValue, byteValue, byteValue));
        blackHole.consume(baselineInstance.method(shortValue, shortValue, shortValue));
        blackHole.consume(baselineInstance.method(intValue, intValue, intValue));
        blackHole.consume(baselineInstance.method(charValue, charValue, charValue));
        blackHole.consume(baselineInstance.method(intValue, intValue, intValue));
        blackHole.consume(baselineInstance.method(longValue, longValue, longValue));
        blackHole.consume(baselineInstance.method(floatValue, floatValue, floatValue));
        blackHole.consume(baselineInstance.method(doubleValue, doubleValue, doubleValue));
        blackHole.consume(baselineInstance.method(stringValue, stringValue, stringValue));
    }
    public void benchmarkByteBuddy(Blackhole blackHole) {
        blackHole.consume(byteBuddyInstance.method(booleanValue));
        blackHole.consume(byteBuddyInstance.method(byteValue));
        blackHole.consume(byteBuddyInstance.method(shortValue));
        blackHole.consume(byteBuddyInstance.method(intValue));
        blackHole.consume(byteBuddyInstance.method(charValue));
        blackHole.consume(byteBuddyInstance.method(intValue));
        blackHole.consume(byteBuddyInstance.method(longValue));
        blackHole.consume(byteBuddyInstance.method(floatValue));
        blackHole.consume(byteBuddyInstance.method(doubleValue));
        blackHole.consume(byteBuddyInstance.method(stringValue));
        blackHole.consume(byteBuddyInstance.method(booleanValue, booleanValue, booleanValue));
        blackHole.consume(byteBuddyInstance.method(byteValue, byteValue, byteValue));
        blackHole.consume(byteBuddyInstance.method(shortValue, shortValue, shortValue));
        blackHole.consume(byteBuddyInstance.method(intValue, intValue, intValue));
        blackHole.consume(byteBuddyInstance.method(charValue, charValue, charValue));
        blackHole.consume(byteBuddyInstance.method(intValue, intValue, intValue));
        blackHole.consume(byteBuddyInstance.method(longValue, longValue, longValue));
        blackHole.consume(byteBuddyInstance.method(floatValue, floatValue, floatValue));
        blackHole.consume(byteBuddyInstance.method(doubleValue, doubleValue, doubleValue));
        blackHole.consume(byteBuddyInstance.method(stringValue, stringValue, stringValue));
    }
    public void benchmarkCglib(Blackhole blackHole) {
        blackHole.consume(cglibInstance.method(booleanValue));
        blackHole.consume(cglibInstance.method(byteValue));
        blackHole.consume(cglibInstance.method(shortValue));
        blackHole.consume(cglibInstance.method(intValue));
        blackHole.consume(cglibInstance.method(charValue));
        blackHole.consume(cglibInstance.method(intValue));
        blackHole.consume(cglibInstance.method(longValue));
        blackHole.consume(cglibInstance.method(floatValue));
        blackHole.consume(cglibInstance.method(doubleValue));
        blackHole.consume(cglibInstance.method(stringValue));
        blackHole.consume(cglibInstance.method(booleanValue, booleanValue, booleanValue));
        blackHole.consume(cglibInstance.method(byteValue, byteValue, byteValue));
        blackHole.consume(cglibInstance.method(shortValue, shortValue, shortValue));
        blackHole.consume(cglibInstance.method(intValue, intValue, intValue));
        blackHole.consume(cglibInstance.method(charValue, charValue, charValue));
        blackHole.consume(cglibInstance.method(intValue, intValue, intValue));
        blackHole.consume(cglibInstance.method(longValue, longValue, longValue));
        blackHole.consume(cglibInstance.method(floatValue, floatValue, floatValue));
        blackHole.consume(cglibInstance.method(doubleValue, doubleValue, doubleValue));
        blackHole.consume(cglibInstance.method(stringValue, stringValue, stringValue));
    }
    public void benchmarkJavassist(Blackhole blackHole) {
        blackHole.consume(javassistInstance.method(booleanValue));
        blackHole.consume(javassistInstance.method(byteValue));
        blackHole.consume(javassistInstance.method(shortValue));
        blackHole.consume(javassistInstance.method(intValue));
        blackHole.consume(javassistInstance.method(charValue));
        blackHole.consume(javassistInstance.method(intValue));
        blackHole.consume(javassistInstance.method(longValue));
        blackHole.consume(javassistInstance.method(floatValue));
        blackHole.consume(javassistInstance.method(doubleValue));
        blackHole.consume(javassistInstance.method(stringValue));
        blackHole.consume(javassistInstance.method(booleanValue, booleanValue, booleanValue));
        blackHole.consume(javassistInstance.method(byteValue, byteValue, byteValue));
        blackHole.consume(javassistInstance.method(shortValue, shortValue, shortValue));
        blackHole.consume(javassistInstance.method(intValue, intValue, intValue));
        blackHole.consume(javassistInstance.method(charValue, charValue, charValue));
        blackHole.consume(javassistInstance.method(intValue, intValue, intValue));
        blackHole.consume(javassistInstance.method(longValue, longValue, longValue));
        blackHole.consume(javassistInstance.method(floatValue, floatValue, floatValue));
        blackHole.consume(javassistInstance.method(doubleValue, doubleValue, doubleValue));
        blackHole.consume(javassistInstance.method(stringValue, stringValue, stringValue));
    }
    public void benchmarkJdkProxy(Blackhole blackHole) {
        blackHole.consume(jdkProxyInstance.method(booleanValue));
        blackHole.consume(jdkProxyInstance.method(byteValue));
        blackHole.consume(jdkProxyInstance.method(shortValue));
        blackHole.consume(jdkProxyInstance.method(intValue));
        blackHole.consume(jdkProxyInstance.method(charValue));
        blackHole.consume(jdkProxyInstance.method(intValue));
        blackHole.consume(jdkProxyInstance.method(longValue));
        blackHole.consume(jdkProxyInstance.method(floatValue));
        blackHole.consume(jdkProxyInstance.method(doubleValue));
        blackHole.consume(jdkProxyInstance.method(stringValue));
        blackHole.consume(jdkProxyInstance.method(booleanValue, booleanValue, booleanValue));
        blackHole.consume(jdkProxyInstance.method(byteValue, byteValue, byteValue));
        blackHole.consume(jdkProxyInstance.method(shortValue, shortValue, shortValue));
        blackHole.consume(jdkProxyInstance.method(intValue, intValue, intValue));
        blackHole.consume(jdkProxyInstance.method(charValue, charValue, charValue));
        blackHole.consume(jdkProxyInstance.method(intValue, intValue, intValue));
        blackHole.consume(jdkProxyInstance.method(longValue, longValue, longValue));
        blackHole.consume(jdkProxyInstance.method(floatValue, floatValue, floatValue));
        blackHole.consume(jdkProxyInstance.method(doubleValue, doubleValue, doubleValue));
        blackHole.consume(jdkProxyInstance.method(stringValue, stringValue, stringValue));
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```