##CONTEXT_SIZE=5521
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.agent;
public class ByteBuddyAgent {
    public static final String LATENT_RESOLVE = "net.bytebuddy.agent.latent";
    private static final String AGENT_CLASS_PROPERTY = "Agent-Class";
    private static final String CAN_REDEFINE_CLASSES_PROPERTY = "Can-Redefine-Classes";
    private static final String CAN_RETRANSFORM_CLASSES_PROPERTY = "Can-Retransform-Classes";
    private static final String CAN_SET_NATIVE_METHOD_PREFIX = "Can-Set-Native-Method-Prefix";
    private static final String MANIFEST_VERSION_VALUE = "1.0";
    private static final ClassLoader BOOTSTRAP_CLASS_LOADER = null;
    private static final String WITHOUT_ARGUMENT = null;
    private static final String ATTACHER_FILE_NAME = "byteBuddyAttacher";
    private static final String CLASS_FILE_EXTENSION = ".class";
    private static final String JAR_FILE_EXTENSION = ".jar";
    private static final String CLASS_PATH_ARGUMENT = "-cp";
    private static final String AGENT_ARGUMENT_SEPARATOR = "=";
    private static final String JAVA_HOME = "java.home";
    private static final String OS_NAME = "os.name";
    private static final AttachmentTypeEvaluator ATTACHMENT_TYPE_EVALUATOR = doPrivileged(AttachmentTypeEvaluator.InstallationAction.INSTANCE);
    private ByteBuddyAgent() {
        throw new UnsupportedOperationException("This class is a utility class and not supposed to be instantiated");
    }
    private static <T> T doPrivileged(PrivilegedAction<T> action) {
        try {
            return (T) Class.forName("java.security.AccessController").getMethod("doPrivileged", PrivilegedAction.class).invoke(null, action);
        } catch (ClassNotFoundException ignored) {
            return action.run();
        } catch (InvocationTargetException exception) {
            throw new IllegalStateException("Failed to invoke access controller", exception.getTargetException());
        } catch (IllegalAccessException exception) {
            throw new IllegalStateException("Failed to access access controller", exception);
        } catch (NoSuchMethodException exception) {
            throw new IllegalStateException("Failed to resolve well-known access controller method", exception);
        }
    }
    public static Instrumentation getInstrumentation() {
        Instrumentation instrumentation = doGetInstrumentation();
        if (instrumentation == null) {
            throw new IllegalStateException("The Byte Buddy agent is not initialized or unavailable");
        } else {
            return instrumentation;
        }
    }
    public static void attach(File agentJar, String processId) {
        attach(agentJar, processId, WITHOUT_ARGUMENT);
    }
    public static void attach(File agentJar, String processId, @MaybeNull String argument) {
        attach(agentJar, processId, argument, AttachmentProvider.DEFAULT);
    }
    public static void attach(File agentJar, String processId, AttachmentProvider attachmentProvider) {
        attach(agentJar, processId, WITHOUT_ARGUMENT, attachmentProvider);
    }
    public static void attach(File agentJar, String processId, @MaybeNull String argument, AttachmentProvider attachmentProvider) {
        install(attachmentProvider, processId, argument, new AgentProvider.ForExistingAgent(agentJar), false);
    }
    public static void attach(File agentJar, ProcessProvider processProvider) {
        attach(agentJar, processProvider, WITHOUT_ARGUMENT);
    }
    public static void attach(File agentJar, ProcessProvider processProvider, @MaybeNull String argument) {
        attach(agentJar, processProvider, argument, AttachmentProvider.DEFAULT);
    }
    public static void attach(File agentJar, ProcessProvider processProvider, AttachmentProvider attachmentProvider) {
        attach(agentJar, processProvider, WITHOUT_ARGUMENT, attachmentProvider);
    }
    public static void attach(File agentJar, ProcessProvider processProvider, @MaybeNull String argument, AttachmentProvider attachmentProvider) {
        install(attachmentProvider, processProvider.resolve(), argument, new AgentProvider.ForExistingAgent(agentJar), false);
    }
    public static void attachNative(File agentLibrary, String processId) {
        attachNative(agentLibrary, processId, WITHOUT_ARGUMENT);
    }
    public static void attachNative(File agentLibrary, String processId, @MaybeNull String argument) {
        attachNative(agentLibrary, processId, argument, AttachmentProvider.DEFAULT);
    }
    public static void attachNative(File agentLibrary, String processId, AttachmentProvider attachmentProvider) {
        attachNative(agentLibrary, processId, WITHOUT_ARGUMENT, attachmentProvider);
    }
    public static void attachNative(File agentLibrary, String processId, @MaybeNull String argument, AttachmentProvider attachmentProvider) {
        install(attachmentProvider, processId, argument, new AgentProvider.ForExistingAgent(agentLibrary), true);
    }
    public static void attachNative(File agentLibrary, ProcessProvider processProvider) {
        attachNative(agentLibrary, processProvider, WITHOUT_ARGUMENT);
    }
    public static void attachNative(File agentLibrary, ProcessProvider processProvider, @MaybeNull String argument) {
        attachNative(agentLibrary, processProvider, argument, AttachmentProvider.DEFAULT);
    }
    public static void attachNative(File agentLibrary, ProcessProvider processProvider, AttachmentProvider attachmentProvider) {
        attachNative(agentLibrary, processProvider, WITHOUT_ARGUMENT, attachmentProvider);
    }
    public static void attachNative(File agentLibrary, ProcessProvider processProvider, @MaybeNull String argument, AttachmentProvider attachmentProvider) {
        install(attachmentProvider, processProvider.resolve(), argument, new AgentProvider.ForExistingAgent(agentLibrary), true);
    }
    public static Instrumentation install() {
        return install(AttachmentProvider.DEFAULT);
    }
    public static Instrumentation install(AttachmentProvider attachmentProvider) {
        return install(attachmentProvider, ProcessProvider.ForCurrentVm.INSTANCE);
    }
    public static Instrumentation install(ProcessProvider processProvider) {
        return install(AttachmentProvider.DEFAULT, processProvider);
    }
    public static synchronized Instrumentation install(AttachmentProvider attachmentProvider, ProcessProvider processProvider) {
        Instrumentation instrumentation = doGetInstrumentation();
        if (instrumentation != null) {
            return instrumentation;
        }
        install(attachmentProvider, processProvider.resolve(), WITHOUT_ARGUMENT, AgentProvider.ForByteBuddyAgent.INSTANCE, false);
        return getInstrumentation();
    }
    private static void install(AttachmentProvider attachmentProvider, String processId, @MaybeNull String argument, AgentProvider agentProvider, boolean isNative) {
        AttachmentProvider.Accessor attachmentAccessor = attachmentProvider.attempt();
        if (!attachmentAccessor.isAvailable()) {
            throw new IllegalStateException("No compatible attachment provider is available");
        }
        try {
            if (attachmentAccessor.isExternalAttachmentRequired() && ATTACHMENT_TYPE_EVALUATOR.requiresExternalAttachment(processId)) {
                installExternal(attachmentAccessor.getExternalAttachment(), processId, agentProvider.resolve(), isNative, argument);
            } else {
                Attacher.install(attachmentAccessor.getVirtualMachineType(), processId, agentProvider.resolve().getAbsolutePath(), isNative, argument);
            }
        } catch (RuntimeException exception) {
            throw exception;
        } catch (Exception exception) {
            throw new IllegalStateException("Error during attachment using: " + attachmentProvider, exception);
        }
    }
    private static void installExternal(AttachmentProvider.Accessor.ExternalAttachment externalAttachment, String processId, File agent, boolean isNative, @MaybeNull String argument) throws Exception {
        File selfResolvedJar = trySelfResolve(), attachmentJar = null;
        try {
            if (selfResolvedJar == null) {
                InputStream inputStream = Attacher.class.getResourceAsStream('/' + Attacher.class.getName().replace('.', '/') + CLASS_FILE_EXTENSION);
                if (inputStream == null) {
                    throw new IllegalStateException("Cannot locate class file for Byte Buddy installation process");
                }
                try {
                    attachmentJar = File.createTempFile(ATTACHER_FILE_NAME, JAR_FILE_EXTENSION);
                    OutputStream outputStream = new FileOutputStream(attachmentJar);
                    try {
                        JarOutputStream jarOutputStream = new JarOutputStream(outputStream);
                        jarOutputStream.putNextEntry(new JarEntry(Attacher.class.getName().replace('.', '/') + CLASS_FILE_EXTENSION));
                        byte[] buffer = new byte[1024 * 8];
                        int index;
                        while ((index = inputStream.read(buffer)) != -1) {
                            jarOutputStream.write(buffer, 0, index);
                        }
                        jarOutputStream.closeEntry();
                        jarOutputStream.close();
                    } finally {
                        outputStream.close();
                    }
                } finally {
                    inputStream.close();
                }
            }
            StringBuilder classPath = new StringBuilder().append((selfResolvedJar == null ? attachmentJar : selfResolvedJar).getCanonicalPath());
            for (File jar : externalAttachment.getClassPath()) {
                classPath.append(File.pathSeparatorChar).append(jar.getCanonicalPath());
            }
            if (new ProcessBuilder(System.getProperty(JAVA_HOME) + File.separatorChar + "bin" + File.separatorChar + (System.getProperty(OS_NAME, "").toLowerCase(Locale.US).contains("windows") ? "java.exe" : "java"), "-D" + Attacher.DUMP_PROPERTY + AGENT_ARGUMENT_SEPARATOR + System.getProperty(Attacher.DUMP_PROPERTY, ""), CLASS_PATH_ARGUMENT, classPath.toString(), Attacher.class.getName(), externalAttachment.getVirtualMachineType(), processId, agent.getAbsolutePath(), Boolean.toString(isNative), argument == null ? "" : (AGENT_ARGUMENT_SEPARATOR + argument)).start().waitFor() != 0) {
                throw new IllegalStateException("Could not self-attach to current VM using external process - set a property " + Attacher.DUMP_PROPERTY + " to dump the process output to a file at the specified location");
            }
        } finally {
            if (attachmentJar != null) {
                if (!attachmentJar.delete()) {
                    attachmentJar.deleteOnExit();
                }
            }
        }
    }
    private static File trySelfResolve() {
        try {
            if (Boolean.getBoolean(LATENT_RESOLVE)) {
                return null;
            }
            ProtectionDomain protectionDomain = Attacher.class.getProtectionDomain();
            if (protectionDomain == null) {
                return null;
            }
            CodeSource codeSource = protectionDomain.getCodeSource();
            if (codeSource == null) {
                return null;
            }
            URL location = codeSource.getLocation();
            if (!location.getProtocol().equals("file")) {
                return null;
            }
            try {
                File file = new File(location.toURI());
                if (file.getPath().contains(AGENT_ARGUMENT_SEPARATOR)) {
                    return null;
                }
                return file;
            } catch (URISyntaxException ignored) {
                return new File(location.getPath());
            }
        } catch (Exception ignored) {
            return null;
        }
    }
    private static Instrumentation doGetInstrumentation() {
        if (!Installer.NAME.equals(Installer.class.getName())) {
            Instrumentation instrumentation = doGetInstrumentation(Installer.NAME);
            if (instrumentation != null) {
                return instrumentation;
            }
        }
        return doGetInstrumentation(Installer.class.getName());
    }
    private static Instrumentation doGetInstrumentation(String name) {
        try {
            Class<?> installer = Class.forName(name, true, ClassLoader.getSystemClassLoader());
            try {
                Class<?> module = Class.forName("java.lang.Module");
                Method getModule = Class.class.getMethod("getModule");
                Object source = getModule.invoke(ByteBuddyAgent.class), target = getModule.invoke(installer);
                if (!((Boolean) module.getMethod("canRead", module).invoke(source, target))) {
                    module.getMethod("addReads", module).invoke(source, target);
                }
            } catch (ClassNotFoundException ignored) {
            }
            return (Instrumentation) Class.forName(name, true, ClassLoader.getSystemClassLoader()).getMethod("getInstrumentation").invoke(null);
        } catch (Exception ignored) {
            return null;
        }
    }
    public interface AttachmentProvider {
        AttachmentProvider DEFAULT = new Compound(ForModularizedVm.INSTANCE, ForJ9Vm.INSTANCE, ForStandardToolsJarVm.JVM_ROOT, ForStandardToolsJarVm.JDK_ROOT, ForStandardToolsJarVm.MACINTOSH, ForUserDefinedToolsJar.INSTANCE, ForEmulatedAttachment.INSTANCE);
        Accessor attempt();
        interface Accessor {
            String VIRTUAL_MACHINE_TYPE_NAME = "com.sun.tools.attach.VirtualMachine";
            String VIRTUAL_MACHINE_TYPE_NAME_J9 = "com.ibm.tools.attach.VirtualMachine";
            boolean isAvailable();
            boolean isExternalAttachmentRequired();
            Class<?> getVirtualMachineType();
            ExternalAttachment getExternalAttachment();
            enum Unavailable implements Accessor {
                INSTANCE;
                public boolean isAvailable() {
                    return false;
                }
                public boolean isExternalAttachmentRequired() {
                    throw new IllegalStateException("Cannot read the virtual machine type for an unavailable accessor");
                }
                public Class<?> getVirtualMachineType() {
                    throw new IllegalStateException("Cannot read the virtual machine type for an unavailable accessor");
                }
                public ExternalAttachment getExternalAttachment() {
                    throw new IllegalStateException("Cannot read the virtual machine type for an unavailable accessor");
                }
            }
            class ExternalAttachment {
                private final String virtualMachineType;
                private final List<File> classPath;
                public ExternalAttachment(String virtualMachineType, List<File> classPath) {
                    this.virtualMachineType = virtualMachineType;
                    this.classPath = classPath;
                }
                public String getVirtualMachineType() {
                    return virtualMachineType;
                }
                public List<File> getClassPath() {
                    return classPath;
                }
            }
            abstract class Simple implements Accessor {
                protected final Class<?> virtualMachineType;
                protected Simple(Class<?> virtualMachineType) {
                    this.virtualMachineType = virtualMachineType;
                }
                public static Accessor of(@MaybeNull ClassLoader classLoader, File... classPath) {
                    try {
                        return new Simple.WithExternalAttachment(Class.forName(VIRTUAL_MACHINE_TYPE_NAME, false, classLoader), Arrays.asList(classPath));
                    } catch (ClassNotFoundException ignored) {
                        return Unavailable.INSTANCE;
                    }
                }
                public static Accessor ofJ9() {
                    try {
                        return new Simple.WithExternalAttachment(ClassLoader.getSystemClassLoader().loadClass(VIRTUAL_MACHINE_TYPE_NAME_J9), Collections.<File>emptyList());
                    } catch (ClassNotFoundException ignored) {
                        return Unavailable.INSTANCE;
                    }
                }
                public boolean isAvailable() {
                    return true;
                }
                public Class<?> getVirtualMachineType() {
                    return virtualMachineType;
                }
                protected static class WithExternalAttachment extends Simple {
                    private final List<File> classPath;
                    public WithExternalAttachment(Class<?> virtualMachineType, List<File> classPath) {
                        super(virtualMachineType);
                        this.classPath = classPath;
                    }
                    public boolean isExternalAttachmentRequired() {
                        return true;
                    }
                    public ExternalAttachment getExternalAttachment() {
                        return new ExternalAttachment(virtualMachineType.getName(), classPath);
                    }
                }
                protected static class WithDirectAttachment extends Simple {
                    public WithDirectAttachment(Class<?> virtualMachineType) {
                        super(virtualMachineType);
                    }
                    public boolean isExternalAttachmentRequired() {
                        return false;
                    }
                    public ExternalAttachment getExternalAttachment() {
                        throw new IllegalStateException("Cannot apply external attachment");
                    }
                }
            }
        }
        enum ForModularizedVm implements AttachmentProvider {
            INSTANCE;
            public Accessor attempt() {
                return Accessor.Simple.of(ClassLoader.getSystemClassLoader());
            }
        }
        enum ForJ9Vm implements AttachmentProvider {
            INSTANCE;
            public Accessor attempt() {
                return Accessor.Simple.ofJ9();
            }
        }
        enum ForStandardToolsJarVm implements AttachmentProvider {
            JVM_ROOT("../lib/tools.jar"), JDK_ROOT("lib/tools.jar"), MACINTOSH("../Classes/classes.jar");
            private static final String JAVA_HOME_PROPERTY = "java.home";
            private final String toolsJarPath;
            ForStandardToolsJarVm(String toolsJarPath) {
                this.toolsJarPath = toolsJarPath;
            }
            public Accessor attempt() {
                File toolsJar = new File(System.getProperty(JAVA_HOME_PROPERTY), toolsJarPath);
                try {
                    return toolsJar.isFile() && toolsJar.canRead() ? Accessor.Simple.of(new URLClassLoader(new URL[] { toolsJar.toURI().toURL() }, BOOTSTRAP_CLASS_LOADER), toolsJar) : Accessor.Unavailable.INSTANCE;
                } catch (MalformedURLException exception) {
                    throw new IllegalStateException("Could not represent " + toolsJar + " as URL");
                }
            }
        }
        enum ForUserDefinedToolsJar implements AttachmentProvider {
            INSTANCE;
            public static final String PROPERTY = "net.bytebuddy.agent.toolsjar";
            public Accessor attempt() {
                String location = System.getProperty(PROPERTY);
                if (location == null) {
                    return Accessor.Unavailable.INSTANCE;
                } else {
                    File toolsJar = new File(location);
                    try {
                        return Accessor.Simple.of(new URLClassLoader(new URL[] { toolsJar.toURI().toURL() }, BOOTSTRAP_CLASS_LOADER), toolsJar);
                    } catch (MalformedURLException exception) {
                        throw new IllegalStateException("Could not represent " + toolsJar + " as URL");
                    }
                }
            }
        }
        enum ForEmulatedAttachment implements AttachmentProvider {
            INSTANCE;
            public Accessor attempt() {
                try {
                    return new Accessor.Simple.WithDirectAttachment(doPrivileged(VirtualMachine.Resolver.INSTANCE));
                } catch (Throwable ignored) {
                    return Accessor.Unavailable.INSTANCE;
                }
            }
        }
        class Compound implements AttachmentProvider {
            private final List<AttachmentProvider> attachmentProviders;
            public Compound(AttachmentProvider... attachmentProvider) {
                this(Arrays.asList(attachmentProvider));
            }
            public Compound(List<? extends AttachmentProvider> attachmentProviders) {
                this.attachmentProviders = new ArrayList<AttachmentProvider>();
                for (AttachmentProvider attachmentProvider : attachmentProviders) {
                    if (attachmentProvider instanceof Compound) {
                        this.attachmentProviders.addAll(((Compound) attachmentProvider).attachmentProviders);
                    } else {
                        this.attachmentProviders.add(attachmentProvider);
                    }
                }
            }
            public Accessor attempt() {
                for (AttachmentProvider attachmentProvider : attachmentProviders) {
                    Accessor accessor = attachmentProvider.attempt();
                    if (accessor.isAvailable()) {
                        return accessor;
                    }
                }
                return Accessor.Unavailable.INSTANCE;
            }
        }
    }
    public interface ProcessProvider {
        String resolve();
        enum ForCurrentVm implements ProcessProvider {
            INSTANCE;
            private final ProcessProvider dispatcher;
            ForCurrentVm() {
                dispatcher = ForJava9CapableVm.make();
            }
            public String resolve() {
                return dispatcher.resolve();
            }
            protected enum ForLegacyVm implements ProcessProvider {
                INSTANCE;
                public String resolve() {
                    String runtimeName;
                    try {
                        Method method = Class.forName("java.lang.management.ManagementFactory").getMethod("getRuntimeMXBean");
                        runtimeName = (String) method.getReturnType().getMethod("getName").invoke(method.invoke(null));
                    } catch (Exception exception) {
                        throw new IllegalStateException("Failed to access VM name via management factory", exception);
                    }
                    int processIdIndex = runtimeName.indexOf('@');
                    if (processIdIndex == -1) {
                        throw new IllegalStateException("Cannot extract process id from runtime management bean");
                    } else {
                        return runtimeName.substring(0, processIdIndex);
                    }
                }
            }
            protected static class ForJava9CapableVm implements ProcessProvider {
                private final Method current;
                private final Method pid;
                protected ForJava9CapableVm(Method current, Method pid) {
                    this.current = current;
                    this.pid = pid;
                }
                public static ProcessProvider make() {
                    try {
                        return new ForJava9CapableVm(Class.forName("java.lang.ProcessHandle").getMethod("current"), Class.forName("java.lang.ProcessHandle").getMethod("pid"));
                    } catch (Exception ignored) {
                        return ForLegacyVm.INSTANCE;
                    }
                }
                public String resolve() {
                    try {
                        return pid.invoke(current.invoke(null)).toString();
                    } catch (IllegalAccessException exception) {
                        throw new IllegalStateException("Cannot access Java 9 process API", exception);
                    } catch (InvocationTargetException exception) {
                        throw new IllegalStateException("Error when accessing Java 9 process API", exception.getTargetException());
                    }
                }
            }
        }
    }
    protected interface AgentProvider {
        File resolve() throws IOException;
        enum ForByteBuddyAgent implements AgentProvider {
            INSTANCE;
            private static final String AGENT_FILE_NAME = "byteBuddyAgent";
            private static File trySelfResolve(Class<?> installer) throws IOException {
                ProtectionDomain protectionDomain = installer.getProtectionDomain();
                if (Boolean.getBoolean(LATENT_RESOLVE)) {
                    return null;
                }
                if (protectionDomain == null) {
                    return null;
                }
                CodeSource codeSource = protectionDomain.getCodeSource();
                if (codeSource == null) {
                    return null;
                }
                URL location = codeSource.getLocation();
                if (!location.getProtocol().equals("file")) {
                    return null;
                }
                File agentJar;
                try {
                    agentJar = new File(location.toURI());
                } catch (URISyntaxException ignored) {
                    agentJar = new File(location.getPath());
                }
                if (!agentJar.isFile() || !agentJar.canRead()) {
                    return null;
                }
                Manifest manifest;
                InputStream inputStream = new FileInputStream(agentJar);
                try {
                    JarInputStream jarInputStream = new JarInputStream(inputStream);
                    manifest = jarInputStream.getManifest();
                    jarInputStream.close();
                } finally {
                    inputStream.close();
                }
                if (manifest == null) {
                    return null;
                }
                Attributes attributes = manifest.getMainAttributes();
                if (attributes == null) {
                    return null;
                }
                if (installer.getName().equals(attributes.getValue(AGENT_CLASS_PROPERTY)) && Boolean.parseBoolean(attributes.getValue(CAN_REDEFINE_CLASSES_PROPERTY)) && Boolean.parseBoolean(attributes.getValue(CAN_RETRANSFORM_CLASSES_PROPERTY)) && Boolean.parseBoolean(attributes.getValue(CAN_SET_NATIVE_METHOD_PREFIX))) {
                    return agentJar;
                } else {
                    return null;
                }
            }
            private static File createJarFile() throws IOException {
                InputStream inputStream = Installer.class.getResourceAsStream('/' + Installer.class.getName().replace('.', '/') + CLASS_FILE_EXTENSION);
                if (inputStream == null) {
                    throw new IllegalStateException("Cannot locate class file for Byte Buddy installer");
                }
                try {
                    File agentJar = File.createTempFile(AGENT_FILE_NAME, JAR_FILE_EXTENSION);
                    agentJar.deleteOnExit();
                    Manifest manifest = new Manifest();
                    manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, MANIFEST_VERSION_VALUE);
                    manifest.getMainAttributes().put(new Attributes.Name(AGENT_CLASS_PROPERTY), Installer.class.getName());
                    manifest.getMainAttributes().put(new Attributes.Name(CAN_REDEFINE_CLASSES_PROPERTY), Boolean.TRUE.toString());
                    manifest.getMainAttributes().put(new Attributes.Name(CAN_RETRANSFORM_CLASSES_PROPERTY), Boolean.TRUE.toString());
                    manifest.getMainAttributes().put(new Attributes.Name(CAN_SET_NATIVE_METHOD_PREFIX), Boolean.TRUE.toString());
                    OutputStream outputStream = new FileOutputStream(agentJar);
                    try {
                        JarOutputStream jarOutputStream = new JarOutputStream(outputStream, manifest);
                        jarOutputStream.putNextEntry(new JarEntry(Installer.class.getName().replace('.', '/') + CLASS_FILE_EXTENSION));
                        byte[] buffer = new byte[1024 * 8];
                        int index;
                        while ((index = inputStream.read(buffer)) != -1) {
                            jarOutputStream.write(buffer, 0, index);
                        }
                        jarOutputStream.closeEntry();
                        jarOutputStream.close();
                    } finally {
                        outputStream.close();
                    }
                    return agentJar;
                } finally {
                    inputStream.close();
                }
            }
            public File resolve() throws IOException {
                try {
                    if (!Installer.class.getName().equals(Installer.NAME)) {
                        try {
                            File resolved = trySelfResolve(Class.forName(Installer.NAME, false, ClassLoader.getSystemClassLoader()));
                            if (resolved != null) {
                                return resolved;
                            }
                        } catch (ClassNotFoundException ignored) {
                        }
                    }
                    File resolved = trySelfResolve(Installer.class);
                    if (resolved != null) {
                        return resolved;
                    }
                } catch (Exception ignored) {
                }
                return createJarFile();
            }
        }
        class ForExistingAgent implements AgentProvider {
            private final File agent;
            protected ForExistingAgent(File agent) {
                this.agent = agent;
            }
            public File resolve() {
                return agent;
            }
        }
    }
    protected interface AttachmentTypeEvaluator {
        boolean requiresExternalAttachment(String processId);
        enum InstallationAction implements PrivilegedAction<AttachmentTypeEvaluator> {
            INSTANCE;
            private static final String JDK_ALLOW_SELF_ATTACH = "jdk.attach.allowAttachSelf";
            public AttachmentTypeEvaluator run() {
                try {
                    if (Boolean.getBoolean(JDK_ALLOW_SELF_ATTACH)) {
                        return Disabled.INSTANCE;
                    } else {
                        return new ForJava9CapableVm(Class.forName("java.lang.ProcessHandle").getMethod("current"), Class.forName("java.lang.ProcessHandle").getMethod("pid"));
                    }
                } catch (Exception ignored) {
                    return Disabled.INSTANCE;
                }
            }
        }
        enum Disabled implements AttachmentTypeEvaluator {
            INSTANCE;
            public boolean requiresExternalAttachment(String processId) {
                return false;
            }
        }
        class ForJava9CapableVm implements AttachmentTypeEvaluator {
            private final Method current;
            private final Method pid;
            protected ForJava9CapableVm(Method current, Method pid) {
                this.current = current;
                this.pid = pid;
            }
            public boolean requiresExternalAttachment(String processId) {
                try {
                    return pid.invoke(current.invoke(null)).toString().equals(processId);
                } catch (IllegalAccessException exception) {
                    throw new IllegalStateException("Cannot access Java 9 process API", exception);
                } catch (InvocationTargetException exception) {
                    throw new IllegalStateException("Error when accessing Java 9 process API", exception.getTargetException());
                }
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```