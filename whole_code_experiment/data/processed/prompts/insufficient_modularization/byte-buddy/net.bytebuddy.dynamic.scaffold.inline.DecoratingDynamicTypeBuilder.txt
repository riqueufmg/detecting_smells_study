##CONTEXT_SIZE=2335
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.dynamic.scaffold.inline;
public class DecoratingDynamicTypeBuilder<T> extends DynamicType.Builder.AbstractBase.UsingTypeWriter<T> {
    private final TypeDescription instrumentedType;
    private final TypeAttributeAppender typeAttributeAppender;
    private final AsmVisitorWrapper asmVisitorWrapper;
    private final ClassFileVersion classFileVersion;
    private final AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy;
    private final AnnotationValueFilter.Factory annotationValueFilterFactory;
    private final AnnotationRetention annotationRetention;
    private final Implementation.Context.Factory implementationContextFactory;
    private final MethodGraph.Compiler methodGraphCompiler;
    private final TypeValidation typeValidation;
    private final AsmClassReader.Factory classReaderFactory;
    private final AsmClassWriter.Factory classWriterFactory;
    private final LatentMatcher<? super MethodDescription> ignoredMethods;
    private final List<DynamicType> auxiliaryTypes;
    private final ClassFileLocator classFileLocator;
    public DecoratingDynamicTypeBuilder(TypeDescription instrumentedType, ClassFileVersion classFileVersion, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, Implementation.Context.Factory implementationContextFactory, MethodGraph.Compiler methodGraphCompiler, TypeValidation typeValidation, AsmClassReader.Factory classReaderFactory, AsmClassWriter.Factory classWriterFactory, LatentMatcher<? super MethodDescription> ignoredMethods, ClassFileLocator classFileLocator) {
        this(instrumentedType, annotationRetention.isEnabled() ? new TypeAttributeAppender.ForInstrumentedType.Differentiating(instrumentedType) : TypeAttributeAppender.ForInstrumentedType.INSTANCE, AsmVisitorWrapper.NoOp.INSTANCE, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, classReaderFactory, classWriterFactory, ignoredMethods, Collections.<DynamicType>emptyList(), classFileLocator);
    }
    protected DecoratingDynamicTypeBuilder(TypeDescription instrumentedType, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, ClassFileVersion classFileVersion, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, Implementation.Context.Factory implementationContextFactory, MethodGraph.Compiler methodGraphCompiler, TypeValidation typeValidation, AsmClassReader.Factory classReaderFactory, AsmClassWriter.Factory classWriterFactory, LatentMatcher<? super MethodDescription> ignoredMethods, List<DynamicType> auxiliaryTypes, ClassFileLocator classFileLocator) {
        this.instrumentedType = instrumentedType;
        this.typeAttributeAppender = typeAttributeAppender;
        this.asmVisitorWrapper = asmVisitorWrapper;
        this.classFileVersion = classFileVersion;
        this.auxiliaryTypeNamingStrategy = auxiliaryTypeNamingStrategy;
        this.annotationValueFilterFactory = annotationValueFilterFactory;
        this.annotationRetention = annotationRetention;
        this.implementationContextFactory = implementationContextFactory;
        this.methodGraphCompiler = methodGraphCompiler;
        this.typeValidation = typeValidation;
        this.classReaderFactory = classReaderFactory;
        this.classWriterFactory = classWriterFactory;
        this.ignoredMethods = ignoredMethods;
        this.auxiliaryTypes = auxiliaryTypes;
        this.classFileLocator = classFileLocator;
    }
    public DynamicType.Builder<T> visit(AsmVisitorWrapper asmVisitorWrapper) {
        return new DecoratingDynamicTypeBuilder<T>(instrumentedType, typeAttributeAppender, new AsmVisitorWrapper.Compound(this.asmVisitorWrapper, asmVisitorWrapper), classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes, classFileLocator);
    }
    public DynamicType.Builder<T> suffix(String suffix) {
        throw new UnsupportedOperationException("Cannot change name of decorated type: " + instrumentedType);
    }
    public DynamicType.Builder<T> name(String name) {
        throw new UnsupportedOperationException("Cannot change name of decorated type: " + instrumentedType);
    }
    public DynamicType.Builder<T> modifiers(int modifiers) {
        throw new UnsupportedOperationException("Cannot change modifiers of decorated type: " + instrumentedType);
    }
    public DynamicType.Builder<T> merge(Collection<? extends ModifierContributor.ForType> modifierContributors) {
        throw new UnsupportedOperationException("Cannot change modifiers of decorated type: " + instrumentedType);
    }
    public ModuleDefinition<T> module(String name, int modifiers) {
        throw new UnsupportedOperationException("Cannot change module information of decorated type: " + instrumentedType);
    }
    public ModuleDefinition<T> adjustModule(Collection<? extends ModifierContributor.ForModule> modifierContributors) {
        throw new UnsupportedOperationException("Cannot change module information of decorated type: " + instrumentedType);
    }
    public DynamicType.Builder<T> topLevelType() {
        throw new UnsupportedOperationException("Cannot change type declaration of decorated type: " + instrumentedType);
    }
    public InnerTypeDefinition.ForType<T> innerTypeOf(TypeDescription type) {
        throw new UnsupportedOperationException("Cannot change type declaration of decorated type: " + instrumentedType);
    }
    public InnerTypeDefinition<T> innerTypeOf(MethodDescription.InDefinedShape methodDescription) {
        throw new UnsupportedOperationException("Cannot change type declaration of decorated type: " + instrumentedType);
    }
    public DynamicType.Builder<T> declaredTypes(Collection<? extends TypeDescription> types) {
        throw new UnsupportedOperationException("Cannot change type declaration of decorated type: " + instrumentedType);
    }
    public DynamicType.Builder<T> nestHost(TypeDescription type) {
        throw new UnsupportedOperationException("Cannot change type declaration of decorated type: " + instrumentedType);
    }
    public DynamicType.Builder<T> nestMembers(Collection<? extends TypeDescription> types) {
        throw new UnsupportedOperationException("Cannot change type declaration of decorated type: " + instrumentedType);
    }
    public DynamicType.Builder<T> permittedSubclass(Collection<? extends TypeDescription> types) {
        throw new UnsupportedOperationException("Cannot change permitted subclasses of decorated type: " + instrumentedType);
    }
    public DynamicType.Builder<T> unsealed() {
        throw new UnsupportedOperationException("Cannot unseal decorated type: " + instrumentedType);
    }
    public DynamicType.Builder<T> attribute(TypeAttributeAppender typeAttributeAppender) {
        return new DecoratingDynamicTypeBuilder<T>(instrumentedType, new TypeAttributeAppender.Compound(this.typeAttributeAppender, typeAttributeAppender), asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes, classFileLocator);
    }
    public DynamicType.Builder<T> annotateType(Collection<? extends AnnotationDescription> annotations) {
        return attribute(new TypeAttributeAppender.Explicit(new ArrayList<AnnotationDescription>(annotations)));
    }
    public MethodDefinition.ImplementationDefinition.Optional<T> implement(Collection<? extends TypeDefinition> interfaceTypes) {
        throw new UnsupportedOperationException("Cannot implement interface for decorated type: " + instrumentedType);
    }
    public DynamicType.Builder<T> initializer(ByteCodeAppender byteCodeAppender) {
        throw new UnsupportedOperationException("Cannot add initializer of decorated type: " + instrumentedType);
    }
    public DynamicType.Builder<T> initializer(LoadedTypeInitializer loadedTypeInitializer) {
        throw new UnsupportedOperationException("Cannot add initializer of decorated type: " + instrumentedType);
    }
    public TypeVariableDefinition<T> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
        throw new UnsupportedOperationException("Cannot add type variable to decorated type: " + instrumentedType);
    }
    public DynamicType.Builder<T> transform(ElementMatcher<? super TypeDescription.Generic> matcher, Transformer<TypeVariableToken> transformer) {
        throw new UnsupportedOperationException("Cannot transform decorated type: " + instrumentedType);
    }
    public FieldDefinition.Optional.Valuable<T> defineField(String name, TypeDefinition type, int modifiers) {
        throw new UnsupportedOperationException("Cannot define field for decorated type: " + instrumentedType);
    }
    public FieldDefinition.Valuable<T> field(LatentMatcher<? super FieldDescription> matcher) {
        throw new UnsupportedOperationException("Cannot change field for decorated type: " + instrumentedType);
    }
    public DynamicType.Builder<T> ignoreAlso(LatentMatcher<? super MethodDescription> ignoredMethods) {
        return new DecoratingDynamicTypeBuilder<T>(instrumentedType, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, classReaderFactory, classWriterFactory, new LatentMatcher.Disjunction<MethodDescription>(this.ignoredMethods, ignoredMethods), auxiliaryTypes, classFileLocator);
    }
    public MethodDefinition.ParameterDefinition.Initial<T> defineMethod(String name, TypeDefinition returnType, int modifiers) {
        throw new UnsupportedOperationException("Cannot define method for decorated type: " + instrumentedType);
    }
    public MethodDefinition.ParameterDefinition.Initial<T> defineConstructor(int modifiers) {
        throw new UnsupportedOperationException("Cannot define constructor for decorated type: " + instrumentedType);
    }
    public MethodDefinition.ImplementationDefinition<T> invokable(LatentMatcher<? super MethodDescription> matcher) {
        throw new UnsupportedOperationException("Cannot intercept method for decorated type: " + instrumentedType);
    }
    public RecordComponentDefinition.Optional<T> defineRecordComponent(String name, TypeDefinition type) {
        throw new UnsupportedOperationException("Cannot define record component for decorated type: " + instrumentedType);
    }
    public RecordComponentDefinition<T> recordComponent(LatentMatcher<? super RecordComponentDescription> matcher) {
        throw new UnsupportedOperationException("Cannot change record component for decorated type: " + instrumentedType);
    }
    public DynamicType.Builder<T> require(Collection<DynamicType> auxiliaryTypes) {
        return new DecoratingDynamicTypeBuilder<T>(instrumentedType, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, classReaderFactory, classWriterFactory, ignoredMethods, CompoundList.of(this.auxiliaryTypes, new ArrayList<DynamicType>(auxiliaryTypes)), classFileLocator);
    }
    protected TypeWriter<T> toTypeWriter() {
        return toTypeWriter(TypePool.Empty.INSTANCE);
    }
    protected TypeWriter<T> toTypeWriter(TypePool typePool) {
        return TypeWriter.Default.<T>forDecoration(instrumentedType, classFileVersion, auxiliaryTypes, CompoundList.of(methodGraphCompiler.compile((TypeDefinition) instrumentedType).listNodes().asMethodList().filter(not(ignoredMethods.resolve(instrumentedType))), instrumentedType.getDeclaredMethods().filter(not(isVirtual()))), typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classReaderFactory, classWriterFactory, TypePool.Explicit.wrap(instrumentedType, auxiliaryTypes, typePool), classFileLocator);
    }
    public TypeDescription toTypeDescription() {
        return instrumentedType;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```