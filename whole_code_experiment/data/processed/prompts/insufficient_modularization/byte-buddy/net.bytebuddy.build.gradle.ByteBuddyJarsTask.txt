##CONTEXT_SIZE=533
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.build.gradle;
public class ByteBuddyJarsTask extends AbstractByteBuddyTask {
    private File source;
    private File target;
    private Iterable<File> classPath;
    private Iterable<File> discoverySet;
    @Inject
    @SuppressWarnings("this-escape")
    public ByteBuddyJarsTask() {
        new ByteBuddyJarsTaskExtension(null).configure(this);
    }
    public File getSource() {
        return source;
    }
    public void setSource(File source) {
        this.source = source;
    }
    public File getTarget() {
        return target;
    }
    public void setTarget(File target) {
        this.target = target;
    }
    public Iterable<File> getClassPath() {
        return classPath;
    }
    public void setClassPath(Iterable<File> classPath) {
        this.classPath = classPath;
    }
    public Iterable<File> getDiscoverySet() {
        return discoverySet;
    }
    public void setDiscoverySet(@MaybeNull Iterable<File> discoverySet) {
        this.discoverySet = discoverySet;
    }
    protected File source() {
        return getSource();
    }
    protected File target() {
        return getTarget();
    }
    protected Iterable<File> classPath() {
        return getClassPath();
    }
    protected Iterable<File> discoverySet() {
        return discoverySet;
    }
    public void apply() throws IOException {
        File source = getSource().getAbsoluteFile(), target = getTarget().getAbsoluteFile();
        if (!source.equals(getTarget()) && deleteRecursively(getTarget())) {
            getLogger().debug("Deleted target directory {}", getTarget());
        }
        Queue<File> queue = QueueFactory.make(Collections.singletonList(source));
        while (!queue.isEmpty()) {
            File candidate = queue.remove();
            File[] file = candidate.listFiles();
            if (file != null) {
                queue.addAll(Arrays.asList(file));
            } else {
                if (!candidate.getAbsoluteFile().toString().startsWith(source.toString())) {
                    throw new IllegalStateException(candidate + " is not a subdirectory of " + source);
                }
                File resolved = new File(target, candidate.toString().substring(source.toString().length()));
                if (resolved.getParentFile().mkdirs()) {
                    getLogger().debug("Created host directory for {}", resolved);
                }
                getLogger().debug("Transforming {} to {}", candidate, resolved);
                doApply(new Plugin.Engine.Source.ForJarFile(candidate), new Plugin.Engine.Target.ForJarFile(resolved));
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```