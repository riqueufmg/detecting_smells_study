##CONTEXT_SIZE=1609
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy;
public class TypeCache<T> extends ReferenceQueue<ClassLoader> {
    private static final Class<?> NOT_FOUND = null;
    protected final Sort sort;
    protected final ConcurrentMap<StorageKey, ConcurrentMap<T, Object>> cache;
    public TypeCache() {
        this(Sort.STRONG);
    }
    public TypeCache(Sort sort) {
        this.sort = sort;
        cache = new ConcurrentHashMap<StorageKey, ConcurrentMap<T, Object>>();
    }
    public Class<?> find(@MaybeNull ClassLoader classLoader, T key) {
        ConcurrentMap<T, Object> storage = cache.get(new LookupKey(classLoader));
        if (storage == null) {
            return NOT_FOUND;
        } else {
            Object value = storage.get(key);
            if (value == null) {
                return NOT_FOUND;
            } else if (value instanceof Reference<?>) {
                return (Class<?>) ((Reference<?>) value).get();
            } else {
                return (Class<?>) value;
            }
        }
    }
    public Class<?> insert(@MaybeNull ClassLoader classLoader, T key, Class<?> type) {
        ConcurrentMap<T, Object> storage = cache.get(new LookupKey(classLoader));
        if (storage == null) {
            storage = new ConcurrentHashMap<T, Object>();
            ConcurrentMap<T, Object> previous = cache.putIfAbsent(new StorageKey(classLoader, this), storage);
            if (previous != null) {
                storage = previous;
            }
        }
        Object value = sort.wrap(type), previous = storage.putIfAbsent(key, value);
        while (previous != null) {
            Class<?> previousType = (Class<?>) (previous instanceof Reference<?> ? ((Reference<?>) previous).get() : previous);
            if (previousType != null) {
                return previousType;
            } else if (storage.remove(key, previous)) {
                previous = storage.putIfAbsent(key, value);
            } else {
                previous = storage.get(key);
                if (previous == null) {
                    previous = storage.putIfAbsent(key, value);
                }
            }
        }
        return type;
    }
    public Class<?> findOrInsert(@MaybeNull ClassLoader classLoader, T key, Callable<Class<?>> lazy) {
        Class<?> type = find(classLoader, key);
        if (type != null) {
            return type;
        } else {
            try {
                return insert(classLoader, key, lazy.call());
            } catch (Throwable throwable) {
                throw new IllegalArgumentException("Could not create type", throwable);
            }
        }
    }
    public Class<?> findOrInsert(@MaybeNull ClassLoader classLoader, T key, Callable<Class<?>> lazy, Object monitor) {
        Class<?> type = find(classLoader, key);
        if (type != null) {
            return type;
        } else {
            synchronized (monitor) {
                return findOrInsert(classLoader, key, lazy);
            }
        }
    }
    public void expungeStaleEntries() {
        Reference<?> reference;
        while ((reference = poll()) != null) {
            cache.remove(reference);
        }
    }
    public void clear() {
        cache.clear();
    }
    public enum Sort {
        WEAK {
            @Override
            protected Reference<Class<?>> wrap(Class<?> type) {
                return new WeakReference<Class<?>>(type);
            }
        }
        , SOFT {
            @Override
            protected Reference<Class<?>> wrap(Class<?> type) {
                return new SoftReference<Class<?>>(type);
            }
        }
        , STRONG {
            @Override
            protected Class<?> wrap(Class<?> type) {
                return type;
            }
        }
        ;
        protected abstract Object wrap(Class<?> type);
    }
    protected static class LookupKey {
        private final ClassLoader classLoader;
        private final int hashCode;
        protected LookupKey(@MaybeNull ClassLoader classLoader) {
            this.classLoader = classLoader;
            hashCode = System.identityHashCode(classLoader);
        }
        public int hashCode() {
            return hashCode;
        }
        public boolean equals(@MaybeNull Object other) {
            if (this == other) {
                return true;
            } else if (other instanceof LookupKey) {
                return classLoader == ((LookupKey) other).classLoader;
            } else if (other instanceof StorageKey) {
                StorageKey storageKey = (StorageKey) other;
                return hashCode == storageKey.hashCode && classLoader == storageKey.get();
            } else {
                return false;
            }
        }
    }
    protected static class StorageKey extends WeakReference<ClassLoader> {
        private final int hashCode;
        protected StorageKey(@MaybeNull ClassLoader classLoader, ReferenceQueue<? super ClassLoader> referenceQueue) {
            super(classLoader, referenceQueue);
            hashCode = System.identityHashCode(classLoader);
        }
        public int hashCode() {
            return hashCode;
        }
        public boolean equals(@MaybeNull Object other) {
            if (this == other) {
                return true;
            } else if (other instanceof LookupKey) {
                LookupKey lookupKey = (LookupKey) other;
                return hashCode == lookupKey.hashCode && get() == lookupKey.classLoader;
            } else if (other instanceof StorageKey) {
                StorageKey storageKey = (StorageKey) other;
                return hashCode == storageKey.hashCode && get() == storageKey.get();
            } else {
                return false;
            }
        }
    }
    public static class WithInlineExpunction<S> extends TypeCache<S> {
        public WithInlineExpunction() {
            this(Sort.STRONG);
        }
        public WithInlineExpunction(Sort sort) {
            super(sort);
        }
        public Class<?> find(@MaybeNull ClassLoader classLoader, S key) {
            try {
                return super.find(classLoader, key);
            } finally {
                expungeStaleEntries();
            }
        }
        public Class<?> insert(@MaybeNull ClassLoader classLoader, S key, Class<?> type) {
            try {
                return super.insert(classLoader, key, type);
            } finally {
                expungeStaleEntries();
            }
        }
        public Class<?> findOrInsert(@MaybeNull ClassLoader classLoader, S key, Callable<Class<?>> builder) {
            try {
                return super.findOrInsert(classLoader, key, builder);
            } finally {
                expungeStaleEntries();
            }
        }
        public Class<?> findOrInsert(@MaybeNull ClassLoader classLoader, S key, Callable<Class<?>> builder, Object monitor) {
            try {
                return super.findOrInsert(classLoader, key, builder, monitor);
            } finally {
                expungeStaleEntries();
            }
        }
    }
    public static class SimpleKey {
        private final Set<String> types;
        public SimpleKey(Class<?> type, Class<?>... additionalType) {
            this(type, Arrays.asList(additionalType));
        }
        public SimpleKey(Class<?> type, Collection<? extends Class<?>> additionalTypes) {
            this(CompoundList.of(type, new ArrayList<Class<?>>(additionalTypes)));
        }
        public SimpleKey(Collection<? extends Class<?>> types) {
            this.types = new HashSet<String>();
            for (Class<?> type : types) {
                this.types.add(type.getName());
            }
        }
        public int hashCode() {
            return types.hashCode();
        }
        public boolean equals(@MaybeNull Object other) {
            if (this == other) {
                return true;
            } else if (other == null || getClass() != other.getClass()) {
                return false;
            }
            SimpleKey simpleKey = (SimpleKey) other;
            return types.equals(simpleKey.types);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```