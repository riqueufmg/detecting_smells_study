##CONTEXT_SIZE=2381
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.dynamic.loading;
public interface PackageDefinitionStrategy {
    Definition define(ClassLoader classLoader, String packageName, String typeName);
    enum NoOp implements PackageDefinitionStrategy {
        INSTANCE;
        public Definition define(ClassLoader classLoader, String packageName, String typeName) {
            return Definition.Undefined.INSTANCE;
        }
    }
    enum Trivial implements PackageDefinitionStrategy {
        INSTANCE;
        public Definition define(ClassLoader classLoader, String packageName, String typeName) {
            return Definition.Trivial.INSTANCE;
        }
    }
    interface Definition {
        boolean isDefined();
        String getSpecificationTitle();
        String getSpecificationVersion();
        String getSpecificationVendor();
        String getImplementationTitle();
        String getImplementationVersion();
        String getImplementationVendor();
        URL getSealBase();
        boolean isCompatibleTo(Package definedPackage);
        enum Undefined implements Definition {
            INSTANCE;
            public boolean isDefined() {
                return false;
            }
            public String getSpecificationTitle() {
                throw new IllegalStateException("Cannot read property of undefined package");
            }
            public String getSpecificationVersion() {
                throw new IllegalStateException("Cannot read property of undefined package");
            }
            public String getSpecificationVendor() {
                throw new IllegalStateException("Cannot read property of undefined package");
            }
            public String getImplementationTitle() {
                throw new IllegalStateException("Cannot read property of undefined package");
            }
            public String getImplementationVersion() {
                throw new IllegalStateException("Cannot read property of undefined package");
            }
            public String getImplementationVendor() {
                throw new IllegalStateException("Cannot read property of undefined package");
            }
            public URL getSealBase() {
                throw new IllegalStateException("Cannot read property of undefined package");
            }
            public boolean isCompatibleTo(Package definedPackage) {
                throw new IllegalStateException("Cannot check compatibility to undefined package");
            }
        }
        enum Trivial implements Definition {
            INSTANCE;
            private static final String NO_VALUE = null;
            private static final URL NOT_SEALED = null;
            public boolean isDefined() {
                return true;
            }
            public String getSpecificationTitle() {
                return NO_VALUE;
            }
            public String getSpecificationVersion() {
                return NO_VALUE;
            }
            public String getSpecificationVendor() {
                return NO_VALUE;
            }
            public String getImplementationTitle() {
                return NO_VALUE;
            }
            public String getImplementationVersion() {
                return NO_VALUE;
            }
            public String getImplementationVendor() {
                return NO_VALUE;
            }
            public URL getSealBase() {
                return NOT_SEALED;
            }
            public boolean isCompatibleTo(Package definedPackage) {
                return true;
            }
        }
        class Simple implements Definition {
            protected final URL sealBase;
            private final String specificationTitle;
            private final String specificationVersion;
            private final String specificationVendor;
            private final String implementationTitle;
            private final String implementationVersion;
            private final String implementationVendor;
            public Simple(@MaybeNull String specificationTitle, @MaybeNull String specificationVersion, @MaybeNull String specificationVendor, @MaybeNull String implementationTitle, @MaybeNull String implementationVersion, @MaybeNull String implementationVendor, @MaybeNull URL sealBase) {
                this.specificationTitle = specificationTitle;
                this.specificationVersion = specificationVersion;
                this.specificationVendor = specificationVendor;
                this.implementationTitle = implementationTitle;
                this.implementationVersion = implementationVersion;
                this.implementationVendor = implementationVendor;
                this.sealBase = sealBase;
            }
            public boolean isDefined() {
                return true;
            }
            public String getSpecificationTitle() {
                return specificationTitle;
            }
            public String getSpecificationVersion() {
                return specificationVersion;
            }
            public String getSpecificationVendor() {
                return specificationVendor;
            }
            public String getImplementationTitle() {
                return implementationTitle;
            }
            public String getImplementationVersion() {
                return implementationVersion;
            }
            public String getImplementationVendor() {
                return implementationVendor;
            }
            public URL getSealBase() {
                return sealBase;
            }
            public boolean isCompatibleTo(Package definedPackage) {
                if (sealBase == null) {
                    return !definedPackage.isSealed();
                } else {
                    return definedPackage.isSealed(sealBase);
                }
            }
            public int hashCode() {
                int result = specificationTitle != null ? specificationTitle.hashCode() : 0;
                result = 31 * result + (specificationVersion != null ? specificationVersion.hashCode() : 0);
                result = 31 * result + (specificationVendor != null ? specificationVendor.hashCode() : 0);
                result = 31 * result + (implementationTitle != null ? implementationTitle.hashCode() : 0);
                result = 31 * result + (implementationVersion != null ? implementationVersion.hashCode() : 0);
                result = 31 * result + (implementationVendor != null ? implementationVendor.hashCode() : 0);
                result = 31 * result + (sealBase != null ? sealBase.hashCode() : 0);
                return result;
            }
            public boolean equals(@MaybeNull Object other) {
                if (this == other) {
                    return true;
                } else if (other == null || getClass() != other.getClass()) {
                    return false;
                }
                Simple simple = (Simple) other;
                return !(specificationTitle != null ? !specificationTitle.equals(simple.specificationTitle) : simple.specificationTitle != null) && !(specificationVersion != null ? !specificationVersion.equals(simple.specificationVersion) : simple.specificationVersion != null) && !(specificationVendor != null ? !specificationVendor.equals(simple.specificationVendor) : simple.specificationVendor != null) && !(implementationTitle != null ? !implementationTitle.equals(simple.implementationTitle) : simple.implementationTitle != null) && !(implementationVersion != null ? !implementationVersion.equals(simple.implementationVersion) : simple.implementationVersion != null) && !(implementationVendor != null ? !implementationVendor.equals(simple.implementationVendor) : simple.implementationVendor != null) && !(sealBase != null ? !sealBase.equals(simple.sealBase) : simple.sealBase != null);
            }
        }
    }
    class ManifestReading implements PackageDefinitionStrategy {
        private static final URL NOT_SEALED = null;
        private static final Attributes.Name[] ATTRIBUTE_NAMES = new Attributes.Name[] { Attributes.Name.SPECIFICATION_TITLE, Attributes.Name.SPECIFICATION_VERSION, Attributes.Name.SPECIFICATION_VENDOR, Attributes.Name.IMPLEMENTATION_TITLE, Attributes.Name.IMPLEMENTATION_VERSION, Attributes.Name.IMPLEMENTATION_VENDOR, Attributes.Name.SEALED };
        private final SealBaseLocator sealBaseLocator;
        public ManifestReading() {
            this(new SealBaseLocator.ForTypeResourceUrl());
        }
        public ManifestReading(SealBaseLocator sealBaseLocator) {
            this.sealBaseLocator = sealBaseLocator;
        }
        public Definition define(ClassLoader classLoader, String packageName, String typeName) {
            InputStream inputStream = classLoader.getResourceAsStream(JarFile.MANIFEST_NAME);
            if (inputStream != null) {
                try {
                    try {
                        Manifest manifest = new Manifest(inputStream);
                        Map<Attributes.Name, String> values = new HashMap<Attributes.Name, String>();
                        Attributes mainAttributes = manifest.getMainAttributes();
                        if (mainAttributes != null) {
                            for (Attributes.Name attributeName : ATTRIBUTE_NAMES) {
                                values.put(attributeName, mainAttributes.getValue(attributeName));
                            }
                        }
                        Attributes attributes = manifest.getAttributes(packageName.replace('.', '/').concat("/"));
                        if (attributes != null) {
                            for (Attributes.Name attributeName : ATTRIBUTE_NAMES) {
                                String value = attributes.getValue(attributeName);
                                if (value != null) {
                                    values.put(attributeName, value);
                                }
                            }
                        }
                        return new Definition.Simple(values.get(Attributes.Name.SPECIFICATION_TITLE), values.get(Attributes.Name.SPECIFICATION_VERSION), values.get(Attributes.Name.SPECIFICATION_VENDOR), values.get(Attributes.Name.IMPLEMENTATION_TITLE), values.get(Attributes.Name.IMPLEMENTATION_VERSION), values.get(Attributes.Name.IMPLEMENTATION_VENDOR), Boolean.parseBoolean(values.get(Attributes.Name.SEALED)) ? sealBaseLocator.findSealBase(classLoader, typeName) : NOT_SEALED);
                    } finally {
                        inputStream.close();
                    }
                } catch (IOException exception) {
                    throw new IllegalStateException("Error while reading manifest file", exception);
                }
            } else {
                return Definition.Trivial.INSTANCE;
            }
        }
        public interface SealBaseLocator {
            URL findSealBase(ClassLoader classLoader, String typeName);
            enum NonSealing implements SealBaseLocator {
                INSTANCE;
                public URL findSealBase(ClassLoader classLoader, String typeName) {
                    return NOT_SEALED;
                }
            }
            class ForFixedValue implements SealBaseLocator {
                private final URL sealBase;
                public ForFixedValue(@MaybeNull URL sealBase) {
                    this.sealBase = sealBase;
                }
                public URL findSealBase(ClassLoader classLoader, String typeName) {
                    return sealBase;
                }
                public int hashCode() {
                    return sealBase == null ? 17 : sealBase.hashCode();
                }
                public boolean equals(@MaybeNull Object other) {
                    if (this == other) {
                        return true;
                    } else if (other == null || getClass() != other.getClass()) {
                        return false;
                    }
                    ForFixedValue forFixedValue = (ForFixedValue) other;
                    return sealBase == null ? forFixedValue.sealBase == null : sealBase.equals(forFixedValue.sealBase);
                }
            }
            class ForTypeResourceUrl implements SealBaseLocator {
                private static final int EXCLUDE_INITIAL_SLASH = 1;
                private static final String CLASS_FILE_EXTENSION = ".class";
                private static final String JAR_FILE = "jar";
                private static final String FILE_SYSTEM = "file";
                private static final String RUNTIME_IMAGE = "jrt";
                private final SealBaseLocator fallback;
                public ForTypeResourceUrl() {
                    this(NonSealing.INSTANCE);
                }
                public ForTypeResourceUrl(SealBaseLocator fallback) {
                    this.fallback = fallback;
                }
                public URL findSealBase(ClassLoader classLoader, String typeName) {
                    URL url = classLoader.getResource(typeName.replace('.', '/') + CLASS_FILE_EXTENSION);
                    if (url != null) {
                        try {
                            if (url.getProtocol().equals(JAR_FILE)) {
                                return URI.create(url.getPath().substring(0, url.getPath().indexOf('!'))).toURL();
                            } else if (url.getProtocol().equals(FILE_SYSTEM)) {
                                return url;
                            } else if (url.getProtocol().equals(RUNTIME_IMAGE)) {
                                String path = url.getPath();
                                int modulePathIndex = path.indexOf('/', EXCLUDE_INITIAL_SLASH);
                                return modulePathIndex == -1 ? url : URI.create(RUNTIME_IMAGE + ":" + path.substring(0, modulePathIndex)).toURL();
                            }
                        } catch (MalformedURLException exception) {
                            throw new IllegalStateException("Unexpected URL: " + url, exception);
                        }
                    }
                    return fallback.findSealBase(classLoader, typeName);
                }
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```