##CONTEXT_SIZE=4974
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.implementation;
public abstract class FieldAccessor implements Implementation {
    protected final FieldLocation fieldLocation;
    protected final Assigner assigner;
    protected final Assigner.Typing typing;
    protected FieldAccessor(FieldLocation fieldLocation, Assigner assigner, Assigner.Typing typing) {
        this.fieldLocation = fieldLocation;
        this.assigner = assigner;
        this.typing = typing;
    }
    public static OwnerTypeLocatable ofField(String name) {
        return of(new FieldNameExtractor.ForFixedValue(name));
    }
    public static OwnerTypeLocatable ofBeanProperty() {
        return of(FieldNameExtractor.ForBeanProperty.INSTANCE, FieldNameExtractor.ForBeanProperty.CAPITALIZED);
    }
    public static OwnerTypeLocatable of(FieldNameExtractor fieldNameExtractor) {
        return of(Collections.singletonList(fieldNameExtractor));
    }
    public static OwnerTypeLocatable of(FieldNameExtractor... fieldNameExtractor) {
        return of(Arrays.asList(fieldNameExtractor));
    }
    public static OwnerTypeLocatable of(List<? extends FieldNameExtractor> fieldNameExtractors) {
        return new ForImplicitProperty(new FieldLocation.Relative(fieldNameExtractors));
    }
    public static AssignerConfigurable of(Field field) {
        return of(new FieldDescription.ForLoadedField(field));
    }
    public static AssignerConfigurable of(FieldDescription fieldDescription) {
        return new ForImplicitProperty(new FieldLocation.Absolute(fieldDescription));
    }
    protected interface FieldLocation {
        FieldLocation with(FieldLocator.Factory fieldLocatorFactory);
        Prepared prepare(TypeDescription instrumentedType);
        interface Prepared {
            FieldDescription resolve(MethodDescription instrumentedMethod);
        }
        class Absolute implements FieldLocation, Prepared {
            private final FieldDescription fieldDescription;
            protected Absolute(FieldDescription fieldDescription) {
                this.fieldDescription = fieldDescription;
            }
            public FieldLocation with(FieldLocator.Factory fieldLocatorFactory) {
                throw new IllegalStateException("Cannot specify a field locator factory for an absolute field location");
            }
            public Prepared prepare(TypeDescription instrumentedType) {
                if (!fieldDescription.isStatic() && !instrumentedType.isAssignableTo(fieldDescription.getDeclaringType().asErasure())) {
                    throw new IllegalStateException(fieldDescription + " is not declared by " + instrumentedType);
                } else if (!fieldDescription.isAccessibleTo(instrumentedType)) {
                    throw new IllegalStateException("Cannot access " + fieldDescription + " from " + instrumentedType);
                }
                return this;
            }
            public FieldDescription resolve(MethodDescription instrumentedMethod) {
                return fieldDescription;
            }
        }
        class Relative implements FieldLocation {
            private final List<? extends FieldNameExtractor> fieldNameExtractors;
            private final FieldLocator.Factory fieldLocatorFactory;
            protected Relative(List<? extends FieldNameExtractor> fieldNameExtractors) {
                this(fieldNameExtractors, FieldLocator.ForClassHierarchy.Factory.INSTANCE);
            }
            private Relative(List<? extends FieldNameExtractor> fieldNameExtractors, FieldLocator.Factory fieldLocatorFactory) {
                this.fieldNameExtractors = fieldNameExtractors;
                this.fieldLocatorFactory = fieldLocatorFactory;
            }
            public FieldLocation with(FieldLocator.Factory fieldLocatorFactory) {
                return new Relative(fieldNameExtractors, fieldLocatorFactory);
            }
            public FieldLocation.Prepared prepare(TypeDescription instrumentedType) {
                return new Prepared(fieldNameExtractors, fieldLocatorFactory.make(instrumentedType));
            }
            protected static class Prepared implements FieldLocation.Prepared {
                private final List<? extends FieldNameExtractor> fieldNameExtractors;
                private final FieldLocator fieldLocator;
                protected Prepared(List<? extends FieldNameExtractor> fieldNameExtractors, FieldLocator fieldLocator) {
                    this.fieldNameExtractors = fieldNameExtractors;
                    this.fieldLocator = fieldLocator;
                }
                public FieldDescription resolve(MethodDescription instrumentedMethod) {
                    FieldLocator.Resolution resolution = FieldLocator.Resolution.Illegal.INSTANCE;
                    Iterator<? extends FieldNameExtractor> iterator = fieldNameExtractors.iterator();
                    while (iterator.hasNext() && !resolution.isResolved()) {
                        resolution = fieldLocator.locate(iterator.next().resolve(instrumentedMethod));
                    }
                    if (!resolution.isResolved()) {
                        throw new IllegalStateException("Cannot resolve field for " + instrumentedMethod + " using " + fieldLocator);
                    }
                    return resolution.getField();
                }
            }
        }
    }
    public interface FieldNameExtractor {
        String resolve(MethodDescription methodDescription);
        enum ForBeanProperty implements FieldNameExtractor {
            INSTANCE {
                @Override
                protected char resolve(char character) {
                    return Character.toLowerCase(character);
                }
            }
            , CAPITALIZED {
                @Override
                protected char resolve(char character) {
                    return Character.toUpperCase(character);
                }
            }
            ;
            public String resolve(MethodDescription methodDescription) {
                String name = methodDescription.getInternalName();
                int crop;
                if (name.startsWith("get") || name.startsWith("set")) {
                    crop = 3;
                } else if (name.startsWith("is")) {
                    crop = 2;
                } else {
                    throw new IllegalArgumentException(methodDescription + " does not follow Java bean naming conventions");
                }
                name = name.substring(crop);
                if (name.length() == 0) {
                    throw new IllegalArgumentException(methodDescription + " does not specify a bean name");
                }
                return resolve(name.charAt(0)) + name.substring(1);
            }
            protected abstract char resolve(char character);
        }
        class ForFixedValue implements FieldNameExtractor {
            private final String name;
            protected ForFixedValue(String name) {
                this.name = name;
            }
            public String resolve(MethodDescription methodDescription) {
                return name;
            }
        }
    }
    public interface PropertyConfigurable extends Implementation {
        Composable setsArgumentAt(int index);
        Composable setsDefaultValue();
        Composable setsValue(Object value);
        Composable setsValue(TypeDescription typeDescription);
        Composable setsValue(ConstantValue constant);
        Composable setsValue(JavaConstant constant);
        Composable setsValue(StackManipulation stackManipulation, Type type);
        Composable setsValue(StackManipulation stackManipulation, TypeDescription.Generic typeDescription);
        Composable setsReference(Object value);
        Composable setsReference(Object value, String name);
        Composable setsFieldValueOf(Field field);
        Composable setsFieldValueOf(FieldDescription fieldDescription);
        Composable setsFieldValueOf(String fieldName);
        Composable setsFieldValueOf(FieldNameExtractor fieldNameExtractor);
    }
    public interface AssignerConfigurable extends PropertyConfigurable {
        PropertyConfigurable withAssigner(Assigner assigner, Assigner.Typing typing);
    }
    public interface OwnerTypeLocatable extends AssignerConfigurable {
        AssignerConfigurable in(Class<?> type);
        AssignerConfigurable in(TypeDescription typeDescription);
        AssignerConfigurable in(FieldLocator.Factory fieldLocatorFactory);
    }
    protected static class ForImplicitProperty extends FieldAccessor implements OwnerTypeLocatable {
        protected ForImplicitProperty(FieldLocation fieldLocation) {
            this(fieldLocation, Assigner.DEFAULT, Assigner.Typing.STATIC);
        }
        private ForImplicitProperty(FieldLocation fieldLocation, Assigner assigner, Assigner.Typing typing) {
            super(fieldLocation, assigner, typing);
        }
        public InstrumentedType prepare(InstrumentedType instrumentedType) {
            return instrumentedType;
        }
        public ByteCodeAppender appender(Target implementationTarget) {
            return new Appender(fieldLocation.prepare(implementationTarget.getInstrumentedType()));
        }
        public Composable setsArgumentAt(int index) {
            if (index < 0) {
                throw new IllegalArgumentException("A parameter index cannot be negative: " + index);
            }
            return new ForSetter.OfParameterValue(fieldLocation, assigner, typing, ForSetter.TerminationHandler.RETURNING, index);
        }
        public Composable setsDefaultValue() {
            return new ForSetter.OfDefaultValue(fieldLocation, assigner, typing, ForSetter.TerminationHandler.RETURNING);
        }
        public Composable setsValue(@MaybeNull Object value) {
            if (value == null) {
                return setsDefaultValue();
            }
            ConstantValue constant = ConstantValue.Simple.wrapOrNull(value);
            return constant == null ? setsReference(value) : setsValue(constant.toStackManipulation(), constant.getTypeDescription().asGenericType());
        }
        public Composable setsValue(TypeDescription typeDescription) {
            return setsValue(ClassConstant.of(typeDescription), Class.class);
        }
        public Composable setsValue(ConstantValue constant) {
            return setsValue(constant.toStackManipulation(), constant.getTypeDescription().asGenericType());
        }
        public Composable setsValue(JavaConstant constant) {
            return setsValue((ConstantValue) constant);
        }
        public Composable setsValue(StackManipulation stackManipulation, Type type) {
            return setsValue(stackManipulation, TypeDescription.Generic.Sort.describe(type));
        }
        public Composable setsValue(StackManipulation stackManipulation, TypeDescription.Generic typeDescription) {
            return new ForSetter.OfConstantValue(fieldLocation, assigner, typing, ForSetter.TerminationHandler.RETURNING, typeDescription, stackManipulation);
        }
        public Composable setsReference(Object value) {
            return setsReference(value, ForSetter.OfReferenceValue.PREFIX + "$" + RandomString.hashOf(value));
        }
        public Composable setsReference(Object value, String name) {
            return new ForSetter.OfReferenceValue(fieldLocation, assigner, typing, ForSetter.TerminationHandler.RETURNING, value, name);
        }
        public Composable setsFieldValueOf(Field field) {
            return setsFieldValueOf(new FieldDescription.ForLoadedField(field));
        }
        public Composable setsFieldValueOf(FieldDescription fieldDescription) {
            return new ForSetter.OfFieldValue(fieldLocation, assigner, typing, ForSetter.TerminationHandler.RETURNING, new FieldLocation.Absolute(fieldDescription));
        }
        public Composable setsFieldValueOf(String fieldName) {
            return setsFieldValueOf(new FieldNameExtractor.ForFixedValue(fieldName));
        }
        public Composable setsFieldValueOf(FieldNameExtractor fieldNameExtractor) {
            return new ForSetter.OfFieldValue(fieldLocation, assigner, typing, ForSetter.TerminationHandler.RETURNING, new FieldLocation.Relative(Collections.singletonList(fieldNameExtractor)));
        }
        public PropertyConfigurable withAssigner(Assigner assigner, Assigner.Typing typing) {
            return new ForImplicitProperty(fieldLocation, assigner, typing);
        }
        public AssignerConfigurable in(Class<?> type) {
            return in(TypeDescription.ForLoadedType.of(type));
        }
        public AssignerConfigurable in(TypeDescription typeDescription) {
            return in(new FieldLocator.ForExactType.Factory(typeDescription));
        }
        public AssignerConfigurable in(FieldLocator.Factory fieldLocatorFactory) {
            return new ForImplicitProperty(fieldLocation.with(fieldLocatorFactory), assigner, typing);
        }
        protected class Appender implements ByteCodeAppender {
            private final FieldLocation.Prepared fieldLocation;
            protected Appender(FieldLocation.Prepared fieldLocation) {
                this.fieldLocation = fieldLocation;
            }
            public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
                if (!instrumentedMethod.isMethod()) {
                    throw new IllegalArgumentException(instrumentedMethod + " does not describe a field getter or setter");
                }
                FieldDescription fieldDescription = fieldLocation.resolve(instrumentedMethod);
                if (!fieldDescription.isStatic() && instrumentedMethod.isStatic()) {
                    throw new IllegalStateException("Cannot set instance field " + fieldDescription + " from " + instrumentedMethod);
                }
                StackManipulation implementation, initialization = fieldDescription.isStatic() ? StackManipulation.Trivial.INSTANCE : MethodVariableAccess.loadThis();
                if (!instrumentedMethod.getReturnType().represents(void.class)) {
                    implementation = new StackManipulation.Compound(initialization, FieldAccess.forField(fieldDescription).read(), assigner.assign(fieldDescription.getType(), instrumentedMethod.getReturnType(), typing), MethodReturn.of(instrumentedMethod.getReturnType()));
                } else if (instrumentedMethod.getReturnType().represents(void.class) && instrumentedMethod.getParameters().size() == 1) {
                    if (fieldDescription.isFinal() && instrumentedMethod.isMethod()) {
                        throw new IllegalStateException("Cannot set final field " + fieldDescription + " from " + instrumentedMethod);
                    }
                    implementation = new StackManipulation.Compound(initialization, MethodVariableAccess.load(instrumentedMethod.getParameters().get(0)), assigner.assign(instrumentedMethod.getParameters().get(0).getType(), fieldDescription.getType(), typing), FieldAccess.forField(fieldDescription).write(), MethodReturn.VOID);
                } else {
                    throw new IllegalArgumentException("Method " + instrumentedMethod + " is no bean accessor");
                }
                if (!implementation.isValid()) {
                    throw new IllegalStateException("Cannot set or get value of " + instrumentedMethod + " using " + fieldDescription);
                }
                return new Size(implementation.apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());
            }
        }
    }
    protected abstract static class ForSetter<T> extends FieldAccessor implements Implementation.Composable {
        private final TerminationHandler terminationHandler;
        protected ForSetter(FieldLocation fieldLocation, Assigner assigner, Assigner.Typing typing, TerminationHandler terminationHandler) {
            super(fieldLocation, assigner, typing);
            this.terminationHandler = terminationHandler;
        }
        public ByteCodeAppender appender(Target implementationTarget) {
            return new Appender(implementationTarget.getInstrumentedType(), initialize(implementationTarget.getInstrumentedType()), fieldLocation.prepare(implementationTarget.getInstrumentedType()));
        }
        protected abstract T initialize(TypeDescription instrumentedType);
        protected abstract StackManipulation resolve(@MaybeNull T initialized, FieldDescription fieldDescription, TypeDescription instrumentedType, MethodDescription instrumentedMethod);
        protected enum TerminationHandler {
            RETURNING {
                @Override
                protected StackManipulation resolve(MethodDescription instrumentedMethod) {
                    if (!instrumentedMethod.getReturnType().represents(void.class)) {
                        throw new IllegalStateException("Cannot implement setter with return value for " + instrumentedMethod);
                    }
                    return MethodReturn.VOID;
                }
            }
            , NON_OPERATIONAL {
                @Override
                protected StackManipulation resolve(MethodDescription instrumentedMethod) {
                    return StackManipulation.Trivial.INSTANCE;
                }
            }
            ;
            protected abstract StackManipulation resolve(MethodDescription instrumentedMethod);
        }
        protected static class OfParameterValue extends ForSetter<Void> {
            private final int index;
            protected OfParameterValue(FieldLocation fieldLocation, Assigner assigner, Assigner.Typing typing, TerminationHandler terminationHandler, int index) {
                super(fieldLocation, assigner, typing, terminationHandler);
                this.index = index;
            }
            public InstrumentedType prepare(InstrumentedType instrumentedType) {
                return instrumentedType;
            }
            protected Void initialize(TypeDescription instrumentedType) {
                return null;
            }
            protected StackManipulation resolve(@MaybeNull Void unused, FieldDescription fieldDescription, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                if (instrumentedMethod.getParameters().size() <= index) {
                    throw new IllegalStateException(instrumentedMethod + " does not define a parameter with index " + index);
                } else {
                    return new StackManipulation.Compound(MethodVariableAccess.load(instrumentedMethod.getParameters().get(index)), assigner.assign(instrumentedMethod.getParameters().get(index).getType(), fieldDescription.getType(), typing));
                }
            }
            public Implementation andThen(Implementation implementation) {
                return new Compound(new OfParameterValue(fieldLocation, assigner, typing, TerminationHandler.NON_OPERATIONAL, index), implementation);
            }
            public Composable andThen(Composable implementation) {
                return new Compound.Composable(new OfParameterValue(fieldLocation, assigner, typing, TerminationHandler.NON_OPERATIONAL, index), implementation);
            }
        }
        protected static class OfDefaultValue extends ForSetter<Void> {
            protected OfDefaultValue(FieldLocation fieldLocation, Assigner assigner, Assigner.Typing typing, TerminationHandler terminationHandler) {
                super(fieldLocation, assigner, typing, terminationHandler);
            }
            public InstrumentedType prepare(InstrumentedType instrumentedType) {
                return instrumentedType;
            }
            protected Void initialize(TypeDescription instrumentedType) {
                return null;
            }
            protected StackManipulation resolve(@MaybeNull Void initialized, FieldDescription fieldDescription, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                return DefaultValue.of(fieldDescription.getType());
            }
            public Implementation andThen(Implementation implementation) {
                return new Compound(new OfDefaultValue(fieldLocation, assigner, typing, TerminationHandler.NON_OPERATIONAL), implementation);
            }
            public Composable andThen(Composable implementation) {
                return new Compound.Composable(new OfDefaultValue(fieldLocation, assigner, typing, TerminationHandler.NON_OPERATIONAL), implementation);
            }
        }
        protected static class OfConstantValue extends ForSetter<Void> {
            private final TypeDescription.Generic typeDescription;
            private final StackManipulation stackManipulation;
            protected OfConstantValue(FieldLocation fieldLocation, Assigner assigner, Assigner.Typing typing, TerminationHandler terminationHandler, TypeDescription.Generic typeDescription, StackManipulation stackManipulation) {
                super(fieldLocation, assigner, typing, terminationHandler);
                this.typeDescription = typeDescription;
                this.stackManipulation = stackManipulation;
            }
            public InstrumentedType prepare(InstrumentedType instrumentedType) {
                return instrumentedType;
            }
            protected Void initialize(TypeDescription instrumentedType) {
                return null;
            }
            protected StackManipulation resolve(@MaybeNull Void unused, FieldDescription fieldDescription, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                return new StackManipulation.Compound(stackManipulation, assigner.assign(typeDescription, fieldDescription.getType(), typing));
            }
            public Implementation andThen(Implementation implementation) {
                return new Compound(new OfConstantValue(fieldLocation, assigner, typing, TerminationHandler.NON_OPERATIONAL, typeDescription, stackManipulation), implementation);
            }
            public Composable andThen(Composable implementation) {
                return new Compound.Composable(new OfConstantValue(fieldLocation, assigner, typing, TerminationHandler.NON_OPERATIONAL, typeDescription, stackManipulation), implementation);
            }
        }
        protected static class OfReferenceValue extends ForSetter<FieldDescription.InDefinedShape> {
            protected static final String PREFIX = "fixedFieldValue";
            private final Object value;
            private final String name;
            protected OfReferenceValue(FieldLocation fieldLocation, Assigner assigner, Assigner.Typing typing, TerminationHandler terminationHandler, Object value, String name) {
                super(fieldLocation, assigner, typing, terminationHandler);
                this.value = value;
                this.name = name;
            }
            public InstrumentedType prepare(InstrumentedType instrumentedType) {
                return instrumentedType.withAuxiliaryField(new FieldDescription.Token(name, Opcodes.ACC_SYNTHETIC | Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, TypeDescription.ForLoadedType.of(value.getClass()).asGenericType()), value);
            }
            protected FieldDescription.InDefinedShape initialize(TypeDescription instrumentedType) {
                return instrumentedType.getDeclaredFields().filter(named(name)).getOnly();
            }
            protected StackManipulation resolve(@MaybeNull FieldDescription.InDefinedShape target, FieldDescription fieldDescription, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                if (fieldDescription.isFinal() && instrumentedMethod.isMethod()) {
                    throw new IllegalArgumentException("Cannot set final field " + fieldDescription + " from " + instrumentedMethod);
                }
                return new StackManipulation.Compound(FieldAccess.forField(target).read(), assigner.assign(TypeDescription.ForLoadedType.of(value.getClass()).asGenericType(), fieldDescription.getType(), typing));
            }
            public Implementation andThen(Implementation implementation) {
                return new Compound(new OfReferenceValue(fieldLocation, assigner, typing, TerminationHandler.NON_OPERATIONAL, value, name), implementation);
            }
            public Composable andThen(Composable implementation) {
                return new Compound.Composable(new OfReferenceValue(fieldLocation, assigner, typing, TerminationHandler.NON_OPERATIONAL, value, name), implementation);
            }
        }
        protected static class OfFieldValue extends ForSetter<FieldLocation.Prepared> {
            private final FieldLocation target;
            protected OfFieldValue(FieldLocation fieldLocation, Assigner assigner, Assigner.Typing typing, TerminationHandler terminationHandler, FieldLocation target) {
                super(fieldLocation, assigner, typing, terminationHandler);
                this.target = target;
            }
            public InstrumentedType prepare(InstrumentedType instrumentedType) {
                return instrumentedType;
            }
            protected FieldLocation.Prepared initialize(TypeDescription instrumentedType) {
                return target.prepare(instrumentedType);
            }
            protected StackManipulation resolve(@MaybeNull FieldLocation.Prepared target, FieldDescription fieldDescription, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                FieldDescription resolved = target.resolve(instrumentedMethod);
                if (!resolved.isStatic() && instrumentedMethod.isStatic()) {
                    throw new IllegalStateException("Cannot set instance field " + fieldDescription + " from " + instrumentedMethod);
                }
                return new StackManipulation.Compound(resolved.isStatic() ? StackManipulation.Trivial.INSTANCE : MethodVariableAccess.loadThis(), FieldAccess.forField(resolved).read(), assigner.assign(resolved.getType(), fieldDescription.getType(), typing));
            }
            public Implementation andThen(Implementation implementation) {
                return new Compound(new OfFieldValue(fieldLocation, assigner, typing, TerminationHandler.NON_OPERATIONAL, target), implementation);
            }
            public Composable andThen(Composable implementation) {
                return new Compound.Composable(new OfFieldValue(fieldLocation, assigner, typing, TerminationHandler.NON_OPERATIONAL, target), implementation);
            }
        }
        protected class Appender implements ByteCodeAppender {
            private final TypeDescription instrumentedType;
            private final T initialized;
            private final FieldLocation.Prepared fieldLocation;
            protected Appender(TypeDescription instrumentedType, @MaybeNull T initialized, FieldLocation.Prepared fieldLocation) {
                this.instrumentedType = instrumentedType;
                this.initialized = initialized;
                this.fieldLocation = fieldLocation;
            }
            public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
                FieldDescription fieldDescription = fieldLocation.resolve(instrumentedMethod);
                if (!fieldDescription.isStatic() && instrumentedMethod.isStatic()) {
                    throw new IllegalStateException("Cannot set instance field " + fieldDescription + " from " + instrumentedMethod);
                } else if (fieldDescription.isFinal() && instrumentedMethod.isMethod()) {
                    throw new IllegalStateException("Cannot set final field " + fieldDescription + " from " + instrumentedMethod);
                }
                StackManipulation stackManipulation = resolve(initialized, fieldDescription, instrumentedType, instrumentedMethod);
                if (!stackManipulation.isValid()) {
                    throw new IllegalStateException("Set value cannot be assigned to " + fieldDescription);
                }
                return new Size(new StackManipulation.Compound(instrumentedMethod.isStatic() ? StackManipulation.Trivial.INSTANCE : MethodVariableAccess.loadThis(), stackManipulation, FieldAccess.forField(fieldDescription).write(), terminationHandler.resolve(instrumentedMethod)).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```