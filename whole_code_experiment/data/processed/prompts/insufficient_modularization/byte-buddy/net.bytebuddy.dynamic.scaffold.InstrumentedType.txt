##CONTEXT_SIZE=11107
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.dynamic.scaffold;
public interface InstrumentedType extends TypeDescription {
    InstrumentedType withModuleDescription(@MaybeNull ModuleDescription moduleDescription);
    InstrumentedType withField(FieldDescription.Token token);
    InstrumentedType withAuxiliaryField(FieldDescription.Token token, Object value);
    InstrumentedType withMethod(MethodDescription.Token token);
    InstrumentedType withRecordComponent(RecordComponentDescription.Token token);
    InstrumentedType withModifiers(int modifiers);
    InstrumentedType withInterfaces(TypeList.Generic interfaceTypes);
    InstrumentedType withTypeVariable(TypeVariableToken typeVariable);
    InstrumentedType withAnnotations(List<? extends AnnotationDescription> annotationDescriptions);
    InstrumentedType withNestHost(TypeDescription nestHost);
    InstrumentedType withNestMembers(TypeList nestMembers);
    InstrumentedType withEnclosingType(TypeDescription enclosingType);
    InstrumentedType withEnclosingMethod(MethodDescription.InDefinedShape enclosingMethod);
    InstrumentedType withDeclaringType(@MaybeNull TypeDescription declaringType);
    InstrumentedType withDeclaredTypes(TypeList declaredTypes);
    InstrumentedType withPermittedSubclasses(@MaybeNull TypeList permittedSubclasses);
    InstrumentedType withLocalClass(boolean localClass);
    InstrumentedType withAnonymousClass(boolean anonymousClass);
    InstrumentedType withRecord(boolean record);
    InstrumentedType withInitializer(LoadedTypeInitializer loadedTypeInitializer);
    InstrumentedType withInitializer(ByteCodeAppender byteCodeAppender);
    LoadedTypeInitializer getLoadedTypeInitializer();
    TypeInitializer getTypeInitializer();
    TypeDescription validated();
    interface WithFlexibleName extends InstrumentedType {
        WithFlexibleName withModuleDescription(@MaybeNull ModuleDescription moduleDescription);
        WithFlexibleName withField(FieldDescription.Token token);
        WithFlexibleName withAuxiliaryField(FieldDescription.Token token, Object value);
        WithFlexibleName withMethod(MethodDescription.Token token);
        WithFlexibleName withRecordComponent(RecordComponentDescription.Token token);
        WithFlexibleName withModifiers(int modifiers);
        WithFlexibleName withInterfaces(TypeList.Generic interfaceTypes);
        WithFlexibleName withNestHost(TypeDescription nestHost);
        WithFlexibleName withNestMembers(TypeList nestMembers);
        WithFlexibleName withEnclosingType(@MaybeNull TypeDescription enclosingType);
        WithFlexibleName withEnclosingMethod(MethodDescription.InDefinedShape enclosingMethod);
        WithFlexibleName withDeclaringType(@MaybeNull TypeDescription declaringType);
        WithFlexibleName withDeclaredTypes(TypeList declaredTypes);
        WithFlexibleName withPermittedSubclasses(@MaybeNull TypeList permittedSubclasses);
        WithFlexibleName withLocalClass(boolean localClass);
        WithFlexibleName withAnonymousClass(boolean anonymousClass);
        WithFlexibleName withRecord(boolean record);
        WithFlexibleName withTypeVariable(TypeVariableToken typeVariable);
        WithFlexibleName withAnnotations(List<? extends AnnotationDescription> annotationDescriptions);
        WithFlexibleName withInitializer(LoadedTypeInitializer loadedTypeInitializer);
        WithFlexibleName withInitializer(ByteCodeAppender byteCodeAppender);
        WithFlexibleName withName(String name);
        WithFlexibleName withTypeVariables(ElementMatcher<? super Generic> matcher, Transformer<TypeVariableToken> transformer);
    }
    interface Prepareable {
        InstrumentedType prepare(InstrumentedType instrumentedType);
        enum NoOp implements Prepareable {
            INSTANCE;
            public InstrumentedType prepare(InstrumentedType instrumentedType) {
                return instrumentedType;
            }
        }
    }
    interface Factory {
        InstrumentedType.WithFlexibleName represent(TypeDescription typeDescription);
        InstrumentedType.WithFlexibleName subclass(String name, int modifiers, @MaybeNull TypeDescription.Generic superClass);
        enum Default implements Factory {
            MODIFIABLE {
                public InstrumentedType.WithFlexibleName represent(TypeDescription typeDescription) {
                    return new InstrumentedType.Default(typeDescription.getName(), typeDescription.getModifiers(), typeDescription.toModuleDescription(), typeDescription.getTypeVariables().asTokenList(is(typeDescription)), typeDescription.getSuperClass(), typeDescription.getInterfaces().accept(Generic.Visitor.Substitutor.ForDetachment.of(typeDescription)), typeDescription.getDeclaredFields().asTokenList(is(typeDescription)), Collections.<String, Object>emptyMap(), typeDescription.getDeclaredMethods().asTokenList(is(typeDescription)), typeDescription.getRecordComponents().asTokenList(is(typeDescription)), typeDescription.getDeclaredAnnotations(), TypeInitializer.None.INSTANCE, LoadedTypeInitializer.NoOp.INSTANCE, typeDescription.getDeclaringType(), typeDescription.getEnclosingMethod(), typeDescription.getEnclosingType(), typeDescription.getDeclaredTypes(), typeDescription.isSealed() ? typeDescription.getPermittedSubtypes() : TypeList.UNDEFINED, typeDescription.isAnonymousType(), typeDescription.isLocalType(), typeDescription.isRecord(), typeDescription.isNestHost() ? TargetType.DESCRIPTION : typeDescription.getNestHost(), typeDescription.isNestHost() ? typeDescription.getNestMembers().filter(not(is(typeDescription))) : Collections.<TypeDescription>emptyList());
                }
            }
            , FROZEN {
                public InstrumentedType.WithFlexibleName represent(TypeDescription typeDescription) {
                    return new Frozen(typeDescription, LoadedTypeInitializer.NoOp.INSTANCE);
                }
            }
            ;
            public InstrumentedType.WithFlexibleName subclass(String name, int modifiers, @MaybeNull TypeDescription.Generic superClass) {
                return new InstrumentedType.Default(name, modifiers, ModuleDescription.UNDEFINED, Collections.<TypeVariableToken>emptyList(), superClass, Collections.<Generic>emptyList(), Collections.<FieldDescription.Token>emptyList(), Collections.<String, Object>emptyMap(), Collections.<MethodDescription.Token>emptyList(), Collections.<RecordComponentDescription.Token>emptyList(), Collections.<AnnotationDescription>emptyList(), TypeInitializer.None.INSTANCE, LoadedTypeInitializer.NoOp.INSTANCE, TypeDescription.UNDEFINED, MethodDescription.UNDEFINED, TypeDescription.UNDEFINED, Collections.<TypeDescription>emptyList(), TypeList.UNDEFINED, false, false, false, TargetType.DESCRIPTION, Collections.<TypeDescription>emptyList());
            }
        }
    }
    class Default extends AbstractBase.OfSimpleType implements InstrumentedType.WithFlexibleName {
        private static final Set<String> KEYWORDS = new HashSet<String>(Arrays.asList("abstract", "continue", "for", "new", "switch", "assert", "default", "goto", "package", "synchronized", "boolean", "do", "if", "private", "this", "break", "double", "implements", "protected", "throw", "byte", "else", "import", "public", "throws", "case", "enum", "instanceof", "return", "transient", "catch", "extends", "int", "short", "try", "char", "final", "interface", "static", "void", "class", "finally", "long", "strictfp", "volatile", "const", "float", "native", "super", "while"));
        private final String name;
        private final int modifiers;
        private final Generic superClass;
        private final ModuleDescription moduleDescription;
        private final List<? extends TypeVariableToken> typeVariables;
        private final List<? extends Generic> interfaceTypes;
        private final List<? extends FieldDescription.Token> fieldTokens;
        private final Map<String, Object> auxiliaryFields;
        private final List<? extends MethodDescription.Token> methodTokens;
        private final List<? extends RecordComponentDescription.Token> recordComponentTokens;
        private final List<? extends AnnotationDescription> annotationDescriptions;
        private final TypeInitializer typeInitializer;
        private final LoadedTypeInitializer loadedTypeInitializer;
        private final TypeDescription declaringType;
        private final MethodDescription.InDefinedShape enclosingMethod;
        private final TypeDescription enclosingType;
        private final List<? extends TypeDescription> declaredTypes;
        private final List<? extends TypeDescription> permittedSubclasses;
        private final boolean anonymousClass;
        private final boolean localClass;
        private final boolean record;
        private final TypeDescription nestHost;
        private final List<? extends TypeDescription> nestMembers;
        protected Default(String name, int modifiers, @MaybeNull ModuleDescription moduleDescription, List<? extends TypeVariableToken> typeVariables, @MaybeNull Generic superClass, List<? extends Generic> interfaceTypes, List<? extends FieldDescription.Token> fieldTokens, Map<String, Object> auxiliaryFieldValues, List<? extends MethodDescription.Token> methodTokens, List<? extends RecordComponentDescription.Token> recordComponentTokens, List<? extends AnnotationDescription> annotationDescriptions, TypeInitializer typeInitializer, LoadedTypeInitializer loadedTypeInitializer, @MaybeNull TypeDescription declaringType, @MaybeNull MethodDescription.InDefinedShape enclosingMethod, @MaybeNull TypeDescription enclosingType, List<? extends TypeDescription> declaredTypes, @MaybeNull List<? extends TypeDescription> permittedSubclasses, boolean anonymousClass, boolean localClass, boolean record, TypeDescription nestHost, List<? extends TypeDescription> nestMembers) {
            this.name = name;
            this.modifiers = modifiers;
            this.moduleDescription = moduleDescription;
            this.typeVariables = typeVariables;
            this.superClass = superClass;
            this.interfaceTypes = interfaceTypes;
            this.fieldTokens = fieldTokens;
            this.auxiliaryFields = auxiliaryFieldValues;
            this.methodTokens = methodTokens;
            this.recordComponentTokens = recordComponentTokens;
            this.annotationDescriptions = annotationDescriptions;
            this.typeInitializer = typeInitializer;
            this.loadedTypeInitializer = loadedTypeInitializer;
            this.declaringType = declaringType;
            this.enclosingMethod = enclosingMethod;
            this.enclosingType = enclosingType;
            this.declaredTypes = declaredTypes;
            this.permittedSubclasses = permittedSubclasses;
            this.anonymousClass = anonymousClass;
            this.localClass = localClass;
            this.record = record;
            this.nestHost = nestHost;
            this.nestMembers = nestMembers;
        }
        public static InstrumentedType of(String name, TypeDescription.Generic superClass, ModifierContributor.ForType... modifierContributor) {
            return of(name, superClass, ModifierContributor.Resolver.of(modifierContributor).resolve());
        }
        public static InstrumentedType of(String name, TypeDescription.Generic superClass, int modifiers) {
            return Factory.Default.MODIFIABLE.subclass(name, modifiers, superClass);
        }
        public WithFlexibleName withModifiers(int modifiers) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withField(FieldDescription.Token token) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, CompoundList.of(fieldTokens, token.accept(Generic.Visitor.Substitutor.ForDetachment.of(this))), auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withAuxiliaryField(FieldDescription.Token token, Object value) {
            Map<String, Object> auxiliaryFields = new HashMap<String, Object>(this.auxiliaryFields);
            Object previous = auxiliaryFields.put(token.getName(), value);
            if (previous != null) {
                if (previous == value) {
                    return this;
                } else {
                    throw new IllegalStateException("Field " + token.getName() + " for " + this + " already mapped to " + previous + " and not " + value);
                }
            }
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, CompoundList.of(fieldTokens, token.accept(Generic.Visitor.Substitutor.ForDetachment.of(this))), auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, new LoadedTypeInitializer.Compound(loadedTypeInitializer, new LoadedTypeInitializer.ForStaticField(token.getName(), value)), declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withMethod(MethodDescription.Token token) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, CompoundList.of(methodTokens, token.accept(Generic.Visitor.Substitutor.ForDetachment.of(this))), recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withRecordComponent(RecordComponentDescription.Token token) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, CompoundList.of(recordComponentTokens, token.accept(Generic.Visitor.Substitutor.ForDetachment.of(this))), annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, true, nestHost, nestMembers);
        }
        public WithFlexibleName withInterfaces(TypeList.Generic interfaceTypes) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, CompoundList.of(this.interfaceTypes, interfaceTypes.accept(Generic.Visitor.Substitutor.ForDetachment.of(this))), fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withAnnotations(List<? extends AnnotationDescription> annotationDescriptions) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, CompoundList.of(this.annotationDescriptions, annotationDescriptions), typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withNestHost(TypeDescription nestHost) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost.equals(this) ? TargetType.DESCRIPTION : nestHost, Collections.<TypeDescription>emptyList());
        }
        public WithFlexibleName withNestMembers(TypeList nestMembers) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, TargetType.DESCRIPTION, CompoundList.of(this.nestMembers, nestMembers));
        }
        public WithFlexibleName withEnclosingType(@MaybeNull TypeDescription enclosingType) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, MethodDescription.UNDEFINED, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withEnclosingMethod(MethodDescription.InDefinedShape enclosingMethod) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingMethod.getDeclaringType(), declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withDeclaringType(@MaybeNull TypeDescription declaringType) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withDeclaredTypes(TypeList declaredTypes) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, CompoundList.of(this.declaredTypes, declaredTypes), permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withPermittedSubclasses(@MaybeNull TypeList permittedSubclasses) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses == null || this.permittedSubclasses == null ? permittedSubclasses : CompoundList.of(this.permittedSubclasses, permittedSubclasses), anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withModuleDescription(@MaybeNull ModuleDescription moduleDescription) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withTypeVariable(TypeVariableToken typeVariable) {
            return new Default(name, modifiers, moduleDescription, CompoundList.of(typeVariables, typeVariable.accept(Generic.Visitor.Substitutor.ForDetachment.of(this))), superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withName(String name) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withTypeVariables(ElementMatcher<? super Generic> matcher, Transformer<TypeVariableToken> transformer) {
            List<TypeVariableToken> typeVariables = new ArrayList<TypeVariableToken>(this.typeVariables.size());
            int index = 0;
            for (TypeVariableToken typeVariableToken : this.typeVariables) {
                typeVariables.add(matcher.matches(getTypeVariables().get(index++)) ? transformer.transform(this, typeVariableToken) : typeVariableToken);
            }
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withLocalClass(boolean localClass) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, false, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withAnonymousClass(boolean anonymousClass) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, false, record, nestHost, nestMembers);
        }
        public WithFlexibleName withRecord(boolean record) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, record ? recordComponentTokens : Collections.<RecordComponentDescription.Token>emptyList(), annotationDescriptions, typeInitializer, loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withInitializer(LoadedTypeInitializer loadedTypeInitializer) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer, new LoadedTypeInitializer.Compound(this.loadedTypeInitializer, loadedTypeInitializer), declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public WithFlexibleName withInitializer(ByteCodeAppender byteCodeAppender) {
            return new Default(name, modifiers, moduleDescription, typeVariables, superClass, interfaceTypes, fieldTokens, auxiliaryFields, methodTokens, recordComponentTokens, annotationDescriptions, typeInitializer.expandWith(byteCodeAppender), loadedTypeInitializer, declaringType, enclosingMethod, enclosingType, declaredTypes, permittedSubclasses, anonymousClass, localClass, record, nestHost, nestMembers);
        }
        public LoadedTypeInitializer getLoadedTypeInitializer() {
            return loadedTypeInitializer;
        }
        public TypeInitializer getTypeInitializer() {
            return typeInitializer;
        }
        public MethodDescription.InDefinedShape getEnclosingMethod() {
            return enclosingMethod;
        }
        public TypeDescription getEnclosingType() {
            return enclosingType;
        }
        public TypeList getDeclaredTypes() {
            return new TypeList.Explicit(declaredTypes);
        }
        public boolean isAnonymousType() {
            return anonymousClass;
        }
        public boolean isLocalType() {
            return localClass;
        }
        public PackageDescription getPackage() {
            int packageIndex = name.lastIndexOf('.');
            return packageIndex == -1 ? PackageDescription.DEFAULT : new PackageDescription.Simple(name.substring(0, packageIndex));
        }
        public ModuleDescription toModuleDescription() {
            return moduleDescription;
        }
        public AnnotationList getDeclaredAnnotations() {
            return new AnnotationList.Explicit(annotationDescriptions);
        }
        public TypeDescription getDeclaringType() {
            return declaringType;
        }
        public Generic getSuperClass() {
            return superClass == null ? Generic.UNDEFINED : new Generic.LazyProjection.WithResolvedErasure(superClass, Generic.Visitor.Substitutor.ForAttachment.of(this));
        }
        public TypeList.Generic getInterfaces() {
            return new TypeList.Generic.ForDetachedTypes.WithResolvedErasure(interfaceTypes, TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(this));
        }
        public FieldList<FieldDescription.InDefinedShape> getDeclaredFields() {
            return new FieldList.ForTokens(this, fieldTokens);
        }
        public MethodList<MethodDescription.InDefinedShape> getDeclaredMethods() {
            return new MethodList.ForTokens(this, methodTokens);
        }
        public TypeList.Generic getTypeVariables() {
            return TypeList.Generic.ForDetachedTypes.attachVariables(this, typeVariables);
        }
        public int getModifiers() {
            return modifiers;
        }
        public String getName() {
            return name;
        }
        public TypeDescription getNestHost() {
            return nestHost.represents(TargetType.class) ? this : nestHost;
        }
        public TypeList getNestMembers() {
            return nestHost.represents(TargetType.class) ? new TypeList.Explicit(CompoundList.of(this, nestMembers)) : nestHost.getNestMembers();
        }
        public RecordComponentList<RecordComponentDescription.InDefinedShape> getRecordComponents() {
            return new RecordComponentList.ForTokens(this, recordComponentTokens);
        }
        public boolean isRecord() {
            return record && superClass != null && getSuperClass().asErasure().equals(JavaType.RECORD.getTypeStub());
        }
        public boolean isSealed() {
            return permittedSubclasses != null;
        }
        public TypeList getPermittedSubtypes() {
            return permittedSubclasses == null ? new TypeList.Empty() : new TypeList.Explicit(permittedSubclasses);
        }
        public TypeDescription validated() {
            if (!isValidIdentifier(getName().split("\\."))) {
                throw new IllegalStateException("Illegal type name: " + getName() + " for " + this);
            } else if ((getModifiers() & ~ModifierContributor.ForType.MASK) != EMPTY_MASK) {
                throw new IllegalStateException("Illegal modifiers " + getModifiers() + " for " + this);
            } else if (isPackageType() && getModifiers() != PackageDescription.PACKAGE_MODIFIERS) {
                throw new IllegalStateException("Illegal modifiers " + getModifiers() + " for package " + this);
            } else if (isModuleType() && getModifiers() != ModifierContributor.EMPTY_MASK) {
                throw new IllegalStateException("Illegal modifiers " + getModifiers() + " for module " + this);
            }
            TypeDescription.Generic superClass = getSuperClass();
            if (superClass != null) {
                if (!superClass.accept(Generic.Visitor.Validator.SUPER_CLASS)) {
                    throw new IllegalStateException("Illegal super class " + superClass + " for " + this);
                } else if (!superClass.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {
                    throw new IllegalStateException("Illegal type annotations on super class " + superClass + " for " + this);
                } else if (!superClass.asErasure().isVisibleTo(this)) {
                    throw new IllegalStateException("Invisible super type " + superClass + " for " + this);
                }
            }
            Set<TypeDescription> interfaceErasures = new HashSet<TypeDescription>();
            for (TypeDescription.Generic interfaceType : getInterfaces()) {
                if (!interfaceType.accept(Generic.Visitor.Validator.INTERFACE)) {
                    throw new IllegalStateException("Illegal interface " + interfaceType + " for " + this);
                } else if (!interfaceType.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {
                    throw new IllegalStateException("Illegal type annotations on interface " + interfaceType + " for " + this);
                } else if (!interfaceErasures.add(interfaceType.asErasure())) {
                    throw new IllegalStateException("Already implemented interface " + interfaceType + " for " + this);
                } else if (!interfaceType.asErasure().isVisibleTo(this)) {
                    throw new IllegalStateException("Invisible interface type " + interfaceType + " for " + this);
                }
            }
            TypeList.Generic typeVariables = getTypeVariables();
            if (!typeVariables.isEmpty() && isAssignableTo(Throwable.class)) {
                throw new IllegalStateException("Cannot define throwable " + this + " to be generic");
            }
            Set<String> typeVariableNames = new HashSet<String>();
            for (TypeDescription.Generic typeVariable : typeVariables) {
                String variableSymbol = typeVariable.getSymbol();
                if (!typeVariableNames.add(variableSymbol)) {
                    throw new IllegalStateException("Duplicate type variable symbol '" + typeVariable + "' for " + this);
                } else if (!isValidIdentifier(variableSymbol)) {
                    throw new IllegalStateException("Illegal type variable name '" + typeVariable + "' for " + this);
                } else if (!Generic.Visitor.Validator.ForTypeAnnotations.ofFormalTypeVariable(typeVariable)) {
                    throw new IllegalStateException("Illegal type annotation on '" + typeVariable + "' for " + this);
                }
                boolean interfaceBound = false;
                Set<TypeDescription.Generic> bounds = new HashSet<Generic>();
                for (TypeDescription.Generic bound : typeVariable.getUpperBounds()) {
                    if (!bound.accept(Generic.Visitor.Validator.TYPE_VARIABLE)) {
                        throw new IllegalStateException("Illegal type variable bound " + bound + " of " + typeVariable + " for " + this);
                    } else if (!bound.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {
                        throw new IllegalStateException("Illegal type annotations on type variable " + bound + " for " + this);
                    } else if (!bounds.add(bound)) {
                        throw new IllegalStateException("Duplicate bound " + bound + " of " + typeVariable + " for " + this);
                    } else if (interfaceBound && (bound.getSort().isTypeVariable() || !bound.isInterface())) {
                        throw new IllegalStateException("Illegal interface bound " + bound + " of " + typeVariable + " for " + this);
                    }
                    interfaceBound = true;
                }
                if (!interfaceBound) {
                    throw new IllegalStateException("Type variable " + typeVariable + " for " + this + " does not define at least one bound");
                }
            }
            TypeDescription enclosingType = getEnclosingType();
            if (enclosingType != null && (enclosingType.isArray() || enclosingType.isPrimitive())) {
                throw new IllegalStateException("Cannot define array type or primitive type " + enclosingType + " + as enclosing type for " + this);
            }
            MethodDescription.InDefinedShape enclosingMethod = getEnclosingMethod();
            if (enclosingMethod != null && enclosingMethod.isTypeInitializer()) {
                throw new IllegalStateException("Cannot enclose type declaration in class initializer " + enclosingMethod);
            }
            TypeDescription declaringType = getDeclaringType();
            if (declaringType != null) {
                if (declaringType.isPrimitive() || declaringType.isArray()) {
                    throw new IllegalStateException("Cannot define array type or primitive type " + declaringType + " as declaring type for " + this);
                }
            } else if (enclosingType == null && enclosingMethod == null && (isLocalType() || isAnonymousType())) {
                throw new IllegalStateException("Cannot define an anonymous or local class without a declaring type for " + this);
            }
            Set<TypeDescription> declaredTypes = new HashSet<TypeDescription>();
            for (TypeDescription declaredType : getDeclaredTypes()) {
                if (declaredType.isArray() || declaredType.isPrimitive()) {
                    throw new IllegalStateException("Cannot define array type or primitive type " + declaredType + " + as declared type for " + this);
                } else if (!declaredTypes.add(declaredType)) {
                    throw new IllegalStateException("Duplicate definition of declared type " + declaredType);
                }
            }
            TypeDescription nestHost = getNestHost();
            if (nestHost.equals(this)) {
                Set<TypeDescription> nestMembers = new HashSet<TypeDescription>();
                for (TypeDescription nestMember : getNestMembers()) {
                    if (nestMember.isArray() || nestMember.isPrimitive()) {
                        throw new IllegalStateException("Cannot define array type or primitive type " + nestMember + " + as nest member of " + this);
                    } else if (!nestMember.isSamePackage(this)) {
                        throw new IllegalStateException("Cannot define nest member " + nestMember + " + within different package then " + this);
                    } else if (!nestMembers.add(nestMember)) {
                        throw new IllegalStateException("Duplicate definition of nest member " + nestMember);
                    }
                }
            } else if (nestHost.isArray() || nestHost.isPrimitive()) {
                throw new IllegalStateException("Cannot define array type or primitive type " + nestHost + " + as nest host for " + this);
            } else if (!nestHost.isSamePackage(this)) {
                throw new IllegalStateException("Cannot define nest host " + nestHost + " within different package then " + this);
            }
            for (TypeDescription permittedSubclass : getPermittedSubtypes()) {
                if (!permittedSubclass.isAssignableTo(this) || permittedSubclass.equals(this)) {
                    throw new IllegalStateException("Cannot assign permitted subclass " + permittedSubclass + " to " + this);
                }
            }
            Set<TypeDescription> typeAnnotationTypes = new HashSet<TypeDescription>();
            for (AnnotationDescription annotationDescription : getDeclaredAnnotations()) {
                if (!annotationDescription.isSupportedOn(ElementType.TYPE) && !(isAnnotation() && annotationDescription.isSupportedOn(ElementType.ANNOTATION_TYPE)) && !(isPackageType() && annotationDescription.isSupportedOn(ElementType.PACKAGE)) && !(isModuleType() && annotationDescription.isSupportedOn("MODULE"))) {
                    throw new IllegalStateException("Cannot add " + annotationDescription + " on " + this);
                } else if (!typeAnnotationTypes.add(annotationDescription.getAnnotationType())) {
                    throw new IllegalStateException("Duplicate annotation " + annotationDescription + " for " + this);
                }
            }
            Set<FieldDescription.SignatureToken> fieldSignatureTokens = new HashSet<FieldDescription.SignatureToken>();
            for (FieldDescription.InDefinedShape fieldDescription : getDeclaredFields()) {
                String fieldName = fieldDescription.getName();
                if (!fieldSignatureTokens.add(fieldDescription.asSignatureToken())) {
                    throw new IllegalStateException("Duplicate field definition for " + fieldDescription);
                } else if (!isValidUnqualifiedNameIdentifier(fieldName)) {
                    throw new IllegalStateException("Illegal field name for " + fieldDescription);
                } else if ((fieldDescription.getModifiers() & ~ModifierContributor.ForField.MASK) != EMPTY_MASK) {
                    throw new IllegalStateException("Illegal field modifiers " + fieldDescription.getModifiers() + " for " + fieldDescription);
                }
                Generic fieldType = fieldDescription.getType();
                if (!fieldType.accept(Generic.Visitor.Validator.FIELD)) {
                    throw new IllegalStateException("Illegal field type " + fieldType + " for " + fieldDescription);
                } else if (!fieldType.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {
                    throw new IllegalStateException("Illegal type annotations on " + fieldType + " for " + this);
                } else if (!fieldDescription.isSynthetic() && !fieldType.asErasure().isVisibleTo(this)) {
                    throw new IllegalStateException("Invisible field type " + fieldDescription.getType() + " for " + fieldDescription);
                }
                Set<TypeDescription> fieldAnnotationTypes = new HashSet<TypeDescription>();
                for (AnnotationDescription annotationDescription : fieldDescription.getDeclaredAnnotations()) {
                    if (!annotationDescription.isSupportedOn(ElementType.FIELD)) {
                        throw new IllegalStateException("Cannot add " + annotationDescription + " on " + fieldDescription);
                    } else if (!fieldAnnotationTypes.add(annotationDescription.getAnnotationType())) {
                        throw new IllegalStateException("Duplicate annotation " + annotationDescription + " for " + fieldDescription);
                    }
                }
            }
            Set<MethodDescription.SignatureToken> methodSignatureTokens = new HashSet<MethodDescription.SignatureToken>();
            for (MethodDescription.InDefinedShape methodDescription : getDeclaredMethods()) {
                if (!methodSignatureTokens.add(methodDescription.asSignatureToken())) {
                    throw new IllegalStateException("Duplicate method signature for " + methodDescription);
                } else if ((methodDescription.getModifiers() & ~ModifierContributor.ForMethod.MASK) != 0) {
                    throw new IllegalStateException("Illegal modifiers " + methodDescription.getModifiers() + " for " + methodDescription);
                } else if (methodDescription.isAbstract() && (methodDescription.getModifiers() & Opcodes.ACC_STRICT) != 0) {
                    throw new IllegalStateException("Cannot declare strict computations for " + methodDescription);
                } else if (isInterface() && !methodDescription.isPublic() && !methodDescription.isPrivate()) {
                    throw new IllegalStateException("Methods declared by an interface must be public or private " + methodDescription);
                }
                Set<String> methodTypeVariableNames = new HashSet<String>();
                for (TypeDescription.Generic typeVariable : methodDescription.getTypeVariables()) {
                    String variableSymbol = typeVariable.getSymbol();
                    if (!methodTypeVariableNames.add(variableSymbol)) {
                        throw new IllegalStateException("Duplicate type variable symbol '" + typeVariable + "' for " + methodDescription);
                    } else if (!isValidIdentifier(variableSymbol)) {
                        throw new IllegalStateException("Illegal type variable name '" + typeVariable + "' for " + methodDescription);
                    } else if (!Generic.Visitor.Validator.ForTypeAnnotations.ofFormalTypeVariable(typeVariable)) {
                        throw new IllegalStateException("Illegal type annotation on '" + typeVariable + "' for " + methodDescription);
                    }
                    boolean interfaceBound = false;
                    Set<TypeDescription.Generic> bounds = new HashSet<Generic>();
                    for (TypeDescription.Generic bound : typeVariable.getUpperBounds()) {
                        if (!bound.accept(Generic.Visitor.Validator.TYPE_VARIABLE)) {
                            throw new IllegalStateException("Illegal type variable bound " + bound + " of " + typeVariable + " for " + methodDescription);
                        } else if (!bound.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {
                            throw new IllegalStateException("Illegal type annotations on bound " + bound + " of " + typeVariable + " for " + this);
                        } else if (!bounds.add(bound)) {
                            throw new IllegalStateException("Duplicate bound " + bound + " of " + typeVariable + " for " + methodDescription);
                        } else if (interfaceBound && (bound.getSort().isTypeVariable() || !bound.isInterface())) {
                            throw new IllegalStateException("Illegal interface bound " + bound + " of " + typeVariable + " for " + methodDescription);
                        }
                        interfaceBound = true;
                    }
                    if (!interfaceBound) {
                        throw new IllegalStateException("Type variable " + typeVariable + " for " + methodDescription + " does not define at least one bound");
                    }
                }
                Generic returnType = methodDescription.getReturnType();
                if (methodDescription.isTypeInitializer()) {
                    throw new IllegalStateException("Illegal explicit declaration of a type initializer by " + this);
                } else if (methodDescription.isConstructor()) {
                    if (!returnType.represents(void.class)) {
                        throw new IllegalStateException("A constructor must return void " + methodDescription);
                    } else if (!returnType.getDeclaredAnnotations().isEmpty()) {
                        throw new IllegalStateException("The void non-type must not be annotated for " + methodDescription);
                    }
                } else if (!isValidMethodIdentifier(methodDescription.getInternalName())) {
                    throw new IllegalStateException("Illegal method name " + returnType + " for " + methodDescription);
                } else if (!returnType.accept(Generic.Visitor.Validator.METHOD_RETURN)) {
                    throw new IllegalStateException("Illegal return type " + returnType + " for " + methodDescription);
                } else if (!returnType.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {
                    throw new IllegalStateException("Illegal type annotations on return type " + returnType + " for " + methodDescription);
                } else if (!methodDescription.isSynthetic() && !methodDescription.getReturnType().asErasure().isVisibleTo(this)) {
                    throw new IllegalStateException("Invisible return type " + methodDescription.getReturnType() + " for " + methodDescription);
                }
                Set<String> parameterNames = new HashSet<String>();
                for (ParameterDescription.InDefinedShape parameterDescription : methodDescription.getParameters()) {
                    Generic parameterType = parameterDescription.getType();
                    if (!parameterType.accept(Generic.Visitor.Validator.METHOD_PARAMETER)) {
                        throw new IllegalStateException("Illegal parameter type of " + parameterDescription + " for " + methodDescription);
                    } else if (!parameterType.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {
                        throw new IllegalStateException("Illegal type annotations on parameter " + parameterDescription + " for " + methodDescription);
                    } else if (!methodDescription.isSynthetic() && !parameterType.asErasure().isVisibleTo(this)) {
                        throw new IllegalStateException("Invisible parameter type of " + parameterDescription + " for " + methodDescription);
                    }
                    if (parameterDescription.isNamed()) {
                        String parameterName = parameterDescription.getName();
                        if (!parameterNames.add(parameterName)) {
                            throw new IllegalStateException("Duplicate parameter name of " + parameterDescription + " for " + methodDescription);
                        } else if (!isValidUnqualifiedNameIdentifier(parameterName)) {
                            throw new IllegalStateException("Illegal parameter name of " + parameterDescription + " for " + methodDescription);
                        }
                    }
                    if (parameterDescription.hasModifiers() && (parameterDescription.getModifiers() & ~ModifierContributor.ForParameter.MASK) != EMPTY_MASK) {
                        throw new IllegalStateException("Illegal modifiers of " + parameterDescription + " for " + methodDescription);
                    }
                    Set<TypeDescription> parameterAnnotationTypes = new HashSet<TypeDescription>();
                    for (AnnotationDescription annotationDescription : parameterDescription.getDeclaredAnnotations()) {
                        if (!annotationDescription.isSupportedOn(ElementType.PARAMETER)) {
                            throw new IllegalStateException("Cannot add " + annotationDescription + " on " + parameterDescription);
                        } else if (!parameterAnnotationTypes.add(annotationDescription.getAnnotationType())) {
                            throw new IllegalStateException("Duplicate annotation " + annotationDescription + " of " + parameterDescription + " for " + methodDescription);
                        }
                    }
                }
                for (TypeDescription.Generic exceptionType : methodDescription.getExceptionTypes()) {
                    if (!exceptionType.accept(Generic.Visitor.Validator.EXCEPTION)) {
                        throw new IllegalStateException("Illegal exception type " + exceptionType + " for " + methodDescription);
                    } else if (!exceptionType.accept(Generic.Visitor.Validator.ForTypeAnnotations.INSTANCE)) {
                        throw new IllegalStateException("Illegal type annotations on " + exceptionType + " for " + methodDescription);
                    } else if (!methodDescription.isSynthetic() && !exceptionType.asErasure().isVisibleTo(this)) {
                        throw new IllegalStateException("Invisible exception type " + exceptionType + " for " + methodDescription);
                    }
                }
                Set<TypeDescription> methodAnnotationTypes = new HashSet<TypeDescription>();
                for (AnnotationDescription annotationDescription : methodDescription.getDeclaredAnnotations()) {
                    if (!annotationDescription.isSupportedOn(methodDescription.isMethod() ? ElementType.METHOD : ElementType.CONSTRUCTOR)) {
                        throw new IllegalStateException("Cannot add " + annotationDescription + " on " + methodDescription);
                    } else if (!methodAnnotationTypes.add(annotationDescription.getAnnotationType())) {
                        throw new IllegalStateException("Duplicate annotation " + annotationDescription + " for " + methodDescription);
                    }
                }
                AnnotationValue<?, ?> defaultValue = methodDescription.getDefaultValue();
                if (defaultValue != null && !methodDescription.isDefaultValue(defaultValue)) {
                    throw new IllegalStateException("Illegal default value " + defaultValue + "for " + methodDescription);
                }
                Generic receiverType = methodDescription.getReceiverType();
                if (receiverType != null && !receiverType.accept(Generic.Visitor.Validator.RECEIVER)) {
                    throw new IllegalStateException("Illegal receiver type " + receiverType + " for " + methodDescription);
                } else if (methodDescription.isStatic()) {
                    if (receiverType != null) {
                        throw new IllegalStateException("Static method " + methodDescription + " defines a non-null receiver " + receiverType);
                    }
                } else if (methodDescription.isConstructor()) {
                    if (receiverType == null || !receiverType.asErasure().equals(enclosingType == null ? this : enclosingType)) {
                        throw new IllegalStateException("Constructor " + methodDescription + " defines an illegal receiver " + receiverType);
                    }
                } else if (receiverType == null || !equals(receiverType.asErasure())) {
                    throw new IllegalStateException("Method " + methodDescription + " defines an illegal receiver " + receiverType);
                }
            }
            return this;
        }
        private static boolean isValidIdentifier(String[] identifier) {
            if (identifier.length == 0) {
                return false;
            }
            for (String part : identifier) {
                if (!isValidIdentifier(part)) {
                    return false;
                }
            }
            return true;
        }
        private static boolean isValidIdentifier(String identifier) {
            if (KEYWORDS.contains(identifier) || identifier.length() == 0 || !(Character.isJavaIdentifierStart(identifier.charAt(0)) || Character.isUnicodeIdentifierStart(identifier.charAt(0)))) {
                return false;
            } else if (identifier.equals(PackageDescription.PACKAGE_CLASS_NAME) || identifier.equals(ModuleDescription.MODULE_CLASS_NAME)) {
                return true;
            }
            for (int index = 1; index < identifier.length(); index++) {
                if (!(Character.isJavaIdentifierPart(identifier.charAt(index)) || Character.isUnicodeIdentifierPart(identifier.charAt(index)))) {
                    return false;
                }
            }
            return true;
        }
        private static boolean isValidUnqualifiedNameIdentifier(String identifier) {
            if (identifier.length() == 0) {
                return false;
            }
            for (int index = 0; index < identifier.length(); index++) {
                switch(identifier.charAt(index)) {
                    case '.':
                    case ';':
                    case '[':
                    case '/':
                        return false;
                }
            }
            return true;
        }
        private static boolean isValidMethodIdentifier(String identifier) {
            if (identifier.length() == 0) {
                return false;
            }
            if (identifier.equals(MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME) || identifier.equals(MethodDescription.CONSTRUCTOR_INTERNAL_NAME)) {
                return true;
            }
            for (int index = 0; index < identifier.length(); index++) {
                switch(identifier.charAt(index)) {
                    case '.':
                    case ';':
                    case '[':
                    case '/':
                    case '<':
                    case '>':
                        return false;
                }
            }
            return true;
        }
    }
    class Frozen extends AbstractBase.OfSimpleType implements InstrumentedType.WithFlexibleName {
        private final TypeDescription typeDescription;
        private final LoadedTypeInitializer loadedTypeInitializer;
        protected Frozen(TypeDescription typeDescription, LoadedTypeInitializer loadedTypeInitializer) {
            this.typeDescription = typeDescription;
            this.loadedTypeInitializer = loadedTypeInitializer;
        }
        public AnnotationList getDeclaredAnnotations() {
            return typeDescription.getDeclaredAnnotations();
        }
        public int getModifiers() {
            return typeDescription.getModifiers();
        }
        public TypeList.Generic getTypeVariables() {
            return typeDescription.getTypeVariables();
        }
        public String getName() {
            return typeDescription.getName();
        }
        public Generic getSuperClass() {
            return typeDescription.getSuperClass();
        }
        public TypeList.Generic getInterfaces() {
            return typeDescription.getInterfaces();
        }
        public FieldList<FieldDescription.InDefinedShape> getDeclaredFields() {
            return typeDescription.getDeclaredFields();
        }
        public MethodList<MethodDescription.InDefinedShape> getDeclaredMethods() {
            return typeDescription.getDeclaredMethods();
        }
        public boolean isAnonymousType() {
            return typeDescription.isAnonymousType();
        }
        public boolean isLocalType() {
            return typeDescription.isLocalType();
        }
        public PackageDescription getPackage() {
            return typeDescription.getPackage();
        }
        public ModuleDescription toModuleDescription() {
            return typeDescription.toModuleDescription();
        }
        public TypeDescription getEnclosingType() {
            return typeDescription.getEnclosingType();
        }
        public TypeDescription getDeclaringType() {
            return typeDescription.getDeclaringType();
        }
        public TypeList getDeclaredTypes() {
            return typeDescription.getDeclaredTypes();
        }
        public MethodDescription.InDefinedShape getEnclosingMethod() {
            return typeDescription.getEnclosingMethod();
        }
        public String getGenericSignature() {
            return typeDescription.getGenericSignature();
        }
        public int getActualModifiers(boolean superFlag) {
            return typeDescription.getActualModifiers(superFlag);
        }
        public TypeDescription getNestHost() {
            return typeDescription.getNestHost();
        }
        public TypeList getNestMembers() {
            return typeDescription.getNestMembers();
        }
        public RecordComponentList<RecordComponentDescription.InDefinedShape> getRecordComponents() {
            return typeDescription.getRecordComponents();
        }
        public boolean isRecord() {
            return typeDescription.isRecord();
        }
        public boolean isSealed() {
            return typeDescription.isSealed();
        }
        public TypeList getPermittedSubtypes() {
            return typeDescription.getPermittedSubtypes();
        }
        public WithFlexibleName withModuleDescription(@MaybeNull ModuleDescription moduleDescription) {
            throw new IllegalStateException("Cannot define module meta data for frozen type: " + typeDescription);
        }
        public WithFlexibleName withField(FieldDescription.Token token) {
            throw new IllegalStateException("Cannot define field for frozen type: " + typeDescription);
        }
        public WithFlexibleName withAuxiliaryField(FieldDescription.Token token, Object value) {
            throw new IllegalStateException("Cannot define auxiliary field for frozen type: " + typeDescription);
        }
        public WithFlexibleName withMethod(MethodDescription.Token token) {
            throw new IllegalStateException("Cannot define method for frozen type: " + typeDescription);
        }
        public WithFlexibleName withRecordComponent(RecordComponentDescription.Token token) {
            throw new IllegalStateException("Cannot define record component for frozen type: " + typeDescription);
        }
        public WithFlexibleName withModifiers(int modifiers) {
            throw new IllegalStateException("Cannot change modifiers for frozen type: " + typeDescription);
        }
        public WithFlexibleName withInterfaces(TypeList.Generic interfaceTypes) {
            throw new IllegalStateException("Cannot add interfaces for frozen type: " + typeDescription);
        }
        public WithFlexibleName withTypeVariable(TypeVariableToken typeVariable) {
            throw new IllegalStateException("Cannot define type variable for frozen type: " + typeDescription);
        }
        public WithFlexibleName withAnnotations(List<? extends AnnotationDescription> annotationDescriptions) {
            throw new IllegalStateException("Cannot add annotation to frozen type: " + typeDescription);
        }
        public WithFlexibleName withNestHost(TypeDescription nestHost) {
            throw new IllegalStateException("Cannot set nest host of frozen type: " + typeDescription);
        }
        public WithFlexibleName withNestMembers(TypeList nestMembers) {
            throw new IllegalStateException("Cannot add nest members to frozen type: " + typeDescription);
        }
        public WithFlexibleName withEnclosingType(@MaybeNull TypeDescription enclosingType) {
            throw new IllegalStateException("Cannot set enclosing type of frozen type: " + typeDescription);
        }
        public WithFlexibleName withEnclosingMethod(MethodDescription.InDefinedShape enclosingMethod) {
            throw new IllegalStateException("Cannot set enclosing method of frozen type: " + typeDescription);
        }
        public WithFlexibleName withDeclaringType(@MaybeNull TypeDescription declaringType) {
            throw new IllegalStateException("Cannot add declaring type to frozen type: " + typeDescription);
        }
        public WithFlexibleName withDeclaredTypes(TypeList declaredTypes) {
            throw new IllegalStateException("Cannot add declared types to frozen type: " + typeDescription);
        }
        public WithFlexibleName withPermittedSubclasses(@MaybeNull TypeList permittedSubclasses) {
            throw new IllegalStateException("Cannot add permitted subclasses to frozen type: " + typeDescription);
        }
        public WithFlexibleName withLocalClass(boolean localClass) {
            throw new IllegalStateException("Cannot define local class state for frozen type: " + typeDescription);
        }
        public WithFlexibleName withAnonymousClass(boolean anonymousClass) {
            throw new IllegalStateException("Cannot define anonymous class state for frozen type: " + typeDescription);
        }
        public WithFlexibleName withRecord(boolean record) {
            throw new IllegalStateException("Cannot define record state for frozen type: " + typeDescription);
        }
        public WithFlexibleName withInitializer(LoadedTypeInitializer loadedTypeInitializer) {
            return new Frozen(typeDescription, new LoadedTypeInitializer.Compound(this.loadedTypeInitializer, loadedTypeInitializer));
        }
        public WithFlexibleName withInitializer(ByteCodeAppender byteCodeAppender) {
            throw new IllegalStateException("Cannot add initializer to frozen type: " + typeDescription);
        }
        public WithFlexibleName withName(String name) {
            throw new IllegalStateException("Cannot change name of frozen type: " + typeDescription);
        }
        public WithFlexibleName withTypeVariables(ElementMatcher<? super Generic> matcher, Transformer<TypeVariableToken> transformer) {
            throw new IllegalStateException("Cannot add type variables of frozen type: " + typeDescription);
        }
        public LoadedTypeInitializer getLoadedTypeInitializer() {
            return loadedTypeInitializer;
        }
        public TypeInitializer getTypeInitializer() {
            return TypeInitializer.None.INSTANCE;
        }
        public ClassFileVersion getClassFileVersion() {
            return typeDescription.getClassFileVersion();
        }
        public TypeDescription validated() {
            return typeDescription;
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```