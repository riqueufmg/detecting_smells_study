##CONTEXT_SIZE=2015
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.implementation;
public abstract class InvocationHandlerAdapter implements Implementation.Composable {
    private static final TypeDescription.Generic INVOCATION_HANDLER_TYPE = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(InvocationHandler.class);
    private static final boolean UNCACHED = false;
    private static final boolean CACHED = true;
    private static final boolean UNPRIVILEGED = false;
    private static final boolean PRIVILEGED = true;
    private static final boolean RETURNING = true;
    private static final boolean DROPPING = false;
    protected final String fieldName;
    protected final boolean cached;
    protected final boolean privileged;
    protected final boolean returning;
    protected final Assigner assigner;
    protected InvocationHandlerAdapter(String fieldName, boolean cached, boolean privileged, boolean returning, Assigner assigner) {
        this.fieldName = fieldName;
        this.cached = cached;
        this.privileged = privileged;
        this.returning = returning;
        this.assigner = assigner;
    }
    public static InvocationHandlerAdapter of(InvocationHandler invocationHandler) {
        return of(invocationHandler, ForInstance.PREFIX + "$" + RandomString.hashOf(invocationHandler));
    }
    public static InvocationHandlerAdapter of(InvocationHandler invocationHandler, String fieldName) {
        return new ForInstance(fieldName, CACHED, UNPRIVILEGED, RETURNING, Assigner.DEFAULT, invocationHandler);
    }
    public static InvocationHandlerAdapter toField(String name) {
        return toField(name, FieldLocator.ForClassHierarchy.Factory.INSTANCE);
    }
    public static InvocationHandlerAdapter toField(String name, FieldLocator.Factory fieldLocatorFactory) {
        return new ForField(name, CACHED, UNPRIVILEGED, RETURNING, Assigner.DEFAULT, fieldLocatorFactory);
    }
    private List<StackManipulation> argumentValuesOf(MethodDescription instrumentedMethod) {
        TypeList.Generic parameterTypes = instrumentedMethod.getParameters().asTypeList();
        List<StackManipulation> instruction = new ArrayList<StackManipulation>(parameterTypes.size());
        int currentIndex = 1;
        for (TypeDescription.Generic parameterType : parameterTypes) {
            instruction.add(new StackManipulation.Compound(MethodVariableAccess.of(parameterType).loadFrom(currentIndex), assigner.assign(parameterType, TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class), Assigner.Typing.STATIC)));
            currentIndex += parameterType.getStackSize().getSize();
        }
        return instruction;
    }
    public abstract WithoutPrivilegeConfiguration withoutMethodCache();
    public abstract Implementation withAssigner(Assigner assigner);
    public abstract AssignerConfigurable withPrivilegedLookup();
    protected ByteCodeAppender.Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod, StackManipulation preparingManipulation, FieldDescription fieldDescription) {
        if (instrumentedMethod.isStatic() || instrumentedMethod.isConstructor()) {
            throw new IllegalStateException("It is not possible to apply an invocation handler onto the static method or constructor " + instrumentedMethod);
        }
        MethodConstant.CanCache methodConstant = privileged ? MethodConstant.ofPrivileged(instrumentedMethod.asDefined()) : MethodConstant.of(instrumentedMethod.asDefined());
        StackManipulation.Size stackSize = new StackManipulation.Compound(preparingManipulation, FieldAccess.forField(fieldDescription).read(), MethodVariableAccess.loadThis(), cached ? methodConstant.cached() : methodConstant, instrumentedMethod.getParameters().isEmpty() ? NullConstant.INSTANCE : ArrayFactory.forType(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class)).withValues(argumentValuesOf(instrumentedMethod)), MethodInvocation.invoke(INVOCATION_HANDLER_TYPE.getDeclaredMethods().filter(isAbstract()).getOnly()), returning ? new StackManipulation.Compound(assigner.assign(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class), instrumentedMethod.getReturnType(), Assigner.Typing.DYNAMIC), MethodReturn.of(instrumentedMethod.getReturnType())) : Removal.SINGLE).apply(methodVisitor, implementationContext);
        return new ByteCodeAppender.Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
    }
    public interface AssignerConfigurable extends Implementation.Composable {
        Implementation.Composable withAssigner(Assigner assigner);
    }
    public interface WithoutPrivilegeConfiguration extends AssignerConfigurable {
        AssignerConfigurable withPrivilegedLookup();
    }
    protected static class ForInstance extends InvocationHandlerAdapter implements WithoutPrivilegeConfiguration {
        private static final String PREFIX = "invocationHandler";
        protected final InvocationHandler invocationHandler;
        protected ForInstance(String fieldName, boolean cached, boolean privileged, boolean returning, Assigner assigner, InvocationHandler invocationHandler) {
            super(fieldName, cached, privileged, returning, assigner);
            this.invocationHandler = invocationHandler;
        }
        public WithoutPrivilegeConfiguration withoutMethodCache() {
            return new ForInstance(fieldName, UNCACHED, privileged, returning, assigner, invocationHandler);
        }
        public Implementation.Composable withAssigner(Assigner assigner) {
            return new ForInstance(fieldName, cached, privileged, returning, assigner, invocationHandler);
        }
        public AssignerConfigurable withPrivilegedLookup() {
            return new ForInstance(fieldName, cached, PRIVILEGED, returning, assigner, invocationHandler);
        }
        public Implementation andThen(Implementation implementation) {
            return new Compound(new ForInstance(fieldName, cached, privileged, DROPPING, assigner, invocationHandler), implementation);
        }
        public Composable andThen(Composable implementation) {
            return new Compound.Composable(new ForInstance(fieldName, cached, privileged, DROPPING, assigner, invocationHandler), implementation);
        }
        public InstrumentedType prepare(InstrumentedType instrumentedType) {
            if (!instrumentedType.getDeclaredFields().filter(named(fieldName).and(fieldType(INVOCATION_HANDLER_TYPE.asErasure()))).isEmpty()) {
                throw new IllegalStateException("Field with name " + fieldName + " and type " + INVOCATION_HANDLER_TYPE.asErasure() + " already declared by " + instrumentedType);
            }
            return instrumentedType.withField(new FieldDescription.Token(fieldName, Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_VOLATILE | Opcodes.ACC_SYNTHETIC, INVOCATION_HANDLER_TYPE)).withInitializer(new LoadedTypeInitializer.ForStaticField(fieldName, invocationHandler));
        }
        public ByteCodeAppender appender(Target implementationTarget) {
            return new Appender(implementationTarget.getInstrumentedType());
        }
        protected class Appender implements ByteCodeAppender {
            private final TypeDescription instrumentedType;
            protected Appender(TypeDescription instrumentedType) {
                this.instrumentedType = instrumentedType;
            }
            public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
                return ForInstance.this.apply(methodVisitor, implementationContext, instrumentedMethod, StackManipulation.Trivial.INSTANCE, instrumentedType.getDeclaredFields().filter(named(fieldName).and(genericFieldType(INVOCATION_HANDLER_TYPE))).getOnly());
            }
        }
    }
    protected static class ForField extends InvocationHandlerAdapter implements WithoutPrivilegeConfiguration {
        private final FieldLocator.Factory fieldLocatorFactory;
        protected ForField(String fieldName, boolean cached, boolean privileged, boolean returning, Assigner assigner, FieldLocator.Factory fieldLocatorFactory) {
            super(fieldName, cached, privileged, returning, assigner);
            this.fieldLocatorFactory = fieldLocatorFactory;
        }
        public WithoutPrivilegeConfiguration withoutMethodCache() {
            return new ForField(fieldName, UNCACHED, privileged, returning, assigner, fieldLocatorFactory);
        }
        public Implementation.Composable withAssigner(Assigner assigner) {
            return new ForField(fieldName, cached, privileged, returning, assigner, fieldLocatorFactory);
        }
        public AssignerConfigurable withPrivilegedLookup() {
            return new ForField(fieldName, cached, PRIVILEGED, returning, assigner, fieldLocatorFactory);
        }
        public Implementation andThen(Implementation implementation) {
            return new Compound(new ForField(fieldName, cached, privileged, DROPPING, assigner, fieldLocatorFactory), implementation);
        }
        public Composable andThen(Composable implementation) {
            return new Compound.Composable(new ForField(fieldName, cached, privileged, DROPPING, assigner, fieldLocatorFactory), implementation);
        }
        public InstrumentedType prepare(InstrumentedType instrumentedType) {
            return instrumentedType;
        }
        public ByteCodeAppender appender(Target implementationTarget) {
            FieldLocator.Resolution resolution = fieldLocatorFactory.make(implementationTarget.getInstrumentedType()).locate(fieldName);
            if (!resolution.isResolved()) {
                throw new IllegalStateException("Could not find a field named '" + fieldName + "' for " + implementationTarget.getInstrumentedType());
            } else if (!resolution.getField().getType().asErasure().isAssignableTo(InvocationHandler.class)) {
                throw new IllegalStateException("Field " + resolution.getField() + " does not declare a type that is assignable to invocation handler");
            }
            return new Appender(resolution.getField());
        }
        protected class Appender implements ByteCodeAppender {
            private final FieldDescription fieldDescription;
            protected Appender(FieldDescription fieldDescription) {
                this.fieldDescription = fieldDescription;
            }
            public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
                return ForField.this.apply(methodVisitor, implementationContext, instrumentedMethod, fieldDescription.isStatic() ? StackManipulation.Trivial.INSTANCE : MethodVariableAccess.loadThis(), fieldDescription);
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```