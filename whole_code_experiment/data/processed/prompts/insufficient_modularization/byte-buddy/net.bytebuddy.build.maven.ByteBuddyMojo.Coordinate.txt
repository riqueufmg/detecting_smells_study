##CONTEXT_SIZE=6318
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.build.maven;
public abstract class ByteBuddyMojo extends AbstractMojo {
    private static final String JAVA_FILE_EXTENSION = ".java";
    public MavenProject project;
    public MojoExecution execution;
    public RepositorySystem repositorySystem;
    public RepositorySystemSession repositorySystemSession;
    public List<Transformation> transformations;
    public Initialization initialization;
    public String suffix;
    public boolean failOnLiveInitializer;
    public boolean skip;
    public boolean warnOnMissingOutputDirectory;
    public boolean warnOnEmptyTypeSet;
    public boolean failFast;
    public boolean extendedParsing;
    public Discovery discovery;
    public boolean classPathDiscovery;
    public int threads;
    public int staleMilliseconds;
    public Integer multiReleaseVersion;
    public void execute() throws MojoExecutionException, MojoFailureException {
        if (project == null || repositorySystem == null || discovery == null) {
            throw new MojoExecutionException("Plugin is not initialized correctly");
        } else if (skip) {
            getLog().info("Not applying instrumentation as a result of plugin configuration.");
            return;
        }
        List<Transformer> transformers = new ArrayList<Transformer>();
        Set<String> undiscoverable = new HashSet<String>();
        if (transformations != null) {
            for (Transformation transformation : transformations) {
                transformers.add(new Transformer.ForConfiguredPlugin(transformation));
                if (discovery.isRecordConfiguration()) {
                    undiscoverable.add(transformation.getPlugin());
                }
            }
        }
        Map<Coordinate, String> coordinates = new HashMap<Coordinate, String>();
        if (project.getDependencyManagement() != null) {
            for (Dependency dependency : project.getDependencyManagement().getDependencies()) {
                coordinates.put(new Coordinate(dependency.getGroupId(), dependency.getArtifactId()), dependency.getVersion());
            }
        }
        List<String> elements = resolveClassPathElements(coordinates);
        if (discovery.isDiscover(transformers)) {
            try {
                for (String name : Plugin.Engine.Default.scan(ByteBuddyMojo.class.getClassLoader())) {
                    if (undiscoverable.add(name)) {
                        transformers.add(new Transformer.ForDiscoveredPlugin(name));
                        getLog().debug("Registered discovered plugin: " + name);
                    } else {
                        getLog().info("Skipping discovered plugin " + name + " which was previously discovered or registered");
                    }
                }
                if (classPathDiscovery) {
                    List<URL> urls = new ArrayList<URL>(elements.size());
                    for (String element : elements) {
                        urls.add(new File(element).toURI().toURL());
                    }
                    ClassLoader classLoader = new URLClassLoader(urls.toArray(new URL[0]));
                    try {
                        for (String name : Plugin.Engine.Default.scan(classLoader)) {
                            if (undiscoverable.add(name)) {
                                transformers.add(new Transformer.ForDiscoveredPlugin.FromClassLoader(name, elements));
                                getLog().debug("Registered discovered plugin: " + name);
                            } else {
                                getLog().info("Skipping discovered plugin " + name + " which was previously discovered or registered");
                            }
                        }
                    } finally {
                        if (classLoader instanceof Closeable) {
                            ((Closeable) classLoader).close();
                        }
                    }
                }
            } catch (IOException exception) {
                throw new MojoExecutionException("Failed plugin discovery", exception);
            }
        }
        if (transformers.isEmpty()) {
            getLog().warn("No transformations are specified or discovered. Skipping plugin application.");
            return;
        } else {
            getLog().debug(transformers.size() + " plugins are being applied via configuration and discovery");
        }
        try {
            apply(transformers, elements, coordinates);
        } catch (IOException exception) {
            throw new MojoFailureException("Error during writing process", exception);
        }
    }
    protected abstract List<String> resolveClassPathElements(Map<Coordinate, String> coordinates) throws MojoExecutionException, MojoFailureException;
    protected abstract void apply(List<Transformer> transformers, List<String> elements, Map<Coordinate, String> coordinates) throws MojoExecutionException, MojoFailureException, IOException;
    protected Plugin.Engine.Summary transform(List<? extends String> classPath, Map<Coordinate, String> coordinates, List<Transformer> transformers, Plugin.Engine.Source source, Plugin.Engine.Target target, File file, boolean filtered) throws MojoExecutionException, IOException {
        File staleness = new File(project.getBuild().getDirectory(), "maven-status" + File.separator + execution.getArtifactId() + File.separator + execution.getGoal() + File.separator + execution.getExecutionId() + File.separator + "staleness");
        StalenessFilter stalenessFilter;
        if (filtered || staleMilliseconds < 0) {
            stalenessFilter = null;
            getLog().debug("Stale file detection is disabled");
        } else if (staleness.exists()) {
            stalenessFilter = new StalenessFilter(getLog(), staleness.lastModified() + staleMilliseconds);
            source = new Plugin.Engine.Source.Filtering(source, stalenessFilter);
            getLog().debug("Using stale file detection with a margin of " + staleMilliseconds + " milliseconds");
        } else {
            stalenessFilter = null;
            getLog().debug("Did not discover previous staleness file");
        }
        List<File> artifacts = new ArrayList<File>(classPath.size());
        for (String element : classPath) {
            artifacts.add(new File(element));
        }
        ClassLoaderResolver classLoaderResolver = new ClassLoaderResolver(getLog(), repositorySystem, repositorySystemSession == null ? MavenRepositorySystemUtils.newSession() : repositorySystemSession, project.getRemotePluginRepositories());
        try {
            List<Plugin.Factory> factories = new ArrayList<Plugin.Factory>(transformers.size());
            for (Transformer transformer : transformers) {
                String plugin = transformer.getPlugin();
                try {
                    factories.add(new Plugin.Factory.UsingReflection((Class<? extends Plugin>) Class.forName(plugin, false, transformer.toClassLoader(classLoaderResolver, coordinates, project.getGroupId(), project.getArtifactId(), project.getVersion(), project.getPackaging()))).with(transformer.toArgumentResolvers()).with(Plugin.Factory.UsingReflection.ArgumentResolver.ForType.of(File.class, file), Plugin.Factory.UsingReflection.ArgumentResolver.ForType.of(Log.class, getLog()), Plugin.Factory.UsingReflection.ArgumentResolver.ForType.of(BuildLogger.class, new MavenBuildLogger(getLog())), Plugin.Factory.UsingReflection.ArgumentResolver.ForType.of(File[].class, artifacts.toArray(new File[0]))));
                    getLog().info("Resolved plugin: " + plugin);
                } catch (Throwable throwable) {
                    throw new MojoExecutionException("Cannot resolve plugin: " + plugin, throwable);
                }
            }
            String managed = coordinates.get(new Coordinate(project.getGroupId(), project.getArtifactId()));
            EntryPoint entryPoint = (initialization == null ? new Initialization() : initialization).getEntryPoint(classLoaderResolver, project.getGroupId(), project.getArtifactId(), managed == null ? project.getVersion() : managed, project.getPackaging());
            getLog().info("Resolved entry point: " + entryPoint);
            String javaVersionString = findJavaVersionString(project, "release");
            if (javaVersionString == null) {
                javaVersionString = findJavaVersionString(project, "target");
            }
            ClassFileVersion classFileVersion;
            if (javaVersionString == null) {
                classFileVersion = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5);
                getLog().warn("Could not locate Java target version, build is JDK dependant: " + classFileVersion.getMajorVersion());
            } else {
                classFileVersion = ClassFileVersion.ofJavaVersionString(javaVersionString);
                getLog().debug("Java version detected: " + javaVersionString);
            }
            ClassFileVersion multiReleaseClassFileVersion = multiReleaseVersion == null ? classFileVersion : ClassFileVersion.ofJavaVersion(multiReleaseVersion);
            List<ClassFileLocator> classFileLocators = new ArrayList<ClassFileLocator>(artifacts.size());
            classFileLocators.add(ClassFileLocator.ForClassLoader.ofPlatformLoader());
            for (File artifact : artifacts) {
                classFileLocators.add(artifact.isFile() ? ClassFileLocator.ForJarFile.of(artifact, multiReleaseClassFileVersion) : ClassFileLocator.ForFolder.of(artifact, multiReleaseClassFileVersion));
            }
            ClassFileLocator classFileLocator = new ClassFileLocator.Compound(classFileLocators);
            Plugin.Engine.Summary summary;
            try {
                getLog().info("Processing class files located in in: " + file);
                Plugin.Engine pluginEngine;
                try {
                    pluginEngine = Plugin.Engine.Default.of(entryPoint, classFileVersion, suffix == null || suffix.length() == 0 ? MethodNameTransformer.Suffixing.withRandomSuffix() : new MethodNameTransformer.Suffixing(suffix));
                } catch (Throwable throwable) {
                    throw new MojoExecutionException("Cannot create plugin engine", throwable);
                }
                try {
                    summary = pluginEngine.with(extendedParsing ? Plugin.Engine.PoolStrategy.Default.EXTENDED : Plugin.Engine.PoolStrategy.Default.FAST).with(classFileLocator).with(multiReleaseClassFileVersion).with(new TransformationLogger(getLog())).withErrorHandlers(Plugin.Engine.ErrorHandler.Enforcing.ALL_TYPES_RESOLVED, failOnLiveInitializer ? Plugin.Engine.ErrorHandler.Enforcing.NO_LIVE_INITIALIZERS : Plugin.Engine.Listener.NoOp.INSTANCE, failFast ? Plugin.Engine.ErrorHandler.Failing.FAIL_FAST : Plugin.Engine.ErrorHandler.Failing.FAIL_LAST).with(threads == 0 ? Plugin.Engine.Dispatcher.ForSerialTransformation.Factory.INSTANCE : new Plugin.Engine.Dispatcher.ForParallelTransformation.WithThrowawayExecutorService.Factory(threads)).apply(source, target, factories);
                } catch (Throwable throwable) {
                    throw new MojoExecutionException("Failed to transform class files in " + file, throwable);
                }
            } finally {
                classFileLocator.close();
            }
            if (!summary.getFailed().isEmpty()) {
                throw new MojoExecutionException(summary.getFailed() + " type transformation(s) have failed");
            } else if (warnOnEmptyTypeSet && summary.getTransformed().isEmpty()) {
                if (stalenessFilter != null && stalenessFilter.getFiltered() > 0) {
                    getLog().info("No types were transformed during plugin execution but " + stalenessFilter.getFiltered() + " class file(s) were considered stale");
                } else {
                    getLog().warn("No types were transformed during plugin execution");
                }
            } else {
                getLog().info("Transformed " + summary.getTransformed().size() + " type(s)");
            }
            if (!(staleness.getParentFile().isDirectory() || staleness.getParentFile().mkdirs()) || (!staleness.createNewFile() && (!staleness.delete() || !staleness.createNewFile()))) {
                throw new MojoExecutionException("Failed to define instrumentation staleness: " + staleness.getAbsolutePath());
            }
            return summary;
        } finally {
            classLoaderResolver.close();
        }
    }
    private static String findJavaVersionString(MavenProject project, String property) {
        do {
            String value = project.getProperties().getProperty("maven.compiler." + property);
            if (value != null) {
                return value;
            }
            PluginManagement management = project.getPluginManagement();
            for (org.apache.maven.model.Plugin plugin : management == null ? project.getBuildPlugins() : CompoundList.of(project.getBuildPlugins(), management.getPlugins())) {
                if ("maven-compiler-plugin".equals(plugin.getArtifactId())) {
                    if (plugin.getConfiguration() instanceof Xpp3Dom) {
                        Xpp3Dom node = ((Xpp3Dom) plugin.getConfiguration()).getChild(property);
                        if (node != null) {
                            return node.getValue();
                        }
                    }
                }
            }
            project = project.getParent();
        } while (project != null);
        return null;
    }
    private static class FilePrefixMatcher extends ElementMatcher.Junction.ForNonNullValues<Plugin.Engine.Source.Element> {
        private final List<String> names;
        private FilePrefixMatcher(List<String> names) {
            this.names = names;
        }
        protected boolean doMatch(Plugin.Engine.Source.Element target) {
            for (String name : names) {
                if (target.getName().equals(name + ClassFileLocator.CLASS_FILE_EXTENSION) || target.getName().startsWith(name + "$") && target.getName().endsWith(ClassFileLocator.CLASS_FILE_EXTENSION)) {
                    return true;
                }
            }
            return false;
        }
    }
    public abstract static class ForLifecycleTypes extends ByteBuddyMojo {
        public BuildContext context;
        public boolean incremental;
        protected abstract String getOutputDirectory();
        protected abstract String getSourceDirectory();
        protected void apply(List<Transformer> transformers, List<String> elements, Map<Coordinate, String> coordinates) throws MojoExecutionException, IOException {
            File root = new File(getOutputDirectory());
            if (!root.exists()) {
                if (warnOnMissingOutputDirectory) {
                    getLog().warn("Skipping instrumentation due to missing directory: " + root);
                } else {
                    getLog().info("Skipping instrumentation due to missing directory: " + root);
                }
                return;
            } else if (!root.isDirectory()) {
                throw new MojoExecutionException("Not a directory: " + root);
            }
            String sourceDirectory = getSourceDirectory();
            if (incremental && context != null && sourceDirectory != null) {
                getLog().debug("Considering incremental build with context: " + context);
                Plugin.Engine.Source source;
                if (context.isIncremental()) {
                    Scanner scanner = context.newScanner(new File(sourceDirectory));
                    scanner.scan();
                    List<String> names = new ArrayList<String>();
                    for (String file : scanner.getIncludedFiles()) {
                        if (file.endsWith(JAVA_FILE_EXTENSION)) {
                            names.add(file.substring(0, file.length() - JAVA_FILE_EXTENSION.length()));
                        }
                    }
                    source = new Plugin.Engine.Source.Filtering(new Plugin.Engine.Source.ForFolder(root), new FilePrefixMatcher(names));
                    getLog().debug("Incrementally processing: " + names);
                } else {
                    source = new Plugin.Engine.Source.ForFolder(root);
                    getLog().debug("Cannot build incrementally - all class files are processed");
                }
                Plugin.Engine.Summary summary = transform(elements, coordinates, transformers, source, new Plugin.Engine.Target.ForFolder(root), root, true);
                for (TypeDescription typeDescription : summary.getTransformed()) {
                    context.refresh(new File(getOutputDirectory(), typeDescription.getName() + ClassFileLocator.CLASS_FILE_EXTENSION));
                }
            } else {
                getLog().debug("Not applying incremental build with context: " + context);
                transform(elements, coordinates, transformers, new Plugin.Engine.Source.ForFolder(root), new Plugin.Engine.Target.ForFolder(root), root, false);
            }
        }
        public abstract static class ForProductionTypes extends ForLifecycleTypes {
            protected String getOutputDirectory() {
                return project.getBuild().getOutputDirectory();
            }
            protected String getSourceDirectory() {
                return project.getBuild().getSourceDirectory();
            }
            public static class WithoutRuntimeDependencies extends ForProductionTypes {
                protected List<String> resolveClassPathElements(Map<Coordinate, String> coordinates) throws MojoFailureException {
                    try {
                        return project.getCompileClasspathElements();
                    } catch (DependencyResolutionRequiredException exception) {
                        throw new MojoFailureException("Could not resolve class path", exception);
                    }
                }
            }
            public static class WithRuntimeDependencies extends ForProductionTypes {
                protected List<String> resolveClassPathElements(Map<Coordinate, String> coordinates) {
                    try {
                        return project.getRuntimeClasspathElements();
                    } catch (DependencyResolutionRequiredException exception) {
                        throw new RuntimeException("Could not resolve runtime class path", exception);
                    }
                }
            }
            public static class WithExtendedDependencies extends ForProductionTypes {
                protected List<String> resolveClassPathElements(Map<Coordinate, String> coordinates) {
                    List<String> classPath = new ArrayList<String>(project.getArtifacts().size() + 1);
                    String directory = project.getBuild().getOutputDirectory();
                    if (directory != null) {
                        classPath.add(directory);
                    }
                    for (Artifact artifact : project.getArtifacts()) {
                        if (artifact.getArtifactHandler().isAddedToClasspath() && !Artifact.SCOPE_TEST.equals(artifact.getScope()) && !Artifact.SCOPE_IMPORT.equals(artifact.getScope())) {
                            File file = artifact.getFile();
                            if (file != null) {
                                classPath.add(file.getPath());
                            }
                        }
                    }
                    return classPath;
                }
            }
        }
        public static class ForTestTypes extends ForLifecycleTypes {
            protected String getOutputDirectory() {
                return project.getBuild().getTestOutputDirectory();
            }
            protected String getSourceDirectory() {
                return project.getBuild().getTestSourceDirectory();
            }
            protected List<String> resolveClassPathElements(Map<Coordinate, String> coordinates) throws MojoFailureException {
                try {
                    return project.getTestClasspathElements();
                } catch (DependencyResolutionRequiredException exception) {
                    throw new MojoFailureException("Could not resolve test class path", exception);
                }
            }
        }
    }
    public static class ForExplicitLocations extends ByteBuddyMojo {
        public String source;
        public String target;
        public List<CoordinateConfiguration> dependencies;
        protected List<String> resolveClassPathElements(Map<Coordinate, String> coordinates) throws MojoExecutionException, MojoFailureException {
            List<String> classPath = new ArrayList<String>();
            classPath.add(source);
            classPath.addAll(resolveImplicitClassPathElements());
            if (dependencies != null && !dependencies.isEmpty()) {
                RepositorySystemSession repositorySystemSession = this.repositorySystemSession == null ? MavenRepositorySystemUtils.newSession() : this.repositorySystemSession;
                for (CoordinateConfiguration dependency : dependencies) {
                    String managed = coordinates.get(new Coordinate(dependency.getGroupId(project.getGroupId()), dependency.getArtifactId(project.getArtifactId())));
                    MavenCoordinate mavenCoordinate = dependency.asCoordinate(project.getGroupId(), project.getArtifactId(), managed == null ? project.getVersion() : managed, project.getPackaging());
                    try {
                        DependencyNode root = repositorySystem.collectDependencies(repositorySystemSession, new CollectRequest(new org.eclipse.aether.graph.Dependency(mavenCoordinate.asArtifact(), "runtime"), project.getRemotePluginRepositories())).getRoot();
                        repositorySystem.resolveDependencies(repositorySystemSession, new DependencyRequest().setRoot(root));
                        PreorderNodeListGenerator preorderNodeListGenerator = new PreorderNodeListGenerator();
                        root.accept(preorderNodeListGenerator);
                        for (org.eclipse.aether.artifact.Artifact artifact : preorderNodeListGenerator.getArtifacts(false)) {
                            classPath.add(artifact.getFile().toString());
                        }
                    } catch (DependencyCollectionException exception) {
                        throw new MojoExecutionException("Could not collect dependencies for " + mavenCoordinate, exception);
                    } catch (DependencyResolutionException exception) {
                        throw new MojoFailureException("Could not resolve dependencies for " + mavenCoordinate, exception);
                    }
                }
            }
            return classPath;
        }
        protected List<String> resolveImplicitClassPathElements() throws MojoFailureException {
            return Collections.emptyList();
        }
        protected void apply(List<Transformer> transformers, List<String> elements, Map<Coordinate, String> coordinates) throws MojoExecutionException, MojoFailureException, IOException {
            File source = new File(this.source), target = new File(this.target);
            getLog().info("Transforming " + this.source + " to " + this.target);
            Plugin.Engine.Source resolved;
            if (source.isDirectory()) {
                resolved = new Plugin.Engine.Source.ForFolder(source);
            } else if (source.exists()) {
                resolved = new Plugin.Engine.Source.ForJarFile(source);
            } else {
                throw new MojoFailureException("Source location does not exist: " + source);
            }
            transform(elements, coordinates, transformers, resolved, target.isDirectory() ? new Plugin.Engine.Target.ForFolder(target) : new Plugin.Engine.Target.ForJarFile(target), source, false);
        }
        public static class WithoutRuntimeDependencies extends ForExplicitLocations {
            protected List<String> resolveImplicitClassPathElements() throws MojoFailureException {
                try {
                    return project.getCompileClasspathElements();
                } catch (DependencyResolutionRequiredException exception) {
                    throw new MojoFailureException("Could not resolve class path", exception);
                }
            }
        }
        public static class WithRuntimeDependencies extends ForExplicitLocations {
            protected List<String> resolveImplicitClassPathElements() {
                try {
                    return project.getRuntimeClasspathElements();
                } catch (DependencyResolutionRequiredException exception) {
                    throw new RuntimeException("Could not resolve runtime class path", exception);
                }
            }
        }
        public static class WithExtendedDependencies extends ForExplicitLocations {
            protected List<String> resolveImplicitClassPathElements() {
                List<String> classPath = new ArrayList<String>(project.getArtifacts().size() + 1);
                String directory = project.getBuild().getOutputDirectory();
                if (directory != null) {
                    classPath.add(directory);
                }
                for (Artifact artifact : project.getArtifacts()) {
                    if (artifact.getArtifactHandler().isAddedToClasspath() && !Artifact.SCOPE_TEST.equals(artifact.getScope()) && !Artifact.SCOPE_IMPORT.equals(artifact.getScope())) {
                        File file = artifact.getFile();
                        if (file != null) {
                            classPath.add(file.getPath());
                        }
                    }
                }
                return classPath;
            }
        }
        public static class ForTestTypes extends ForExplicitLocations {
            protected List<String> resolveImplicitClassPathElements() throws MojoFailureException {
                try {
                    return project.getTestClasspathElements();
                } catch (DependencyResolutionRequiredException exception) {
                    throw new MojoFailureException("Could not resolve test class path", exception);
                }
            }
        }
    }
    public static class ForDependencyFolder extends ByteBuddyMojo {
        public String source;
        public String target;
        protected List<String> resolveClassPathElements(Map<Coordinate, String> coordinates) {
            try {
                return project.getCompileClasspathElements();
            } catch (DependencyResolutionRequiredException exception) {
                throw new RuntimeException("Could not resolve class path", exception);
            }
        }
        protected void apply(List<Transformer> transformers, List<String> elements, Map<Coordinate, String> coordinates) throws MojoExecutionException, MojoFailureException, IOException {
            File source = new File(this.source), target = this.target == null ? source : new File(this.target);
            getLog().info("Transforming dependencies in " + this.source + (this.target == null ? "" : (" to " + this.target)));
            if (!source.isDirectory()) {
                throw new MojoFailureException("Expected " + this.source + " to be a folder");
            } else if (this.target != null && target.isFile()) {
                throw new MojoFailureException("Did not expect " + this.target + " to be a file");
            }
            File[] file = source.listFiles();
            if (file != null) {
                for (File aFile : file) {
                    if (aFile.isFile()) {
                        transform(elements, coordinates, transformers, new Plugin.Engine.Source.ForJarFile(aFile), new Plugin.Engine.Target.ForJarFile(new File(target, aFile.getName())), aFile, false);
                    }
                }
            }
        }
    }
    protected static class MavenBuildLogger implements BuildLogger {
        private final Log log;
        protected MavenBuildLogger(Log log) {
            this.log = log;
        }
        public boolean isDebugEnabled() {
            return log.isDebugEnabled();
        }
        public void debug(String message) {
            log.debug(message);
        }
        public void debug(String message, Throwable throwable) {
            log.debug(message, throwable);
        }
        public boolean isInfoEnabled() {
            return log.isInfoEnabled();
        }
        public void info(String message) {
            log.info(message);
        }
        public void info(String message, Throwable throwable) {
            log.info(message, throwable);
        }
        public boolean isWarnEnabled() {
            return log.isWarnEnabled();
        }
        public void warn(String message) {
            log.warn(message);
        }
        public void warn(String message, Throwable throwable) {
            log.warn(message, throwable);
        }
        public boolean isErrorEnabled() {
            return log.isErrorEnabled();
        }
        public void error(String message) {
            log.error(message);
        }
        public void error(String message, Throwable throwable) {
            log.error(message, throwable);
        }
    }
    protected static class TransformationLogger extends Plugin.Engine.Listener.Adapter {
        private final Log log;
        protected TransformationLogger(Log log) {
            this.log = log;
        }
        public void onTransformation(TypeDescription typeDescription, List<Plugin> plugins) {
            log.debug("Transformed " + typeDescription + " using " + plugins);
        }
        public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
            log.warn("Failed to transform " + typeDescription + " using " + plugin, throwable);
        }
        public void onError(Map<TypeDescription, List<Throwable>> throwables) {
            log.warn("Failed to transform " + throwables.size() + " types");
        }
        public void onError(Plugin plugin, Throwable throwable) {
            log.error("Failed to close " + plugin, throwable);
        }
        public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
            log.debug("Discovered live initializer for " + definingType + " as a result of transforming " + typeDescription);
        }
    }
    protected abstract static class Transformer {
        protected abstract String getPlugin() throws MojoExecutionException;
        protected abstract List<? extends Plugin.Factory.UsingReflection.ArgumentResolver> toArgumentResolvers();
        protected abstract ClassLoader toClassLoader(ClassLoaderResolver classLoaderResolver, Map<Coordinate, String> coordinates, String groupId, String artifactId, String version, String packaging) throws MojoFailureException, MojoExecutionException;
        protected static class ForConfiguredPlugin extends Transformer {
            private final Transformation transformation;
            protected ForConfiguredPlugin(Transformation transformation) {
                this.transformation = transformation;
            }
            protected String getPlugin() throws MojoExecutionException {
                return transformation.getPlugin();
            }
            protected List<? extends Plugin.Factory.UsingReflection.ArgumentResolver> toArgumentResolvers() {
                return transformation.makeArgumentResolvers();
            }
            protected ClassLoader toClassLoader(ClassLoaderResolver classLoaderResolver, Map<Coordinate, String> coordinates, String groupId, String artifactId, String version, String packaging) throws MojoFailureException, MojoExecutionException {
                String managed = coordinates.get(new Coordinate(transformation.getGroupId(groupId), transformation.getArtifactId(artifactId)));
                return classLoaderResolver.resolve(transformation.asCoordinate(groupId, artifactId, managed == null ? version : managed, packaging));
            }
        }
        protected static class ForDiscoveredPlugin extends Transformer {
            private final String plugin;
            protected ForDiscoveredPlugin(String plugin) {
                this.plugin = plugin;
            }
            protected String getPlugin() {
                return plugin;
            }
            protected List<? extends Plugin.Factory.UsingReflection.ArgumentResolver> toArgumentResolvers() {
                return Collections.emptyList();
            }
            protected ClassLoader toClassLoader(ClassLoaderResolver classLoaderResolver, Map<Coordinate, String> coordinates, String groupId, String artifactId, String version, String packaging) {
                return ByteBuddyMojo.class.getClassLoader();
            }
            protected static class FromClassLoader extends ForDiscoveredPlugin {
                private final List<String> classPath;
                protected FromClassLoader(String plugin, List<String> classPath) {
                    super(plugin);
                    this.classPath = classPath;
                }
                protected ClassLoader toClassLoader(ClassLoaderResolver classLoaderResolver, Map<Coordinate, String> coordinates, String groupId, String artifactId, String version, String packaging) {
                    URL[] url = new URL[classPath.size()];
                    for (int index = 0; index < classPath.size(); index++) {
                        try {
                            url[index] = new File(classPath.get(index)).toURI().toURL();
                        } catch (MalformedURLException exception) {
                            throw new IllegalStateException("Failed to resolve class path element to URL: " + classPath.get(index), exception);
                        }
                    }
                    return new URLClassLoader(url, ByteBuddyMojo.class.getClassLoader());
                }
            }
        }
    }
    protected static class Coordinate {
        private final String groupId;
        private final String artifactId;
        protected Coordinate(String groupId, String artifactId) {
            this.groupId = groupId;
            this.artifactId = artifactId;
        }
        public int hashCode() {
            int result = groupId.hashCode();
            result = 31 * result + artifactId.hashCode();
            return result;
        }
        public boolean equals(Object other) {
            if (this == other)
                return true;
            if (other == null || getClass() != other.getClass())
                return false;
            Coordinate that = (Coordinate) other;
            if (!groupId.equals(that.groupId))
                return false;
            return artifactId.equals(that.artifactId);
        }
    }
    protected static class StalenessFilter extends ElementMatcher.Junction.ForNonNullValues<Plugin.Engine.Source.Element> {
        private final Log log;
        private final long latestTimestamp;
        private int filtered;
        protected StalenessFilter(Log log, long latestTimestamp) {
            this.log = log;
            this.latestTimestamp = latestTimestamp;
        }
        protected boolean doMatch(Plugin.Engine.Source.Element target) {
            File file = target.resolveAs(File.class);
            if (file == null) {
                throw new IllegalStateException("Expected " + target + " to resolve to a file");
            }
            if (file.lastModified() < latestTimestamp) {
                filtered += 1;
                log.debug("Filtering " + file + " due to staleness: " + file.lastModified());
                return false;
            } else {
                return true;
            }
        }
        protected int getFiltered() {
            return filtered;
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```