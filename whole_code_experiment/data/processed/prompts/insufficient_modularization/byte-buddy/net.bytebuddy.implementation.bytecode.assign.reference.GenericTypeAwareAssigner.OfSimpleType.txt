##CONTEXT_SIZE=1919
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.implementation.bytecode.assign.reference;
public enum GenericTypeAwareAssigner implements Assigner {
    INSTANCE;
    public StackManipulation assign(TypeDescription.Generic source, TypeDescription.Generic target, Typing typing) {
        if (source.isPrimitive() || target.isPrimitive()) {
            return source.equals(target) ? StackManipulation.Trivial.INSTANCE : StackManipulation.Illegal.INSTANCE;
        } else if (source.accept(new IsAssignableToVisitor(target))) {
            return StackManipulation.Trivial.INSTANCE;
        } else if (typing.isDynamic()) {
            return source.asErasure().isAssignableTo(target.asErasure()) ? StackManipulation.Trivial.INSTANCE : TypeCasting.to(target);
        } else {
            return StackManipulation.Illegal.INSTANCE;
        }
    }
    protected static class IsAssignableToVisitor implements TypeDescription.Generic.Visitor<Boolean> {
        private final TypeDescription.Generic typeDescription;
        private final boolean polymorphic;
        public IsAssignableToVisitor(TypeDescription.Generic typeDescription) {
            this(typeDescription, true);
        }
        protected IsAssignableToVisitor(TypeDescription.Generic typeDescription, boolean polymorphic) {
            this.typeDescription = typeDescription;
            this.polymorphic = polymorphic;
        }
        public Boolean onGenericArray(TypeDescription.Generic genericArray) {
            return typeDescription.accept(new OfGenericArray(genericArray, polymorphic));
        }
        public Boolean onWildcard(TypeDescription.Generic wildcard) {
            return typeDescription.accept(new OfWildcard(wildcard));
        }
        public Boolean onParameterizedType(TypeDescription.Generic parameterizedType) {
            return typeDescription.accept(new OfParameterizedType(parameterizedType, polymorphic));
        }
        public Boolean onTypeVariable(TypeDescription.Generic typeVariable) {
            if (typeVariable.getTypeVariableSource().isInferrable()) {
                throw new UnsupportedOperationException("Assignability checks for type variables declared by methods are not currently supported");
            } else if (typeVariable.equals(typeDescription)) {
                return true;
            } else if (polymorphic) {
                Queue<TypeDescription.Generic> candidates = QueueFactory.make(typeVariable.getUpperBounds());
                while (!candidates.isEmpty()) {
                    TypeDescription.Generic candidate = candidates.remove();
                    if (candidate.accept(new IsAssignableToVisitor(typeDescription))) {
                        return true;
                    } else if (candidate.getSort().isTypeVariable()) {
                        candidates.addAll(candidate.getUpperBounds());
                    }
                }
                return false;
            } else {
                return false;
            }
        }
        public Boolean onNonGenericType(TypeDescription.Generic typeDescription) {
            return this.typeDescription.accept(new OfNonGenericType(typeDescription, polymorphic));
        }
        protected abstract static class OfManifestType implements TypeDescription.Generic.Visitor<Boolean> {
            protected final TypeDescription.Generic typeDescription;
            protected final boolean polymorphic;
            protected OfManifestType(TypeDescription.Generic typeDescription, boolean polymorphic) {
                this.typeDescription = typeDescription;
                this.polymorphic = polymorphic;
            }
            public Boolean onWildcard(TypeDescription.Generic wildcard) {
                for (TypeDescription.Generic upperBound : wildcard.getUpperBounds()) {
                    if (!typeDescription.accept(new IsAssignableToVisitor(upperBound))) {
                        return false;
                    }
                }
                for (TypeDescription.Generic lowerBound : wildcard.getLowerBounds()) {
                    if (!lowerBound.accept(new IsAssignableToVisitor(typeDescription))) {
                        return false;
                    }
                }
                return true;
            }
            public Boolean onTypeVariable(TypeDescription.Generic typeVariable) {
                if (typeVariable.getTypeVariableSource().isInferrable()) {
                    throw new UnsupportedOperationException("Assignability checks for type variables declared by methods arel not currently supported");
                } else {
                    return false;
                }
            }
        }
        protected abstract static class OfSimpleType extends OfManifestType {
            protected OfSimpleType(TypeDescription.Generic typeDescription, boolean polymorphic) {
                super(typeDescription, polymorphic);
            }
            public Boolean onParameterizedType(TypeDescription.Generic parameterizedType) {
                Queue<TypeDescription.Generic> candidates = QueueFactory.make(Collections.singleton(typeDescription));
                Set<TypeDescription> previous = new HashSet<TypeDescription>(Collections.singleton(typeDescription.asErasure()));
                do {
                    TypeDescription.Generic candidate = candidates.remove();
                    if (candidate.asErasure().equals(parameterizedType.asErasure())) {
                        if (candidate.getSort().isNonGeneric()) {
                            return true;
                        } else {
                            TypeList.Generic source = candidate.getTypeArguments(), target = parameterizedType.getTypeArguments();
                            int size = target.size();
                            if (source.size() != size) {
                                return false;
                            }
                            for (int index = 0; index < size; index++) {
                                if (!source.get(index).accept(new IsAssignableToVisitor(target.get(index), false))) {
                                    return false;
                                }
                            }
                            TypeDescription.Generic ownerType = parameterizedType.getOwnerType();
                            return ownerType == null || ownerType.accept(new IsAssignableToVisitor(ownerType));
                        }
                    } else if (polymorphic) {
                        TypeDescription.Generic superClass = candidate.getSuperClass();
                        if (superClass != null && previous.add(superClass.asErasure())) {
                            candidates.add(superClass);
                        }
                        for (TypeDescription.Generic anInterface : candidate.getInterfaces()) {
                            if (previous.add(anInterface.asErasure())) {
                                candidates.add(anInterface);
                            }
                        }
                    }
                } while (!candidates.isEmpty());
                return false;
            }
            public Boolean onNonGenericType(TypeDescription.Generic typeDescription) {
                return polymorphic ? this.typeDescription.asErasure().isAssignableTo(typeDescription.asErasure()) : this.typeDescription.asErasure().equals(typeDescription.asErasure());
            }
        }
        protected static class OfGenericArray extends OfManifestType {
            protected OfGenericArray(TypeDescription.Generic typeDescription, boolean polymorphic) {
                super(typeDescription, polymorphic);
            }
            public Boolean onGenericArray(TypeDescription.Generic genericArray) {
                TypeDescription.Generic source = typeDescription.getComponentType(), target = genericArray.getComponentType();
                while (source.getSort().isGenericArray() && target.getSort().isGenericArray()) {
                    source = source.getComponentType();
                    target = target.getComponentType();
                }
                return !source.getSort().isGenericArray() && !target.getSort().isGenericArray() && source.accept(new IsAssignableToVisitor(target));
            }
            public Boolean onParameterizedType(TypeDescription.Generic parameterizedType) {
                return false;
            }
            public Boolean onNonGenericType(TypeDescription.Generic typeDescription) {
                return polymorphic ? this.typeDescription.asErasure().isAssignableTo(typeDescription.asErasure()) : this.typeDescription.asErasure().equals(typeDescription.asErasure());
            }
        }
        protected static class OfWildcard implements TypeDescription.Generic.Visitor<Boolean> {
            private final TypeDescription.Generic wildcard;
            protected OfWildcard(TypeDescription.Generic wildcard) {
                this.wildcard = wildcard;
            }
            public Boolean onGenericArray(TypeDescription.Generic genericArray) {
                return false;
            }
            public Boolean onWildcard(TypeDescription.Generic wildcard) {
                boolean hasUpperBounds = false, hasLowerBounds = false;
                for (TypeDescription.Generic target : wildcard.getUpperBounds()) {
                    for (TypeDescription.Generic source : this.wildcard.getUpperBounds()) {
                        if (!source.accept(new IsAssignableToVisitor(target))) {
                            return false;
                        }
                    }
                    hasUpperBounds = hasUpperBounds || !target.represents(Object.class);
                }
                for (TypeDescription.Generic target : wildcard.getLowerBounds()) {
                    for (TypeDescription.Generic source : this.wildcard.getLowerBounds()) {
                        if (!target.accept(new IsAssignableToVisitor(source))) {
                            return false;
                        }
                    }
                    hasLowerBounds = true;
                }
                if (hasUpperBounds) {
                    return this.wildcard.getLowerBounds().isEmpty();
                } else if (hasLowerBounds) {
                    TypeList.Generic upperBounds = this.wildcard.getUpperBounds();
                    return upperBounds.size() == 0 || upperBounds.size() == 1 && upperBounds.getOnly().represents(Object.class);
                } else {
                    return true;
                }
            }
            public Boolean onParameterizedType(TypeDescription.Generic parameterizedType) {
                return false;
            }
            public Boolean onTypeVariable(TypeDescription.Generic typeVariable) {
                return false;
            }
            public Boolean onNonGenericType(TypeDescription.Generic typeDescription) {
                return false;
            }
        }
        protected static class OfParameterizedType extends OfSimpleType {
            protected OfParameterizedType(TypeDescription.Generic typeDescription, boolean polymorphic) {
                super(typeDescription, polymorphic);
            }
            public Boolean onGenericArray(TypeDescription.Generic genericArray) {
                return false;
            }
        }
        protected static class OfNonGenericType extends OfSimpleType {
            protected OfNonGenericType(TypeDescription.Generic typeDescription, boolean polymorphic) {
                super(typeDescription, polymorphic);
            }
            public Boolean onGenericArray(TypeDescription.Generic genericArray) {
                return polymorphic ? typeDescription.asErasure().isAssignableTo(genericArray.asErasure()) : typeDescription.asErasure().equals(genericArray.asErasure());
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```