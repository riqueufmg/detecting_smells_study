##CONTEXT_SIZE=11741
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.description.annotation;
public interface AnnotationValue<T, S> {
    AnnotationValue<?, ?> UNDEFINED = null;
    State getState();
    Sort getSort();
    AnnotationValue<T, S> filter(MethodDescription.InDefinedShape property);
    AnnotationValue<T, S> filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition);
    T resolve();
    <W> W resolve(Class<? extends W> type);
    Loaded<S> load(@MaybeNull ClassLoader classLoader);
    enum RenderingDispatcher {
        LEGACY_VM('[', ']', true) {
            @Override
            public String toSourceString(char value) {
                return Character.toString(value);
            }
            @Override
            public String toSourceString(long value) {
                return Long.toString(value);
            }
            @Override
            public String toSourceString(float value) {
                return Float.toString(value);
            }
            @Override
            public String toSourceString(double value) {
                return Double.toString(value);
            }
            @Override
            public String toSourceString(String value) {
                return value;
            }
            @Override
            public String toSourceString(TypeDescription value) {
                return value.toString();
            }
        }
        , JAVA_9_CAPABLE_VM('{', '}', true) {
            @Override
            public String toSourceString(char value) {
                StringBuilder stringBuilder = new StringBuilder().append('\'');
                if (value == '\'') {
                    stringBuilder.append("\\'");
                } else {
                    stringBuilder.append(value);
                }
                return stringBuilder.append('\'').toString();
            }
            @Override
            public String toSourceString(long value) {
                return Math.abs(value) <= Integer.MAX_VALUE ? String.valueOf(value) : value + "L";
            }
            @Override
            public String toSourceString(float value) {
                return Math.abs(value) <= Float.MAX_VALUE ? value + "f" : (Float.isInfinite(value) ? (value < 0.0f ? "-1.0f/0.0f" : "1.0f/0.0f") : "0.0f/0.0f");
            }
            @Override
            public String toSourceString(double value) {
                return Math.abs(value) <= Double.MAX_VALUE ? Double.toString(value) : (Double.isInfinite(value) ? (value < 0.0d ? "-1.0/0.0" : "1.0/0.0") : "0.0/0.0");
            }
            @Override
            public String toSourceString(String value) {
                return "\"" + (value.indexOf('"') == -1 ? value : value.replace("\"", "\\\"")) + "\"";
            }
            @Override
            public String toSourceString(TypeDescription value) {
                return value.getActualName() + ClassFileLocator.CLASS_FILE_EXTENSION;
            }
        }
        , JAVA_14_CAPABLE_VM('{', '}', true) {
            @Override
            public String toSourceString(byte value) {
                return "(byte)0x" + Integer.toHexString(value & 0xFF);
            }
            @Override
            public String toSourceString(char value) {
                StringBuilder stringBuilder = new StringBuilder().append('\'');
                if (value == '\'') {
                    stringBuilder.append("\\'");
                } else {
                    stringBuilder.append(value);
                }
                return stringBuilder.append('\'').toString();
            }
            @Override
            public String toSourceString(long value) {
                return value + "L";
            }
            @Override
            public String toSourceString(float value) {
                return Math.abs(value) <= Float.MAX_VALUE ? value + "f" : (Float.isInfinite(value) ? (value < 0.0f ? "-1.0f/0.0f" : "1.0f/0.0f") : "0.0f/0.0f");
            }
            @Override
            public String toSourceString(double value) {
                return Math.abs(value) <= Double.MAX_VALUE ? Double.toString(value) : (Double.isInfinite(value) ? (value < 0.0d ? "-1.0/0.0" : "1.0/0.0") : "0.0/0.0");
            }
            @Override
            public String toSourceString(String value) {
                return "\"" + (value.indexOf('"') == -1 ? value : value.replace("\"", "\\\"")) + "\"";
            }
            @Override
            public String toSourceString(TypeDescription value) {
                return value.getActualName() + ClassFileLocator.CLASS_FILE_EXTENSION;
            }
        }
        , JAVA_17_CAPABLE_VM('{', '}', false) {
            @Override
            public String toSourceString(byte value) {
                return "(byte)0x" + Integer.toHexString(value & 0xFF);
            }
            @Override
            public String toSourceString(char value) {
                StringBuilder stringBuilder = new StringBuilder().append('\'');
                if (value == '\'') {
                    stringBuilder.append("\\'");
                } else {
                    stringBuilder.append(value);
                }
                return stringBuilder.append('\'').toString();
            }
            @Override
            public String toSourceString(long value) {
                return value + "L";
            }
            @Override
            public String toSourceString(float value) {
                return Math.abs(value) <= Float.MAX_VALUE ? value + "f" : (Float.isInfinite(value) ? (value < 0.0f ? "-1.0f/0.0f" : "1.0f/0.0f") : "0.0f/0.0f");
            }
            @Override
            public String toSourceString(double value) {
                return Math.abs(value) <= Double.MAX_VALUE ? Double.toString(value) : (Double.isInfinite(value) ? (value < 0.0d ? "-1.0/0.0" : "1.0/0.0") : "0.0/0.0");
            }
            @Override
            public String toSourceString(String value) {
                return "\"" + (value.indexOf('"') == -1 ? value : value.replace("\"", "\\\"")) + "\"";
            }
            @Override
            public String toSourceString(TypeDescription value) {
                return value.getActualName() + ClassFileLocator.CLASS_FILE_EXTENSION;
            }
            @Override
            public String toTypeErrorString(Class<?> type) {
                return type.getName();
            }
        }
        , JAVA_19_CAPABLE_VM('{', '}', ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isLessThan(ClassFileVersion.JAVA_V17)) {
            @Override
            public String toSourceString(byte value) {
                return "(byte)0x" + Integer.toHexString(value & 0xFF);
            }
            @Override
            public String toSourceString(char value) {
                StringBuilder stringBuilder = new StringBuilder().append('\'');
                if (value == '\'') {
                    stringBuilder.append("\\'");
                } else {
                    stringBuilder.append(value);
                }
                return stringBuilder.append('\'').toString();
            }
            @Override
            public String toSourceString(long value) {
                return value + "L";
            }
            @Override
            public String toSourceString(float value) {
                return Math.abs(value) <= Float.MAX_VALUE ? value + "f" : (Float.isInfinite(value) ? (value < 0.0f ? "-1.0f/0.0f" : "1.0f/0.0f") : "0.0f/0.0f");
            }
            @Override
            public String toSourceString(double value) {
                return Math.abs(value) <= Double.MAX_VALUE ? Double.toString(value) : (Double.isInfinite(value) ? (value < 0.0d ? "-1.0/0.0" : "1.0/0.0") : "0.0/0.0");
            }
            @Override
            public String toSourceString(String value) {
                return "\"" + (value.indexOf('"') == -1 ? value : value.replace("\"", "\\\"")) + "\"";
            }
            @Override
            public String toSourceString(TypeDescription value) {
                return value.getCanonicalName() + ClassFileLocator.CLASS_FILE_EXTENSION;
            }
            @Override
            public String toTypeErrorString(Class<?> type) {
                return type.getName();
            }
        }
        ;
        private static final String ARRAY_PREFIX = "Array with component tag: ";
        public static final RenderingDispatcher CURRENT;
        static {
            ClassFileVersion classFileVersion = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5);
            if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V19)) {
                CURRENT = RenderingDispatcher.JAVA_19_CAPABLE_VM;
            } else if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V17)) {
                CURRENT = RenderingDispatcher.JAVA_17_CAPABLE_VM;
            } else if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V14)) {
                CURRENT = RenderingDispatcher.JAVA_14_CAPABLE_VM;
            } else if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V9)) {
                CURRENT = RenderingDispatcher.JAVA_9_CAPABLE_VM;
            } else {
                CURRENT = RenderingDispatcher.LEGACY_VM;
            }
        }
        private final char openingBrace;
        private final char closingBrace;
        private final boolean componentAsInteger;
        RenderingDispatcher(char openingBrace, char closingBrace, boolean componentAsInteger) {
            this.openingBrace = openingBrace;
            this.closingBrace = closingBrace;
            this.componentAsInteger = componentAsInteger;
        }
        public String toSourceString(boolean value) {
            return Boolean.toString(value);
        }
        public String toSourceString(byte value) {
            return Byte.toString(value);
        }
        public String toSourceString(short value) {
            return Short.toString(value);
        }
        public abstract String toSourceString(char value);
        public String toSourceString(int value) {
            return Integer.toString(value);
        }
        public abstract String toSourceString(long value);
        public abstract String toSourceString(float value);
        public abstract String toSourceString(double value);
        public abstract String toSourceString(String value);
        public abstract String toSourceString(TypeDescription value);
        public String toSourceString(List<?> values) {
            StringBuilder stringBuilder = new StringBuilder().append(openingBrace);
            boolean first = true;
            for (Object value : values) {
                if (first) {
                    first = false;
                } else {
                    stringBuilder.append(", ");
                }
                stringBuilder.append(value);
            }
            return stringBuilder.append(closingBrace).toString();
        }
        public String toArrayErrorString(Sort sort) {
            return ARRAY_PREFIX + (componentAsInteger || !sort.isDefined() ? Integer.toString(sort.getTag()) : Character.toString((char) sort.getTag()));
        }
        public String toTypeErrorString(Class<?> type) {
            return type.toString();
        }
    }
    interface Loaded<U> {
        State getState();
        U resolve();
        <V> V resolve(Class<? extends V> type);
        boolean represents(Object value);
        abstract class AbstractBase<W> implements Loaded<W> {
            public <X> X resolve(Class<? extends X> type) {
                return type.cast(resolve());
            }
            public abstract static class ForUnresolvedProperty<Z> extends AbstractBase<Z> {
                public State getState() {
                    return State.UNRESOLVED;
                }
                public boolean represents(Object value) {
                    return false;
                }
            }
        }
    }
    enum State {
        UNDEFINED, UNRESOLVED, RESOLVED;
        public boolean isDefined() {
            return this != UNDEFINED;
        }
        public boolean isResolved() {
            return this == RESOLVED;
        }
    }
    enum Sort {
        BOOLEAN('Z'),
        BYTE('B'),
        SHORT('S'),
        CHARACTER('C'),
        INTEGER('I'),
        LONG('J'),
        FLOAT('F'),
        DOUBLE('D'),
        STRING('s'),
        TYPE('c'),
        ENUMERATION('e'),
        ANNOTATION('@'),
        ARRAY('['),
        NONE(0);
        private final int tag;
        Sort(int tag) {
            this.tag = tag;
        }
        public static Sort of(TypeDefinition typeDefinition) {
            if (typeDefinition.represents(boolean.class)) {
                return BOOLEAN;
            } else if (typeDefinition.represents(byte.class)) {
                return BYTE;
            } else if (typeDefinition.represents(short.class)) {
                return SHORT;
            } else if (typeDefinition.represents(char.class)) {
                return CHARACTER;
            } else if (typeDefinition.represents(int.class)) {
                return INTEGER;
            } else if (typeDefinition.represents(long.class)) {
                return LONG;
            } else if (typeDefinition.represents(float.class)) {
                return FLOAT;
            } else if (typeDefinition.represents(double.class)) {
                return DOUBLE;
            } else if (typeDefinition.represents(String.class)) {
                return STRING;
            } else if (typeDefinition.represents(Class.class)) {
                return TYPE;
            } else if (typeDefinition.isEnum()) {
                return ENUMERATION;
            } else if (typeDefinition.isAnnotation()) {
                return ANNOTATION;
            } else if (typeDefinition.isArray()) {
                return ARRAY;
            } else {
                return NONE;
            }
        }
        protected int getTag() {
            return tag;
        }
        public boolean isDefined() {
            return this != NONE;
        }
    }
    abstract class AbstractBase<U, V> implements AnnotationValue<U, V> {
        public <W> W resolve(Class<? extends W> type) {
            return type.cast(resolve());
        }
        public AnnotationValue<U, V> filter(MethodDescription.InDefinedShape property) {
            return filter(property, property.getReturnType());
        }
    }
    class ForConstant<U> extends AbstractBase<U, U> {
        private final U value;
        private final PropertyDelegate propertyDelegate;
        protected ForConstant(U value, PropertyDelegate propertyDelegate) {
            this.value = value;
            this.propertyDelegate = propertyDelegate;
        }
        public static AnnotationValue<Boolean, Boolean> of(boolean value) {
            return new ForConstant<Boolean>(value, PropertyDelegate.ForNonArrayType.BOOLEAN);
        }
        public static AnnotationValue<Byte, Byte> of(byte value) {
            return new ForConstant<Byte>(value, PropertyDelegate.ForNonArrayType.BYTE);
        }
        public static AnnotationValue<Short, Short> of(short value) {
            return new ForConstant<Short>(value, PropertyDelegate.ForNonArrayType.SHORT);
        }
        public static AnnotationValue<Character, Character> of(char value) {
            return new ForConstant<Character>(value, PropertyDelegate.ForNonArrayType.CHARACTER);
        }
        public static AnnotationValue<Integer, Integer> of(int value) {
            return new ForConstant<Integer>(value, PropertyDelegate.ForNonArrayType.INTEGER);
        }
        public static AnnotationValue<Long, Long> of(long value) {
            return new ForConstant<Long>(value, PropertyDelegate.ForNonArrayType.LONG);
        }
        public static AnnotationValue<Float, Float> of(float value) {
            return new ForConstant<Float>(value, PropertyDelegate.ForNonArrayType.FLOAT);
        }
        public static AnnotationValue<Double, Double> of(double value) {
            return new ForConstant<Double>(value, PropertyDelegate.ForNonArrayType.DOUBLE);
        }
        public static AnnotationValue<String, String> of(String value) {
            return new ForConstant<String>(value, PropertyDelegate.ForNonArrayType.STRING);
        }
        public static AnnotationValue<boolean[], boolean[]> of(boolean... value) {
            return new ForConstant<boolean[]>(value, PropertyDelegate.ForArrayType.BOOLEAN);
        }
        public static AnnotationValue<byte[], byte[]> of(byte... value) {
            return new ForConstant<byte[]>(value, PropertyDelegate.ForArrayType.BYTE);
        }
        public static AnnotationValue<short[], short[]> of(short... value) {
            return new ForConstant<short[]>(value, PropertyDelegate.ForArrayType.SHORT);
        }
        public static AnnotationValue<char[], char[]> of(char... value) {
            return new ForConstant<char[]>(value, PropertyDelegate.ForArrayType.CHARACTER);
        }
        public static AnnotationValue<int[], int[]> of(int... value) {
            return new ForConstant<int[]>(value, PropertyDelegate.ForArrayType.INTEGER);
        }
        public static AnnotationValue<long[], long[]> of(long... value) {
            return new ForConstant<long[]>(value, PropertyDelegate.ForArrayType.LONG);
        }
        public static AnnotationValue<float[], float[]> of(float... value) {
            return new ForConstant<float[]>(value, PropertyDelegate.ForArrayType.FLOAT);
        }
        public static AnnotationValue<double[], double[]> of(double... value) {
            return new ForConstant<double[]>(value, PropertyDelegate.ForArrayType.DOUBLE);
        }
        public static AnnotationValue<String[], String[]> of(String... value) {
            return new ForConstant<String[]>(value, PropertyDelegate.ForArrayType.STRING);
        }
        public static AnnotationValue<?, ?> of(Object value) {
            if (value instanceof Boolean) {
                return of(((Boolean) value).booleanValue());
            } else if (value instanceof Byte) {
                return of(((Byte) value).byteValue());
            } else if (value instanceof Short) {
                return of(((Short) value).shortValue());
            } else if (value instanceof Character) {
                return of(((Character) value).charValue());
            } else if (value instanceof Integer) {
                return of(((Integer) value).intValue());
            } else if (value instanceof Long) {
                return of(((Long) value).longValue());
            } else if (value instanceof Float) {
                return of(((Float) value).floatValue());
            } else if (value instanceof Double) {
                return of(((Double) value).doubleValue());
            } else if (value instanceof String) {
                return of((String) value);
            } else if (value instanceof boolean[]) {
                return of((boolean[]) value);
            } else if (value instanceof byte[]) {
                return of((byte[]) value);
            } else if (value instanceof short[]) {
                return of((short[]) value);
            } else if (value instanceof char[]) {
                return of((char[]) value);
            } else if (value instanceof int[]) {
                return of((int[]) value);
            } else if (value instanceof long[]) {
                return of((long[]) value);
            } else if (value instanceof float[]) {
                return of((float[]) value);
            } else if (value instanceof double[]) {
                return of((double[]) value);
            } else if (value instanceof String[]) {
                return of((String[]) value);
            } else {
                throw new IllegalArgumentException("Not a constant annotation value: " + value);
            }
        }
        public State getState() {
            return State.RESOLVED;
        }
        public Sort getSort() {
            return Sort.of(TypeDescription.ForLoadedType.of(value.getClass()).asUnboxed());
        }
        public AnnotationValue<U, U> filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
            if (typeDefinition.asErasure().asBoxed().represents(value.getClass())) {
                return this;
            } else if (value.getClass().isArray()) {
                return new ForMismatchedType<U, U>(property, RenderingDispatcher.CURRENT.toArrayErrorString(Sort.of(TypeDescription.ForLoadedType.of(value.getClass().getComponentType()))));
            } else if (value instanceof Enum<?>) {
                return new ForMismatchedType<U, U>(property, value.getClass().getName() + '.' + ((Enum<?>) value).name());
            } else {
                return new ForMismatchedType<U, U>(property, RenderingDispatcher.CURRENT.toTypeErrorString(value.getClass()) + '[' + value + ']');
            }
        }
        public U resolve() {
            return value;
        }
        public AnnotationValue.Loaded<U> load(@MaybeNull ClassLoader classLoader) {
            return new Loaded<U>(value, propertyDelegate);
        }
        public int hashCode() {
            return propertyDelegate.hashCode(value);
        }
        public boolean equals(@MaybeNull Object other) {
            return this == other || other instanceof AnnotationValue<?, ?> && propertyDelegate.equals(value, ((AnnotationValue<?, ?>) other).resolve());
        }
        public String toString() {
            return propertyDelegate.toString(value);
        }
        protected interface PropertyDelegate {
            <S> S copy(S value);
            int hashCode(Object value);
            boolean equals(Object self, Object other);
            String toString(Object value);
            enum ForNonArrayType implements PropertyDelegate {
                BOOLEAN {
                    public String toString(Object value) {
                        return RenderingDispatcher.CURRENT.toSourceString((Boolean) value);
                    }
                }
                ,
                BYTE {
                    public String toString(Object value) {
                        return RenderingDispatcher.CURRENT.toSourceString((Byte) value);
                    }
                }
                ,
                SHORT {
                    public String toString(Object value) {
                        return RenderingDispatcher.CURRENT.toSourceString((Short) value);
                    }
                }
                ,
                CHARACTER {
                    public String toString(Object value) {
                        return RenderingDispatcher.CURRENT.toSourceString((Character) value);
                    }
                }
                ,
                INTEGER {
                    public String toString(Object value) {
                        return RenderingDispatcher.CURRENT.toSourceString((Integer) value);
                    }
                }
                ,
                LONG {
                    public String toString(Object value) {
                        return RenderingDispatcher.CURRENT.toSourceString((Long) value);
                    }
                }
                ,
                FLOAT {
                    public String toString(Object value) {
                        return RenderingDispatcher.CURRENT.toSourceString((Float) value);
                    }
                }
                ,
                DOUBLE {
                    public String toString(Object value) {
                        return RenderingDispatcher.CURRENT.toSourceString((Double) value);
                    }
                }
                ,
                STRING {
                    public String toString(Object value) {
                        return RenderingDispatcher.CURRENT.toSourceString((String) value);
                    }
                }
                ;
                public <S> S copy(S value) {
                    return value;
                }
                public int hashCode(Object value) {
                    return value.hashCode();
                }
                public boolean equals(Object self, Object other) {
                    return self.equals(other);
                }
            }
            enum ForArrayType implements PropertyDelegate {
                BOOLEAN {
                    @Override
                    protected Object doCopy(Object value) {
                        return ((boolean[]) value).clone();
                    }
                    public int hashCode(Object value) {
                        return Arrays.hashCode((boolean[]) value);
                    }
                    public boolean equals(Object self, Object other) {
                        return other instanceof boolean[] && Arrays.equals((boolean[]) self, (boolean[]) other);
                    }
                    @Override
                    protected String toString(Object array, int index) {
                        return ForNonArrayType.BOOLEAN.toString(Array.getBoolean(array, index));
                    }
                }
                ,
                BYTE {
                    @Override
                    protected Object doCopy(Object value) {
                        return ((byte[]) value).clone();
                    }
                    public int hashCode(Object value) {
                        return Arrays.hashCode((byte[]) value);
                    }
                    public boolean equals(Object self, Object other) {
                        return other instanceof byte[] && Arrays.equals((byte[]) self, (byte[]) other);
                    }
                    @Override
                    protected String toString(Object array, int index) {
                        return ForNonArrayType.BYTE.toString(Array.getByte(array, index));
                    }
                }
                ,
                SHORT {
                    @Override
                    protected Object doCopy(Object value) {
                        return ((short[]) value).clone();
                    }
                    public int hashCode(Object value) {
                        return Arrays.hashCode((short[]) value);
                    }
                    public boolean equals(Object self, Object other) {
                        return other instanceof short[] && Arrays.equals((short[]) self, (short[]) other);
                    }
                    @Override
                    protected String toString(Object array, int index) {
                        return ForNonArrayType.SHORT.toString(Array.getShort(array, index));
                    }
                }
                ,
                CHARACTER {
                    @Override
                    protected Object doCopy(Object value) {
                        return ((char[]) value).clone();
                    }
                    public int hashCode(Object value) {
                        return Arrays.hashCode((char[]) value);
                    }
                    public boolean equals(Object self, Object other) {
                        return other instanceof char[] && Arrays.equals((char[]) self, (char[]) other);
                    }
                    @Override
                    protected String toString(Object array, int index) {
                        return ForNonArrayType.CHARACTER.toString(Array.getChar(array, index));
                    }
                }
                ,
                INTEGER {
                    @Override
                    protected Object doCopy(Object value) {
                        return ((int[]) value).clone();
                    }
                    public int hashCode(Object value) {
                        return Arrays.hashCode((int[]) value);
                    }
                    public boolean equals(Object self, Object other) {
                        return other instanceof int[] && Arrays.equals((int[]) self, (int[]) other);
                    }
                    @Override
                    protected String toString(Object array, int index) {
                        return ForNonArrayType.INTEGER.toString(Array.getInt(array, index));
                    }
                }
                ,
                LONG {
                    @Override
                    protected Object doCopy(Object value) {
                        return ((long[]) value).clone();
                    }
                    public int hashCode(Object value) {
                        return Arrays.hashCode((long[]) value);
                    }
                    public boolean equals(Object self, Object other) {
                        return other instanceof long[] && Arrays.equals((long[]) self, (long[]) other);
                    }
                    @Override
                    protected String toString(Object array, int index) {
                        return ForNonArrayType.LONG.toString(Array.getLong(array, index));
                    }
                }
                ,
                FLOAT {
                    @Override
                    protected Object doCopy(Object value) {
                        return ((float[]) value).clone();
                    }
                    public int hashCode(Object value) {
                        return Arrays.hashCode((float[]) value);
                    }
                    public boolean equals(Object self, Object other) {
                        return other instanceof float[] && Arrays.equals((float[]) self, (float[]) other);
                    }
                    @Override
                    protected String toString(Object array, int index) {
                        return ForNonArrayType.FLOAT.toString(Array.getFloat(array, index));
                    }
                }
                ,
                DOUBLE {
                    @Override
                    protected Object doCopy(Object value) {
                        return ((double[]) value).clone();
                    }
                    public int hashCode(Object value) {
                        return Arrays.hashCode((double[]) value);
                    }
                    public boolean equals(Object self, Object other) {
                        return other instanceof double[] && Arrays.equals((double[]) self, (double[]) other);
                    }
                    @Override
                    protected String toString(Object array, int index) {
                        return ForNonArrayType.DOUBLE.toString(Array.getDouble(array, index));
                    }
                }
                ,
                STRING {
                    @Override
                    protected Object doCopy(Object value) {
                        return ((String[]) value).clone();
                    }
                    public int hashCode(Object value) {
                        return Arrays.hashCode((String[]) value);
                    }
                    public boolean equals(Object self, Object other) {
                        return other instanceof String[] && Arrays.equals((String[]) self, (String[]) other);
                    }
                    @Override
                    protected String toString(Object array, int index) {
                        return ForNonArrayType.STRING.toString(Array.get(array, index));
                    }
                }
                ;
                public <S> S copy(S value) {
                    return (S) doCopy(value);
                }
                protected abstract Object doCopy(Object value);
                public String toString(Object value) {
                    List<String> elements = new ArrayList<String>(Array.getLength(value));
                    for (int index = 0; index < Array.getLength(value); index++) {
                        elements.add(toString(value, index));
                    }
                    return RenderingDispatcher.CURRENT.toSourceString(elements);
                }
                protected abstract String toString(Object array, int index);
            }
        }
        protected static class Loaded<V> extends AnnotationValue.Loaded.AbstractBase<V> {
            private final V value;
            private final PropertyDelegate propertyDelegate;
            protected Loaded(V value, PropertyDelegate propertyDelegate) {
                this.value = value;
                this.propertyDelegate = propertyDelegate;
            }
            public State getState() {
                return State.RESOLVED;
            }
            public V resolve() {
                return propertyDelegate.copy(value);
            }
            public boolean represents(Object value) {
                return propertyDelegate.equals(this.value, value);
            }
            public int hashCode() {
                return propertyDelegate.hashCode(value);
            }
            public boolean equals(@MaybeNull Object other) {
                if (this == other) {
                    return true;
                } else if (!(other instanceof AnnotationValue.Loaded<?>)) {
                    return false;
                }
                AnnotationValue.Loaded<?> annotationValue = (AnnotationValue.Loaded<?>) other;
                return annotationValue.getState().isResolved() && propertyDelegate.equals(value, annotationValue.resolve());
            }
            public String toString() {
                return propertyDelegate.toString(value);
            }
        }
    }
    class ForAnnotationDescription<U extends Annotation> extends AbstractBase<AnnotationDescription, U> {
        private final AnnotationDescription annotationDescription;
        public ForAnnotationDescription(AnnotationDescription annotationDescription) {
            this.annotationDescription = annotationDescription;
        }
        public static <V extends Annotation> AnnotationValue<AnnotationDescription, V> of(TypeDescription annotationType, Map<String, ? extends AnnotationValue<?, ?>> annotationValues) {
            return new ForAnnotationDescription<V>(new AnnotationDescription.Latent(annotationType, annotationValues));
        }
        public State getState() {
            return State.RESOLVED;
        }
        public Sort getSort() {
            return Sort.ANNOTATION;
        }
        public AnnotationValue<AnnotationDescription, U> filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
            return typeDefinition.asErasure().equals(annotationDescription.getAnnotationType()) ? this : new ForMismatchedType<AnnotationDescription, U>(property, property.getReturnType().isArray() ? RenderingDispatcher.CURRENT.toArrayErrorString(Sort.ANNOTATION) : annotationDescription.toString());
        }
        public AnnotationDescription resolve() {
            return annotationDescription;
        }
        public AnnotationValue.Loaded<U> load(@MaybeNull ClassLoader classLoader) {
            try {
                return new Loaded<U>(annotationDescription.prepare((Class<U>) Class.forName(annotationDescription.getAnnotationType().getName(), false, classLoader)).load());
            } catch (ClassNotFoundException exception) {
                return new ForMissingType.Loaded<U>(annotationDescription.getAnnotationType().getName(), exception);
            }
        }
        public int hashCode() {
            return annotationDescription.hashCode();
        }
        public boolean equals(@MaybeNull Object other) {
            return this == other || other instanceof AnnotationValue<?, ?> && annotationDescription.equals(((AnnotationValue<?, ?>) other).resolve());
        }
        public String toString() {
            return annotationDescription.toString();
        }
        public static class Loaded<V extends Annotation> extends AnnotationValue.Loaded.AbstractBase<V> {
            private final V annotation;
            public Loaded(V annotation) {
                this.annotation = annotation;
            }
            public State getState() {
                return State.RESOLVED;
            }
            public V resolve() {
                return annotation;
            }
            public boolean represents(Object value) {
                return annotation.equals(value);
            }
            public int hashCode() {
                return annotation.hashCode();
            }
            public boolean equals(@MaybeNull Object other) {
                if (this == other) {
                    return true;
                } else if (!(other instanceof AnnotationValue.Loaded<?>)) {
                    return false;
                }
                AnnotationValue.Loaded<?> annotationValue = (AnnotationValue.Loaded<?>) other;
                return annotationValue.getState().isResolved() && annotation.equals(annotationValue.resolve());
            }
            public String toString() {
                return annotation.toString();
            }
        }
    }
    class ForEnumerationDescription<U extends Enum<U>> extends AbstractBase<EnumerationDescription, U> {
        private final EnumerationDescription enumerationDescription;
        public ForEnumerationDescription(EnumerationDescription enumerationDescription) {
            this.enumerationDescription = enumerationDescription;
        }
        public static <V extends Enum<V>> AnnotationValue<EnumerationDescription, V> of(EnumerationDescription value) {
            return new ForEnumerationDescription<V>(value);
        }
        public EnumerationDescription resolve() {
            return enumerationDescription;
        }
        public State getState() {
            return State.RESOLVED;
        }
        public Sort getSort() {
            return Sort.ENUMERATION;
        }
        public AnnotationValue<EnumerationDescription, U> filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
            return typeDefinition.asErasure().equals(enumerationDescription.getEnumerationType()) ? this : new ForMismatchedType<EnumerationDescription, U>(property, property.getReturnType().isArray() ? RenderingDispatcher.CURRENT.toArrayErrorString(Sort.ENUMERATION) : enumerationDescription.getEnumerationType().getName() + '.' + enumerationDescription.getValue());
        }
        public AnnotationValue.Loaded<U> load(@MaybeNull ClassLoader classLoader) {
            try {
                return new Loaded<U>(enumerationDescription.load((Class<U>) Class.forName(enumerationDescription.getEnumerationType().getName(), false, classLoader)));
            } catch (ClassNotFoundException exception) {
                return new ForMissingType.Loaded<U>(enumerationDescription.getEnumerationType().getName(), exception);
            }
        }
        public int hashCode() {
            return enumerationDescription.hashCode();
        }
        public boolean equals(@MaybeNull Object other) {
            return this == other || other instanceof AnnotationValue<?, ?> && enumerationDescription.equals(((AnnotationValue<?, ?>) other).resolve());
        }
        public String toString() {
            return enumerationDescription.toString();
        }
        public static class Loaded<V extends Enum<V>> extends AnnotationValue.Loaded.AbstractBase<V> {
            private final V enumeration;
            public Loaded(V enumeration) {
                this.enumeration = enumeration;
            }
            public State getState() {
                return State.RESOLVED;
            }
            public V resolve() {
                return enumeration;
            }
            public boolean represents(Object value) {
                return enumeration.equals(value);
            }
            public int hashCode() {
                return enumeration.hashCode();
            }
            public boolean equals(@MaybeNull Object other) {
                if (this == other) {
                    return true;
                } else if (!(other instanceof AnnotationValue.Loaded<?>)) {
                    return false;
                }
                AnnotationValue.Loaded<?> annotationValue = (AnnotationValue.Loaded<?>) other;
                return annotationValue.getState().isResolved() && enumeration.equals(annotationValue.resolve());
            }
            public String toString() {
                return enumeration.toString();
            }
            public static class WithIncompatibleRuntimeType extends AnnotationValue.Loaded.AbstractBase<Enum<?>> {
                private final Class<?> type;
                public WithIncompatibleRuntimeType(Class<?> type) {
                    this.type = type;
                }
                public State getState() {
                    return State.UNRESOLVED;
                }
                public Enum<?> resolve() {
                    throw new IncompatibleClassChangeError("Not an enumeration type: " + type.getName());
                }
                public boolean represents(Object value) {
                    return false;
                }
            }
        }
        public static class WithUnknownConstant<U extends Enum<U>> extends AbstractBase<EnumerationDescription, U> {
            private final TypeDescription typeDescription;
            private final String value;
            public WithUnknownConstant(TypeDescription typeDescription, String value) {
                this.typeDescription = typeDescription;
                this.value = value;
            }
            public State getState() {
                return State.UNRESOLVED;
            }
            public Sort getSort() {
                return Sort.NONE;
            }
            public AnnotationValue<EnumerationDescription, U> filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
                return this;
            }
            public EnumerationDescription resolve() {
                throw new IllegalStateException(typeDescription + " does not declare enumeration constant " + value);
            }
            public AnnotationValue.Loaded<U> load(@MaybeNull ClassLoader classLoader) {
                try {
                    return (AnnotationValue.Loaded<U>) (Object) new Loaded((Class<Enum<?>>) Class.forName(typeDescription.getName(), false, classLoader), value);
                } catch (ClassNotFoundException exception) {
                    return new ForMissingType.Loaded<U>(typeDescription.getName(), exception);
                }
            }
            public String toString() {
                return value + " /* Warning: constant not present! */";
            }
            public static class Loaded extends AnnotationValue.Loaded.AbstractBase.ForUnresolvedProperty<Enum<?>> {
                private final Class<? extends Enum<?>> enumType;
                private final String value;
                public Loaded(Class<? extends Enum<?>> enumType, String value) {
                    this.enumType = enumType;
                    this.value = value;
                }
                public Enum<?> resolve() {
                    throw new EnumConstantNotPresentException(enumType, value);
                }
                public String toString() {
                    return value + " /* Warning: constant not present! */";
                }
            }
        }
    }
    class ForTypeDescription<U extends Class<U>> extends AbstractBase<TypeDescription, U> {
        private static final boolean NO_INITIALIZATION = false;
        private static final Map<TypeDescription, Class<?>> PRIMITIVE_TYPES;
        static {
            PRIMITIVE_TYPES = new HashMap<TypeDescription, Class<?>>();
            for (Class<?> type : new Class<?>[] { boolean.class, byte.class, short.class, char.class, int.class, long.class, float.class, double.class, void.class }) {
                PRIMITIVE_TYPES.put(TypeDescription.ForLoadedType.of(type), type);
            }
        }
        private final TypeDescription typeDescription;
        public ForTypeDescription(TypeDescription typeDescription) {
            this.typeDescription = typeDescription;
        }
        public static <V extends Class<V>> AnnotationValue<TypeDescription, V> of(TypeDescription typeDescription) {
            return new ForTypeDescription<V>(typeDescription);
        }
        public State getState() {
            return State.RESOLVED;
        }
        public Sort getSort() {
            return Sort.TYPE;
        }
        public AnnotationValue<TypeDescription, U> filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
            return typeDefinition.asErasure().represents(Class.class) ? this : new ForMismatchedType<TypeDescription, U>(property, property.getReturnType().isArray() ? RenderingDispatcher.CURRENT.toArrayErrorString(Sort.TYPE) : Class.class.getName() + '[' + typeDescription.getName() + ']');
        }
        public TypeDescription resolve() {
            return typeDescription;
        }
        public AnnotationValue.Loaded<U> load(@MaybeNull ClassLoader classLoader) {
            try {
                return new Loaded<U>((U) (typeDescription.isPrimitive() ? PRIMITIVE_TYPES.get(typeDescription) : Class.forName(typeDescription.getName(), NO_INITIALIZATION, classLoader)));
            } catch (ClassNotFoundException exception) {
                return new ForMissingType.Loaded<U>(typeDescription.getName(), exception);
            }
        }
        public int hashCode() {
            return typeDescription.hashCode();
        }
        public boolean equals(@MaybeNull Object other) {
            return this == other || other instanceof AnnotationValue<?, ?> && typeDescription.equals(((AnnotationValue<?, ?>) other).resolve());
        }
        public String toString() {
            return RenderingDispatcher.CURRENT.toSourceString(typeDescription);
        }
        protected static class Loaded<U extends Class<U>> extends AnnotationValue.Loaded.AbstractBase<U> {
            private final U type;
            public Loaded(U type) {
                this.type = type;
            }
            public State getState() {
                return State.RESOLVED;
            }
            public U resolve() {
                return type;
            }
            public boolean represents(Object value) {
                return type.equals(value);
            }
            public int hashCode() {
                return type.hashCode();
            }
            public boolean equals(@MaybeNull Object other) {
                if (this == other) {
                    return true;
                } else if (!(other instanceof AnnotationValue.Loaded<?>)) {
                    return false;
                }
                AnnotationValue.Loaded<?> annotationValue = (AnnotationValue.Loaded<?>) other;
                return annotationValue.getState().isResolved() && type.equals(annotationValue.resolve());
            }
            public String toString() {
                return RenderingDispatcher.CURRENT.toSourceString(TypeDescription.ForLoadedType.of(type));
            }
        }
    }
    class ForDescriptionArray<U, V> extends AbstractBase<U, V> {
        private final Class<?> unloadedComponentType;
        private final TypeDescription componentType;
        private final List<? extends AnnotationValue<?, ?>> values;
        public ForDescriptionArray(Class<?> unloadedComponentType, TypeDescription componentType, List<? extends AnnotationValue<?, ?>> values) {
            this.unloadedComponentType = unloadedComponentType;
            this.componentType = componentType;
            this.values = values;
        }
        public static <W extends Enum<W>> AnnotationValue<EnumerationDescription[], W[]> of(TypeDescription enumerationType, EnumerationDescription[] enumerationDescription) {
            List<AnnotationValue<EnumerationDescription, W>> values = new ArrayList<AnnotationValue<EnumerationDescription, W>>(enumerationDescription.length);
            for (EnumerationDescription value : enumerationDescription) {
                if (!value.getEnumerationType().equals(enumerationType)) {
                    throw new IllegalArgumentException(value + " is not of " + enumerationType);
                }
                values.add(ForEnumerationDescription.<W>of(value));
            }
            return new ForDescriptionArray<EnumerationDescription[], W[]>(EnumerationDescription.class, enumerationType, values);
        }
        public static <W extends Annotation> AnnotationValue<AnnotationDescription[], W[]> of(TypeDescription annotationType, AnnotationDescription[] annotationDescription) {
            List<AnnotationValue<AnnotationDescription, W>> values = new ArrayList<AnnotationValue<AnnotationDescription, W>>(annotationDescription.length);
            for (AnnotationDescription value : annotationDescription) {
                if (!value.getAnnotationType().equals(annotationType)) {
                    throw new IllegalArgumentException(value + " is not of " + annotationType);
                }
                values.add(new ForAnnotationDescription<W>(value));
            }
            return new ForDescriptionArray<AnnotationDescription[], W[]>(AnnotationDescription.class, annotationType, values);
        }
        public static AnnotationValue<TypeDescription[], Class<?>[]> of(TypeDescription[] typeDescription) {
            List<AnnotationValue<TypeDescription, Class<?>>> values = new ArrayList<AnnotationValue<TypeDescription, Class<?>>>(typeDescription.length);
            for (TypeDescription value : typeDescription) {
                values.add((AnnotationValue) ForTypeDescription.<Class>of(value));
            }
            return new ForDescriptionArray<TypeDescription[], Class<?>[]>(TypeDescription.class, TypeDescription.ForLoadedType.of(Class.class), values);
        }
        public State getState() {
            return State.RESOLVED;
        }
        public Sort getSort() {
            return Sort.ARRAY;
        }
        public AnnotationValue<U, V> filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
            if (typeDefinition.isArray() && typeDefinition.getComponentType().asErasure().equals(componentType)) {
                for (AnnotationValue<?, ?> value : values) {
                    if (value.getSort() != Sort.of(componentType)) {
                        return new ForMismatchedType<U, V>(property, RenderingDispatcher.CURRENT.toArrayErrorString(value.getSort()));
                    }
                    value = value.filter(property, typeDefinition.getComponentType());
                    if (value.getState() != State.RESOLVED) {
                        return (AnnotationValue<U, V>) value;
                    }
                }
                return this;
            } else {
                return new ForMismatchedType<U, V>(property, RenderingDispatcher.CURRENT.toArrayErrorString(Sort.of(componentType)));
            }
        }
        public U resolve() {
            @SuppressWarnings("unchecked")
            U resolved = (U) Array.newInstance(unloadedComponentType, values.size());
            int index = 0;
            for (AnnotationValue<?, ?> value : values) {
                Array.set(resolved, index++, value.resolve());
            }
            return resolved;
        }
        public AnnotationValue.Loaded<V> load(@MaybeNull ClassLoader classLoader) {
            List<AnnotationValue.Loaded<?>> values = new ArrayList<AnnotationValue.Loaded<?>>(this.values.size());
            for (AnnotationValue<?, ?> value : this.values) {
                values.add(value.load(classLoader));
            }
            try {
                return new Loaded<V>((Class<V>) (componentType.isPrimitive() ? unloadedComponentType : Class.forName(componentType.getName(), false, classLoader)), values);
            } catch (ClassNotFoundException exception) {
                return new ForMissingType.Loaded<V>(componentType.getName(), exception);
            }
        }
        public int hashCode() {
            int result = 1;
            for (AnnotationValue<?, ?> value : values) {
                result = 31 * result + value.hashCode();
            }
            return result;
        }
        public boolean equals(@MaybeNull Object other) {
            if (this == other) {
                return true;
            } else if (!(other instanceof AnnotationValue<?, ?>)) {
                return false;
            }
            AnnotationValue<?, ?> annotationValue = (AnnotationValue<?, ?>) other;
            Object value = annotationValue.resolve();
            if (!value.getClass().isArray()) {
                return false;
            }
            if (values.size() != Array.getLength(value)) {
                return false;
            }
            Iterator<? extends AnnotationValue<?, ?>> iterator = values.iterator();
            for (int index = 0; index < values.size(); index++) {
                AnnotationValue<?, ?> self = iterator.next();
                if (!self.resolve().equals(Array.get(value, index))) {
                    return false;
                }
            }
            return true;
        }
        public String toString() {
            return RenderingDispatcher.CURRENT.toSourceString(values);
        }
        protected static class Loaded<W> extends AnnotationValue.Loaded.AbstractBase<W> {
            private final Class<W> componentType;
            private final List<AnnotationValue.Loaded<?>> values;
            protected Loaded(Class<W> componentType, List<AnnotationValue.Loaded<?>> values) {
                this.componentType = componentType;
                this.values = values;
            }
            public State getState() {
                for (AnnotationValue.Loaded<?> value : values) {
                    if (!value.getState().isResolved()) {
                        return State.UNRESOLVED;
                    }
                }
                return State.RESOLVED;
            }
            public W resolve() {
                @SuppressWarnings("unchecked")
                W array = (W) Array.newInstance(componentType, values.size());
                int index = 0;
                for (AnnotationValue.Loaded<?> annotationValue : values) {
                    Array.set(array, index++, annotationValue.resolve());
                }
                return array;
            }
            public boolean represents(Object value) {
                if (!value.getClass().isArray())
                    return false;
                if (value.getClass().getComponentType() != componentType)
                    return false;
                if (values.size() != Array.getLength(value))
                    return false;
                Iterator<AnnotationValue.Loaded<?>> iterator = values.iterator();
                for (int index = 0; index < Array.getLength(value); index++) {
                    AnnotationValue.Loaded<?> self = iterator.next();
                    if (!self.represents(Array.get(value, index))) {
                        return false;
                    }
                }
                return true;
            }
            public int hashCode() {
                int result = 1;
                for (AnnotationValue.Loaded<?> value : values) {
                    result = 31 * result + value.hashCode();
                }
                return result;
            }
            public boolean equals(@MaybeNull Object other) {
                if (this == other) {
                    return true;
                } else if (!(other instanceof AnnotationValue.Loaded<?>)) {
                    return false;
                }
                AnnotationValue.Loaded<?> annotationValue = (AnnotationValue.Loaded<?>) other;
                if (!annotationValue.getState().isResolved()) {
                    return false;
                }
                Object value = annotationValue.resolve();
                if (!value.getClass().isArray()) {
                    return false;
                }
                if (values.size() != Array.getLength(value)) {
                    return false;
                }
                Iterator<AnnotationValue.Loaded<?>> iterator = values.iterator();
                for (int index = 0; index < Array.getLength(value); index++) {
                    AnnotationValue.Loaded<?> self = iterator.next();
                    if (!self.getState().isResolved() || !self.resolve().equals(Array.get(value, index))) {
                        return false;
                    }
                }
                return true;
            }
            public String toString() {
                return RenderingDispatcher.CURRENT.toSourceString(values);
            }
        }
    }
    class ForMissingType<U, V> extends AbstractBase<U, V> {
        private final String typeName;
        public ForMissingType(String typeName) {
            this.typeName = typeName;
        }
        public State getState() {
            return State.UNRESOLVED;
        }
        public Sort getSort() {
            return Sort.NONE;
        }
        public AnnotationValue<U, V> filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
            return this;
        }
        public U resolve() {
            throw new IllegalStateException("Type not found: " + typeName);
        }
        public AnnotationValue.Loaded<V> load(@MaybeNull ClassLoader classLoader) {
            return new Loaded<V>(typeName, new ClassNotFoundException(typeName));
        }
        public String toString() {
            return typeName + ".class /* Warning: type not present! */";
        }
        public static class Loaded<U> extends AnnotationValue.Loaded.AbstractBase.ForUnresolvedProperty<U> {
            private final String typeName;
            private final ClassNotFoundException exception;
            public Loaded(String typeName, ClassNotFoundException exception) {
                this.typeName = typeName;
                this.exception = exception;
            }
            public U resolve() {
                throw new TypeNotPresentException(typeName, exception);
            }
            public String toString() {
                return typeName + ".class /* Warning: type not present! */";
            }
        }
    }
    class ForMismatchedType<U, V> extends AbstractBase<U, V> {
        private final MethodDescription.InDefinedShape property;
        private final String value;
        public ForMismatchedType(MethodDescription.InDefinedShape property, String value) {
            this.property = property;
            this.value = value;
        }
        public State getState() {
            return State.UNRESOLVED;
        }
        public Sort getSort() {
            return Sort.NONE;
        }
        public AnnotationValue<U, V> filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
            return new ForMismatchedType<U, V>(property, value);
        }
        public U resolve() {
            throw new IllegalStateException(value + " cannot be used as value for " + property);
        }
        public AnnotationValue.Loaded<V> load(@MaybeNull ClassLoader classLoader) {
            try {
                Class<?> type = Class.forName(property.getDeclaringType().getName(), false, classLoader);
                try {
                    return new Loaded<V>(type.getMethod(property.getName()), value);
                } catch (NoSuchMethodException exception) {
                    return new ForIncompatibleType.Loaded<V>(type);
                }
            } catch (ClassNotFoundException exception) {
                return new ForMissingType.Loaded<V>(property.getDeclaringType().getName(), exception);
            }
        }
        public String toString() {
            return "/* Warning type mismatch! \"" + value + "\" */";
        }
        public static class Loaded<W> extends AnnotationValue.Loaded.AbstractBase.ForUnresolvedProperty<W> {
            private final Method property;
            private final String value;
            public Loaded(Method property, String value) {
                this.property = property;
                this.value = value;
            }
            public W resolve() {
                throw new AnnotationTypeMismatchException(property, value);
            }
            public String toString() {
                return "/* Warning type mismatch! \"" + value + "\" */";
            }
        }
    }
    class ForMissingValue<U, V> extends AnnotationValue.AbstractBase<U, V> {
        private final TypeDescription typeDescription;
        private final String property;
        public ForMissingValue(TypeDescription typeDescription, String property) {
            this.typeDescription = typeDescription;
            this.property = property;
        }
        public State getState() {
            return State.UNDEFINED;
        }
        public Sort getSort() {
            return Sort.NONE;
        }
        public AnnotationValue<U, V> filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
            return this;
        }
        public AnnotationValue.Loaded<V> load(@MaybeNull ClassLoader classLoader) {
            try {
                Class<? extends Annotation> type = (Class<? extends Annotation>) Class.forName(typeDescription.getName(), false, classLoader);
                return type.isAnnotation() ? new Loaded<V>(type, property) : new ForIncompatibleType.Loaded<V>(type);
            } catch (ClassNotFoundException exception) {
                return new ForMissingType.Loaded<V>(typeDescription.getName(), exception);
            }
        }
        public U resolve() {
            throw new IllegalStateException(typeDescription + " does not define " + property);
        }
        public static class Loaded<W> extends AnnotationValue.Loaded.AbstractBase<W> {
            private final Class<? extends Annotation> type;
            private final String property;
            public Loaded(Class<? extends Annotation> type, String property) {
                this.type = type;
                this.property = property;
            }
            public State getState() {
                return State.UNDEFINED;
            }
            public W resolve() {
                throw new IncompleteAnnotationException(type, property);
            }
            public boolean represents(Object value) {
                return false;
            }
        }
    }
    class ForIncompatibleType<U, V> extends AnnotationValue.AbstractBase<U, V> {
        private final TypeDescription typeDescription;
        public ForIncompatibleType(TypeDescription typeDescription) {
            this.typeDescription = typeDescription;
        }
        public State getState() {
            return State.UNRESOLVED;
        }
        public Sort getSort() {
            return Sort.NONE;
        }
        public AnnotationValue<U, V> filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
            return this;
        }
        public U resolve() {
            throw new IllegalStateException("Property is defined with an incompatible runtime type: " + typeDescription);
        }
        public AnnotationValue.Loaded<V> load(@MaybeNull ClassLoader classLoader) {
            try {
                return new Loaded<V>(Class.forName(typeDescription.getName(), false, classLoader));
            } catch (ClassNotFoundException exception) {
                return new ForMissingType.Loaded<V>(typeDescription.getName(), exception);
            }
        }
        public String toString() {
            return "/* Warning type incompatibility! \"" + typeDescription.getName() + "\" */";
        }
        public static class Loaded<W> extends AnnotationValue.Loaded.AbstractBase.ForUnresolvedProperty<W> {
            private final Class<?> type;
            public Loaded(Class<?> type) {
                this.type = type;
            }
            public W resolve() {
                throw new IncompatibleClassChangeError(type.toString());
            }
            public String toString() {
                return "/* Warning type incompatibility! \"" + type.getName() + "\" */";
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```