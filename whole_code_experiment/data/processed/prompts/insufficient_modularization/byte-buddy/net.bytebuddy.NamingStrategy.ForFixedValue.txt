##CONTEXT_SIZE=1366
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy;
public interface NamingStrategy {
    String BYTE_BUDDY_RENAME_PACKAGE = "net.bytebuddy.renamed";
    String NO_PREFIX = "";
    String subclass(TypeDescription.Generic superClass);
    String redefine(TypeDescription typeDescription);
    String rebase(TypeDescription typeDescription);
    abstract class AbstractBase implements NamingStrategy {
        public String subclass(TypeDescription.Generic superClass) {
            return name(superClass.asErasure());
        }
        protected abstract String name(TypeDescription superClass);
        public String redefine(TypeDescription typeDescription) {
            return typeDescription.getName();
        }
        public String rebase(TypeDescription typeDescription) {
            return typeDescription.getName();
        }
    }
    class Suffixing extends AbstractBase {
        private static final String JAVA_PACKAGE = "java.";
        private final String suffix;
        private final String javaLangPackagePrefix;
        private final BaseNameResolver baseNameResolver;
        public Suffixing(String suffix) {
            this(suffix, BaseNameResolver.ForUnnamedType.INSTANCE);
        }
        public Suffixing(String suffix, String javaLangPackagePrefix) {
            this(suffix, BaseNameResolver.ForUnnamedType.INSTANCE, javaLangPackagePrefix);
        }
        public Suffixing(String suffix, BaseNameResolver baseNameResolver) {
            this(suffix, baseNameResolver, BYTE_BUDDY_RENAME_PACKAGE);
        }
        public Suffixing(String suffix, BaseNameResolver baseNameResolver, String javaLangPackagePrefix) {
            this.suffix = suffix;
            this.baseNameResolver = baseNameResolver;
            this.javaLangPackagePrefix = javaLangPackagePrefix;
        }
        protected String name(TypeDescription superClass) {
            String baseName = baseNameResolver.resolve(superClass);
            if (baseName.startsWith(JAVA_PACKAGE) && !javaLangPackagePrefix.equals("")) {
                baseName = javaLangPackagePrefix + "." + baseName;
            }
            return baseName + "$" + suffix;
        }
        public interface BaseNameResolver {
            String resolve(TypeDescription typeDescription);
            enum ForUnnamedType implements BaseNameResolver {
                INSTANCE;
                public String resolve(TypeDescription typeDescription) {
                    return typeDescription.getName();
                }
            }
            class ForGivenType implements BaseNameResolver {
                private final TypeDescription typeDescription;
                public ForGivenType(TypeDescription typeDescription) {
                    this.typeDescription = typeDescription;
                }
                public String resolve(TypeDescription typeDescription) {
                    return this.typeDescription.getName();
                }
            }
            class ForFixedValue implements BaseNameResolver {
                private final String name;
                public ForFixedValue(String name) {
                    this.name = name;
                }
                public String resolve(TypeDescription typeDescription) {
                    return name;
                }
            }
            class WithCallerSuffix implements BaseNameResolver {
                private final BaseNameResolver delegate;
                public WithCallerSuffix(BaseNameResolver delegate) {
                    this.delegate = delegate;
                }
                public String resolve(TypeDescription typeDescription) {
                    boolean matched = false;
                    String caller = null;
                    for (StackTraceElement stackTraceElement : new Throwable().getStackTrace()) {
                        if (stackTraceElement.getClassName().equals(ByteBuddy.class.getName())) {
                            matched = true;
                        } else if (matched) {
                            caller = stackTraceElement.getClassName() + "." + stackTraceElement.getMethodName();
                            break;
                        }
                    }
                    if (caller == null) {
                        throw new IllegalStateException("Base name resolver not invoked via " + ByteBuddy.class);
                    }
                    return delegate.resolve(typeDescription) + "$" + caller.replace('.', '$');
                }
            }
        }
    }
    class SuffixingRandom extends Suffixing {
        private final RandomString randomString;
        public SuffixingRandom(String suffix) {
            this(suffix, Suffixing.BaseNameResolver.ForUnnamedType.INSTANCE);
        }
        public SuffixingRandom(String suffix, String javaLangPackagePrefix) {
            this(suffix, Suffixing.BaseNameResolver.ForUnnamedType.INSTANCE, javaLangPackagePrefix);
        }
        @Deprecated
        public SuffixingRandom(String suffix, BaseNameResolver baseNameResolver) {
            this(suffix, (Suffixing.BaseNameResolver) baseNameResolver);
        }
        public SuffixingRandom(String suffix, Suffixing.BaseNameResolver baseNameResolver) {
            this(suffix, baseNameResolver, BYTE_BUDDY_RENAME_PACKAGE);
        }
        @Deprecated
        public SuffixingRandom(String suffix, BaseNameResolver baseNameResolver, String javaLangPackagePrefix) {
            this(suffix, (Suffixing.BaseNameResolver) baseNameResolver, javaLangPackagePrefix);
        }
        public SuffixingRandom(String suffix, Suffixing.BaseNameResolver baseNameResolver, String javaLangPackagePrefix) {
            this(suffix, baseNameResolver, javaLangPackagePrefix, new RandomString());
        }
        @Deprecated
        public SuffixingRandom(String suffix, BaseNameResolver baseNameResolver, String javaLangPackagePrefix, RandomString randomString) {
            this(suffix, (Suffixing.BaseNameResolver) baseNameResolver, javaLangPackagePrefix, randomString);
        }
        public SuffixingRandom(String suffix, Suffixing.BaseNameResolver baseNameResolver, String javaLangPackagePrefix, RandomString randomString) {
            super(suffix, baseNameResolver, javaLangPackagePrefix);
            this.randomString = randomString;
        }
        protected String name(TypeDescription superClass) {
            return super.name(superClass) + "$" + randomString.nextString();
        }
        public interface BaseNameResolver extends Suffixing.BaseNameResolver {
            enum ForUnnamedType implements BaseNameResolver {
                INSTANCE;
                public String resolve(TypeDescription typeDescription) {
                    return typeDescription.getName();
                }
            }
            class ForGivenType extends Suffixing.BaseNameResolver.ForGivenType implements BaseNameResolver {
                public ForGivenType(TypeDescription typeDescription) {
                    super(typeDescription);
                }
            }
            class ForFixedValue extends Suffixing.BaseNameResolver.ForFixedValue implements BaseNameResolver {
                public ForFixedValue(String name) {
                    super(name);
                }
            }
        }
    }
    class PrefixingRandom extends AbstractBase {
        private final String prefix;
        private final RandomString randomString;
        public PrefixingRandom(String prefix) {
            this.prefix = prefix;
            randomString = new RandomString();
        }
        protected String name(TypeDescription superClass) {
            return prefix + "." + superClass.getName() + "$" + randomString.nextString();
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```