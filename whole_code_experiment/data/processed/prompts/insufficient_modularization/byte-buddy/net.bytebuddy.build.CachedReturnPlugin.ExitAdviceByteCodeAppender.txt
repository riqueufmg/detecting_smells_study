##CONTEXT_SIZE=1720
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.build;
public class CachedReturnPlugin extends Plugin.ForElementMatcher implements Plugin.Factory {
    private static final String NAME_INFIX = "_";
    private static final MethodDescription.InDefinedShape ENHANCE_VALUE = TypeDescription.ForLoadedType.of(Enhance.class).getDeclaredMethods().filter(named("value")).getOnly();
    private final boolean ignoreExistingFields;
    private final RandomString randomString;
    public CachedReturnPlugin() {
        this(false);
    }
    public CachedReturnPlugin(boolean ignoreExistingFields) {
        super(declaresMethod(isAnnotatedWith(Enhance.class)));
        this.ignoreExistingFields = ignoreExistingFields;
        randomString = new RandomString();
    }
    public Plugin make() {
        return this;
    }
    public DynamicType.Builder<?> apply(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassFileLocator classFileLocator) {
        for (MethodDescription.InDefinedShape methodDescription : typeDescription.getDeclaredMethods().filter(not(isBridge()).<MethodDescription>and(isAnnotatedWith(Enhance.class)))) {
            if (methodDescription.isAbstract()) {
                throw new IllegalStateException("Cannot cache the value of an abstract method: " + methodDescription);
            } else if (!methodDescription.getParameters().isEmpty()) {
                throw new IllegalStateException("Cannot cache the value of a method with parameters: " + methodDescription);
            } else if (methodDescription.getReturnType().represents(void.class)) {
                throw new IllegalStateException("Cannot cache void result for " + methodDescription);
            }
            String name = methodDescription.getDeclaredAnnotations().ofType(Enhance.class).getValue(ENHANCE_VALUE).resolve(String.class);
            if (name.length() == 0) {
                name = methodDescription.getName() + NAME_INFIX + randomString.nextString();
            } else if (ignoreExistingFields && !typeDescription.getDeclaredFields().filter(named(name)).isEmpty()) {
                return builder;
            }
            builder = builder.defineField(name, methodDescription.getReturnType().asErasure(), methodDescription.isStatic() ? Ownership.STATIC : Ownership.MEMBER, methodDescription.isStatic() ? FieldPersistence.PLAIN : FieldPersistence.TRANSIENT, Visibility.PRIVATE, SyntheticState.SYNTHETIC).visit(AdviceResolver.of(methodDescription.getReturnType()).toAdvice(name).on(is(methodDescription)));
        }
        return builder;
    }
    public void close() {
    }
    public @interface Enhance {
        String value() default "";
    }
    protected @interface CacheField {
    }
    protected enum AdviceResolver {
        BOOLEAN(boolean.class, Opcodes.ILOAD, Opcodes.ISTORE, Opcodes.NOP, Opcodes.IFNE),
        BYTE(byte.class, Opcodes.ILOAD, Opcodes.ISTORE, Opcodes.NOP, Opcodes.IFNE),
        SHORT(short.class, Opcodes.ILOAD, Opcodes.ISTORE, Opcodes.NOP, Opcodes.IFNE),
        CHARACTER(char.class, Opcodes.ILOAD, Opcodes.ISTORE, Opcodes.NOP, Opcodes.IFNE),
        INTEGER(int.class, Opcodes.ILOAD, Opcodes.ISTORE, Opcodes.NOP, Opcodes.IFNE),
        LONG(long.class, Opcodes.LLOAD, Opcodes.LSTORE, Opcodes.L2I, Opcodes.IFNE),
        FLOAT(float.class, Opcodes.FLOAD, Opcodes.FSTORE, Opcodes.F2I, Opcodes.IFNE),
        DOUBLE(double.class, Opcodes.DLOAD, Opcodes.DSTORE, Opcodes.D2I, Opcodes.IFNE),
        REFERENCE(Object.class, Opcodes.ALOAD, Opcodes.ASTORE, Opcodes.NOP, Opcodes.IFNONNULL);
        private final DynamicType dynamicType;
        AdviceResolver(Class<?> type, int load, int store, int convert, int branch) {
            dynamicType = new ByteBuddy(ClassFileVersion.JAVA_V6).with(TypeValidation.DISABLED).subclass(Object.class, ConstructorStrategy.Default.NO_CONSTRUCTORS).name(CachedReturnPlugin.class.getName() + "$Advice$" + this).defineMethod("enter", type, Ownership.STATIC).withParameter(type).annotateParameter(AnnotationDescription.Builder.ofType(CachedReturnPlugin.CacheField.class).build()).intercept(new Implementation.Simple(MethodVariableAccess.of(TypeDescription.ForLoadedType.of(type)).loadFrom(0), MethodReturn.of(TypeDescription.ForLoadedType.of(type)))).annotateMethod(AnnotationDescription.Builder.ofType(Advice.OnMethodEnter.class).define("skipOn", Advice.OnNonDefaultValue.class).build()).defineMethod("exit", void.class, Ownership.STATIC).withParameter(type).annotateParameter(AnnotationDescription.Builder.ofType(Advice.Return.class).define("readOnly", false).define("typing", Assigner.Typing.DYNAMIC).build()).withParameter(type).annotateParameter(AnnotationDescription.Builder.ofType(CachedReturnPlugin.CacheField.class).build()).intercept(new Implementation.Simple(new ExitAdviceByteCodeAppender(load, store, convert, branch, StackSize.of(type).getSize()))).annotateMethod(AnnotationDescription.Builder.ofType(Advice.OnMethodExit.class).build()).make();
        }
        protected static AdviceResolver of(TypeDefinition typeDefinition) {
            if (typeDefinition.represents(boolean.class)) {
                return BOOLEAN;
            } else if (typeDefinition.represents(byte.class)) {
                return BYTE;
            } else if (typeDefinition.represents(short.class)) {
                return SHORT;
            } else if (typeDefinition.represents(char.class)) {
                return CHARACTER;
            } else if (typeDefinition.represents(int.class)) {
                return INTEGER;
            } else if (typeDefinition.represents(long.class)) {
                return LONG;
            } else if (typeDefinition.represents(float.class)) {
                return FLOAT;
            } else if (typeDefinition.represents(double.class)) {
                return DOUBLE;
            } else if (typeDefinition.isPrimitive()) {
                throw new IllegalArgumentException("Unexpected advice type: " + typeDefinition);
            } else {
                return REFERENCE;
            }
        }
        protected Advice toAdvice(String name) {
            return Advice.withCustomMapping().bind(CacheField.class, new CacheFieldOffsetMapping(name)).to(dynamicType.getTypeDescription(), dynamicType);
        }
        protected static class ExitAdviceByteCodeAppender implements ByteCodeAppender {
            private final int load;
            private final int store;
            private final int convert;
            private final int branch;
            private final int size;
            protected ExitAdviceByteCodeAppender(int load, int store, int convert, int branch, int size) {
                this.load = load;
                this.store = store;
                this.convert = convert;
                this.branch = branch;
                this.size = size;
            }
            public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
                Label complete = new Label(), uncached = new Label();
                methodVisitor.visitVarInsn(load, 0);
                if (convert != Opcodes.NOP) {
                    methodVisitor.visitInsn(convert);
                }
                methodVisitor.visitJumpInsn(branch, uncached);
                methodVisitor.visitVarInsn(load, size);
                methodVisitor.visitVarInsn(store, 0);
                methodVisitor.visitJumpInsn(Opcodes.GOTO, complete);
                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);
                methodVisitor.visitLabel(uncached);
                methodVisitor.visitVarInsn(load, 0);
                methodVisitor.visitVarInsn(store, size);
                methodVisitor.visitLabel(complete);
                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);
                methodVisitor.visitInsn(Opcodes.RETURN);
                return new Size(size * 2, instrumentedMethod.getStackSize());
            }
        }
    }
    protected static class CacheFieldOffsetMapping implements Advice.OffsetMapping {
        private final String name;
        protected CacheFieldOffsetMapping(String name) {
            this.name = name;
        }
        public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Advice.ArgumentHandler argumentHandler, Sort sort) {
            return new Target.ForField.ReadWrite(instrumentedType.getDeclaredFields().filter(named(name)).getOnly());
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```