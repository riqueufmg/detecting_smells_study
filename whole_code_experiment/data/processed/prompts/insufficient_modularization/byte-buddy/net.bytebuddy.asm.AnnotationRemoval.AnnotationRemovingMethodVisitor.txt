##CONTEXT_SIZE=2237
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.asm;
public class AnnotationRemoval extends AsmVisitorWrapper.AbstractBase {
    private static final int METHOD_NONE = -4;
    private static final int METHOD_ALL = -3;
    private static final int METHOD_ONLY = -2;
    private static final int METHOD_PARAMETERS = -1;
    private final boolean type;
    private final ElementMatcher<? super FieldDescription.InDefinedShape> fieldMatcher;
    private final ElementMatcher<? super MethodDescription> methodMatcher;
    private final ElementMatcher<? super AnnotationDescription> annotationMatcher;
    private final int parameters;
    protected AnnotationRemoval(boolean type, ElementMatcher<? super FieldDescription.InDefinedShape.InDefinedShape> fieldMatcher, ElementMatcher<? super MethodDescription> methodMatcher, ElementMatcher<? super AnnotationDescription> annotationMatcher, int parameters) {
        this.type = type;
        this.fieldMatcher = fieldMatcher;
        this.methodMatcher = methodMatcher;
        this.annotationMatcher = annotationMatcher;
        this.parameters = parameters;
    }
    public static AnnotationRemoval strip(ElementMatcher<? super AnnotationDescription> matcher) {
        return new AnnotationRemoval(true, any(), any(), matcher, METHOD_ALL);
    }
    public AsmVisitorWrapper onType() {
        return new AnnotationRemoval(true, none(), none(), annotationMatcher, METHOD_NONE);
    }
    public AsmVisitorWrapper onFields(ElementMatcher<? super FieldDescription> matcher) {
        return new AnnotationRemoval(false, matcher, none(), annotationMatcher, METHOD_NONE);
    }
    public AsmVisitorWrapper onMethods(ElementMatcher<? super MethodDescription> matcher) {
        return onInvokables(isMethod().and(matcher));
    }
    public AsmVisitorWrapper onMethodsAndParameters(ElementMatcher<? super MethodDescription> matcher) {
        return onInvokablesAndParameters(isMethod().and(matcher));
    }
    public AsmVisitorWrapper onMethodParameters(ElementMatcher<? super MethodDescription> matcher) {
        return onInvokableParameters(isMethod().and(matcher));
    }
    public AsmVisitorWrapper onMethodParameter(ElementMatcher<? super MethodDescription> matcher, int parameter) {
        return onInvokableParameter(isMethod().and(matcher), parameter);
    }
    public AsmVisitorWrapper onConstructors(ElementMatcher<? super MethodDescription> matcher) {
        return onInvokables(isConstructor().and(matcher));
    }
    public AsmVisitorWrapper onConstructorsAndParameters(ElementMatcher<? super MethodDescription> matcher) {
        return onInvokablesAndParameters(isConstructor().and(matcher));
    }
    public AsmVisitorWrapper onConstructorParameters(ElementMatcher<? super MethodDescription> matcher) {
        return onInvokableParameters(isConstructor().and(matcher));
    }
    public AsmVisitorWrapper onConstructorParameter(ElementMatcher<? super MethodDescription> matcher, int parameter) {
        return onInvokableParameter(isConstructor().and(matcher), parameter);
    }
    public AsmVisitorWrapper onInvokables(ElementMatcher<? super MethodDescription> matcher) {
        return new AnnotationRemoval(false, none(), matcher, annotationMatcher, METHOD_ONLY);
    }
    public AsmVisitorWrapper onInvokablesAndParameters(ElementMatcher<? super MethodDescription> matcher) {
        return new AnnotationRemoval(false, none(), matcher, annotationMatcher, METHOD_ALL);
    }
    public AsmVisitorWrapper onInvokableParameters(ElementMatcher<? super MethodDescription> matcher) {
        return new AnnotationRemoval(false, none(), matcher, annotationMatcher, METHOD_PARAMETERS);
    }
    public AsmVisitorWrapper onInvokableParameter(ElementMatcher<? super MethodDescription> matcher, int parameter) {
        if (parameter < 0) {
            throw new IllegalArgumentException("Parameter index cannot be negative: " + parameter);
        }
        return new AnnotationRemoval(false, none(), matcher, annotationMatcher, parameter);
    }
    public ClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, Implementation.Context implementationContext, TypePool typePool, FieldList<FieldDescription.InDefinedShape> fields, MethodList<?> methods, int writerFlags, int readerFlags) {
        Map<String, AnnotationDescription> mappedAnnotations = new HashMap<String, AnnotationDescription>();
        if (type) {
            for (AnnotationDescription annotation : instrumentedType.getDeclaredAnnotations()) {
                mappedAnnotations.put(annotation.getAnnotationType().getDescriptor(), annotation);
            }
        }
        Map<String, FieldDescription.InDefinedShape> mappedFields = new HashMap<String, FieldDescription.InDefinedShape>();
        for (FieldDescription.InDefinedShape fieldDescription : fields) {
            mappedFields.put(fieldDescription.getInternalName() + fieldDescription.getDescriptor(), fieldDescription);
        }
        Map<String, MethodDescription> mappedMethods = new HashMap<String, MethodDescription>();
        for (MethodDescription methodDescription : CompoundList.<MethodDescription>of(methods, new MethodDescription.Latent.TypeInitializer(instrumentedType))) {
            mappedMethods.put(methodDescription.getInternalName() + methodDescription.getDescriptor(), methodDescription);
        }
        return new AnnotationRemovingClassVisitor(classVisitor, fieldMatcher, methodMatcher, annotationMatcher, parameters, mappedFields, mappedMethods, mappedAnnotations);
    }
    private static class AnnotationRemovingClassVisitor extends ClassVisitor {
        private final ElementMatcher<? super FieldDescription.InDefinedShape> fieldMatcher;
        private final ElementMatcher<? super MethodDescription> methodMatcher;
        private final ElementMatcher<? super AnnotationDescription> annotationMatcher;
        private final int parameters;
        private final Map<String, FieldDescription.InDefinedShape> fields;
        private final Map<String, MethodDescription> methods;
        private final Map<String, AnnotationDescription> annotations;
        private AnnotationRemovingClassVisitor(ClassVisitor classVisitor, ElementMatcher<? super FieldDescription.InDefinedShape> fieldMatcher, ElementMatcher<? super MethodDescription> methodMatcher, ElementMatcher<? super AnnotationDescription> annotationMatcher, int parameters, Map<String, FieldDescription.InDefinedShape> fields, Map<String, MethodDescription> methods, Map<String, AnnotationDescription> annotations) {
            super(OpenedClassReader.ASM_API, classVisitor);
            this.fieldMatcher = fieldMatcher;
            this.methodMatcher = methodMatcher;
            this.annotationMatcher = annotationMatcher;
            this.parameters = parameters;
            this.fields = fields;
            this.methods = methods;
            this.annotations = annotations;
        }
        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
            AnnotationDescription annotation = annotations.get(descriptor);
            return annotation != null && annotationMatcher.matches(annotation) ? null : super.visitAnnotation(descriptor, visible);
        }
        public FieldVisitor visitField(int modifiers, String internalName, String descriptor, String signature, Object value) {
            FieldVisitor fieldVisitor = super.visitField(modifiers, internalName, descriptor, signature, value);
            if (fieldVisitor == null) {
                return null;
            }
            FieldDescription.InDefinedShape fieldDescription = fields.get(internalName + descriptor);
            if (fieldDescription != null && fieldMatcher.matches(fieldDescription)) {
                Map<String, AnnotationDescription> mappedAnnotations = new HashMap<String, AnnotationDescription>();
                for (AnnotationDescription annotation : fieldDescription.getDeclaredAnnotations()) {
                    mappedAnnotations.put(annotation.getAnnotationType().getDescriptor(), annotation);
                }
                return new AnnotationRemovingFieldVisitor(fieldVisitor, annotationMatcher, mappedAnnotations);
            } else {
                return fieldVisitor;
            }
        }
        public MethodVisitor visitMethod(int modifiers, String internalName, String descriptor, String signature, String[] exception) {
            MethodVisitor methodVisitor = super.visitMethod(modifiers, internalName, descriptor, signature, exception);
            if (methodVisitor == null) {
                return null;
            }
            MethodDescription methodDescription = methods.get(internalName + descriptor);
            if (methodDescription != null && methodMatcher.matches(methodDescription)) {
                Map<Integer, Map<String, AnnotationDescription>> mappedParameterAnnotations = new HashMap<Integer, Map<String, AnnotationDescription>>();
                if (parameters >= 0 || parameters == METHOD_PARAMETERS || parameters == METHOD_ALL) {
                    for (ParameterDescription parameter : methodDescription.getParameters()) {
                        Map<String, AnnotationDescription> mappedAnnotations = new HashMap<String, AnnotationDescription>();
                        if (parameter.getIndex() == parameters || parameters < 0) {
                            for (AnnotationDescription annotation : parameter.getDeclaredAnnotations()) {
                                mappedAnnotations.put(annotation.getAnnotationType().getDescriptor(), annotation);
                            }
                        }
                        mappedParameterAnnotations.put(parameter.getIndex(), mappedAnnotations);
                    }
                }
                Map<String, AnnotationDescription> mappedAnnotations = new HashMap<String, AnnotationDescription>();
                if (parameters == METHOD_ONLY || parameters == METHOD_ALL) {
                    for (AnnotationDescription annotation : methodDescription.getDeclaredAnnotations()) {
                        mappedAnnotations.put(annotation.getAnnotationType().getDescriptor(), annotation);
                    }
                }
                return new AnnotationRemovingMethodVisitor(methodVisitor, annotationMatcher, mappedParameterAnnotations, mappedAnnotations);
            } else {
                return methodVisitor;
            }
        }
    }
    private static class AnnotationRemovingFieldVisitor extends FieldVisitor {
        private final ElementMatcher<? super AnnotationDescription> annotationMatcher;
        private final Map<String, AnnotationDescription> annotations;
        private AnnotationRemovingFieldVisitor(FieldVisitor fieldVisitor, ElementMatcher<? super AnnotationDescription> annotationMatcher, Map<String, AnnotationDescription> annotations) {
            super(OpenedClassReader.ASM_API, fieldVisitor);
            this.annotationMatcher = annotationMatcher;
            this.annotations = annotations;
        }
        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
            AnnotationDescription annotation = annotations.get(descriptor);
            return annotation != null && annotationMatcher.matches(annotation) ? null : super.visitAnnotation(descriptor, visible);
        }
    }
    private static class AnnotationRemovingMethodVisitor extends MethodVisitor {
        private final ElementMatcher<? super AnnotationDescription> annotationMatcher;
        private final Map<Integer, Map<String, AnnotationDescription>> parameterAnnotations;
        private final Map<String, AnnotationDescription> annotations;
        private AnnotationRemovingMethodVisitor(MethodVisitor methodVisitor, ElementMatcher<? super AnnotationDescription> annotationMatcher, Map<Integer, Map<String, AnnotationDescription>> parameterAnnotations, Map<String, AnnotationDescription> annotations) {
            super(OpenedClassReader.ASM_API, methodVisitor);
            this.annotationMatcher = annotationMatcher;
            this.parameterAnnotations = parameterAnnotations;
            this.annotations = annotations;
        }
        public AnnotationVisitor visitParameterAnnotation(int parameter, String descriptor, boolean visible) {
            Map<String, AnnotationDescription> annotations = parameterAnnotations.get(parameter);
            if (annotations != null) {
                AnnotationDescription annotation = annotations.get(descriptor);
                return annotation != null && annotationMatcher.matches(annotation) ? null : super.visitParameterAnnotation(parameter, descriptor, visible);
            } else {
                return super.visitParameterAnnotation(parameter, descriptor, visible);
            }
        }
        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
            AnnotationDescription annotation = annotations.get(descriptor);
            return annotation != null && annotationMatcher.matches(annotation) ? null : super.visitAnnotation(descriptor, visible);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```