##CONTEXT_SIZE=24763
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.dynamic;
public interface DynamicType extends ClassFileLocator {
    TypeDescription getTypeDescription();
    byte[] getBytes();
    LoadedTypeInitializer getLoadedTypeInitializer();
    List<? extends DynamicType> getAuxiliaries();
    Set<TypeDescription> getAuxiliaryTypeDescriptions();
    Set<TypeDescription> getAllTypeDescriptions();
    Map<TypeDescription, byte[]> getAuxiliaryTypes();
    Map<TypeDescription, byte[]> getAllTypes();
    Map<TypeDescription, LoadedTypeInitializer> getLoadedTypeInitializers();
    boolean hasAliveLoadedTypeInitializers();
    Map<TypeDescription, File> saveIn(File folder) throws IOException;
    File inject(File sourceJar, File targetJar) throws IOException;
    File inject(File jar) throws IOException;
    File toJar(File file) throws IOException;
    File toJar(File file, Manifest manifest) throws IOException;
    void close();
    interface Builder<T> {
        Builder<T> visit(AsmVisitorWrapper asmVisitorWrapper);
        Builder<T> name(String name);
        Builder<T> suffix(String suffix);
        Builder<T> modifiers(ModifierContributor.ForType... modifierContributor);
        Builder<T> modifiers(Collection<? extends ModifierContributor.ForType> modifierContributors);
        Builder<T> modifiers(int modifiers);
        Builder<T> merge(ModifierContributor.ForType... modifierContributor);
        Builder<T> merge(Collection<? extends ModifierContributor.ForType> modifierContributors);
        ModuleDefinition<T> module(String name, ModifierContributor.ForModule... modifierContributors);
        ModuleDefinition<T> module(String name, Collection<? extends ModifierContributor.ForModule> modifierContributors);
        ModuleDefinition<T> module(String name, int modifiers);
        ModuleDefinition<T> adjustModule(ModifierContributor.ForModule... modifierContributor);
        ModuleDefinition<T> adjustModule(Collection<? extends ModifierContributor.ForModule> modifierContributors);
        Builder<T> topLevelType();
        InnerTypeDefinition.ForType<T> innerTypeOf(Class<?> type);
        InnerTypeDefinition.ForType<T> innerTypeOf(TypeDescription type);
        InnerTypeDefinition<T> innerTypeOf(Method method);
        InnerTypeDefinition<T> innerTypeOf(Constructor<?> constructor);
        InnerTypeDefinition<T> innerTypeOf(MethodDescription.InDefinedShape methodDescription);
        Builder<T> declaredTypes(Class<?>... type);
        Builder<T> declaredTypes(TypeDescription... type);
        Builder<T> declaredTypes(List<? extends Class<?>> types);
        Builder<T> declaredTypes(Collection<? extends TypeDescription> types);
        Builder<T> noNestMate();
        Builder<T> nestHost(Class<?> type);
        Builder<T> nestHost(TypeDescription type);
        Builder<T> nestMembers(Class<?>... type);
        Builder<T> nestMembers(TypeDescription... type);
        Builder<T> nestMembers(List<? extends Class<?>> types);
        Builder<T> nestMembers(Collection<? extends TypeDescription> types);
        Builder<T> permittedSubclass(Class<?>... type);
        Builder<T> permittedSubclass(TypeDescription... type);
        Builder<T> permittedSubclass(List<? extends Class<?>> types);
        Builder<T> permittedSubclass(Collection<? extends TypeDescription> types);
        Builder<T> unsealed();
        Builder<T> attribute(TypeAttributeAppender typeAttributeAppender);
        Builder<T> annotateType(Annotation... annotation);
        Builder<T> annotateType(List<? extends Annotation> annotations);
        Builder<T> annotateType(AnnotationDescription... annotation);
        Builder<T> annotateType(Collection<? extends AnnotationDescription> annotations);
        MethodDefinition.ImplementationDefinition.Optional<T> implement(Type... interfaceType);
        MethodDefinition.ImplementationDefinition.Optional<T> implement(List<? extends Type> interfaceTypes);
        MethodDefinition.ImplementationDefinition.Optional<T> implement(TypeDefinition... interfaceType);
        MethodDefinition.ImplementationDefinition.Optional<T> implement(Collection<? extends TypeDefinition> interfaceTypes);
        Builder<T> initializer(ByteCodeAppender byteCodeAppender);
        Builder<T> initializer(LoadedTypeInitializer loadedTypeInitializer);
        Builder<T> require(TypeDescription type, byte[] binaryRepresentation);
        Builder<T> require(TypeDescription type, byte[] binaryRepresentation, LoadedTypeInitializer typeInitializer);
        Builder<T> require(DynamicType... auxiliaryType);
        Builder<T> require(Collection<DynamicType> auxiliaryTypes);
        TypeVariableDefinition<T> typeVariable(String symbol);
        TypeVariableDefinition<T> typeVariable(String symbol, Type... bound);
        TypeVariableDefinition<T> typeVariable(String symbol, List<? extends Type> bounds);
        TypeVariableDefinition<T> typeVariable(String symbol, TypeDefinition... bound);
        TypeVariableDefinition<T> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds);
        Builder<T> transform(ElementMatcher<? super TypeDescription.Generic> matcher, Transformer<TypeVariableToken> transformer);
        FieldDefinition.Optional.Valuable<T> defineField(String name, Type type, ModifierContributor.ForField... modifierContributor);
        FieldDefinition.Optional.Valuable<T> defineField(String name, Type type, Collection<? extends ModifierContributor.ForField> modifierContributors);
        FieldDefinition.Optional.Valuable<T> defineField(String name, Type type, int modifiers);
        FieldDefinition.Optional.Valuable<T> defineField(String name, TypeDefinition type, ModifierContributor.ForField... modifierContributor);
        FieldDefinition.Optional.Valuable<T> defineField(String name, TypeDefinition type, Collection<? extends ModifierContributor.ForField> modifierContributors);
        FieldDefinition.Optional.Valuable<T> defineField(String name, TypeDefinition type, int modifiers);
        FieldDefinition.Optional.Valuable<T> define(Field field);
        FieldDefinition.Optional.Valuable<T> define(FieldDescription field);
        FieldDefinition.Optional<T> serialVersionUid(long serialVersionUid);
        FieldDefinition.Valuable<T> field(ElementMatcher<? super FieldDescription> matcher);
        FieldDefinition.Valuable<T> field(LatentMatcher<? super FieldDescription> matcher);
        Builder<T> ignoreAlso(ElementMatcher<? super MethodDescription> ignoredMethods);
        Builder<T> ignoreAlso(LatentMatcher<? super MethodDescription> ignoredMethods);
        MethodDefinition.ParameterDefinition.Initial<T> defineMethod(String name, Type returnType, ModifierContributor.ForMethod... modifierContributor);
        MethodDefinition.ParameterDefinition.Initial<T> defineMethod(String name, Type returnType, Collection<? extends ModifierContributor.ForMethod> modifierContributors);
        MethodDefinition.ParameterDefinition.Initial<T> defineMethod(String name, Type returnType, int modifiers);
        MethodDefinition.ParameterDefinition.Initial<T> defineMethod(String name, TypeDefinition returnType, ModifierContributor.ForMethod... modifierContributor);
        MethodDefinition.ParameterDefinition.Initial<T> defineMethod(String name, TypeDefinition returnType, Collection<? extends ModifierContributor.ForMethod> modifierContributors);
        MethodDefinition.ParameterDefinition.Initial<T> defineMethod(String name, TypeDefinition returnType, int modifiers);
        MethodDefinition.ParameterDefinition.Initial<T> defineConstructor(ModifierContributor.ForMethod... modifierContributor);
        MethodDefinition.ParameterDefinition.Initial<T> defineConstructor(Collection<? extends ModifierContributor.ForMethod> modifierContributors);
        MethodDefinition.ParameterDefinition.Initial<T> defineConstructor(int modifiers);
        MethodDefinition.ImplementationDefinition<T> define(Method method);
        MethodDefinition.ImplementationDefinition<T> define(Constructor<?> constructor);
        MethodDefinition.ImplementationDefinition<T> define(MethodDescription methodDescription);
        FieldDefinition.Optional<T> defineProperty(String name, Type type);
        FieldDefinition.Optional<T> defineProperty(String name, Type type, boolean readOnly);
        FieldDefinition.Optional<T> defineProperty(String name, TypeDefinition type);
        FieldDefinition.Optional<T> defineProperty(String name, TypeDefinition type, boolean readOnly);
        MethodDefinition.ImplementationDefinition<T> method(ElementMatcher<? super MethodDescription> matcher);
        MethodDefinition.ImplementationDefinition<T> constructor(ElementMatcher<? super MethodDescription> matcher);
        MethodDefinition.ImplementationDefinition<T> invokable(ElementMatcher<? super MethodDescription> matcher);
        MethodDefinition.ImplementationDefinition<T> invokable(LatentMatcher<? super MethodDescription> matcher);
        Builder<T> withHashCodeEquals();
        Builder<T> withToString();
        RecordComponentDefinition.Optional<T> defineRecordComponent(String name, Type type);
        RecordComponentDefinition.Optional<T> defineRecordComponent(String name, TypeDefinition type);
        RecordComponentDefinition.Optional<T> define(RecordComponentDescription recordComponentDescription);
        RecordComponentDefinition<T> recordComponent(ElementMatcher<? super RecordComponentDescription> matcher);
        RecordComponentDefinition<T> recordComponent(LatentMatcher<? super RecordComponentDescription> matcher);
        ContextClassVisitor wrap(ClassVisitor classVisitor);
        ContextClassVisitor wrap(ClassVisitor classVisitor, int writerFlags, int readerFlags);
        ContextClassVisitor wrap(ClassVisitor classVisitor, TypePool typePool);
        ContextClassVisitor wrap(ClassVisitor classVisitor, TypePool typePool, int writerFlags, int readerFlags);
        DynamicType.Unloaded<T> make();
        DynamicType.Unloaded<T> make(TypeResolutionStrategy typeResolutionStrategy);
        DynamicType.Unloaded<T> make(TypePool typePool);
        DynamicType.Unloaded<T> make(TypeResolutionStrategy typeResolutionStrategy, TypePool typePool);
        TypeDescription toTypeDescription();
        interface ModuleDefinition<S> extends Builder<S> {
            ModuleDefinition<S> version(@MaybeNull String version);
            ModuleDefinition<S> mainClass(@MaybeNull Class<?> type);
            ModuleDefinition<S> mainClass(@MaybeNull TypeDescription typeDescription);
            ModuleDefinition<S> mainClass(@MaybeNull String name);
            ModuleDefinition<S> packages(String... aPackage);
            ModuleDefinition<S> packages(Collection<String> packages);
            ModuleDefinition<S> requires(String... module);
            ModuleDefinition<S> requires(Collection<String> modules);
            RequiresDefinition<S> require(String module, ModifierContributor.ForModule.OfRequire... modifierContributor);
            RequiresDefinition<S> require(String module, Collection<? extends ModifierContributor.ForModule.OfRequire> modifierContributors);
            RequiresDefinition<S> require(String module, int modifiers);
            ModuleDefinition<S> exports(String... aPackage);
            ModuleDefinition<S> exports(Collection<String> packages);
            ModuleDefinition<S> export(String aPackage, ModifierContributor.ForModule.OfExport... modifierContributor);
            ModuleDefinition<S> export(String aPackage, Collection<? extends ModifierContributor.ForModule.OfExport> modifierContributors);
            ModuleDefinition<S> export(String aPackage, int modifiers);
            ModuleDefinition<S> opens(String... aPackage);
            ModuleDefinition<S> opens(Collection<String> packages);
            ModuleDefinition<S> open(String aPackage, ModifierContributor.ForModule.OfOpen... modifierContributor);
            ModuleDefinition<S> open(String aPackage, Collection<? extends ModifierContributor.ForModule.OfOpen> modifierContributors);
            ModuleDefinition<S> open(String aPackage, int modifiers);
            ModuleDefinition<S> uses(Class<?>... service);
            ModuleDefinition<S> uses(TypeDescription... service);
            ModuleDefinition<S> uses(String... service);
            ModuleDefinition<S> uses(Collection<String> services);
            ModuleDefinition<S> provides(Class<?> service, Class<?>... implementation);
            ModuleDefinition<S> provides(Class<?> service, Collection<Class<?>> implementations);
            ModuleDefinition<S> provides(TypeDescription service, TypeDescription... implementation);
            ModuleDefinition<S> provides(TypeDescription service, Collection<TypeDescription> implementations);
            ModuleDefinition<S> provides(String service, String... implementation);
            ModuleDefinition<S> provides(String service, Collection<String> implementations);
            interface RequiresDefinition<U> extends ModuleDefinition<U> {
                RequiresDefinition<U> requiredVersion(@MaybeNull String version);
                abstract class Delegator<V> extends ModuleDefinition.AbstractBase.Delegator<V> implements RequiresDefinition<V> {
                }
            }
            interface ExportsDefinition<U> extends ModuleDefinition<U> {
                ExportsDefinition<U> to(String... module);
                ExportsDefinition<U> to(Collection<String> modules);
                abstract class Delegator<V> extends ModuleDefinition.AbstractBase.Delegator<V> implements ExportsDefinition<V> {
                    public ExportsDefinition<V> to(String... module) {
                        return to(Arrays.asList(module));
                    }
                }
            }
            interface OpensDefinition<S> extends ModuleDefinition<S> {
                OpensDefinition<S> to(String... module);
                OpensDefinition<S> to(Collection<String> modules);
                abstract class Delegator<V> extends ModuleDefinition.AbstractBase.Delegator<V> implements OpensDefinition<V> {
                    public OpensDefinition<V> to(String... module) {
                        return to(Arrays.asList(module));
                    }
                }
            }
            abstract class AbstractBase<U> extends Builder.AbstractBase.Delegator<U> implements ModuleDefinition<U> {
                public ModuleDefinition<U> mainClass(@MaybeNull Class<?> type) {
                    return mainClass(type == null ? null : TypeDescription.ForLoadedType.of(type));
                }
                public ModuleDefinition<U> mainClass(@MaybeNull TypeDescription typeDescription) {
                    if (typeDescription != null && (typeDescription.isArray() || typeDescription.isPrimitive())) {
                        throw new IllegalArgumentException("Cannot use primitive types for main class: " + typeDescription);
                    }
                    return mainClass(typeDescription == null ? null : typeDescription.getName());
                }
                public ModuleDefinition<U> packages(String... aPackage) {
                    return packages(Arrays.asList(aPackage));
                }
                public ModuleDefinition<U> requires(String... module) {
                    return requires(Arrays.asList(module));
                }
                public ModuleDefinition<U> requires(Collection<String> modules) {
                    ModuleDefinition<U> definition = this;
                    for (String module : modules) {
                        definition = definition.requires(module);
                    }
                    return definition;
                }
                public RequiresDefinition<U> require(String module, ModifierContributor.ForModule.OfRequire... modifierContributor) {
                    return require(module, Arrays.asList(modifierContributor));
                }
                public RequiresDefinition<U> require(String module, Collection<? extends ModifierContributor.ForModule.OfRequire> modifierContributors) {
                    return require(module, ModifierContributor.Resolver.of(modifierContributors).resolve());
                }
                public ModuleDefinition<U> exports(String... aPackage) {
                    return exports(Arrays.asList(aPackage));
                }
                public ModuleDefinition<U> exports(Collection<String> packages) {
                    ModuleDefinition<U> definition = this;
                    for (String aPackage : packages) {
                        definition = definition.export(aPackage);
                    }
                    return definition;
                }
                public ModuleDefinition<U> export(String aPackage, ModifierContributor.ForModule.OfExport... modifierContributor) {
                    return export(aPackage, Arrays.asList(modifierContributor));
                }
                public ModuleDefinition<U> export(String aPackage, Collection<? extends ModifierContributor.ForModule.OfExport> modifierContributors) {
                    return export(aPackage, ModifierContributor.Resolver.of(modifierContributors).resolve());
                }
                public ModuleDefinition<U> opens(String... aPackage) {
                    return opens(Arrays.asList(aPackage));
                }
                public ModuleDefinition<U> opens(Collection<String> packages) {
                    ModuleDefinition<U> definition = this;
                    for (String aPackage : packages) {
                        definition = definition.open(aPackage);
                    }
                    return definition;
                }
                public ModuleDefinition<U> open(String aPackage, ModifierContributor.ForModule.OfOpen... modifierContributor) {
                    return open(aPackage, Arrays.asList(modifierContributor));
                }
                public ModuleDefinition<U> open(String aPackage, Collection<? extends ModifierContributor.ForModule.OfOpen> modifierContributors) {
                    return open(aPackage, ModifierContributor.Resolver.of(modifierContributors).resolve());
                }
                public ModuleDefinition<U> uses(Class<?>... service) {
                    return uses(new TypeList.ForLoadedTypes(service));
                }
                public ModuleDefinition<U> uses(TypeDescription... service) {
                    return uses(Arrays.asList(service));
                }
                private ModuleDefinition<U> uses(List<TypeDescription> services) {
                    List<String> names = new ArrayList<String>(services.size());
                    for (TypeDescription service : services) {
                        if (service.isArray() || service.isPrimitive()) {
                            throw new IllegalArgumentException("A service can only be provided by a regular class: " + service);
                        }
                        names.add(service.getName());
                    }
                    return uses(names);
                }
                public ModuleDefinition<U> uses(String... service) {
                    return uses(Arrays.asList(service));
                }
                public ModuleDefinition<U> provides(Class<?> service, Class<?>... implementations) {
                    return provides(service, Arrays.asList(implementations));
                }
                public ModuleDefinition<U> provides(Class<?> service, Collection<Class<?>> implementations) {
                    return provides(TypeDescription.ForLoadedType.of(service), new TypeList.ForLoadedTypes(new ArrayList<Class<?>>(implementations)));
                }
                public ModuleDefinition<U> provides(TypeDescription service, TypeDescription... implementation) {
                    return provides(service, Arrays.asList(implementation));
                }
                public ModuleDefinition<U> provides(TypeDescription service, Collection<TypeDescription> implementations) {
                    if (service.isArray() || service.isPrimitive()) {
                        throw new IllegalArgumentException("Service must be a regular class: " + service);
                    }
                    List<String> names = new ArrayList<String>(implementations.size());
                    for (TypeDescription implementation : implementations) {
                        if (implementation.isArray() || implementation.isPrimitive() || implementation.isAbstract()) {
                            throw new IllegalArgumentException("Service implementation must be a regular, non-abstract class: " + implementation);
                        }
                        names.add(implementation.getName());
                    }
                    return provides(service.getName(), names);
                }
                public ModuleDefinition<U> provides(String service, String... implementations) {
                    return provides(service, Arrays.asList(implementations));
                }
                public abstract static class Delegator<V> extends ModuleDefinition.AbstractBase<V> {
                    public ModuleDefinition<V> version(@MaybeNull String version) {
                        return materialize().version(version);
                    }
                    public ModuleDefinition<V> mainClass(@MaybeNull String name) {
                        return materialize().mainClass(name);
                    }
                    public ModuleDefinition<V> packages(Collection<String> packages) {
                        return materialize().packages(packages);
                    }
                    public RequiresDefinition<V> require(String module, int modifiers) {
                        return materialize().require(module, modifiers);
                    }
                    public ModuleDefinition<V> export(String aPackage, int modifiers) {
                        return materialize().export(aPackage, modifiers);
                    }
                    public ModuleDefinition<V> open(String aPackage, int modifiers) {
                        return materialize().open(aPackage, modifiers);
                    }
                    public ModuleDefinition<V> uses(Collection<String> services) {
                        return materialize().uses(services);
                    }
                    public ModuleDefinition<V> provides(String service, Collection<String> implementations) {
                        return materialize().provides(service, implementations);
                    }
                    protected abstract ModuleDefinition<V> materialize();
                }
            }
        }
        interface InnerTypeDefinition<S> extends Builder<S> {
            Builder<S> asAnonymousType();
            interface ForType<U> extends InnerTypeDefinition<U> {
                Builder<U> asMemberType();
            }
        }
        interface TypeVariableDefinition<S> extends Builder<S> {
            TypeVariableDefinition<S> annotateTypeVariable(Annotation... annotation);
            TypeVariableDefinition<S> annotateTypeVariable(List<? extends Annotation> annotations);
            TypeVariableDefinition<S> annotateTypeVariable(AnnotationDescription... annotation);
            TypeVariableDefinition<S> annotateTypeVariable(Collection<? extends AnnotationDescription> annotations);
            abstract class AbstractBase<U> extends Builder.AbstractBase.Delegator<U> implements TypeVariableDefinition<U> {
                public TypeVariableDefinition<U> annotateTypeVariable(Annotation... annotation) {
                    return annotateTypeVariable(Arrays.asList(annotation));
                }
                public TypeVariableDefinition<U> annotateTypeVariable(List<? extends Annotation> annotations) {
                    return annotateTypeVariable(new AnnotationList.ForLoadedAnnotations(annotations));
                }
                public TypeVariableDefinition<U> annotateTypeVariable(AnnotationDescription... annotation) {
                    return annotateTypeVariable(Arrays.asList(annotation));
                }
            }
        }
        interface FieldDefinition<S> {
            FieldDefinition.Optional<S> annotateField(Annotation... annotation);
            FieldDefinition.Optional<S> annotateField(List<? extends Annotation> annotations);
            FieldDefinition.Optional<S> annotateField(AnnotationDescription... annotation);
            FieldDefinition.Optional<S> annotateField(Collection<? extends AnnotationDescription> annotations);
            FieldDefinition.Optional<S> attribute(FieldAttributeAppender.Factory fieldAttributeAppenderFactory);
            FieldDefinition.Optional<S> transform(Transformer<FieldDescription> transformer);
            interface Valuable<U> extends FieldDefinition<U> {
                FieldDefinition.Optional<U> value(boolean value);
                FieldDefinition.Optional<U> value(int value);
                FieldDefinition.Optional<U> value(long value);
                FieldDefinition.Optional<U> value(float value);
                FieldDefinition.Optional<U> value(double value);
                FieldDefinition.Optional<U> value(String value);
            }
            interface Optional<U> extends FieldDefinition<U>, Builder<U> {
                interface Valuable<V> extends FieldDefinition.Valuable<V>, Optional<V> {
                    abstract class AbstractBase<U> extends Optional.AbstractBase<U> implements Optional.Valuable<U> {
                        public FieldDefinition.Optional<U> value(boolean value) {
                            return defaultValue(value ? 1 : 0);
                        }
                        public FieldDefinition.Optional<U> value(int value) {
                            return defaultValue(value);
                        }
                        public FieldDefinition.Optional<U> value(long value) {
                            return defaultValue(value);
                        }
                        public FieldDefinition.Optional<U> value(float value) {
                            return defaultValue(value);
                        }
                        public FieldDefinition.Optional<U> value(double value) {
                            return defaultValue(value);
                        }
                        public FieldDefinition.Optional<U> value(String value) {
                            if (value == null) {
                                throw new IllegalArgumentException("Cannot define 'null' as constant value");
                            }
                            return defaultValue(value);
                        }
                        protected abstract FieldDefinition.Optional<U> defaultValue(Object defaultValue);
                        private abstract static class Adapter<V> extends Optional.Valuable.AbstractBase<V> {
                            protected final FieldAttributeAppender.Factory fieldAttributeAppenderFactory;
                            protected final Transformer<FieldDescription> transformer;
                            protected final Object defaultValue;
                            protected Adapter(FieldAttributeAppender.Factory fieldAttributeAppenderFactory, Transformer<FieldDescription> transformer, @MaybeNull Object defaultValue) {
                                this.fieldAttributeAppenderFactory = fieldAttributeAppenderFactory;
                                this.transformer = transformer;
                                this.defaultValue = defaultValue;
                            }
                            public FieldDefinition.Optional<V> attribute(FieldAttributeAppender.Factory fieldAttributeAppenderFactory) {
                                return materialize(new FieldAttributeAppender.Factory.Compound(this.fieldAttributeAppenderFactory, fieldAttributeAppenderFactory), transformer, defaultValue);
                            }
                            public FieldDefinition.Optional<V> transform(Transformer<FieldDescription> transformer) {
                                return materialize(fieldAttributeAppenderFactory, new Transformer.Compound<FieldDescription>(this.transformer, transformer), defaultValue);
                            }
                            protected FieldDefinition.Optional<V> defaultValue(Object defaultValue) {
                                return materialize(fieldAttributeAppenderFactory, transformer, defaultValue);
                            }
                            protected abstract FieldDefinition.Optional<V> materialize(FieldAttributeAppender.Factory fieldAttributeAppenderFactory, Transformer<FieldDescription> transformer, @MaybeNull Object defaultValue);
                        }
                    }
                }
                abstract class AbstractBase<U> extends Builder.AbstractBase.Delegator<U> implements FieldDefinition.Optional<U> {
                    public FieldDefinition.Optional<U> annotateField(Annotation... annotation) {
                        return annotateField(Arrays.asList(annotation));
                    }
                    public FieldDefinition.Optional<U> annotateField(List<? extends Annotation> annotations) {
                        return annotateField(new AnnotationList.ForLoadedAnnotations(annotations));
                    }
                    public FieldDefinition.Optional<U> annotateField(AnnotationDescription... annotation) {
                        return annotateField(Arrays.asList(annotation));
                    }
                }
            }
        }
        interface MethodDefinition<S> extends Builder<S> {
            MethodDefinition<S> annotateMethod(Annotation... annotation);
            MethodDefinition<S> annotateMethod(List<? extends Annotation> annotations);
            MethodDefinition<S> annotateMethod(AnnotationDescription... annotation);
            MethodDefinition<S> annotateMethod(Collection<? extends AnnotationDescription> annotations);
            MethodDefinition<S> annotateParameter(int index, Annotation... annotation);
            MethodDefinition<S> annotateParameter(int index, List<? extends Annotation> annotations);
            MethodDefinition<S> annotateParameter(int index, AnnotationDescription... annotation);
            MethodDefinition<S> annotateParameter(int index, Collection<? extends AnnotationDescription> annotations);
            MethodDefinition<S> attribute(MethodAttributeAppender.Factory methodAttributeAppenderFactory);
            MethodDefinition<S> transform(Transformer<MethodDescription> transformer);
            interface ReceiverTypeDefinition<U> extends MethodDefinition<U> {
                MethodDefinition<U> receiverType(AnnotatedElement receiverType);
                MethodDefinition<U> receiverType(TypeDescription.Generic receiverType);
                abstract class AbstractBase<V> extends MethodDefinition.AbstractBase<V> implements ReceiverTypeDefinition<V> {
                    public MethodDefinition<V> receiverType(AnnotatedElement receiverType) {
                        return receiverType(TypeDefinition.Sort.describeAnnotated(receiverType));
                    }
                }
            }
            interface ImplementationDefinition<U> {
                MethodDefinition.ReceiverTypeDefinition<U> intercept(Implementation implementation);
                MethodDefinition.ReceiverTypeDefinition<U> withoutCode();
                MethodDefinition.ReceiverTypeDefinition<U> defaultValue(AnnotationValue<?, ?> annotationValue);
                <W> MethodDefinition.ReceiverTypeDefinition<U> defaultValue(W value, Class<? extends W> type);
                interface Optional<V> extends ImplementationDefinition<V>, Builder<V> {
                }
                abstract class AbstractBase<V> implements ImplementationDefinition<V> {
                    public <W> MethodDefinition.ReceiverTypeDefinition<V> defaultValue(W value, Class<? extends W> type) {
                        return defaultValue(AnnotationDescription.ForLoadedAnnotation.asValue(value, type));
                    }
                }
            }
            interface TypeVariableDefinition<U> extends ImplementationDefinition<U> {
                Annotatable<U> typeVariable(String symbol);
                Annotatable<U> typeVariable(String symbol, Type... bound);
                Annotatable<U> typeVariable(String symbol, List<? extends Type> bounds);
                Annotatable<U> typeVariable(String symbol, TypeDefinition... bound);
                Annotatable<U> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds);
                interface Annotatable<V> extends TypeVariableDefinition<V> {
                    Annotatable<V> annotateTypeVariable(Annotation... annotation);
                    Annotatable<V> annotateTypeVariable(List<? extends Annotation> annotations);
                    Annotatable<V> annotateTypeVariable(AnnotationDescription... annotation);
                    Annotatable<V> annotateTypeVariable(Collection<? extends AnnotationDescription> annotations);
                    abstract class AbstractBase<W> extends TypeVariableDefinition.AbstractBase<W> implements Annotatable<W> {
                        public TypeVariableDefinition.Annotatable<W> annotateTypeVariable(Annotation... annotation) {
                            return annotateTypeVariable(Arrays.asList(annotation));
                        }
                        public TypeVariableDefinition.Annotatable<W> annotateTypeVariable(List<? extends Annotation> annotations) {
                            return annotateTypeVariable(new AnnotationList.ForLoadedAnnotations(annotations));
                        }
                        public TypeVariableDefinition.Annotatable<W> annotateTypeVariable(AnnotationDescription... annotation) {
                            return annotateTypeVariable(Arrays.asList(annotation));
                        }
                        protected abstract static class Adapter<X> extends TypeVariableDefinition.Annotatable.AbstractBase<X> {
                            public TypeVariableDefinition.Annotatable<X> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
                                return materialize().typeVariable(symbol, bounds);
                            }
                            public MethodDefinition.ReceiverTypeDefinition<X> intercept(Implementation implementation) {
                                return materialize().intercept(implementation);
                            }
                            public MethodDefinition.ReceiverTypeDefinition<X> withoutCode() {
                                return materialize().withoutCode();
                            }
                            public MethodDefinition.ReceiverTypeDefinition<X> defaultValue(AnnotationValue<?, ?> annotationValue) {
                                return materialize().defaultValue(annotationValue);
                            }
                            public <V> MethodDefinition.ReceiverTypeDefinition<X> defaultValue(V value, Class<? extends V> type) {
                                return materialize().defaultValue(value, type);
                            }
                            protected abstract MethodDefinition.ParameterDefinition<X> materialize();
                        }
                    }
                }
                abstract class AbstractBase<V> extends ImplementationDefinition.AbstractBase<V> implements TypeVariableDefinition<V> {
                    public Annotatable<V> typeVariable(String symbol) {
                        return typeVariable(symbol, Collections.singletonList(Object.class));
                    }
                    public Annotatable<V> typeVariable(String symbol, Type... bound) {
                        return typeVariable(symbol, Arrays.asList(bound));
                    }
                    public Annotatable<V> typeVariable(String symbol, List<? extends Type> bounds) {
                        return typeVariable(symbol, new TypeList.Generic.ForLoadedTypes(bounds));
                    }
                    public Annotatable<V> typeVariable(String symbol, TypeDefinition... bound) {
                        return typeVariable(symbol, Arrays.asList(bound));
                    }
                }
            }
            interface ExceptionDefinition<U> extends TypeVariableDefinition<U> {
                ExceptionDefinition<U> throwing(Type... type);
                ExceptionDefinition<U> throwing(List<? extends Type> types);
                ExceptionDefinition<U> throwing(TypeDefinition... type);
                ExceptionDefinition<U> throwing(Collection<? extends TypeDefinition> types);
                abstract class AbstractBase<V> extends TypeVariableDefinition.AbstractBase<V> implements ExceptionDefinition<V> {
                    public ExceptionDefinition<V> throwing(Type... type) {
                        return throwing(Arrays.asList(type));
                    }
                    public ExceptionDefinition<V> throwing(List<? extends Type> types) {
                        return throwing(new TypeList.Generic.ForLoadedTypes(types));
                    }
                    public ExceptionDefinition<V> throwing(TypeDefinition... type) {
                        return throwing(Arrays.asList(type));
                    }
                }
            }
            interface ParameterDefinition<U> extends ExceptionDefinition<U> {
                Annotatable<U> withParameter(Type type, String name, ModifierContributor.ForParameter... modifierContributor);
                Annotatable<U> withParameter(Type type, String name, Collection<? extends ModifierContributor.ForParameter> modifierContributors);
                Annotatable<U> withParameter(Type type, String name, int modifiers);
                Annotatable<U> withParameter(TypeDefinition type, String name, ModifierContributor.ForParameter... modifierContributor);
                Annotatable<U> withParameter(TypeDefinition type, String name, Collection<? extends ModifierContributor.ForParameter> modifierContributors);
                Annotatable<U> withParameter(TypeDefinition type, String name, int modifiers);
                interface Annotatable<V> extends ParameterDefinition<V> {
                    Annotatable<V> annotateParameter(Annotation... annotation);
                    Annotatable<V> annotateParameter(List<? extends Annotation> annotations);
                    Annotatable<V> annotateParameter(AnnotationDescription... annotation);
                    Annotatable<V> annotateParameter(Collection<? extends AnnotationDescription> annotations);
                    abstract class AbstractBase<W> extends ParameterDefinition.AbstractBase<W> implements Annotatable<W> {
                        public ParameterDefinition.Annotatable<W> annotateParameter(Annotation... annotation) {
                            return annotateParameter(Arrays.asList(annotation));
                        }
                        public ParameterDefinition.Annotatable<W> annotateParameter(List<? extends Annotation> annotations) {
                            return annotateParameter(new AnnotationList.ForLoadedAnnotations(annotations));
                        }
                        public ParameterDefinition.Annotatable<W> annotateParameter(AnnotationDescription... annotation) {
                            return annotateParameter(Arrays.asList(annotation));
                        }
                        protected abstract static class Adapter<X> extends ParameterDefinition.Annotatable.AbstractBase<X> {
                            public ParameterDefinition.Annotatable<X> withParameter(TypeDefinition type, String name, int modifiers) {
                                return materialize().withParameter(type, name, modifiers);
                            }
                            public ExceptionDefinition<X> throwing(Collection<? extends TypeDefinition> types) {
                                return materialize().throwing(types);
                            }
                            public TypeVariableDefinition.Annotatable<X> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
                                return materialize().typeVariable(symbol, bounds);
                            }
                            public MethodDefinition.ReceiverTypeDefinition<X> intercept(Implementation implementation) {
                                return materialize().intercept(implementation);
                            }
                            public MethodDefinition.ReceiverTypeDefinition<X> withoutCode() {
                                return materialize().withoutCode();
                            }
                            public MethodDefinition.ReceiverTypeDefinition<X> defaultValue(AnnotationValue<?, ?> annotationValue) {
                                return materialize().defaultValue(annotationValue);
                            }
                            public <V> MethodDefinition.ReceiverTypeDefinition<X> defaultValue(V value, Class<? extends V> type) {
                                return materialize().defaultValue(value, type);
                            }
                            protected abstract MethodDefinition.ParameterDefinition<X> materialize();
                        }
                    }
                }
                interface Simple<V> extends ExceptionDefinition<V> {
                    Annotatable<V> withParameter(Type type);
                    Annotatable<V> withParameter(TypeDefinition type);
                    interface Annotatable<V> extends Simple<V> {
                        Annotatable<V> annotateParameter(Annotation... annotation);
                        Annotatable<V> annotateParameter(List<? extends Annotation> annotations);
                        Annotatable<V> annotateParameter(AnnotationDescription... annotation);
                        Annotatable<V> annotateParameter(Collection<? extends AnnotationDescription> annotations);
                        abstract class AbstractBase<W> extends Simple.AbstractBase<W> implements Annotatable<W> {
                            public Simple.Annotatable<W> annotateParameter(Annotation... annotation) {
                                return annotateParameter(Arrays.asList(annotation));
                            }
                            public Simple.Annotatable<W> annotateParameter(List<? extends Annotation> annotations) {
                                return annotateParameter(new AnnotationList.ForLoadedAnnotations(annotations));
                            }
                            public Simple.Annotatable<W> annotateParameter(AnnotationDescription... annotation) {
                                return annotateParameter(Arrays.asList(annotation));
                            }
                            protected abstract static class Adapter<X> extends Simple.Annotatable.AbstractBase<X> {
                                public Simple.Annotatable<X> withParameter(TypeDefinition type) {
                                    return materialize().withParameter(type);
                                }
                                public ExceptionDefinition<X> throwing(Collection<? extends TypeDefinition> types) {
                                    return materialize().throwing(types);
                                }
                                public TypeVariableDefinition.Annotatable<X> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
                                    return materialize().typeVariable(symbol, bounds);
                                }
                                public MethodDefinition.ReceiverTypeDefinition<X> intercept(Implementation implementation) {
                                    return materialize().intercept(implementation);
                                }
                                public MethodDefinition.ReceiverTypeDefinition<X> withoutCode() {
                                    return materialize().withoutCode();
                                }
                                public MethodDefinition.ReceiverTypeDefinition<X> defaultValue(AnnotationValue<?, ?> annotationValue) {
                                    return materialize().defaultValue(annotationValue);
                                }
                                public <V> MethodDefinition.ReceiverTypeDefinition<X> defaultValue(V value, Class<? extends V> type) {
                                    return materialize().defaultValue(value, type);
                                }
                                protected abstract MethodDefinition.ParameterDefinition.Simple<X> materialize();
                            }
                        }
                    }
                    abstract class AbstractBase<W> extends ExceptionDefinition.AbstractBase<W> implements Simple<W> {
                        public Simple.Annotatable<W> withParameter(Type type) {
                            return withParameter(TypeDefinition.Sort.describe(type));
                        }
                    }
                }
                interface Initial<V> extends ParameterDefinition<V>, Simple<V> {
                    ExceptionDefinition<V> withParameters(Type... type);
                    ExceptionDefinition<V> withParameters(List<? extends Type> types);
                    ExceptionDefinition<V> withParameters(TypeDefinition... type);
                    ExceptionDefinition<V> withParameters(Collection<? extends TypeDefinition> types);
                    abstract class AbstractBase<W> extends ParameterDefinition.AbstractBase<W> implements Initial<W> {
                        public Simple.Annotatable<W> withParameter(Type type) {
                            return withParameter(TypeDefinition.Sort.describe(type));
                        }
                        public ExceptionDefinition<W> withParameters(Type... type) {
                            return withParameters(Arrays.asList(type));
                        }
                        public ExceptionDefinition<W> withParameters(List<? extends Type> types) {
                            return withParameters(new TypeList.Generic.ForLoadedTypes(types));
                        }
                        public ExceptionDefinition<W> withParameters(TypeDefinition... type) {
                            return withParameters(Arrays.asList(type));
                        }
                        public ExceptionDefinition<W> withParameters(Collection<? extends TypeDefinition> types) {
                            ParameterDefinition.Simple<W> parameterDefinition = this;
                            for (TypeDefinition type : types) {
                                parameterDefinition = parameterDefinition.withParameter(type);
                            }
                            return parameterDefinition;
                        }
                    }
                }
                abstract class AbstractBase<V> extends ExceptionDefinition.AbstractBase<V> implements ParameterDefinition<V> {
                    public ParameterDefinition.Annotatable<V> withParameter(Type type, String name, ModifierContributor.ForParameter... modifierContributor) {
                        return withParameter(type, name, Arrays.asList(modifierContributor));
                    }
                    public ParameterDefinition.Annotatable<V> withParameter(Type type, String name, Collection<? extends ModifierContributor.ForParameter> modifierContributors) {
                        return withParameter(type, name, ModifierContributor.Resolver.of(modifierContributors).resolve());
                    }
                    public ParameterDefinition.Annotatable<V> withParameter(Type type, String name, int modifiers) {
                        return withParameter(TypeDefinition.Sort.describe(type), name, modifiers);
                    }
                    public ParameterDefinition.Annotatable<V> withParameter(TypeDefinition type, String name, ModifierContributor.ForParameter... modifierContributor) {
                        return withParameter(type, name, Arrays.asList(modifierContributor));
                    }
                    public ParameterDefinition.Annotatable<V> withParameter(TypeDefinition type, String name, Collection<? extends ModifierContributor.ForParameter> modifierContributors) {
                        return withParameter(type, name, ModifierContributor.Resolver.of(modifierContributors).resolve());
                    }
                }
            }
            abstract class AbstractBase<U> extends Builder.AbstractBase.Delegator<U> implements MethodDefinition<U> {
                public MethodDefinition<U> annotateMethod(Annotation... annotation) {
                    return annotateMethod(Arrays.asList(annotation));
                }
                public MethodDefinition<U> annotateMethod(List<? extends Annotation> annotations) {
                    return annotateMethod(new AnnotationList.ForLoadedAnnotations(annotations));
                }
                public MethodDefinition<U> annotateMethod(AnnotationDescription... annotation) {
                    return annotateMethod(Arrays.asList(annotation));
                }
                public MethodDefinition<U> annotateParameter(int index, Annotation... annotation) {
                    return annotateParameter(index, Arrays.asList(annotation));
                }
                public MethodDefinition<U> annotateParameter(int index, List<? extends Annotation> annotations) {
                    return annotateParameter(index, new AnnotationList.ForLoadedAnnotations(annotations));
                }
                public MethodDefinition<U> annotateParameter(int index, AnnotationDescription... annotation) {
                    return annotateParameter(index, Arrays.asList(annotation));
                }
                protected abstract static class Adapter<V> extends MethodDefinition.ReceiverTypeDefinition.AbstractBase<V> {
                    protected final MethodRegistry.Handler handler;
                    protected final MethodAttributeAppender.Factory methodAttributeAppenderFactory;
                    protected final Transformer<MethodDescription> transformer;
                    protected Adapter(MethodRegistry.Handler handler, MethodAttributeAppender.Factory methodAttributeAppenderFactory, Transformer<MethodDescription> transformer) {
                        this.handler = handler;
                        this.methodAttributeAppenderFactory = methodAttributeAppenderFactory;
                        this.transformer = transformer;
                    }
                    public MethodDefinition<V> attribute(MethodAttributeAppender.Factory methodAttributeAppenderFactory) {
                        return materialize(handler, new MethodAttributeAppender.Factory.Compound(this.methodAttributeAppenderFactory, methodAttributeAppenderFactory), transformer);
                    }
                    public MethodDefinition<V> transform(Transformer<MethodDescription> transformer) {
                        return materialize(handler, methodAttributeAppenderFactory, new Transformer.Compound<MethodDescription>(this.transformer, transformer));
                    }
                    protected abstract MethodDefinition<V> materialize(MethodRegistry.Handler handler, MethodAttributeAppender.Factory methodAttributeAppenderFactory, Transformer<MethodDescription> transformer);
                }
            }
        }
        interface RecordComponentDefinition<S> {
            Optional<S> annotateRecordComponent(Annotation... annotation);
            Optional<S> annotateRecordComponent(List<? extends Annotation> annotations);
            Optional<S> annotateRecordComponent(AnnotationDescription... annotation);
            Optional<S> annotateRecordComponent(Collection<? extends AnnotationDescription> annotations);
            Optional<S> attribute(RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory);
            Optional<S> transform(Transformer<RecordComponentDescription> transformer);
            interface Optional<U> extends RecordComponentDefinition<U>, Builder<U> {
                abstract class AbstractBase<U> extends Builder.AbstractBase.Delegator<U> implements RecordComponentDefinition.Optional<U> {
                    public Optional<U> annotateRecordComponent(Annotation... annotation) {
                        return annotateRecordComponent(Arrays.asList(annotation));
                    }
                    public Optional<U> annotateRecordComponent(List<? extends Annotation> annotations) {
                        return annotateRecordComponent(new AnnotationList.ForLoadedAnnotations(annotations));
                    }
                    public Optional<U> annotateRecordComponent(AnnotationDescription... annotation) {
                        return annotateRecordComponent(Arrays.asList(annotation));
                    }
                }
            }
        }
        abstract class AbstractBase<S> implements Builder<S> {
            public ModuleDefinition<S> module(String name, ModifierContributor.ForModule... modifierContributors) {
                return module(name, Arrays.asList(modifierContributors));
            }
            public ModuleDefinition<S> module(String name, Collection<? extends ModifierContributor.ForModule> modifierContributors) {
                return module(name, ModifierContributor.Resolver.of(modifierContributors).resolve());
            }
            public ModuleDefinition<S> adjustModule(ModifierContributor.ForModule... modifierContributor) {
                return adjustModule(Arrays.asList(modifierContributor));
            }
            public InnerTypeDefinition.ForType<S> innerTypeOf(Class<?> type) {
                return innerTypeOf(TypeDescription.ForLoadedType.of(type));
            }
            public InnerTypeDefinition<S> innerTypeOf(Method method) {
                return innerTypeOf(new MethodDescription.ForLoadedMethod(method));
            }
            public InnerTypeDefinition<S> innerTypeOf(Constructor<?> constructor) {
                return innerTypeOf(new MethodDescription.ForLoadedConstructor(constructor));
            }
            public Builder<S> declaredTypes(Class<?>... type) {
                return declaredTypes(Arrays.asList(type));
            }
            public Builder<S> declaredTypes(TypeDescription... type) {
                return declaredTypes(Arrays.asList(type));
            }
            public Builder<S> declaredTypes(List<? extends Class<?>> type) {
                return declaredTypes(new TypeList.ForLoadedTypes(type));
            }
            public Builder<S> noNestMate() {
                return nestHost(TargetType.DESCRIPTION);
            }
            public Builder<S> nestHost(Class<?> type) {
                return nestHost(TypeDescription.ForLoadedType.of(type));
            }
            public Builder<S> nestMembers(Class<?>... type) {
                return nestMembers(Arrays.asList(type));
            }
            public Builder<S> nestMembers(TypeDescription... type) {
                return nestMembers(Arrays.asList(type));
            }
            public Builder<S> nestMembers(List<? extends Class<?>> types) {
                return nestMembers(new TypeList.ForLoadedTypes(types));
            }
            public Builder<S> permittedSubclass(Class<?>... type) {
                return permittedSubclass(Arrays.asList(type));
            }
            public Builder<S> permittedSubclass(TypeDescription... type) {
                return permittedSubclass(Arrays.asList(type));
            }
            public Builder<S> permittedSubclass(List<? extends Class<?>> types) {
                return permittedSubclass(new TypeList.ForLoadedTypes(types));
            }
            public Builder<S> annotateType(Annotation... annotation) {
                return annotateType(Arrays.asList(annotation));
            }
            public Builder<S> annotateType(List<? extends Annotation> annotations) {
                return annotateType(new AnnotationList.ForLoadedAnnotations(annotations));
            }
            public Builder<S> annotateType(AnnotationDescription... annotation) {
                return annotateType(Arrays.asList(annotation));
            }
            public Builder<S> modifiers(ModifierContributor.ForType... modifierContributor) {
                return modifiers(Arrays.asList(modifierContributor));
            }
            public Builder<S> modifiers(Collection<? extends ModifierContributor.ForType> modifierContributors) {
                return modifiers(ModifierContributor.Resolver.of(modifierContributors).resolve());
            }
            public Builder<S> merge(ModifierContributor.ForType... modifierContributor) {
                return merge(Arrays.asList(modifierContributor));
            }
            public MethodDefinition.ImplementationDefinition.Optional<S> implement(Type... interfaceType) {
                return implement(Arrays.asList(interfaceType));
            }
            public MethodDefinition.ImplementationDefinition.Optional<S> implement(List<? extends Type> interfaceTypes) {
                return implement(new TypeList.Generic.ForLoadedTypes(interfaceTypes));
            }
            public MethodDefinition.ImplementationDefinition.Optional<S> implement(TypeDefinition... interfaceType) {
                return implement(Arrays.asList(interfaceType));
            }
            public TypeVariableDefinition<S> typeVariable(String symbol) {
                return typeVariable(symbol, TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class));
            }
            public TypeVariableDefinition<S> typeVariable(String symbol, Type... bound) {
                return typeVariable(symbol, Arrays.asList(bound));
            }
            public TypeVariableDefinition<S> typeVariable(String symbol, List<? extends Type> bounds) {
                return typeVariable(symbol, new TypeList.Generic.ForLoadedTypes(bounds));
            }
            public TypeVariableDefinition<S> typeVariable(String symbol, TypeDefinition... bound) {
                return typeVariable(symbol, Arrays.asList(bound));
            }
            public RecordComponentDefinition.Optional<S> defineRecordComponent(String name, Type type) {
                return defineRecordComponent(name, TypeDefinition.Sort.describe(type));
            }
            public RecordComponentDefinition.Optional<S> define(RecordComponentDescription recordComponentDescription) {
                return defineRecordComponent(recordComponentDescription.getActualName(), recordComponentDescription.getType());
            }
            public RecordComponentDefinition<S> recordComponent(ElementMatcher<? super RecordComponentDescription> matcher) {
                return recordComponent(new LatentMatcher.Resolved<RecordComponentDescription>(matcher));
            }
            public FieldDefinition.Optional.Valuable<S> defineField(String name, Type type, ModifierContributor.ForField... modifierContributor) {
                return defineField(name, type, Arrays.asList(modifierContributor));
            }
            public FieldDefinition.Optional.Valuable<S> defineField(String name, Type type, Collection<? extends ModifierContributor.ForField> modifierContributors) {
                return defineField(name, type, ModifierContributor.Resolver.of(modifierContributors).resolve());
            }
            public FieldDefinition.Optional.Valuable<S> defineField(String name, Type type, int modifiers) {
                return defineField(name, TypeDefinition.Sort.describe(type), modifiers);
            }
            public FieldDefinition.Optional.Valuable<S> defineField(String name, TypeDefinition type, ModifierContributor.ForField... modifierContributor) {
                return defineField(name, type, Arrays.asList(modifierContributor));
            }
            public FieldDefinition.Optional.Valuable<S> defineField(String name, TypeDefinition type, Collection<? extends ModifierContributor.ForField> modifierContributors) {
                return defineField(name, type, ModifierContributor.Resolver.of(modifierContributors).resolve());
            }
            public FieldDefinition.Optional.Valuable<S> define(Field field) {
                return define(new FieldDescription.ForLoadedField(field));
            }
            public FieldDefinition.Optional.Valuable<S> define(FieldDescription field) {
                return defineField(field.getName(), field.getType(), field.getModifiers());
            }
            public FieldDefinition.Optional<S> serialVersionUid(long serialVersionUid) {
                return defineField("serialVersionUID", long.class, Visibility.PRIVATE, FieldManifestation.FINAL, Ownership.STATIC).value(serialVersionUid);
            }
            public FieldDefinition.Valuable<S> field(ElementMatcher<? super FieldDescription> matcher) {
                return field(new LatentMatcher.Resolved<FieldDescription>(matcher));
            }
            public Builder<S> ignoreAlso(ElementMatcher<? super MethodDescription> ignoredMethods) {
                return ignoreAlso(new LatentMatcher.Resolved<MethodDescription>(ignoredMethods));
            }
            public MethodDefinition.ParameterDefinition.Initial<S> defineMethod(String name, Type returnType, ModifierContributor.ForMethod... modifierContributor) {
                return defineMethod(name, returnType, Arrays.asList(modifierContributor));
            }
            public MethodDefinition.ParameterDefinition.Initial<S> defineMethod(String name, Type returnType, Collection<? extends ModifierContributor.ForMethod> modifierContributors) {
                return defineMethod(name, returnType, ModifierContributor.Resolver.of(modifierContributors).resolve());
            }
            public MethodDefinition.ParameterDefinition.Initial<S> defineMethod(String name, Type returnType, int modifiers) {
                return defineMethod(name, TypeDefinition.Sort.describe(returnType), modifiers);
            }
            public MethodDefinition.ParameterDefinition.Initial<S> defineMethod(String name, TypeDefinition returnType, ModifierContributor.ForMethod... modifierContributor) {
                return defineMethod(name, returnType, Arrays.asList(modifierContributor));
            }
            public MethodDefinition.ParameterDefinition.Initial<S> defineMethod(String name, TypeDefinition returnType, Collection<? extends ModifierContributor.ForMethod> modifierContributors) {
                return defineMethod(name, returnType, ModifierContributor.Resolver.of(modifierContributors).resolve());
            }
            public MethodDefinition.ParameterDefinition.Initial<S> defineConstructor(ModifierContributor.ForMethod... modifierContributor) {
                return defineConstructor(Arrays.asList(modifierContributor));
            }
            public MethodDefinition.ParameterDefinition.Initial<S> defineConstructor(Collection<? extends ModifierContributor.ForMethod> modifierContributors) {
                return defineConstructor(ModifierContributor.Resolver.of(modifierContributors).resolve());
            }
            public MethodDefinition.ImplementationDefinition<S> define(Method method) {
                return define(new MethodDescription.ForLoadedMethod(method));
            }
            public MethodDefinition.ImplementationDefinition<S> define(Constructor<?> constructor) {
                return define(new MethodDescription.ForLoadedConstructor(constructor));
            }
            public MethodDefinition.ImplementationDefinition<S> define(MethodDescription methodDescription) {
                MethodDefinition.ParameterDefinition.Initial<S> initialParameterDefinition = methodDescription.isConstructor() ? defineConstructor(methodDescription.getModifiers()) : defineMethod(methodDescription.getInternalName(), methodDescription.getReturnType(), methodDescription.getModifiers());
                ParameterList<?> parameterList = methodDescription.getParameters();
                MethodDefinition.ExceptionDefinition<S> exceptionDefinition;
                if (parameterList.hasExplicitMetaData()) {
                    MethodDefinition.ParameterDefinition<S> parameterDefinition = initialParameterDefinition;
                    for (ParameterDescription parameter : parameterList) {
                        parameterDefinition = parameterDefinition.withParameter(parameter.getType(), parameter.getName(), parameter.getModifiers());
                    }
                    exceptionDefinition = parameterDefinition;
                } else {
                    exceptionDefinition = initialParameterDefinition.withParameters(parameterList.asTypeList());
                }
                MethodDefinition.TypeVariableDefinition<S> typeVariableDefinition = exceptionDefinition.throwing(methodDescription.getExceptionTypes());
                for (TypeDescription.Generic typeVariable : methodDescription.getTypeVariables()) {
                    typeVariableDefinition = typeVariableDefinition.typeVariable(typeVariable.getSymbol(), typeVariable.getUpperBounds());
                }
                return typeVariableDefinition;
            }
            public FieldDefinition.Optional<S> defineProperty(String name, Type type) {
                return defineProperty(name, TypeDefinition.Sort.describe(type));
            }
            public FieldDefinition.Optional<S> defineProperty(String name, Type type, boolean readOnly) {
                return defineProperty(name, TypeDefinition.Sort.describe(type), readOnly);
            }
            public FieldDefinition.Optional<S> defineProperty(String name, TypeDefinition type) {
                return defineProperty(name, type, false);
            }
            public FieldDefinition.Optional<S> defineProperty(String name, TypeDefinition type, boolean readOnly) {
                if (name.length() == 0) {
                    throw new IllegalArgumentException("A bean property cannot have an empty name");
                } else if (type.represents(void.class)) {
                    throw new IllegalArgumentException("A bean property cannot have a void type");
                }
                DynamicType.Builder<S> builder = this;
                FieldManifestation fieldManifestation;
                if (!readOnly) {
                    builder = builder.defineMethod("set" + Character.toUpperCase(name.charAt(0)) + name.substring(1), void.class, Visibility.PUBLIC).withParameters(type).intercept(FieldAccessor.ofField(name));
                    fieldManifestation = FieldManifestation.PLAIN;
                } else {
                    fieldManifestation = FieldManifestation.FINAL;
                }
                return builder.defineMethod((type.represents(boolean.class) ? "is" : "get") + Character.toUpperCase(name.charAt(0)) + name.substring(1), type, Visibility.PUBLIC).intercept(FieldAccessor.ofField(name)).defineField(name, type, Visibility.PRIVATE, fieldManifestation);
            }
            public MethodDefinition.ImplementationDefinition<S> method(ElementMatcher<? super MethodDescription> matcher) {
                return invokable(isMethod().and(matcher));
            }
            public MethodDefinition.ImplementationDefinition<S> constructor(ElementMatcher<? super MethodDescription> matcher) {
                return invokable(isConstructor().and(matcher));
            }
            public MethodDefinition.ImplementationDefinition<S> invokable(ElementMatcher<? super MethodDescription> matcher) {
                return invokable(new LatentMatcher.Resolved<MethodDescription>(matcher));
            }
            public Builder<S> withHashCodeEquals() {
                return method(isHashCode()).intercept(HashCodeMethod.usingDefaultOffset().withIgnoredFields(isSynthetic())).method(isEquals()).intercept(EqualsMethod.isolated().withIgnoredFields(isSynthetic()));
            }
            public Builder<S> withToString() {
                return method(isToString()).intercept(ToStringMethod.prefixedBySimpleClassName());
            }
            public Builder<S> require(TypeDescription type, byte[] binaryRepresentation) {
                return require(type, binaryRepresentation, LoadedTypeInitializer.NoOp.INSTANCE);
            }
            public Builder<S> require(TypeDescription type, byte[] binaryRepresentation, LoadedTypeInitializer typeInitializer) {
                return require(new Default(type, binaryRepresentation, typeInitializer, Collections.<DynamicType>emptyList()));
            }
            public Builder<S> require(DynamicType... auxiliaryType) {
                return require(Arrays.asList(auxiliaryType));
            }
            public ContextClassVisitor wrap(ClassVisitor classVisitor) {
                return wrap(classVisitor, AsmVisitorWrapper.NO_FLAGS, AsmVisitorWrapper.NO_FLAGS);
            }
            public ContextClassVisitor wrap(ClassVisitor classVisitor, TypePool typePool) {
                return wrap(classVisitor, typePool, AsmVisitorWrapper.NO_FLAGS, AsmVisitorWrapper.NO_FLAGS);
            }
            public Unloaded<S> make(TypePool typePool) {
                return make(TypeResolutionStrategy.Passive.INSTANCE, typePool);
            }
            public Unloaded<S> make() {
                return make(TypeResolutionStrategy.Passive.INSTANCE);
            }
            public abstract static class Delegator<U> extends AbstractBase<U> {
                public ModuleDefinition<U> module(String name, int modifiers) {
                    return materialize().module(name, modifiers);
                }
                public ModuleDefinition<U> adjustModule(ModifierContributor.ForModule... modifierContributor) {
                    return materialize().adjustModule(modifierContributor);
                }
                public ModuleDefinition<U> adjustModule(Collection<? extends ModifierContributor.ForModule> modifierContributors) {
                    return materialize().adjustModule(modifierContributors);
                }
                public Builder<U> visit(AsmVisitorWrapper asmVisitorWrapper) {
                    return materialize().visit(asmVisitorWrapper);
                }
                public Builder<U> initializer(LoadedTypeInitializer loadedTypeInitializer) {
                    return materialize().initializer(loadedTypeInitializer);
                }
                public Builder<U> annotateType(Collection<? extends AnnotationDescription> annotations) {
                    return materialize().annotateType(annotations);
                }
                public Builder<U> attribute(TypeAttributeAppender typeAttributeAppender) {
                    return materialize().attribute(typeAttributeAppender);
                }
                public Builder<U> modifiers(int modifiers) {
                    return materialize().modifiers(modifiers);
                }
                public Builder<U> merge(Collection<? extends ModifierContributor.ForType> modifierContributors) {
                    return materialize().merge(modifierContributors);
                }
                public Builder<U> suffix(String suffix) {
                    return materialize().suffix(suffix);
                }
                public Builder<U> name(String name) {
                    return materialize().name(name);
                }
                public Builder<U> topLevelType() {
                    return materialize().topLevelType();
                }
                public InnerTypeDefinition.ForType<U> innerTypeOf(TypeDescription type) {
                    return materialize().innerTypeOf(type);
                }
                public InnerTypeDefinition<U> innerTypeOf(MethodDescription.InDefinedShape methodDescription) {
                    return materialize().innerTypeOf(methodDescription);
                }
                public Builder<U> declaredTypes(Collection<? extends TypeDescription> types) {
                    return materialize().declaredTypes(types);
                }
                public Builder<U> nestHost(TypeDescription type) {
                    return materialize().nestHost(type);
                }
                public Builder<U> nestMembers(Collection<? extends TypeDescription> types) {
                    return materialize().nestMembers(types);
                }
                public Builder<U> permittedSubclass(Collection<? extends TypeDescription> types) {
                    return materialize().permittedSubclass(types);
                }
                public Builder<U> unsealed() {
                    return materialize().unsealed();
                }
                public MethodDefinition.ImplementationDefinition.Optional<U> implement(Collection<? extends TypeDefinition> interfaceTypes) {
                    return materialize().implement(interfaceTypes);
                }
                public Builder<U> initializer(ByteCodeAppender byteCodeAppender) {
                    return materialize().initializer(byteCodeAppender);
                }
                public Builder<U> ignoreAlso(ElementMatcher<? super MethodDescription> ignoredMethods) {
                    return materialize().ignoreAlso(ignoredMethods);
                }
                public Builder<U> ignoreAlso(LatentMatcher<? super MethodDescription> ignoredMethods) {
                    return materialize().ignoreAlso(ignoredMethods);
                }
                public TypeVariableDefinition<U> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
                    return materialize().typeVariable(symbol, bounds);
                }
                public Builder<U> transform(ElementMatcher<? super TypeDescription.Generic> matcher, Transformer<TypeVariableToken> transformer) {
                    return materialize().transform(matcher, transformer);
                }
                public FieldDefinition.Optional.Valuable<U> defineField(String name, TypeDefinition type, int modifiers) {
                    return materialize().defineField(name, type, modifiers);
                }
                public FieldDefinition.Valuable<U> field(LatentMatcher<? super FieldDescription> matcher) {
                    return materialize().field(matcher);
                }
                public MethodDefinition.ParameterDefinition.Initial<U> defineMethod(String name, TypeDefinition returnType, int modifiers) {
                    return materialize().defineMethod(name, returnType, modifiers);
                }
                public MethodDefinition.ParameterDefinition.Initial<U> defineConstructor(int modifiers) {
                    return materialize().defineConstructor(modifiers);
                }
                public MethodDefinition.ImplementationDefinition<U> invokable(LatentMatcher<? super MethodDescription> matcher) {
                    return materialize().invokable(matcher);
                }
                public Builder<U> require(Collection<DynamicType> auxiliaryTypes) {
                    return materialize().require(auxiliaryTypes);
                }
                public RecordComponentDefinition.Optional<U> defineRecordComponent(String name, TypeDefinition type) {
                    return materialize().defineRecordComponent(name, type);
                }
                public RecordComponentDefinition.Optional<U> define(RecordComponentDescription recordComponentDescription) {
                    return materialize().define(recordComponentDescription);
                }
                public RecordComponentDefinition<U> recordComponent(ElementMatcher<? super RecordComponentDescription> matcher) {
                    return materialize().recordComponent(matcher);
                }
                public RecordComponentDefinition<U> recordComponent(LatentMatcher<? super RecordComponentDescription> matcher) {
                    return materialize().recordComponent(matcher);
                }
                public ContextClassVisitor wrap(ClassVisitor classVisitor, int writerFlags, int readerFlags) {
                    return materialize().wrap(classVisitor, writerFlags, readerFlags);
                }
                public ContextClassVisitor wrap(ClassVisitor classVisitor, TypePool typePool, int writerFlags, int readerFlags) {
                    return materialize().wrap(classVisitor, typePool, writerFlags, readerFlags);
                }
                public DynamicType.Unloaded<U> make() {
                    return materialize().make();
                }
                public Unloaded<U> make(TypeResolutionStrategy typeResolutionStrategy) {
                    return materialize().make(typeResolutionStrategy);
                }
                public Unloaded<U> make(TypePool typePool) {
                    return materialize().make(typePool);
                }
                public Unloaded<U> make(TypeResolutionStrategy typeResolutionStrategy, TypePool typePool) {
                    return materialize().make(typeResolutionStrategy, typePool);
                }
                public TypeDescription toTypeDescription() {
                    return materialize().toTypeDescription();
                }
                protected abstract Builder<U> materialize();
            }
            public abstract static class UsingTypeWriter<U> extends AbstractBase<U> {
                public ContextClassVisitor wrap(ClassVisitor classVisitor, int writerFlags, int readerFlags) {
                    return toTypeWriter().wrap(classVisitor, writerFlags, readerFlags);
                }
                public ContextClassVisitor wrap(ClassVisitor classVisitor, TypePool typePool, int writerFlags, int readerFlags) {
                    return toTypeWriter(typePool).wrap(classVisitor, writerFlags, readerFlags);
                }
                public DynamicType.Unloaded<U> make(TypeResolutionStrategy typeResolutionStrategy) {
                    return toTypeWriter().make(typeResolutionStrategy.resolve());
                }
                public DynamicType.Unloaded<U> make(TypeResolutionStrategy typeResolutionStrategy, TypePool typePool) {
                    return toTypeWriter(typePool).make(typeResolutionStrategy.resolve());
                }
                protected abstract TypeWriter<U> toTypeWriter();
                protected abstract TypeWriter<U> toTypeWriter(TypePool typePool);
            }
            public abstract static class Adapter<U> extends UsingTypeWriter<U> {
                protected final InstrumentedType.WithFlexibleName instrumentedType;
                protected final FieldRegistry fieldRegistry;
                protected final MethodRegistry methodRegistry;
                protected final RecordComponentRegistry recordComponentRegistry;
                protected final TypeAttributeAppender typeAttributeAppender;
                protected final AsmVisitorWrapper asmVisitorWrapper;
                protected final ClassFileVersion classFileVersion;
                protected final AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy;
                protected final AnnotationValueFilter.Factory annotationValueFilterFactory;
                protected final AnnotationRetention annotationRetention;
                protected final Implementation.Context.Factory implementationContextFactory;
                protected final MethodGraph.Compiler methodGraphCompiler;
                protected final TypeValidation typeValidation;
                protected final VisibilityBridgeStrategy visibilityBridgeStrategy;
                protected final AsmClassReader.Factory classReaderFactory;
                protected final AsmClassWriter.Factory classWriterFactory;
                protected final LatentMatcher<? super MethodDescription> ignoredMethods;
                protected final List<? extends DynamicType> auxiliaryTypes;
                protected Adapter(InstrumentedType.WithFlexibleName instrumentedType, FieldRegistry fieldRegistry, MethodRegistry methodRegistry, RecordComponentRegistry recordComponentRegistry, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, ClassFileVersion classFileVersion, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, Implementation.Context.Factory implementationContextFactory, MethodGraph.Compiler methodGraphCompiler, TypeValidation typeValidation, VisibilityBridgeStrategy visibilityBridgeStrategy, AsmClassReader.Factory classReaderFactory, AsmClassWriter.Factory classWriterFactory, LatentMatcher<? super MethodDescription> ignoredMethods, List<? extends DynamicType> auxiliaryTypes) {
                    this.instrumentedType = instrumentedType;
                    this.fieldRegistry = fieldRegistry;
                    this.methodRegistry = methodRegistry;
                    this.recordComponentRegistry = recordComponentRegistry;
                    this.typeAttributeAppender = typeAttributeAppender;
                    this.asmVisitorWrapper = asmVisitorWrapper;
                    this.classFileVersion = classFileVersion;
                    this.auxiliaryTypeNamingStrategy = auxiliaryTypeNamingStrategy;
                    this.annotationValueFilterFactory = annotationValueFilterFactory;
                    this.annotationRetention = annotationRetention;
                    this.implementationContextFactory = implementationContextFactory;
                    this.methodGraphCompiler = methodGraphCompiler;
                    this.typeValidation = typeValidation;
                    this.visibilityBridgeStrategy = visibilityBridgeStrategy;
                    this.classReaderFactory = classReaderFactory;
                    this.classWriterFactory = classWriterFactory;
                    this.ignoredMethods = ignoredMethods;
                    this.auxiliaryTypes = auxiliaryTypes;
                }
                public ModuleDefinition<U> module(String name, int modifiers) {
                    return new ModuleDefinitionAdapter(name, modifiers);
                }
                public ModuleDefinition<U> adjustModule(Collection<? extends ModifierContributor.ForModule> modifierContributors) {
                    ModuleDescription moduleDescription = instrumentedType.toModuleDescription();
                    if (moduleDescription == null) {
                        throw new IllegalStateException("Expected previous module description for " + instrumentedType);
                    }
                    return new ModuleDefinitionAdapter(moduleDescription.getActualName(), ModifierContributor.Resolver.of(modifierContributors).resolve(moduleDescription.getModifiers()), moduleDescription.getVersion(), moduleDescription.getMainClass(), moduleDescription.getPackages(), moduleDescription.getRequires(), moduleDescription.getExports(), moduleDescription.getOpens(), moduleDescription.getUses(), moduleDescription.getProvides());
                }
                public FieldDefinition.Optional.Valuable<U> defineField(String name, TypeDefinition type, int modifiers) {
                    return new FieldDefinitionAdapter(new FieldDescription.Token(name, modifiers, type.asGenericType()));
                }
                public FieldDefinition.Valuable<U> field(LatentMatcher<? super FieldDescription> matcher) {
                    return new FieldMatchAdapter(matcher);
                }
                public MethodDefinition.ParameterDefinition.Initial<U> defineMethod(String name, TypeDefinition returnType, int modifiers) {
                    return new MethodDefinitionAdapter(new MethodDescription.Token(name, modifiers, returnType.asGenericType()));
                }
                public MethodDefinition.ParameterDefinition.Initial<U> defineConstructor(int modifiers) {
                    return new MethodDefinitionAdapter(new MethodDescription.Token(modifiers));
                }
                public MethodDefinition.ImplementationDefinition<U> invokable(LatentMatcher<? super MethodDescription> matcher) {
                    return new MethodMatchAdapter(matcher);
                }
                public MethodDefinition.ImplementationDefinition.Optional<U> implement(Collection<? extends TypeDefinition> interfaceTypes) {
                    return new OptionalMethodMatchAdapter(new TypeList.Generic.Explicit(new ArrayList<TypeDefinition>(interfaceTypes)));
                }
                public Builder<U> ignoreAlso(LatentMatcher<? super MethodDescription> ignoredMethods) {
                    return materialize(instrumentedType, fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, new LatentMatcher.Disjunction<MethodDescription>(this.ignoredMethods, ignoredMethods), auxiliaryTypes);
                }
                public RecordComponentDefinition.Optional<U> defineRecordComponent(String name, TypeDefinition type) {
                    return new RecordComponentDefinitionAdapter(new RecordComponentDescription.Token(name, type.asGenericType()));
                }
                public RecordComponentDefinition<U> recordComponent(LatentMatcher<? super RecordComponentDescription> matcher) {
                    return new RecordComponentMatchAdapter(matcher);
                }
                public Builder<U> initializer(ByteCodeAppender byteCodeAppender) {
                    return materialize(instrumentedType.withInitializer(byteCodeAppender), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                }
                public Builder<U> initializer(LoadedTypeInitializer loadedTypeInitializer) {
                    return materialize(instrumentedType.withInitializer(loadedTypeInitializer), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                }
                public Builder<U> name(String name) {
                    return materialize(instrumentedType.withName(name), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                }
                public Builder<U> suffix(String suffix) {
                    return name(instrumentedType.getName() + "$" + suffix);
                }
                public Builder<U> modifiers(int modifiers) {
                    return materialize(instrumentedType.withModifiers(modifiers), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                }
                public Builder<U> merge(Collection<? extends ModifierContributor.ForType> modifierContributors) {
                    return materialize(instrumentedType.withModifiers(ModifierContributor.Resolver.of(modifierContributors).resolve(instrumentedType.getModifiers())), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                }
                public Builder<U> topLevelType() {
                    return Adapter.this.materialize(instrumentedType.withDeclaringType(TypeDescription.UNDEFINED).withEnclosingType(TypeDescription.UNDEFINED).withLocalClass(false), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                }
                public InnerTypeDefinition.ForType<U> innerTypeOf(TypeDescription type) {
                    return new InnerTypeDefinitionForTypeAdapter(type);
                }
                public InnerTypeDefinition<U> innerTypeOf(MethodDescription.InDefinedShape methodDescription) {
                    return methodDescription.isTypeInitializer() ? new InnerTypeDefinitionForTypeAdapter(methodDescription.getDeclaringType()) : new InnerTypeDefinitionForMethodAdapter(methodDescription);
                }
                public Builder<U> declaredTypes(Collection<? extends TypeDescription> types) {
                    return materialize(instrumentedType.withDeclaredTypes(new TypeList.Explicit(new ArrayList<TypeDescription>(types))), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                }
                public Builder<U> nestHost(TypeDescription type) {
                    return materialize(instrumentedType.withNestHost(type), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                }
                public Builder<U> nestMembers(Collection<? extends TypeDescription> types) {
                    return materialize(instrumentedType.withNestMembers(new TypeList.Explicit(new ArrayList<TypeDescription>(types))), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                }
                public Builder<U> permittedSubclass(Collection<? extends TypeDescription> types) {
                    return materialize(instrumentedType.withPermittedSubclasses(new TypeList.Explicit(new ArrayList<TypeDescription>(types))), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                }
                public Builder<U> unsealed() {
                    return materialize(instrumentedType.withPermittedSubclasses(TypeList.UNDEFINED), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                }
                public TypeVariableDefinition<U> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
                    return new TypeVariableDefinitionAdapter(new TypeVariableToken(symbol, new TypeList.Generic.Explicit(new ArrayList<TypeDefinition>(bounds))));
                }
                public Builder<U> transform(ElementMatcher<? super TypeDescription.Generic> matcher, Transformer<TypeVariableToken> transformer) {
                    return materialize(instrumentedType.withTypeVariables(matcher, transformer), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                }
                public Builder<U> attribute(TypeAttributeAppender typeAttributeAppender) {
                    return materialize(instrumentedType, fieldRegistry, methodRegistry, recordComponentRegistry, new TypeAttributeAppender.Compound(this.typeAttributeAppender, typeAttributeAppender), asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                }
                public Builder<U> annotateType(Collection<? extends AnnotationDescription> annotations) {
                    ModuleDescription moduleDescription = instrumentedType.toModuleDescription();
                    return materialize(instrumentedType.withAnnotations(new ArrayList<AnnotationDescription>(annotations)).withModuleDescription(moduleDescription == null ? ModuleDescription.UNDEFINED : new ModuleDescription.Latent(moduleDescription.getActualName(), moduleDescription.getModifiers(), moduleDescription.getVersion(), moduleDescription.getMainClass(), moduleDescription.getPackages(), moduleDescription.getRequires(), moduleDescription.getExports(), moduleDescription.getOpens(), moduleDescription.getUses(), moduleDescription.getProvides(), CompoundList.of(instrumentedType.getDeclaredAnnotations(), new ArrayList<AnnotationDescription>(annotations)))), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                }
                public Builder<U> visit(AsmVisitorWrapper asmVisitorWrapper) {
                    return materialize(instrumentedType, fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, new AsmVisitorWrapper.Compound(this.asmVisitorWrapper, asmVisitorWrapper), classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                }
                public Builder<U> require(Collection<DynamicType> auxiliaryTypes) {
                    return materialize(instrumentedType, fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, CompoundList.of(this.auxiliaryTypes, new ArrayList<DynamicType>(auxiliaryTypes)));
                }
                public TypeDescription toTypeDescription() {
                    return instrumentedType;
                }
                protected abstract Builder<U> materialize(InstrumentedType.WithFlexibleName instrumentedType, FieldRegistry fieldRegistry, MethodRegistry methodRegistry, RecordComponentRegistry recordComponentRegistry, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, ClassFileVersion classFileVersion, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, Implementation.Context.Factory implementationContextFactory, MethodGraph.Compiler methodGraphCompiler, TypeValidation typeValidation, VisibilityBridgeStrategy visibilityBridgeStrategy, AsmClassReader.Factory classReaderFactory, AsmClassWriter.Factory classWriterFactory, LatentMatcher<? super MethodDescription> ignoredMethods, List<? extends DynamicType> auxiliaryTypes);
                protected class ModuleDefinitionAdapter extends ModuleDefinition.AbstractBase<U> {
                    private final String name;
                    private final int modifiers;
                    private final String version;
                    private final String mainClass;
                    private final Set<String> packages;
                    private final Map<String, ModuleDescription.Requires> requires;
                    private final Map<String, ModuleDescription.Exports> exports;
                    private final Map<String, ModuleDescription.Opens> opens;
                    private final Set<String> uses;
                    private final Map<String, ModuleDescription.Provides> provides;
                    protected ModuleDefinitionAdapter(String name, int modifiers) {
                        this(name, modifiers, null, null, Collections.<String>emptySet(), "java.base".equals(name) ? Collections.<String, ModuleDescription.Requires>emptyMap() : Collections.<String, ModuleDescription.Requires>singletonMap("java.base", new ModuleDescription.Requires.Simple(null, Opcodes.ACC_MANDATED)), Collections.<String, ModuleDescription.Exports>emptyMap(), Collections.<String, ModuleDescription.Opens>emptyMap(), Collections.<String>emptySet(), Collections.<String, ModuleDescription.Provides>emptyMap());
                    }
                    protected ModuleDefinitionAdapter(String name, int modifiers, @MaybeNull String version, @MaybeNull String mainClass, Set<String> packages, Map<String, ModuleDescription.Requires> requires, Map<String, ModuleDescription.Exports> exports, Map<String, ModuleDescription.Opens> opens, Set<String> uses, Map<String, ModuleDescription.Provides> provides) {
                        this.name = name;
                        this.modifiers = modifiers;
                        this.version = version;
                        this.mainClass = mainClass;
                        this.packages = packages;
                        this.requires = requires;
                        this.exports = exports;
                        this.opens = opens;
                        this.uses = uses;
                        this.provides = provides;
                    }
                    public ModuleDefinition<U> version(@MaybeNull String version) {
                        return new ModuleDefinitionAdapter(name, modifiers, version, mainClass, packages, requires, exports, opens, uses, provides);
                    }
                    public ModuleDefinition<U> mainClass(@MaybeNull String name) {
                        return new ModuleDefinitionAdapter(this.name, modifiers, version, name, packages, requires, exports, opens, uses, provides);
                    }
                    public ModuleDefinition<U> packages(Collection<String> packages) {
                        Set<String> merged = new LinkedHashSet<String>(this.packages);
                        merged.addAll(packages);
                        return new ModuleDefinitionAdapter(name, modifiers, version, mainClass, merged, requires, exports, opens, uses, provides);
                    }
                    public RequiresDefinition<U> require(String module, int modifiers) {
                        return new RequiresDefinitionAdapter(module, modifiers);
                    }
                    public ExportsDefinition<U> export(String aPackage, int modifiers) {
                        return new ExportsDefinitionAdapter(aPackage, modifiers);
                    }
                    public OpensDefinition<U> open(String aPackage, int modifiers) {
                        return new OpensDefinitionAdapter(aPackage, modifiers);
                    }
                    public ModuleDefinition<U> uses(Collection<String> services) {
                        Set<String> uses = new LinkedHashSet<String>(this.uses);
                        uses.addAll(services);
                        return new ModuleDefinitionAdapter(name, modifiers, version, mainClass, packages, requires, exports, opens, uses, provides);
                    }
                    public ModuleDefinition<U> provides(String service, Collection<String> implementations) {
                        Map<String, ModuleDescription.Provides> provides = new LinkedHashMap<String, ModuleDescription.Provides>(this.provides);
                        provides.put(service, new ModuleDescription.Provides.Simple(new LinkedHashSet<String>(implementations)));
                        return new ModuleDefinitionAdapter(name, modifiers, version, mainClass, packages, requires, exports, opens, uses, provides);
                    }
                    protected Builder<U> materialize() {
                        return Builder.AbstractBase.Adapter.this.materialize(instrumentedType.withModuleDescription(new ModuleDescription.Latent(name, modifiers, version, mainClass, packages, requires, exports, opens, uses, provides, instrumentedType.getDeclaredAnnotations())).withModifiers(modifiers), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                    }
                    protected class RequiresDefinitionAdapter extends RequiresDefinition.Delegator<U> {
                        private final String module;
                        private final int modifiers;
                        private final String version;
                        protected RequiresDefinitionAdapter(String module, int modifiers) {
                            this(module, modifiers, null);
                        }
                        protected RequiresDefinitionAdapter(String module, int modifiers, @MaybeNull String version) {
                            this.module = module;
                            this.modifiers = modifiers;
                            this.version = version;
                        }
                        public RequiresDefinition<U> requiredVersion(@MaybeNull String version) {
                            return new RequiresDefinitionAdapter(module, modifiers, version);
                        }
                        protected ModuleDefinition<U> materialize() {
                            Map<String, ModuleDescription.Requires> requires = new LinkedHashMap<String, ModuleDescription.Requires>(ModuleDefinitionAdapter.this.requires);
                            requires.put(module, new ModuleDescription.Requires.Simple(version, modifiers));
                            return new ModuleDefinitionAdapter(name, ModuleDefinitionAdapter.this.modifiers, ModuleDefinitionAdapter.this.version, mainClass, packages, requires, exports, opens, uses, provides);
                        }
                    }
                    protected class ExportsDefinitionAdapter extends ExportsDefinition.Delegator<U> {
                        private final String aPackage;
                        private final int modifiers;
                        private final Set<String> targets;
                        protected ExportsDefinitionAdapter(String aPackage, int modifiers) {
                            this(aPackage, modifiers, Collections.<String>emptySet());
                        }
                        protected ExportsDefinitionAdapter(String aPackage, int modifiers, Set<String> targets) {
                            this.aPackage = aPackage;
                            this.modifiers = modifiers;
                            this.targets = targets;
                        }
                        public ExportsDefinition<U> to(Collection<String> modules) {
                            Set<String> targets = new LinkedHashSet<String>(this.targets);
                            targets.addAll(modules);
                            return new ExportsDefinitionAdapter(aPackage, modifiers, targets);
                        }
                        protected ModuleDefinition<U> materialize() {
                            Map<String, ModuleDescription.Exports> exports = new LinkedHashMap<String, ModuleDescription.Exports>(ModuleDefinitionAdapter.this.exports);
                            exports.put(aPackage, new ModuleDescription.Exports.Simple(targets, modifiers));
                            return new ModuleDefinitionAdapter(name, ModuleDefinitionAdapter.this.modifiers, version, mainClass, packages, requires, exports, opens, uses, provides);
                        }
                    }
                    protected class OpensDefinitionAdapter extends OpensDefinition.Delegator<U> {
                        private final String aPackage;
                        private final int modifiers;
                        private final Set<String> targets;
                        protected OpensDefinitionAdapter(String aPackage, int modifiers) {
                            this(aPackage, modifiers, Collections.<String>emptySet());
                        }
                        protected OpensDefinitionAdapter(String aPackage, int modifiers, Set<String> targets) {
                            this.aPackage = aPackage;
                            this.modifiers = modifiers;
                            this.targets = targets;
                        }
                        public OpensDefinition<U> to(Collection<String> modules) {
                            Set<String> targets = new LinkedHashSet<String>(this.targets);
                            targets.addAll(modules);
                            return new OpensDefinitionAdapter(aPackage, modifiers, targets);
                        }
                        protected ModuleDefinition<U> materialize() {
                            Map<String, ModuleDescription.Opens> opens = new LinkedHashMap<String, ModuleDescription.Opens>(ModuleDefinitionAdapter.this.opens);
                            opens.put(aPackage, new ModuleDescription.Opens.Simple(targets, modifiers));
                            return new ModuleDefinitionAdapter(name, ModuleDefinitionAdapter.this.modifiers, version, mainClass, packages, requires, exports, opens, uses, provides);
                        }
                    }
                }
                protected class InnerTypeDefinitionForTypeAdapter extends Builder.AbstractBase.Delegator<U> implements InnerTypeDefinition.ForType<U> {
                    private final TypeDescription typeDescription;
                    protected InnerTypeDefinitionForTypeAdapter(TypeDescription typeDescription) {
                        this.typeDescription = typeDescription;
                    }
                    public Builder<U> asAnonymousType() {
                        return Adapter.this.materialize(instrumentedType.withDeclaringType(TypeDescription.UNDEFINED).withEnclosingType(typeDescription).withAnonymousClass(true), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                    }
                    public Builder<U> asMemberType() {
                        return Adapter.this.materialize(instrumentedType.withDeclaringType(typeDescription).withEnclosingType(typeDescription).withAnonymousClass(false).withLocalClass(false), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                    }
                    protected Builder<U> materialize() {
                        return Adapter.this.materialize(instrumentedType.withDeclaringType(TypeDescription.UNDEFINED).withEnclosingType(typeDescription).withLocalClass(true), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                    }
                }
                protected class InnerTypeDefinitionForMethodAdapter extends Builder.AbstractBase.Delegator<U> implements InnerTypeDefinition<U> {
                    private final MethodDescription.InDefinedShape methodDescription;
                    protected InnerTypeDefinitionForMethodAdapter(MethodDescription.InDefinedShape methodDescription) {
                        this.methodDescription = methodDescription;
                    }
                    public Builder<U> asAnonymousType() {
                        return Adapter.this.materialize(instrumentedType.withDeclaringType(TypeDescription.UNDEFINED).withEnclosingMethod(methodDescription).withAnonymousClass(true), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                    }
                    protected Builder<U> materialize() {
                        return Adapter.this.materialize(instrumentedType.withDeclaringType(TypeDescription.UNDEFINED).withEnclosingMethod(methodDescription).withLocalClass(true), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                    }
                }
                protected class TypeVariableDefinitionAdapter extends TypeVariableDefinition.AbstractBase<U> {
                    private final TypeVariableToken token;
                    protected TypeVariableDefinitionAdapter(TypeVariableToken token) {
                        this.token = token;
                    }
                    public TypeVariableDefinition<U> annotateTypeVariable(Collection<? extends AnnotationDescription> annotations) {
                        return new TypeVariableDefinitionAdapter(new TypeVariableToken(token.getSymbol(), token.getBounds(), CompoundList.of(token.getAnnotations(), new ArrayList<AnnotationDescription>(annotations))));
                    }
                    protected Builder<U> materialize() {
                        return Adapter.this.materialize(instrumentedType.withTypeVariable(token), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                    }
                }
                protected class FieldDefinitionAdapter extends FieldDefinition.Optional.Valuable.AbstractBase.Adapter<U> {
                    private final FieldDescription.Token token;
                    protected FieldDefinitionAdapter(FieldDescription.Token token) {
                        this(FieldAttributeAppender.ForInstrumentedField.INSTANCE, Transformer.NoOp.<FieldDescription>make(), FieldDescription.NO_DEFAULT_VALUE, token);
                    }
                    protected FieldDefinitionAdapter(FieldAttributeAppender.Factory fieldAttributeAppenderFactory, Transformer<FieldDescription> transformer, @MaybeNull Object defaultValue, FieldDescription.Token token) {
                        super(fieldAttributeAppenderFactory, transformer, defaultValue);
                        this.token = token;
                    }
                    public Optional<U> annotateField(Collection<? extends AnnotationDescription> annotations) {
                        return new FieldDefinitionAdapter(fieldAttributeAppenderFactory, transformer, defaultValue, new FieldDescription.Token(token.getName(), token.getModifiers(), token.getType(), CompoundList.of(token.getAnnotations(), new ArrayList<AnnotationDescription>(annotations))));
                    }
                    protected Builder<U> materialize() {
                        return Builder.AbstractBase.Adapter.this.materialize(instrumentedType.withField(token), fieldRegistry.prepend(new LatentMatcher.ForFieldToken(token), fieldAttributeAppenderFactory, defaultValue, transformer), methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                    }
                    protected Optional<U> materialize(FieldAttributeAppender.Factory fieldAttributeAppenderFactory, Transformer<FieldDescription> transformer, @MaybeNull Object defaultValue) {
                        return new FieldDefinitionAdapter(fieldAttributeAppenderFactory, transformer, defaultValue, token);
                    }
                }
                protected class FieldMatchAdapter extends FieldDefinition.Optional.Valuable.AbstractBase.Adapter<U> {
                    private final LatentMatcher<? super FieldDescription> matcher;
                    protected FieldMatchAdapter(LatentMatcher<? super FieldDescription> matcher) {
                        this(FieldAttributeAppender.NoOp.INSTANCE, Transformer.NoOp.<FieldDescription>make(), FieldDescription.NO_DEFAULT_VALUE, matcher);
                    }
                    protected FieldMatchAdapter(FieldAttributeAppender.Factory fieldAttributeAppenderFactory, Transformer<FieldDescription> transformer, @MaybeNull Object defaultValue, LatentMatcher<? super FieldDescription> matcher) {
                        super(fieldAttributeAppenderFactory, transformer, defaultValue);
                        this.matcher = matcher;
                    }
                    public Optional<U> annotateField(Collection<? extends AnnotationDescription> annotations) {
                        return attribute(new FieldAttributeAppender.Explicit(new ArrayList<AnnotationDescription>(annotations)));
                    }
                    protected Builder<U> materialize() {
                        return Builder.AbstractBase.Adapter.this.materialize(instrumentedType, fieldRegistry.prepend(matcher, fieldAttributeAppenderFactory, defaultValue, transformer), methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                    }
                    protected Optional<U> materialize(FieldAttributeAppender.Factory fieldAttributeAppenderFactory, Transformer<FieldDescription> transformer, @MaybeNull Object defaultValue) {
                        return new FieldMatchAdapter(fieldAttributeAppenderFactory, transformer, defaultValue, matcher);
                    }
                }
                protected class MethodDefinitionAdapter extends MethodDefinition.ParameterDefinition.Initial.AbstractBase<U> {
                    private final MethodDescription.Token token;
                    protected MethodDefinitionAdapter(MethodDescription.Token token) {
                        this.token = token;
                    }
                    public MethodDefinition.ParameterDefinition.Annotatable<U> withParameter(TypeDefinition type, String name, int modifiers) {
                        return new ParameterAnnotationAdapter(new ParameterDescription.Token(type.asGenericType(), name, modifiers));
                    }
                    public Simple.Annotatable<U> withParameter(TypeDefinition type) {
                        return new SimpleParameterAnnotationAdapter(new ParameterDescription.Token(type.asGenericType()));
                    }
                    public MethodDefinition.ExceptionDefinition<U> throwing(Collection<? extends TypeDefinition> types) {
                        return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(), token.getModifiers(), token.getTypeVariableTokens(), token.getReturnType(), token.getParameterTokens(), CompoundList.of(token.getExceptionTypes(), new TypeList.Generic.Explicit(new ArrayList<TypeDefinition>(types))), token.getAnnotations(), token.getDefaultValue(), token.getReceiverType()));
                    }
                    public MethodDefinition.TypeVariableDefinition.Annotatable<U> typeVariable(String symbol, Collection<? extends TypeDefinition> bounds) {
                        return new TypeVariableAnnotationAdapter(new TypeVariableToken(symbol, new TypeList.Generic.Explicit(new ArrayList<TypeDefinition>(bounds))));
                    }
                    public MethodDefinition.ReceiverTypeDefinition<U> intercept(Implementation implementation) {
                        return materialize(new MethodRegistry.Handler.ForImplementation(implementation));
                    }
                    public MethodDefinition.ReceiverTypeDefinition<U> withoutCode() {
                        return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(), (token.getModifiers() & Opcodes.ACC_NATIVE) == 0 ? ModifierContributor.Resolver.of(MethodManifestation.ABSTRACT).resolve(token.getModifiers()) : token.getModifiers(), token.getTypeVariableTokens(), token.getReturnType(), token.getParameterTokens(), token.getExceptionTypes(), token.getAnnotations(), token.getDefaultValue(), token.getReceiverType())).materialize(MethodRegistry.Handler.ForAbstractMethod.INSTANCE);
                    }
                    public MethodDefinition.ReceiverTypeDefinition<U> defaultValue(AnnotationValue<?, ?> annotationValue) {
                        return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(), ModifierContributor.Resolver.of(MethodManifestation.ABSTRACT).resolve(token.getModifiers()), token.getTypeVariableTokens(), token.getReturnType(), token.getParameterTokens(), token.getExceptionTypes(), token.getAnnotations(), annotationValue, token.getReceiverType())).materialize(new MethodRegistry.Handler.ForAnnotationValue(annotationValue));
                    }
                    private MethodDefinition.ReceiverTypeDefinition<U> materialize(MethodRegistry.Handler handler) {
                        return new AnnotationAdapter(handler);
                    }
                    protected class TypeVariableAnnotationAdapter extends MethodDefinition.TypeVariableDefinition.Annotatable.AbstractBase.Adapter<U> {
                        private final TypeVariableToken token;
                        protected TypeVariableAnnotationAdapter(TypeVariableToken token) {
                            this.token = token;
                        }
                        protected MethodDefinition.ParameterDefinition<U> materialize() {
                            return new MethodDefinitionAdapter(new MethodDescription.Token(MethodDefinitionAdapter.this.token.getName(), MethodDefinitionAdapter.this.token.getModifiers(), CompoundList.of(MethodDefinitionAdapter.this.token.getTypeVariableTokens(), token), MethodDefinitionAdapter.this.token.getReturnType(), MethodDefinitionAdapter.this.token.getParameterTokens(), MethodDefinitionAdapter.this.token.getExceptionTypes(), MethodDefinitionAdapter.this.token.getAnnotations(), MethodDefinitionAdapter.this.token.getDefaultValue(), MethodDefinitionAdapter.this.token.getReceiverType()));
                        }
                        public Annotatable<U> annotateTypeVariable(Collection<? extends AnnotationDescription> annotations) {
                            return new TypeVariableAnnotationAdapter(new TypeVariableToken(token.getSymbol(), token.getBounds(), CompoundList.of(token.getAnnotations(), new ArrayList<AnnotationDescription>(annotations))));
                        }
                    }
                    protected class ParameterAnnotationAdapter extends MethodDefinition.ParameterDefinition.Annotatable.AbstractBase.Adapter<U> {
                        private final ParameterDescription.Token token;
                        protected ParameterAnnotationAdapter(ParameterDescription.Token token) {
                            this.token = token;
                        }
                        public MethodDefinition.ParameterDefinition.Annotatable<U> annotateParameter(Collection<? extends AnnotationDescription> annotations) {
                            return new ParameterAnnotationAdapter(new ParameterDescription.Token(token.getType(), CompoundList.of(token.getAnnotations(), new ArrayList<AnnotationDescription>(annotations)), token.getName(), token.getModifiers()));
                        }
                        protected MethodDefinition.ParameterDefinition<U> materialize() {
                            return new MethodDefinitionAdapter(new MethodDescription.Token(MethodDefinitionAdapter.this.token.getName(), MethodDefinitionAdapter.this.token.getModifiers(), MethodDefinitionAdapter.this.token.getTypeVariableTokens(), MethodDefinitionAdapter.this.token.getReturnType(), CompoundList.of(MethodDefinitionAdapter.this.token.getParameterTokens(), token), MethodDefinitionAdapter.this.token.getExceptionTypes(), MethodDefinitionAdapter.this.token.getAnnotations(), MethodDefinitionAdapter.this.token.getDefaultValue(), MethodDefinitionAdapter.this.token.getReceiverType()));
                        }
                    }
                    protected class SimpleParameterAnnotationAdapter extends MethodDefinition.ParameterDefinition.Simple.Annotatable.AbstractBase.Adapter<U> {
                        private final ParameterDescription.Token token;
                        protected SimpleParameterAnnotationAdapter(ParameterDescription.Token token) {
                            this.token = token;
                        }
                        public MethodDefinition.ParameterDefinition.Simple.Annotatable<U> annotateParameter(Collection<? extends AnnotationDescription> annotations) {
                            return new SimpleParameterAnnotationAdapter(new ParameterDescription.Token(token.getType(), CompoundList.of(token.getAnnotations(), new ArrayList<AnnotationDescription>(annotations)), token.getName(), token.getModifiers()));
                        }
                        protected MethodDefinition.ParameterDefinition.Simple<U> materialize() {
                            return new MethodDefinitionAdapter(new MethodDescription.Token(MethodDefinitionAdapter.this.token.getName(), MethodDefinitionAdapter.this.token.getModifiers(), MethodDefinitionAdapter.this.token.getTypeVariableTokens(), MethodDefinitionAdapter.this.token.getReturnType(), CompoundList.of(MethodDefinitionAdapter.this.token.getParameterTokens(), token), MethodDefinitionAdapter.this.token.getExceptionTypes(), MethodDefinitionAdapter.this.token.getAnnotations(), MethodDefinitionAdapter.this.token.getDefaultValue(), MethodDefinitionAdapter.this.token.getReceiverType()));
                        }
                    }
                    protected class AnnotationAdapter extends MethodDefinition.AbstractBase.Adapter<U> {
                        protected AnnotationAdapter(MethodRegistry.Handler handler) {
                            this(handler, MethodAttributeAppender.ForInstrumentedMethod.INCLUDING_RECEIVER, Transformer.NoOp.<MethodDescription>make());
                        }
                        protected AnnotationAdapter(MethodRegistry.Handler handler, MethodAttributeAppender.Factory methodAttributeAppenderFactory, Transformer<MethodDescription> transformer) {
                            super(handler, methodAttributeAppenderFactory, transformer);
                        }
                        public MethodDefinition<U> receiverType(TypeDescription.Generic receiverType) {
                            return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(), token.getModifiers(), token.getTypeVariableTokens(), token.getReturnType(), token.getParameterTokens(), token.getExceptionTypes(), token.getAnnotations(), token.getDefaultValue(), receiverType)).new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);
                        }
                        public MethodDefinition<U> annotateMethod(Collection<? extends AnnotationDescription> annotations) {
                            return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(), token.getModifiers(), token.getTypeVariableTokens(), token.getReturnType(), token.getParameterTokens(), token.getExceptionTypes(), CompoundList.of(token.getAnnotations(), new ArrayList<AnnotationDescription>(annotations)), token.getDefaultValue(), token.getReceiverType())).new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);
                        }
                        public MethodDefinition<U> annotateParameter(int index, Collection<? extends AnnotationDescription> annotations) {
                            List<ParameterDescription.Token> parameterTokens = new ArrayList<ParameterDescription.Token>(token.getParameterTokens());
                            parameterTokens.set(index, new ParameterDescription.Token(token.getParameterTokens().get(index).getType(), CompoundList.of(token.getParameterTokens().get(index).getAnnotations(), new ArrayList<AnnotationDescription>(annotations)), token.getParameterTokens().get(index).getName(), token.getParameterTokens().get(index).getModifiers()));
                            return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(), token.getModifiers(), token.getTypeVariableTokens(), token.getReturnType(), parameterTokens, token.getExceptionTypes(), token.getAnnotations(), token.getDefaultValue(), token.getReceiverType())).new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);
                        }
                        protected MethodDefinition<U> materialize(MethodRegistry.Handler handler, MethodAttributeAppender.Factory methodAttributeAppenderFactory, Transformer<MethodDescription> transformer) {
                            return new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);
                        }
                        protected Builder<U> materialize() {
                            return Builder.AbstractBase.Adapter.this.materialize(instrumentedType.withMethod(token), fieldRegistry, methodRegistry.prepend(new LatentMatcher.ForMethodToken(token), handler, methodAttributeAppenderFactory, transformer), recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                        }
                    }
                }
                protected class MethodMatchAdapter extends MethodDefinition.ImplementationDefinition.AbstractBase<U> {
                    private final LatentMatcher<? super MethodDescription> matcher;
                    protected MethodMatchAdapter(LatentMatcher<? super MethodDescription> matcher) {
                        this.matcher = matcher;
                    }
                    public MethodDefinition.ReceiverTypeDefinition<U> intercept(Implementation implementation) {
                        return materialize(new MethodRegistry.Handler.ForImplementation(implementation));
                    }
                    public MethodDefinition.ReceiverTypeDefinition<U> withoutCode() {
                        return materialize(MethodRegistry.Handler.ForAbstractMethod.INSTANCE);
                    }
                    public MethodDefinition.ReceiverTypeDefinition<U> defaultValue(AnnotationValue<?, ?> annotationValue) {
                        return materialize(new MethodRegistry.Handler.ForAnnotationValue(annotationValue));
                    }
                    private MethodDefinition.ReceiverTypeDefinition<U> materialize(MethodRegistry.Handler handler) {
                        return new AnnotationAdapter(handler);
                    }
                    protected class AnnotationAdapter extends MethodDefinition.AbstractBase.Adapter<U> {
                        protected AnnotationAdapter(MethodRegistry.Handler handler) {
                            this(handler, MethodAttributeAppender.NoOp.INSTANCE, Transformer.NoOp.<MethodDescription>make());
                        }
                        protected AnnotationAdapter(MethodRegistry.Handler handler, MethodAttributeAppender.Factory methodAttributeAppenderFactory, Transformer<MethodDescription> transformer) {
                            super(handler, methodAttributeAppenderFactory, transformer);
                        }
                        public MethodDefinition<U> receiverType(TypeDescription.Generic receiverType) {
                            return new AnnotationAdapter(handler, new MethodAttributeAppender.Factory.Compound(methodAttributeAppenderFactory, new MethodAttributeAppender.ForReceiverType(receiverType)), transformer);
                        }
                        public MethodDefinition<U> annotateMethod(Collection<? extends AnnotationDescription> annotations) {
                            return new AnnotationAdapter(handler, new MethodAttributeAppender.Factory.Compound(methodAttributeAppenderFactory, new MethodAttributeAppender.Explicit(new ArrayList<AnnotationDescription>(annotations))), transformer);
                        }
                        public MethodDefinition<U> annotateParameter(int index, Collection<? extends AnnotationDescription> annotations) {
                            return new AnnotationAdapter(handler, new MethodAttributeAppender.Factory.Compound(methodAttributeAppenderFactory, new MethodAttributeAppender.Explicit(index, new ArrayList<AnnotationDescription>(annotations))), transformer);
                        }
                        protected MethodDefinition<U> materialize(MethodRegistry.Handler handler, MethodAttributeAppender.Factory methodAttributeAppenderFactory, Transformer<MethodDescription> transformer) {
                            return new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);
                        }
                        protected Builder<U> materialize() {
                            return Builder.AbstractBase.Adapter.this.materialize(instrumentedType, fieldRegistry, methodRegistry.prepend(matcher, handler, methodAttributeAppenderFactory, transformer), recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                        }
                    }
                }
                protected class OptionalMethodMatchAdapter extends Builder.AbstractBase.Delegator<U> implements MethodDefinition.ImplementationDefinition.Optional<U> {
                    private final TypeList.Generic interfaces;
                    protected OptionalMethodMatchAdapter(TypeList.Generic interfaces) {
                        this.interfaces = interfaces;
                    }
                    protected Builder<U> materialize() {
                        return Adapter.this.materialize(instrumentedType.withInterfaces(interfaces), fieldRegistry, methodRegistry, recordComponentRegistry, typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                    }
                    public MethodDefinition.ReceiverTypeDefinition<U> intercept(Implementation implementation) {
                        return interfaceType().intercept(implementation);
                    }
                    public MethodDefinition.ReceiverTypeDefinition<U> withoutCode() {
                        return interfaceType().withoutCode();
                    }
                    public MethodDefinition.ReceiverTypeDefinition<U> defaultValue(AnnotationValue<?, ?> annotationValue) {
                        return interfaceType().defaultValue(annotationValue);
                    }
                    public <V> MethodDefinition.ReceiverTypeDefinition<U> defaultValue(V value, Class<? extends V> type) {
                        return interfaceType().defaultValue(value, type);
                    }
                    private MethodDefinition.ImplementationDefinition<U> interfaceType() {
                        ElementMatcher.Junction<TypeDescription> elementMatcher = none();
                        for (TypeDescription typeDescription : interfaces.asErasures()) {
                            elementMatcher = elementMatcher.or(isSuperTypeOf(typeDescription));
                        }
                        return materialize().invokable(isDeclaredBy(isInterface().and(elementMatcher)));
                    }
                }
                protected class RecordComponentDefinitionAdapter extends RecordComponentDefinition.Optional.AbstractBase<U> {
                    private final RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory;
                    private final RecordComponentDescription.Token token;
                    private final Transformer<RecordComponentDescription> transformer;
                    protected RecordComponentDefinitionAdapter(RecordComponentDescription.Token token) {
                        this(RecordComponentAttributeAppender.ForInstrumentedRecordComponent.INSTANCE, Transformer.NoOp.<RecordComponentDescription>make(), token);
                    }
                    protected RecordComponentDefinitionAdapter(RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory, Transformer<RecordComponentDescription> transformer, RecordComponentDescription.Token token) {
                        this.recordComponentAttributeAppenderFactory = recordComponentAttributeAppenderFactory;
                        this.transformer = transformer;
                        this.token = token;
                    }
                    public Optional<U> annotateRecordComponent(Collection<? extends AnnotationDescription> annotations) {
                        return new RecordComponentDefinitionAdapter(recordComponentAttributeAppenderFactory, transformer, new RecordComponentDescription.Token(token.getName(), token.getType(), CompoundList.of(token.getAnnotations(), new ArrayList<AnnotationDescription>(annotations))));
                    }
                    public Optional<U> attribute(RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory) {
                        return new RecordComponentDefinitionAdapter(new RecordComponentAttributeAppender.Factory.Compound(this.recordComponentAttributeAppenderFactory, recordComponentAttributeAppenderFactory), transformer, token);
                    }
                    public Optional<U> transform(Transformer<RecordComponentDescription> transformer) {
                        return new RecordComponentDefinitionAdapter(recordComponentAttributeAppenderFactory, new Transformer.Compound<RecordComponentDescription>(this.transformer, transformer), token);
                    }
                    protected Builder<U> materialize() {
                        return Builder.AbstractBase.Adapter.this.materialize(instrumentedType.withRecordComponent(token), fieldRegistry, methodRegistry, recordComponentRegistry.prepend(new LatentMatcher.ForRecordComponentToken(token), recordComponentAttributeAppenderFactory, transformer), typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                    }
                }
                protected class RecordComponentMatchAdapter extends RecordComponentDefinition.Optional.AbstractBase<U> {
                    private final LatentMatcher<? super RecordComponentDescription> matcher;
                    private final RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory;
                    private final Transformer<RecordComponentDescription> transformer;
                    protected RecordComponentMatchAdapter(LatentMatcher<? super RecordComponentDescription> matcher) {
                        this(matcher, RecordComponentAttributeAppender.NoOp.INSTANCE, Transformer.NoOp.<RecordComponentDescription>make());
                    }
                    protected RecordComponentMatchAdapter(LatentMatcher<? super RecordComponentDescription> matcher, RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory, Transformer<RecordComponentDescription> transformer) {
                        this.matcher = matcher;
                        this.recordComponentAttributeAppenderFactory = recordComponentAttributeAppenderFactory;
                        this.transformer = transformer;
                    }
                    public Optional<U> annotateRecordComponent(Collection<? extends AnnotationDescription> annotations) {
                        return attribute(new RecordComponentAttributeAppender.Explicit(new ArrayList<AnnotationDescription>(annotations)));
                    }
                    public Optional<U> attribute(RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory) {
                        return new RecordComponentMatchAdapter(matcher, new RecordComponentAttributeAppender.Factory.Compound(this.recordComponentAttributeAppenderFactory, recordComponentAttributeAppenderFactory), transformer);
                    }
                    public Optional<U> transform(Transformer<RecordComponentDescription> transformer) {
                        return new RecordComponentMatchAdapter(matcher, recordComponentAttributeAppenderFactory, new Transformer.Compound<RecordComponentDescription>(this.transformer, transformer));
                    }
                    protected Builder<U> materialize() {
                        return Builder.AbstractBase.Adapter.this.materialize(instrumentedType, fieldRegistry, methodRegistry, recordComponentRegistry.prepend(matcher, recordComponentAttributeAppenderFactory, transformer), typeAttributeAppender, asmVisitorWrapper, classFileVersion, auxiliaryTypeNamingStrategy, annotationValueFilterFactory, annotationRetention, implementationContextFactory, methodGraphCompiler, typeValidation, visibilityBridgeStrategy, classReaderFactory, classWriterFactory, ignoredMethods, auxiliaryTypes);
                    }
                }
            }
        }
    }
    interface Unloaded<T> extends DynamicType {
        Loaded<T> load(@MaybeNull ClassLoader classLoader);
        <S extends ClassLoader> Loaded<T> load(@MaybeNull S classLoader, ClassLoadingStrategy<? super S> classLoadingStrategy);
        Unloaded<T> include(DynamicType... dynamicType);
        Unloaded<T> include(List<? extends DynamicType> dynamicTypes);
    }
    interface Loaded<T> extends DynamicType {
        Class<? extends T> getLoaded();
        Map<TypeDescription, Class<?>> getLoadedAuxiliaryTypes();
        Map<TypeDescription, Class<?>> getAllLoaded();
    }
    abstract class AbstractBase implements DynamicType {
        private static final String MANIFEST_VERSION = "1.0";
        private static final String TEMP_SUFFIX = "tmp";
        public Resolution locate(String name) throws IOException {
            if (getTypeDescription().getName().equals(name)) {
                return new Resolution.Explicit(getBytes());
            }
            for (DynamicType auxiliaryType : getAuxiliaries()) {
                Resolution resolution = auxiliaryType.locate(name);
                if (resolution.isResolved()) {
                    return resolution;
                }
            }
            return new Resolution.Illegal(name);
        }
        public void close() {
        }
        public Set<TypeDescription> getAuxiliaryTypeDescriptions() {
            Set<TypeDescription> types = new LinkedHashSet<TypeDescription>();
            for (DynamicType auxiliaryType : getAuxiliaries()) {
                types.addAll(auxiliaryType.getAllTypeDescriptions());
            }
            return types;
        }
        public Set<TypeDescription> getAllTypeDescriptions() {
            Set<TypeDescription> types = new LinkedHashSet<TypeDescription>();
            types.add(getTypeDescription());
            for (DynamicType auxiliaryType : getAuxiliaries()) {
                types.addAll(auxiliaryType.getAllTypeDescriptions());
            }
            return types;
        }
        public Map<TypeDescription, byte[]> getAllTypes() {
            Map<TypeDescription, byte[]> allTypes = new LinkedHashMap<TypeDescription, byte[]>();
            allTypes.put(getTypeDescription(), getBytes());
            for (DynamicType auxiliaryType : getAuxiliaries()) {
                allTypes.putAll(auxiliaryType.getAllTypes());
            }
            return allTypes;
        }
        public Map<TypeDescription, LoadedTypeInitializer> getLoadedTypeInitializers() {
            Map<TypeDescription, LoadedTypeInitializer> classLoadingCallbacks = new HashMap<TypeDescription, LoadedTypeInitializer>();
            for (DynamicType auxiliaryType : getAuxiliaries()) {
                classLoadingCallbacks.putAll(auxiliaryType.getLoadedTypeInitializers());
            }
            classLoadingCallbacks.put(getTypeDescription(), getLoadedTypeInitializer());
            return classLoadingCallbacks;
        }
        public boolean hasAliveLoadedTypeInitializers() {
            if (getLoadedTypeInitializer().isAlive()) {
                return true;
            }
            for (DynamicType auxiliaryType : getAuxiliaries()) {
                if (auxiliaryType.hasAliveLoadedTypeInitializers()) {
                    return true;
                }
            }
            return false;
        }
        public Map<TypeDescription, byte[]> getAuxiliaryTypes() {
            Map<TypeDescription, byte[]> auxiliaryTypes = new HashMap<TypeDescription, byte[]>();
            for (DynamicType auxiliaryType : getAuxiliaries()) {
                auxiliaryTypes.put(auxiliaryType.getTypeDescription(), auxiliaryType.getBytes());
                auxiliaryTypes.putAll(auxiliaryType.getAuxiliaryTypes());
            }
            return auxiliaryTypes;
        }
        public Map<TypeDescription, File> saveIn(File folder) throws IOException {
            Map<TypeDescription, File> files = new HashMap<TypeDescription, File>();
            File target = new File(folder, getTypeDescription().getName().replace('.', File.separatorChar) + CLASS_FILE_EXTENSION);
            if (target.getParentFile() != null && !target.getParentFile().isDirectory() && !target.getParentFile().mkdirs()) {
                throw new IllegalArgumentException("Could not create directory: " + target.getParentFile());
            }
            OutputStream outputStream = new FileOutputStream(target);
            try {
                outputStream.write(getBytes());
            } finally {
                outputStream.close();
            }
            files.put(getTypeDescription(), target);
            for (DynamicType auxiliaryType : getAuxiliaries()) {
                files.putAll(auxiliaryType.saveIn(folder));
            }
            return files;
        }
        public File inject(File sourceJar, File targetJar) throws IOException {
            return sourceJar.equals(targetJar) ? inject(sourceJar) : doInject(sourceJar, targetJar);
        }
        public File inject(File jar) throws IOException {
            FileSystem.getInstance().move(doInject(jar, File.createTempFile(jar.getName(), TEMP_SUFFIX)), jar);
            return jar;
        }
        private File doInject(File sourceJar, File targetJar) throws IOException {
            InputStream inputStream = new FileInputStream(sourceJar);
            try {
                JarInputStream jarInputStream = new JarInputStream(inputStream);
                if (!targetJar.isFile() && !targetJar.createNewFile()) {
                    throw new IllegalArgumentException("Could not create file: " + targetJar);
                }
                Manifest manifest = jarInputStream.getManifest();
                OutputStream outputStream = new FileOutputStream(targetJar);
                try {
                    JarOutputStream jarOutputStream = manifest == null ? new JarOutputStream(outputStream) : new JarOutputStream(outputStream, manifest);
                    Map<TypeDescription, byte[]> rawAuxiliaryTypes = getAuxiliaryTypes();
                    Map<String, byte[]> files = new HashMap<String, byte[]>();
                    for (Map.Entry<TypeDescription, byte[]> entry : rawAuxiliaryTypes.entrySet()) {
                        files.put(entry.getKey().getInternalName() + CLASS_FILE_EXTENSION, entry.getValue());
                    }
                    files.put(getTypeDescription().getInternalName() + CLASS_FILE_EXTENSION, getBytes());
                    JarEntry jarEntry;
                    while ((jarEntry = jarInputStream.getNextJarEntry()) != null) {
                        byte[] replacement = files.remove(jarEntry.getName());
                        if (replacement == null) {
                            jarOutputStream.putNextEntry(jarEntry);
                            byte[] buffer = new byte[1024];
                            int index;
                            while ((index = jarInputStream.read(buffer)) != -1) {
                                jarOutputStream.write(buffer, 0, index);
                            }
                        } else {
                            jarOutputStream.putNextEntry(new JarEntry(jarEntry.getName()));
                            jarOutputStream.write(replacement);
                        }
                        jarInputStream.closeEntry();
                        jarOutputStream.closeEntry();
                    }
                    for (Map.Entry<String, byte[]> entry : files.entrySet()) {
                        jarOutputStream.putNextEntry(new JarEntry(entry.getKey()));
                        jarOutputStream.write(entry.getValue());
                        jarOutputStream.closeEntry();
                    }
                    jarOutputStream.close();
                } finally {
                    outputStream.close();
                }
                jarInputStream.close();
            } finally {
                inputStream.close();
            }
            return targetJar;
        }
        public File toJar(File file) throws IOException {
            Manifest manifest = new Manifest();
            manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, MANIFEST_VERSION);
            return toJar(file, manifest);
        }
        public File toJar(File file, Manifest manifest) throws IOException {
            if (!file.isFile() && !file.createNewFile()) {
                throw new IllegalArgumentException("Could not create file: " + file);
            }
            OutputStream outputStream = new FileOutputStream(file);
            try {
                JarOutputStream jarOutputStream = new JarOutputStream(outputStream, manifest);
                for (Map.Entry<TypeDescription, byte[]> entry : getAuxiliaryTypes().entrySet()) {
                    jarOutputStream.putNextEntry(new JarEntry(entry.getKey().getInternalName() + CLASS_FILE_EXTENSION));
                    jarOutputStream.write(entry.getValue());
                    jarOutputStream.closeEntry();
                }
                jarOutputStream.putNextEntry(new JarEntry(getTypeDescription().getInternalName() + CLASS_FILE_EXTENSION));
                jarOutputStream.write(getBytes());
                jarOutputStream.closeEntry();
                jarOutputStream.close();
            } finally {
                outputStream.close();
            }
            return file;
        }
    }
    class Default extends AbstractBase {
        protected final TypeDescription typeDescription;
        protected final byte[] binaryRepresentation;
        protected final LoadedTypeInitializer loadedTypeInitializer;
        protected final List<? extends DynamicType> auxiliaryTypes;
        @SuppressFBWarnings(value = "EI_EXPOSE_REP2", justification = "The array is not modified by class contract.")
        public Default(TypeDescription typeDescription, byte[] binaryRepresentation, LoadedTypeInitializer loadedTypeInitializer, List<? extends DynamicType> auxiliaryTypes) {
            this.typeDescription = typeDescription;
            this.binaryRepresentation = binaryRepresentation;
            this.loadedTypeInitializer = loadedTypeInitializer;
            this.auxiliaryTypes = auxiliaryTypes;
        }
        public TypeDescription getTypeDescription() {
            return typeDescription;
        }
        public byte[] getBytes() {
            return binaryRepresentation;
        }
        public LoadedTypeInitializer getLoadedTypeInitializer() {
            return loadedTypeInitializer;
        }
        public List<? extends DynamicType> getAuxiliaries() {
            return auxiliaryTypes;
        }
        public static class Unloaded<T> extends Default implements DynamicType.Unloaded<T> {
            private final TypeResolutionStrategy.Resolved typeResolutionStrategy;
            public Unloaded(TypeDescription typeDescription, byte[] binaryRepresentation, LoadedTypeInitializer loadedTypeInitializer, List<? extends DynamicType> auxiliaryTypes, TypeResolutionStrategy.Resolved typeResolutionStrategy) {
                super(typeDescription, binaryRepresentation, loadedTypeInitializer, auxiliaryTypes);
                this.typeResolutionStrategy = typeResolutionStrategy;
            }
            public DynamicType.Loaded<T> load(@MaybeNull ClassLoader classLoader) {
                if (classLoader instanceof InjectionClassLoader && !((InjectionClassLoader) classLoader).isSealed()) {
                    return load((InjectionClassLoader) classLoader, InjectionClassLoader.Strategy.INSTANCE);
                } else {
                    return load(classLoader, ClassLoadingStrategy.Default.WRAPPER);
                }
            }
            public <S extends ClassLoader> DynamicType.Loaded<T> load(@MaybeNull S classLoader, ClassLoadingStrategy<? super S> classLoadingStrategy) {
                return new Default.Loaded<T>(typeDescription, binaryRepresentation, loadedTypeInitializer, auxiliaryTypes, typeResolutionStrategy.initialize(this, classLoader, classLoadingStrategy));
            }
            public DynamicType.Unloaded<T> include(DynamicType... dynamicType) {
                return include(Arrays.asList(dynamicType));
            }
            public DynamicType.Unloaded<T> include(List<? extends DynamicType> dynamicType) {
                return new Default.Unloaded<T>(typeDescription, binaryRepresentation, loadedTypeInitializer, CompoundList.of(auxiliaryTypes, dynamicType), typeResolutionStrategy);
            }
        }
        protected static class Loaded<T> extends Default implements DynamicType.Loaded<T> {
            private final Map<TypeDescription, Class<?>> loadedTypes;
            protected Loaded(TypeDescription typeDescription, byte[] typeByte, LoadedTypeInitializer loadedTypeInitializer, List<? extends DynamicType> auxiliaryTypes, Map<TypeDescription, Class<?>> loadedTypes) {
                super(typeDescription, typeByte, loadedTypeInitializer, auxiliaryTypes);
                this.loadedTypes = loadedTypes;
            }
            public Class<? extends T> getLoaded() {
                @SuppressWarnings("unchecked")
                Class<? extends T> type = (Class<? extends T>) loadedTypes.get(typeDescription);
                if (type == null) {
                    throw new IllegalStateException(typeDescription + " cannot be loaded explicitly");
                }
                return type;
            }
            public Map<TypeDescription, Class<?>> getLoadedAuxiliaryTypes() {
                Map<TypeDescription, Class<?>> loadedAuxiliaryTypes = new HashMap<TypeDescription, Class<?>>(loadedTypes);
                loadedAuxiliaryTypes.remove(typeDescription);
                return loadedAuxiliaryTypes;
            }
            public Map<TypeDescription, Class<?>> getAllLoaded() {
                return new HashMap<TypeDescription, Class<?>>(loadedTypes);
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```