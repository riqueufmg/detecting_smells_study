##CONTEXT_SIZE=18117
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.build;
public interface Plugin extends ElementMatcher<TypeDescription>, Closeable {
    DynamicType.Builder<?> apply(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassFileLocator classFileLocator);
    interface WithPreprocessor extends Plugin {
        void onPreprocess(TypeDescription typeDescription, ClassFileLocator classFileLocator);
    }
    interface WithInitialization extends Plugin {
        Map<TypeDescription, byte[]> initialize(ClassFileLocator classFileLocator);
    }
    interface Factory {
        Plugin make();
        class Simple implements Factory {
            private final Plugin plugin;
            public Simple(Plugin plugin) {
                this.plugin = plugin;
            }
            public Plugin make() {
                return plugin;
            }
        }
        class UsingReflection implements Factory {
            private final Class<? extends Plugin> type;
            private final List<ArgumentResolver> argumentResolvers;
            public UsingReflection(Class<? extends Plugin> type) {
                this(type, Collections.<ArgumentResolver>emptyList());
            }
            protected UsingReflection(Class<? extends Plugin> type, List<ArgumentResolver> argumentResolvers) {
                this.type = type;
                this.argumentResolvers = argumentResolvers;
            }
            public UsingReflection with(ArgumentResolver... argumentResolver) {
                return with(Arrays.asList(argumentResolver));
            }
            public UsingReflection with(List<? extends ArgumentResolver> argumentResolvers) {
                return new UsingReflection(type, CompoundList.of(argumentResolvers, this.argumentResolvers));
            }
            public Plugin make() {
                Instantiator instantiator = new Instantiator.Unresolved(type);
                candidates: for (Constructor<?> constructor : type.getConstructors()) {
                    if (!constructor.isSynthetic()) {
                        List<Object> arguments = new ArrayList<Object>(constructor.getParameterTypes().length);
                        int index = 0;
                        for (Class<?> type : constructor.getParameterTypes()) {
                            boolean resolved = false;
                            for (ArgumentResolver argumentResolver : argumentResolvers) {
                                ArgumentResolver.Resolution resolution = argumentResolver.resolve(index, type);
                                if (resolution.isResolved()) {
                                    arguments.add(resolution.getArgument());
                                    resolved = true;
                                    break;
                                }
                            }
                            if (resolved) {
                                index += 1;
                            } else {
                                continue candidates;
                            }
                        }
                        instantiator = instantiator.replaceBy(new Instantiator.Resolved((Constructor<? extends Plugin>) constructor, arguments));
                    }
                }
                return instantiator.instantiate();
            }
            protected interface Instantiator {
                Instantiator replaceBy(Resolved instantiator);
                Plugin instantiate();
                class Unresolved implements Instantiator {
                    private final Class<? extends Plugin> type;
                    protected Unresolved(Class<? extends Plugin> type) {
                        this.type = type;
                    }
                    public Instantiator replaceBy(Resolved instantiator) {
                        return instantiator;
                    }
                    public Plugin instantiate() {
                        throw new IllegalStateException("No constructor resolvable for " + type);
                    }
                }
                class Ambiguous implements Instantiator {
                    private final Constructor<?> left;
                    private final Constructor<?> right;
                    private final int priority;
                    private final int parameters;
                    protected Ambiguous(Constructor<?> left, Constructor<?> right, int priority, int parameters) {
                        this.left = left;
                        this.right = right;
                        this.priority = priority;
                        this.parameters = parameters;
                    }
                    public Instantiator replaceBy(Resolved instantiator) {
                        Priority priority = instantiator.getConstructor().getAnnotation(Priority.class);
                        if ((priority == null ? Priority.DEFAULT : priority.value()) > this.priority) {
                            return instantiator;
                        } else if ((priority == null ? Priority.DEFAULT : priority.value()) < this.priority) {
                            return this;
                        } else if (instantiator.getConstructor().getParameterTypes().length > parameters) {
                            return instantiator;
                        } else {
                            return this;
                        }
                    }
                    public Plugin instantiate() {
                        throw new IllegalStateException("Ambiguous constructors " + left + " and " + right);
                    }
                }
                class Resolved implements Instantiator {
                    private final Constructor<? extends Plugin> constructor;
                    private final List<?> arguments;
                    protected Resolved(Constructor<? extends Plugin> constructor, List<?> arguments) {
                        this.constructor = constructor;
                        this.arguments = arguments;
                    }
                    protected Constructor<? extends Plugin> getConstructor() {
                        return constructor;
                    }
                    public Instantiator replaceBy(Resolved instantiator) {
                        Priority left = constructor.getAnnotation(Priority.class), right = instantiator.getConstructor().getAnnotation(Priority.class);
                        int leftPriority = left == null ? Priority.DEFAULT : left.value(), rightPriority = right == null ? Priority.DEFAULT : right.value();
                        if (leftPriority > rightPriority) {
                            return this;
                        } else if (leftPriority < rightPriority) {
                            return instantiator;
                        } else if (constructor.getParameterTypes().length > instantiator.getConstructor().getParameterTypes().length) {
                            return this;
                        } else if (constructor.getParameterTypes().length < instantiator.getConstructor().getParameterTypes().length) {
                            return instantiator;
                        } else {
                            return new Ambiguous(constructor, instantiator.getConstructor(), leftPriority, constructor.getParameterTypes().length);
                        }
                    }
                    public Plugin instantiate() {
                        try {
                            return constructor.newInstance(arguments.toArray(new Object[0]));
                        } catch (InstantiationException exception) {
                            throw new IllegalStateException("Failed to instantiate plugin via " + constructor, exception);
                        } catch (IllegalAccessException exception) {
                            throw new IllegalStateException("Failed to access " + constructor, exception);
                        } catch (InvocationTargetException exception) {
                            throw new IllegalStateException("Error during construction of" + constructor, exception.getTargetException());
                        }
                    }
                }
            }
            public @interface Priority {
                int DEFAULT = 0;
                int value();
            }
            public interface ArgumentResolver {
                Resolution resolve(int index, Class<?> type);
                interface Resolution {
                    boolean isResolved();
                    Object getArgument();
                    enum Unresolved implements Resolution {
                        INSTANCE;
                        public boolean isResolved() {
                            return false;
                        }
                        public Object getArgument() {
                            throw new IllegalStateException("Cannot get the argument for an unresolved parameter");
                        }
                    }
                    class Resolved implements Resolution {
                        private final Object argument;
                        public Resolved(@MaybeNull Object argument) {
                            this.argument = argument;
                        }
                        public boolean isResolved() {
                            return true;
                        }
                        public Object getArgument() {
                            return argument;
                        }
                    }
                }
                enum NoOp implements ArgumentResolver {
                    INSTANCE;
                    public Resolution resolve(int index, Class<?> type) {
                        return Resolution.Unresolved.INSTANCE;
                    }
                }
                class ForType<T> implements ArgumentResolver {
                    private final Class<? extends T> type;
                    private final T value;
                    protected ForType(Class<? extends T> type, T value) {
                        this.type = type;
                        this.value = value;
                    }
                    public static <S> ArgumentResolver of(Class<? extends S> type, S value) {
                        return new ForType<S>(type, value);
                    }
                    public Resolution resolve(int index, Class<?> type) {
                        return type == this.type ? new Resolution.Resolved(value) : Resolution.Unresolved.INSTANCE;
                    }
                }
                class ForIndex implements ArgumentResolver {
                    private static final Map<Class<?>, Class<?>> WRAPPER_TYPES;
                    static {
                        WRAPPER_TYPES = new HashMap<Class<?>, Class<?>>();
                        WRAPPER_TYPES.put(boolean.class, Boolean.class);
                        WRAPPER_TYPES.put(byte.class, Byte.class);
                        WRAPPER_TYPES.put(short.class, Short.class);
                        WRAPPER_TYPES.put(char.class, Character.class);
                        WRAPPER_TYPES.put(int.class, Integer.class);
                        WRAPPER_TYPES.put(long.class, Long.class);
                        WRAPPER_TYPES.put(float.class, Float.class);
                        WRAPPER_TYPES.put(double.class, Double.class);
                    }
                    private final int index;
                    private final Object value;
                    public ForIndex(int index, @MaybeNull Object value) {
                        this.index = index;
                        this.value = value;
                    }
                    public Resolution resolve(int index, Class<?> type) {
                        if (this.index != index) {
                            return Resolution.Unresolved.INSTANCE;
                        } else if (type.isPrimitive()) {
                            return WRAPPER_TYPES.get(type).isInstance(value) ? new Resolution.Resolved(value) : Resolution.Unresolved.INSTANCE;
                        } else {
                            return value == null || type.isInstance(value) ? new Resolution.Resolved(value) : Resolution.Unresolved.INSTANCE;
                        }
                    }
                    public static class WithDynamicType implements ArgumentResolver {
                        private final int index;
                        private final String value;
                        public WithDynamicType(int index, @MaybeNull String value) {
                            this.index = index;
                            this.value = value;
                        }
                        public Resolution resolve(int index, Class<?> type) {
                            if (this.index != index) {
                                return Resolution.Unresolved.INSTANCE;
                            } else if (type == char.class || type == Character.class) {
                                return value != null && value.length() == 1 ? new Resolution.Resolved(value.charAt(0)) : Resolution.Unresolved.INSTANCE;
                            } else if (type == String.class) {
                                return new Resolution.Resolved(value);
                            } else if (type.isPrimitive()) {
                                type = WRAPPER_TYPES.get(type);
                            }
                            try {
                                Method valueOf = type.getMethod("valueOf", String.class);
                                return Modifier.isStatic(valueOf.getModifiers()) && type.isAssignableFrom(valueOf.getReturnType()) ? new Resolution.Resolved(valueOf.invoke(null, value)) : Resolution.Unresolved.INSTANCE;
                            } catch (IllegalAccessException exception) {
                                throw new IllegalStateException(exception);
                            } catch (InvocationTargetException exception) {
                                throw new IllegalStateException(exception.getTargetException());
                            } catch (NoSuchMethodException ignored) {
                                return Resolution.Unresolved.INSTANCE;
                            }
                        }
                    }
                }
            }
        }
    }
    interface Engine {
        String PLUGIN_FILE = "META-INF/net.bytebuddy/build.plugins";
        Engine with(ByteBuddy byteBuddy);
        Engine with(TypeStrategy typeStrategy);
        Engine with(PoolStrategy poolStrategy);
        Engine with(ClassFileLocator classFileLocator);
        Engine with(@MaybeNull ClassFileVersion classFileVersion);
        Engine with(Listener listener);
        Engine withoutErrorHandlers();
        Engine withErrorHandlers(ErrorHandler... errorHandler);
        Engine withErrorHandlers(List<? extends ErrorHandler> errorHandlers);
        Engine withParallelTransformation(int threads);
        Engine with(Dispatcher.Factory dispatcherFactory);
        Engine ignore(ElementMatcher<? super TypeDescription> matcher);
        Summary apply(File source, File target, Plugin.Factory... factory) throws IOException;
        Summary apply(File source, File target, List<? extends Plugin.Factory> factories) throws IOException;
        Summary apply(Source source, Target target, Plugin.Factory... factory) throws IOException;
        Summary apply(Source source, Target target, List<? extends Plugin.Factory> factories) throws IOException;
        interface TypeStrategy {
            DynamicType.Builder<?> builder(ByteBuddy byteBuddy, TypeDescription typeDescription, ClassFileLocator classFileLocator);
            enum Default implements TypeStrategy {
                REDEFINE {
                    public DynamicType.Builder<?> builder(ByteBuddy byteBuddy, TypeDescription typeDescription, ClassFileLocator classFileLocator) {
                        return byteBuddy.redefine(typeDescription, classFileLocator);
                    }
                }
                , REBASE {
                    public DynamicType.Builder<?> builder(ByteBuddy byteBuddy, TypeDescription typeDescription, ClassFileLocator classFileLocator) {
                        return byteBuddy.rebase(typeDescription, classFileLocator);
                    }
                }
                , DECORATE {
                    public DynamicType.Builder<?> builder(ByteBuddy byteBuddy, TypeDescription typeDescription, ClassFileLocator classFileLocator) {
                        return byteBuddy.decorate(typeDescription, classFileLocator);
                    }
                }
            }
            class ForEntryPoint implements TypeStrategy {
                private final EntryPoint entryPoint;
                private final MethodNameTransformer methodNameTransformer;
                public ForEntryPoint(EntryPoint entryPoint, MethodNameTransformer methodNameTransformer) {
                    this.entryPoint = entryPoint;
                    this.methodNameTransformer = methodNameTransformer;
                }
                public DynamicType.Builder<?> builder(ByteBuddy byteBuddy, TypeDescription typeDescription, ClassFileLocator classFileLocator) {
                    return entryPoint.transform(typeDescription, byteBuddy, classFileLocator, methodNameTransformer);
                }
            }
        }
        interface PoolStrategy {
            TypePool typePool(ClassFileLocator classFileLocator);
            enum Default implements PoolStrategy {
                FAST(TypePool.Default.ReaderMode.FAST), EXTENDED(TypePool.Default.ReaderMode.EXTENDED);
                private final TypePool.Default.ReaderMode readerMode;
                Default(TypePool.Default.ReaderMode readerMode) {
                    this.readerMode = readerMode;
                }
                public TypePool typePool(ClassFileLocator classFileLocator) {
                    return new TypePool.Default.WithLazyResolution(new TypePool.CacheProvider.Simple(), classFileLocator, readerMode, TypePool.ClassLoading.ofPlatformLoader());
                }
            }
            enum Eager implements PoolStrategy {
                FAST(TypePool.Default.ReaderMode.FAST), EXTENDED(TypePool.Default.ReaderMode.EXTENDED);
                private final TypePool.Default.ReaderMode readerMode;
                Eager(TypePool.Default.ReaderMode readerMode) {
                    this.readerMode = readerMode;
                }
                public TypePool typePool(ClassFileLocator classFileLocator) {
                    return new TypePool.Default(new TypePool.CacheProvider.Simple(), classFileLocator, readerMode, TypePool.ClassLoading.ofPlatformLoader());
                }
            }
        }
        interface ErrorHandler {
            void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable);
            void onError(TypeDescription typeDescription, List<Throwable> throwables);
            void onError(Map<TypeDescription, List<Throwable>> throwables);
            void onError(Plugin plugin, Throwable throwable);
            void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType);
            void onUnresolved(String typeName);
            void onManifest(@MaybeNull Manifest manifest);
            void onResource(String name);
            enum Failing implements ErrorHandler {
                FAIL_FAST {
                    public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
                        throw new IllegalStateException("Failed to transform " + typeDescription + " using " + plugin, throwable);
                    }
                    public void onError(TypeDescription typeDescription, List<Throwable> throwables) {
                        throw new IllegalStateException("Failed to transform " + typeDescription + ": " + throwables);
                    }
                    public void onError(Map<TypeDescription, List<Throwable>> throwables) {
                        throw new IllegalStateException("Failed to transform at least one type: " + throwables);
                    }
                }
                , FAIL_AFTER_TYPE {
                    public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
                    }
                    public void onError(TypeDescription typeDescription, List<Throwable> throwables) {
                        throw new IllegalStateException("Failed to transform " + typeDescription + ": " + throwables);
                    }
                    public void onError(Map<TypeDescription, List<Throwable>> throwables) {
                        throw new IllegalStateException("Failed to transform at least one type: " + throwables);
                    }
                }
                , FAIL_LAST {
                    public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
                    }
                    public void onError(TypeDescription typeDescription, List<Throwable> throwables) {
                    }
                    public void onError(Map<TypeDescription, List<Throwable>> throwables) {
                        throw new IllegalStateException("Failed to transform at least one type: " + throwables);
                    }
                }
                ;
                public void onError(Plugin plugin, Throwable throwable) {
                    throw new IllegalStateException("Failed to close plugin " + plugin, throwable);
                }
                public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
                }
                public void onUnresolved(String typeName) {
                }
                public void onManifest(Manifest manifest) {
                }
                public void onResource(String name) {
                }
            }
            enum Enforcing implements ErrorHandler {
                ALL_TYPES_RESOLVED {
                    @Override
                    public void onUnresolved(String typeName) {
                        throw new IllegalStateException("Failed to resolve type description for " + typeName);
                    }
                }
                , NO_LIVE_INITIALIZERS {
                    @Override
                    public void onLiveInitializer(TypeDescription typeDescription, TypeDescription initializedType) {
                        throw new IllegalStateException("Failed to instrument " + typeDescription + " due to live initializer for " + initializedType);
                    }
                }
                , CLASS_FILES_ONLY {
                    @Override
                    public void onResource(String name) {
                        throw new IllegalStateException("Discovered a resource when only class files were allowed: " + name);
                    }
                }
                , MANIFEST_REQUIRED {
                    @Override
                    public void onManifest(@MaybeNull Manifest manifest) {
                        if (manifest == null) {
                            throw new IllegalStateException("Required a manifest but no manifest was found");
                        }
                    }
                }
                ;
                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
                }
                public void onError(TypeDescription typeDescription, List<Throwable> throwables) {
                }
                public void onError(Map<TypeDescription, List<Throwable>> throwables) {
                }
                public void onError(Plugin plugin, Throwable throwable) {
                }
                public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
                }
                public void onUnresolved(String typeName) {
                }
                public void onManifest(@MaybeNull Manifest manifest) {
                }
                public void onResource(String name) {
                }
            }
            class Compound implements ErrorHandler {
                private final List<ErrorHandler> errorHandlers;
                public Compound(ErrorHandler... errorHandler) {
                    this(Arrays.asList(errorHandler));
                }
                public Compound(List<? extends ErrorHandler> errorHandlers) {
                    this.errorHandlers = new ArrayList<ErrorHandler>();
                    for (ErrorHandler errorHandler : errorHandlers) {
                        if (errorHandler instanceof Compound) {
                            this.errorHandlers.addAll(((Compound) errorHandler).errorHandlers);
                        } else if (!(errorHandler instanceof Listener.NoOp)) {
                            this.errorHandlers.add(errorHandler);
                        }
                    }
                }
                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
                    for (ErrorHandler errorHandler : errorHandlers) {
                        errorHandler.onError(typeDescription, plugin, throwable);
                    }
                }
                public void onError(TypeDescription typeDescription, List<Throwable> throwables) {
                    for (ErrorHandler errorHandler : errorHandlers) {
                        errorHandler.onError(typeDescription, throwables);
                    }
                }
                public void onError(Map<TypeDescription, List<Throwable>> throwables) {
                    for (ErrorHandler errorHandler : errorHandlers) {
                        errorHandler.onError(throwables);
                    }
                }
                public void onError(Plugin plugin, Throwable throwable) {
                    for (ErrorHandler errorHandler : errorHandlers) {
                        errorHandler.onError(plugin, throwable);
                    }
                }
                public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
                    for (ErrorHandler errorHandler : errorHandlers) {
                        errorHandler.onLiveInitializer(typeDescription, definingType);
                    }
                }
                public void onUnresolved(String typeName) {
                    for (ErrorHandler errorHandler : errorHandlers) {
                        errorHandler.onUnresolved(typeName);
                    }
                }
                public void onManifest(@MaybeNull Manifest manifest) {
                    for (ErrorHandler errorHandler : errorHandlers) {
                        errorHandler.onManifest(manifest);
                    }
                }
                public void onResource(String name) {
                    for (ErrorHandler errorHandler : errorHandlers) {
                        errorHandler.onResource(name);
                    }
                }
            }
        }
        interface Listener extends ErrorHandler {
            void onDiscovery(String typeName);
            void onTransformation(TypeDescription typeDescription, Plugin plugin);
            void onTransformation(TypeDescription typeDescription, List<Plugin> plugins);
            void onIgnored(TypeDescription typeDescription, Plugin plugin);
            void onIgnored(TypeDescription typeDescription, List<Plugin> plugins);
            void onComplete(TypeDescription typeDescription);
            enum NoOp implements Listener {
                INSTANCE;
                public void onDiscovery(String typeName) {
                }
                public void onTransformation(TypeDescription typeDescription, Plugin plugin) {
                }
                public void onTransformation(TypeDescription typeDescription, List<Plugin> plugins) {
                }
                public void onIgnored(TypeDescription typeDescription, Plugin plugin) {
                }
                public void onIgnored(TypeDescription typeDescription, List<Plugin> plugins) {
                }
                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
                }
                public void onError(TypeDescription typeDescription, List<Throwable> throwables) {
                }
                public void onError(Map<TypeDescription, List<Throwable>> throwables) {
                }
                public void onError(Plugin plugin, Throwable throwable) {
                }
                public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
                }
                public void onComplete(TypeDescription typeDescription) {
                }
                public void onUnresolved(String typeName) {
                }
                public void onManifest(@MaybeNull Manifest manifest) {
                }
                public void onResource(String name) {
                }
            }
            abstract class Adapter implements Listener {
                public void onDiscovery(String typeName) {
                }
                public void onTransformation(TypeDescription typeDescription, Plugin plugin) {
                }
                public void onTransformation(TypeDescription typeDescription, List<Plugin> plugins) {
                }
                public void onIgnored(TypeDescription typeDescription, Plugin plugin) {
                }
                public void onIgnored(TypeDescription typeDescription, List<Plugin> plugins) {
                }
                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
                }
                public void onError(TypeDescription typeDescription, List<Throwable> throwables) {
                }
                public void onError(Map<TypeDescription, List<Throwable>> throwables) {
                }
                public void onError(Plugin plugin, Throwable throwable) {
                }
                public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
                }
                public void onComplete(TypeDescription typeDescription) {
                }
                public void onUnresolved(String typeName) {
                }
                public void onManifest(@MaybeNull Manifest manifest) {
                }
                public void onResource(String name) {
                }
            }
            class StreamWriting extends Adapter {
                protected static final String PREFIX = "[Byte Buddy]";
                private final PrintStream printStream;
                public StreamWriting(PrintStream printStream) {
                    this.printStream = printStream;
                }
                public static StreamWriting toSystemOut() {
                    return new StreamWriting(System.out);
                }
                public static StreamWriting toSystemError() {
                    return new StreamWriting(System.err);
                }
                public Listener withTransformationsOnly() {
                    return new WithTransformationsOnly(this);
                }
                public Listener withErrorsOnly() {
                    return new WithErrorsOnly(this);
                }
                public void onDiscovery(String typeName) {
                    printStream.printf(PREFIX + " DISCOVERY %s", typeName);
                }
                public void onTransformation(TypeDescription typeDescription, Plugin plugin) {
                    printStream.printf(PREFIX + " TRANSFORM %s for %s", typeDescription, plugin);
                }
                public void onIgnored(TypeDescription typeDescription, Plugin plugin) {
                    printStream.printf(PREFIX + " IGNORE %s for %s", typeDescription, plugin);
                }
                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
                    synchronized (printStream) {
                        printStream.printf(PREFIX + " ERROR %s for %s", typeDescription, plugin);
                        throwable.printStackTrace(printStream);
                    }
                }
                public void onError(Plugin plugin, Throwable throwable) {
                    synchronized (printStream) {
                        printStream.printf(PREFIX + " ERROR %s", plugin);
                        throwable.printStackTrace(printStream);
                    }
                }
                public void onUnresolved(String typeName) {
                    printStream.printf(PREFIX + " UNRESOLVED %s", typeName);
                }
                public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
                    printStream.printf(PREFIX + " LIVE %s on %s", typeDescription, definingType);
                }
                public void onComplete(TypeDescription typeDescription) {
                    printStream.printf(PREFIX + " COMPLETE %s", typeDescription);
                }
                public void onManifest(@MaybeNull Manifest manifest) {
                    printStream.printf(PREFIX + " MANIFEST %b", manifest != null);
                }
                public void onResource(String name) {
                    printStream.printf(PREFIX + " RESOURCE %s", name);
                }
            }
            class WithTransformationsOnly extends Adapter {
                private final Listener delegate;
                public WithTransformationsOnly(Listener delegate) {
                    this.delegate = delegate;
                }
                public void onTransformation(TypeDescription typeDescription, Plugin plugin) {
                    delegate.onTransformation(typeDescription, plugin);
                }
                public void onTransformation(TypeDescription typeDescription, List<Plugin> plugins) {
                    delegate.onTransformation(typeDescription, plugins);
                }
                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
                    delegate.onError(typeDescription, plugin, throwable);
                }
                public void onError(TypeDescription typeDescription, List<Throwable> throwables) {
                    delegate.onError(typeDescription, throwables);
                }
                public void onError(Map<TypeDescription, List<Throwable>> throwables) {
                    delegate.onError(throwables);
                }
                public void onError(Plugin plugin, Throwable throwable) {
                    delegate.onError(plugin, throwable);
                }
            }
            class WithErrorsOnly extends Adapter {
                private final Listener delegate;
                public WithErrorsOnly(Listener delegate) {
                    this.delegate = delegate;
                }
                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
                    delegate.onError(typeDescription, plugin, throwable);
                }
                public void onError(TypeDescription typeDescription, List<Throwable> throwables) {
                    delegate.onError(typeDescription, throwables);
                }
                public void onError(Map<TypeDescription, List<Throwable>> throwables) {
                    delegate.onError(throwables);
                }
                public void onError(Plugin plugin, Throwable throwable) {
                    delegate.onError(plugin, throwable);
                }
            }
            class ForErrorHandler extends Adapter {
                private final ErrorHandler errorHandler;
                public ForErrorHandler(ErrorHandler errorHandler) {
                    this.errorHandler = errorHandler;
                }
                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
                    errorHandler.onError(typeDescription, plugin, throwable);
                }
                public void onError(TypeDescription typeDescription, List<Throwable> throwables) {
                    errorHandler.onError(typeDescription, throwables);
                }
                public void onError(Map<TypeDescription, List<Throwable>> throwables) {
                    errorHandler.onError(throwables);
                }
                public void onError(Plugin plugin, Throwable throwable) {
                    errorHandler.onError(plugin, throwable);
                }
                public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
                    errorHandler.onLiveInitializer(typeDescription, definingType);
                }
                public void onUnresolved(String typeName) {
                    errorHandler.onUnresolved(typeName);
                }
                public void onManifest(@MaybeNull Manifest manifest) {
                    errorHandler.onManifest(manifest);
                }
                public void onResource(String name) {
                    errorHandler.onResource(name);
                }
            }
            class Compound implements Listener {
                private final List<Listener> listeners;
                public Compound(Listener... listener) {
                    this(Arrays.asList(listener));
                }
                public Compound(List<? extends Listener> listeners) {
                    this.listeners = new ArrayList<Listener>();
                    for (Listener listener : listeners) {
                        if (listener instanceof Listener.Compound) {
                            this.listeners.addAll(((Listener.Compound) listener).listeners);
                        } else if (!(listener instanceof NoOp)) {
                            this.listeners.add(listener);
                        }
                    }
                }
                public void onDiscovery(String typeName) {
                    for (Listener listener : listeners) {
                        listener.onDiscovery(typeName);
                    }
                }
                public void onTransformation(TypeDescription typeDescription, Plugin plugin) {
                    for (Listener listener : listeners) {
                        listener.onTransformation(typeDescription, plugin);
                    }
                }
                public void onTransformation(TypeDescription typeDescription, List<Plugin> plugins) {
                    for (Listener listener : listeners) {
                        listener.onTransformation(typeDescription, plugins);
                    }
                }
                public void onIgnored(TypeDescription typeDescription, Plugin plugin) {
                    for (Listener listener : listeners) {
                        listener.onIgnored(typeDescription, plugin);
                    }
                }
                public void onIgnored(TypeDescription typeDescription, List<Plugin> plugins) {
                    for (Listener listener : listeners) {
                        listener.onIgnored(typeDescription, plugins);
                    }
                }
                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
                    for (Listener listener : listeners) {
                        listener.onError(typeDescription, plugin, throwable);
                    }
                }
                public void onError(TypeDescription typeDescription, List<Throwable> throwables) {
                    for (Listener listener : listeners) {
                        listener.onError(typeDescription, throwables);
                    }
                }
                public void onError(Map<TypeDescription, List<Throwable>> throwables) {
                    for (Listener listener : listeners) {
                        listener.onError(throwables);
                    }
                }
                public void onError(Plugin plugin, Throwable throwable) {
                    for (Listener listener : listeners) {
                        listener.onError(plugin, throwable);
                    }
                }
                public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
                    for (Listener listener : listeners) {
                        listener.onLiveInitializer(typeDescription, definingType);
                    }
                }
                public void onComplete(TypeDescription typeDescription) {
                    for (Listener listener : listeners) {
                        listener.onComplete(typeDescription);
                    }
                }
                public void onUnresolved(String typeName) {
                    for (Listener listener : listeners) {
                        listener.onUnresolved(typeName);
                    }
                }
                public void onManifest(@MaybeNull Manifest manifest) {
                    for (Listener listener : listeners) {
                        listener.onManifest(manifest);
                    }
                }
                public void onResource(String name) {
                    for (Listener listener : listeners) {
                        listener.onResource(name);
                    }
                }
            }
        }
        interface Source {
            Origin read() throws IOException;
            interface Origin extends Iterable<Element>, Closeable {
                Manifest NO_MANIFEST = null;
                Manifest getManifest() throws IOException;
                ClassFileLocator toClassFileLocator(@MaybeNull ClassFileVersion classFileVersion) throws IOException;
                class ForJarFile implements Origin {
                    private final JarFile file;
                    public ForJarFile(JarFile file) {
                        this.file = file;
                    }
                    public Manifest getManifest() throws IOException {
                        return file.getManifest();
                    }
                    public ClassFileLocator toClassFileLocator(@MaybeNull ClassFileVersion classFileVersion) throws IOException {
                        return classFileVersion == null ? new ClassFileLocator.ForJarFile(file) : ClassFileLocator.ForJarFile.of(file, classFileVersion);
                    }
                    public void close() throws IOException {
                        file.close();
                    }
                    public Iterator<Element> iterator() {
                        return new JarFileIterator(file.entries());
                    }
                    protected class JarFileIterator implements Iterator<Element> {
                        private final Enumeration<JarEntry> enumeration;
                        protected JarFileIterator(Enumeration<JarEntry> enumeration) {
                            this.enumeration = enumeration;
                        }
                        public boolean hasNext() {
                            return enumeration.hasMoreElements();
                        }
                        public Element next() {
                            return new Element.ForJarEntry(file, enumeration.nextElement());
                        }
                        public void remove() {
                            throw new UnsupportedOperationException("remove");
                        }
                    }
                }
                class Filtering implements Origin {
                    private final Origin delegate;
                    private final ElementMatcher<Element> matcher;
                    private final boolean manifest;
                    public Filtering(Origin delegate, ElementMatcher<Element> matcher) {
                        this(delegate, matcher, true);
                    }
                    public Filtering(Origin delegate, ElementMatcher<Element> matcher, boolean manifest) {
                        this.delegate = delegate;
                        this.matcher = matcher;
                        this.manifest = manifest;
                    }
                    public Manifest getManifest() throws IOException {
                        return manifest ? delegate.getManifest() : NO_MANIFEST;
                    }
                    public ClassFileLocator toClassFileLocator(@MaybeNull ClassFileVersion classFileVersion) throws IOException {
                        return delegate.toClassFileLocator(classFileVersion);
                    }
                    public Iterator<Element> iterator() {
                        return new FilteringIterator(delegate.iterator(), matcher);
                    }
                    public void close() throws IOException {
                        delegate.close();
                    }
                    private static class FilteringIterator implements Iterator<Element> {
                        private final Iterator<Element> iterator;
                        private final ElementMatcher<Element> matcher;
                        private Element current;
                        private FilteringIterator(Iterator<Element> iterator, ElementMatcher<Element> matcher) {
                            this.iterator = iterator;
                            this.matcher = matcher;
                            Element element;
                            while (iterator.hasNext()) {
                                element = iterator.next();
                                if (matcher.matches(element)) {
                                    current = element;
                                    break;
                                }
                            }
                        }
                        public boolean hasNext() {
                            return current != null;
                        }
                        public Element next() {
                            if (current == null) {
                                throw new NoSuchElementException();
                            }
                            try {
                                return current;
                            } finally {
                                current = null;
                                Element element;
                                while (iterator.hasNext()) {
                                    element = iterator.next();
                                    if (matcher.matches(element)) {
                                        current = element;
                                        break;
                                    }
                                }
                            }
                        }
                        public void remove() {
                            iterator.remove();
                        }
                    }
                }
            }
            interface Element {
                String getName();
                InputStream getInputStream() throws IOException;
                <T> T resolveAs(Class<T> type);
                class ForByteArray implements Element {
                    private final String name;
                    private final byte[] binaryRepresentation;
                    public ForByteArray(String name, byte[] binaryRepresentation) {
                        this.name = name;
                        this.binaryRepresentation = binaryRepresentation;
                    }
                    public String getName() {
                        return name;
                    }
                    public InputStream getInputStream() {
                        return new ByteArrayInputStream(binaryRepresentation);
                    }
                    public <T> T resolveAs(Class<T> type) {
                        return null;
                    }
                }
                class ForFile implements Element {
                    private final File root;
                    private final File file;
                    public ForFile(File root, File file) {
                        this.root = root;
                        this.file = file;
                    }
                    public String getName() {
                        return root.getAbsoluteFile().toURI().relativize(file.getAbsoluteFile().toURI()).getPath();
                    }
                    public InputStream getInputStream() throws IOException {
                        return new FileInputStream(file);
                    }
                    public <T> T resolveAs(Class<T> type) {
                        return File.class.isAssignableFrom(type) ? (T) file : null;
                    }
                }
                class ForJarEntry implements Element {
                    private final JarFile file;
                    private final JarEntry entry;
                    public ForJarEntry(JarFile file, JarEntry entry) {
                        this.file = file;
                        this.entry = entry;
                    }
                    public String getName() {
                        return entry.getName();
                    }
                    public InputStream getInputStream() throws IOException {
                        return file.getInputStream(entry);
                    }
                    public <T> T resolveAs(Class<T> type) {
                        return JarEntry.class.isAssignableFrom(type) ? (T) entry : null;
                    }
                }
            }
            enum Empty implements Source, Origin {
                INSTANCE;
                public Origin read() {
                    return this;
                }
                public ClassFileLocator toClassFileLocator(@MaybeNull ClassFileVersion classFileVersion) {
                    return ClassFileLocator.NoOp.INSTANCE;
                }
                public Manifest getManifest() {
                    return NO_MANIFEST;
                }
                public Iterator<Element> iterator() {
                    return Collections.<Element>emptySet().iterator();
                }
                public void close() {
                }
            }
            class Compound implements Source {
                private final Collection<? extends Source> sources;
                public Compound(Collection<? extends Source> sources) {
                    this.sources = sources;
                }
                public Source.Origin read() throws IOException {
                    if (sources.isEmpty()) {
                        return Empty.INSTANCE;
                    } else if (sources.size() == 1) {
                        return sources.iterator().next().read();
                    }
                    List<Source.Origin> origins = new ArrayList<Source.Origin>(sources.size());
                    try {
                        for (Source source : sources) {
                            origins.add(source.read());
                        }
                    } catch (IOException exception) {
                        for (Source.Origin origin : origins) {
                            origin.close();
                        }
                        throw exception;
                    }
                    return new Origin(origins);
                }
                protected static class Origin implements Source.Origin {
                    private final List<Source.Origin> origins;
                    protected Origin(List<Source.Origin> origins) {
                        this.origins = origins;
                    }
                    public Manifest getManifest() throws IOException {
                        for (Source.Origin origin : origins) {
                            Manifest manifest = origin.getManifest();
                            if (manifest != null) {
                                return manifest;
                            }
                        }
                        return NO_MANIFEST;
                    }
                    public ClassFileLocator toClassFileLocator(@MaybeNull ClassFileVersion classFileVersion) throws IOException {
                        List<ClassFileLocator> classFileLocators = new ArrayList<ClassFileLocator>(origins.size());
                        for (Source.Origin origin : origins) {
                            classFileLocators.add(origin.toClassFileLocator(classFileVersion));
                        }
                        return new ClassFileLocator.Compound(classFileLocators);
                    }
                    public Iterator<Element> iterator() {
                        return new CompoundIterator(origins);
                    }
                    public void close() throws IOException {
                        for (Source.Origin origin : origins) {
                            origin.close();
                        }
                    }
                    protected static class CompoundIterator implements Iterator<Element> {
                        private Iterator<? extends Element> current;
                        private final Queue<? extends Iterable<? extends Element>> backlog;
                        protected CompoundIterator(List<? extends Iterable<? extends Element>> iterables) {
                            backlog = QueueFactory.make(iterables);
                            forward();
                        }
                        public boolean hasNext() {
                            return current != null && current.hasNext();
                        }
                        public Element next() {
                            try {
                                if (current != null) {
                                    return current.next();
                                } else {
                                    throw new NoSuchElementException();
                                }
                            } finally {
                                forward();
                            }
                        }
                        private void forward() {
                            while ((current == null || !current.hasNext()) && !backlog.isEmpty()) {
                                current = backlog.remove().iterator();
                            }
                        }
                        public void remove() {
                            throw new UnsupportedOperationException("remove");
                        }
                    }
                }
            }
            class InMemory implements Source, Origin {
                private final Map<String, byte[]> storage;
                public InMemory(Map<String, byte[]> storage) {
                    this.storage = storage;
                }
                public static Source ofTypes(Class<?>... type) {
                    return ofTypes(Arrays.asList(type));
                }
                public static Source ofTypes(Collection<? extends Class<?>> types) {
                    return ofTypes(types, Collections.<ClassFileVersion, Collection<? extends Class<?>>>emptyMap());
                }
                public static Source ofTypes(Collection<? extends Class<?>> types, Map<ClassFileVersion, Collection<? extends Class<?>>> versionedTypes) {
                    Map<ClassFileVersion, Map<TypeDescription, byte[]>> versionedBinaryRepresentations = new HashMap<ClassFileVersion, Map<TypeDescription, byte[]>>();
                    for (Map.Entry<ClassFileVersion, Collection<? extends Class<?>>> entry : versionedTypes.entrySet()) {
                        Map<TypeDescription, byte[]> binaryRepresentations = new HashMap<TypeDescription, byte[]>();
                        for (Class<?> type : entry.getValue()) {
                            binaryRepresentations.put(TypeDescription.ForLoadedType.of(type), ClassFileLocator.ForClassLoader.read(type));
                        }
                        versionedBinaryRepresentations.put(entry.getKey(), binaryRepresentations);
                    }
                    Map<TypeDescription, byte[]> binaryRepresentations = new HashMap<TypeDescription, byte[]>();
                    for (Class<?> type : types) {
                        binaryRepresentations.put(TypeDescription.ForLoadedType.of(type), ClassFileLocator.ForClassLoader.read(type));
                    }
                    return ofTypes(binaryRepresentations, versionedBinaryRepresentations);
                }
                public static Source ofTypes(Map<TypeDescription, byte[]> binaryRepresentations) {
                    return ofTypes(binaryRepresentations, Collections.<ClassFileVersion, Map<TypeDescription, byte[]>>emptyMap());
                }
                public static Source ofTypes(Map<TypeDescription, byte[]> binaryRepresentations, Map<ClassFileVersion, Map<TypeDescription, byte[]>> versionedBinaryRepresentations) {
                    Map<String, byte[]> storage = new HashMap<String, byte[]>();
                    for (Map.Entry<TypeDescription, byte[]> entry : binaryRepresentations.entrySet()) {
                        storage.put(entry.getKey().getInternalName() + ClassFileLocator.CLASS_FILE_EXTENSION, entry.getValue());
                    }
                    for (Map.Entry<ClassFileVersion, Map<TypeDescription, byte[]>> versioned : versionedBinaryRepresentations.entrySet()) {
                        for (Map.Entry<TypeDescription, byte[]> entry : versioned.getValue().entrySet()) {
                            storage.put(ClassFileLocator.META_INF_VERSIONS + versioned.getKey().getJavaVersion() + "/" + entry.getKey().getInternalName() + ClassFileLocator.CLASS_FILE_EXTENSION, entry.getValue());
                        }
                    }
                    return new InMemory(storage);
                }
                public Origin read() {
                    return this;
                }
                public ClassFileLocator toClassFileLocator(@MaybeNull ClassFileVersion classFileVersion) {
                    return ClassFileLocator.Simple.ofResources(storage);
                }
                public Manifest getManifest() throws IOException {
                    byte[] binaryRepresentation = storage.get(JarFile.MANIFEST_NAME);
                    if (binaryRepresentation == null) {
                        return NO_MANIFEST;
                    } else {
                        return new Manifest(new ByteArrayInputStream(binaryRepresentation));
                    }
                }
                public Iterator<Element> iterator() {
                    return new MapEntryIterator(storage.entrySet().iterator());
                }
                public void close() {
                }
                protected static class MapEntryIterator implements Iterator<Element> {
                    private final Iterator<Map.Entry<String, byte[]>> iterator;
                    protected MapEntryIterator(Iterator<Map.Entry<String, byte[]>> iterator) {
                        this.iterator = iterator;
                    }
                    public boolean hasNext() {
                        return iterator.hasNext();
                    }
                    public Element next() {
                        Map.Entry<String, byte[]> entry = iterator.next();
                        return new Element.ForByteArray(entry.getKey(), entry.getValue());
                    }
                    public void remove() {
                        throw new UnsupportedOperationException("remove");
                    }
                }
            }
            class ForFolder implements Source, Origin {
                private final File folder;
                public ForFolder(File folder) {
                    this.folder = folder;
                }
                public Origin read() {
                    return this;
                }
                public ClassFileLocator toClassFileLocator(@MaybeNull ClassFileVersion classFileVersion) throws IOException {
                    return classFileVersion == null ? new ClassFileLocator.ForFolder(folder) : ClassFileLocator.ForFolder.of(folder, classFileVersion);
                }
                public Manifest getManifest() throws IOException {
                    File file = new File(folder, JarFile.MANIFEST_NAME);
                    if (file.exists()) {
                        InputStream inputStream = new FileInputStream(file);
                        try {
                            return new Manifest(inputStream);
                        } finally {
                            inputStream.close();
                        }
                    } else {
                        return NO_MANIFEST;
                    }
                }
                public Iterator<Element> iterator() {
                    return new FolderIterator(folder);
                }
                public void close() {
                }
                protected class FolderIterator implements Iterator<Element> {
                    private final Queue<File> files;
                    protected FolderIterator(File folder) {
                        files = QueueFactory.make();
                        File[] file = folder.listFiles();
                        if (file != null) {
                            for (File candidate : file) {
                                if (!candidate.equals(new File(folder, JarFile.MANIFEST_NAME))) {
                                    files.add(candidate);
                                }
                            }
                        }
                    }
                    public boolean hasNext() {
                        return !files.isEmpty();
                    }
                    public Element next() {
                        File next = files.remove();
                        if (next.isDirectory()) {
                            File[] file = next.listFiles();
                            if (file != null) {
                                for (File candidate : file) {
                                    if (!candidate.equals(new File(folder, JarFile.MANIFEST_NAME))) {
                                        files.add(candidate);
                                    }
                                }
                            }
                        }
                        return new Element.ForFile(folder, next);
                    }
                    public void remove() {
                        throw new UnsupportedOperationException("remove");
                    }
                }
            }
            class ForJarFile implements Source {
                private final File file;
                public ForJarFile(File file) {
                    this.file = file;
                }
                public Origin read() throws IOException {
                    return new Origin.ForJarFile(new JarFile(file, false));
                }
            }
            class Filtering implements Source {
                private final Source delegate;
                private final ElementMatcher<Element> matcher;
                private final boolean manifest;
                public Filtering(Source delegate, ElementMatcher<Element> matcher) {
                    this(delegate, matcher, true);
                }
                public Filtering(Source delegate, ElementMatcher<Element> matcher, boolean manifest) {
                    this.delegate = delegate;
                    this.matcher = matcher;
                    this.manifest = manifest;
                }
                public static Source dropMultiReleaseClassFilesAbove(Source delegate, ClassFileVersion classFileVersion) {
                    return new Filtering(delegate, new MultiReleaseVersionMatcher(classFileVersion));
                }
                public static Source dropFolders(Source delegate) {
                    return new Filtering(delegate, NoFolderMatcher.INSTANCE);
                }
                public Origin read() throws IOException {
                    return new Origin.Filtering(delegate.read(), matcher, manifest);
                }
                protected static class MultiReleaseVersionMatcher implements ElementMatcher<Element> {
                    private final ClassFileVersion classFileVersion;
                    protected MultiReleaseVersionMatcher(ClassFileVersion classFileVersion) {
                        this.classFileVersion = classFileVersion;
                    }
                    public boolean matches(@MaybeNull Element target) {
                        if (target == null) {
                            return true;
                        }
                        String name = target.getName();
                        if (name.startsWith("/")) {
                            name = name.substring(1);
                        }
                        if (name.startsWith(ClassFileLocator.META_INF_VERSIONS)) {
                            int version;
                            try {
                                version = Integer.parseInt(name.substring(ClassFileLocator.META_INF_VERSIONS.length(), name.indexOf('/', ClassFileLocator.META_INF_VERSIONS.length())));
                            } catch (NumberFormatException ignored) {
                                return true;
                            }
                            return version <= classFileVersion.getJavaVersion();
                        }
                        return true;
                    }
                }
                protected enum NoFolderMatcher implements ElementMatcher<Element> {
                    INSTANCE;
                    public boolean matches(@MaybeNull Element target) {
                        return target == null || !target.getName().endsWith("/");
                    }
                }
            }
        }
        interface Target {
            Sink write(@MaybeNull Manifest manifest) throws IOException;
            interface Sink extends Closeable {
                void store(Map<TypeDescription, byte[]> binaryRepresentations) throws IOException;
                void store(ClassFileVersion classFileVersion, Map<TypeDescription, byte[]> binaryRepresentations) throws IOException;
                void retain(Source.Element element) throws IOException;
                class ForJarOutputStream implements Sink {
                    private final JarOutputStream outputStream;
                    public ForJarOutputStream(JarOutputStream outputStream) {
                        this.outputStream = outputStream;
                    }
                    public void store(Map<TypeDescription, byte[]> binaryRepresentations) throws IOException {
                        for (Map.Entry<TypeDescription, byte[]> entry : binaryRepresentations.entrySet()) {
                            outputStream.putNextEntry(new JarEntry(entry.getKey().getInternalName() + ClassFileLocator.CLASS_FILE_EXTENSION));
                            outputStream.write(entry.getValue());
                            outputStream.closeEntry();
                        }
                    }
                    public void store(ClassFileVersion classFileVersion, Map<TypeDescription, byte[]> binaryRepresentations) throws IOException {
                        for (Map.Entry<TypeDescription, byte[]> entry : binaryRepresentations.entrySet()) {
                            outputStream.putNextEntry(new JarEntry(ClassFileLocator.META_INF_VERSIONS + classFileVersion.getJavaVersion() + "/" + entry.getKey().getInternalName() + ClassFileLocator.CLASS_FILE_EXTENSION));
                            outputStream.write(entry.getValue());
                            outputStream.closeEntry();
                        }
                    }
                    public void retain(Source.Element element) throws IOException {
                        JarEntry entry = element.resolveAs(JarEntry.class);
                        String name = element.getName();
                        outputStream.putNextEntry(entry == null ? new JarEntry(name) : entry);
                        if (entry != null || !name.endsWith("/")) {
                            InputStream inputStream = element.getInputStream();
                            try {
                                byte[] buffer = new byte[1024];
                                int length;
                                while ((length = inputStream.read(buffer)) != -1) {
                                    outputStream.write(buffer, 0, length);
                                }
                            } finally {
                                inputStream.close();
                            }
                        }
                        outputStream.closeEntry();
                    }
                    public void close() throws IOException {
                        outputStream.close();
                    }
                }
            }
            enum Discarding implements Target, Sink {
                INSTANCE;
                public Sink write(@MaybeNull Manifest manifest) {
                    return this;
                }
                public void store(Map<TypeDescription, byte[]> binaryRepresentations) {
                }
                public void store(ClassFileVersion classFileVersion, Map<TypeDescription, byte[]> binaryRepresentations) throws IOException {
                }
                public void retain(Source.Element element) {
                }
                public void close() {
                }
            }
            class InMemory implements Target, Sink {
                private final Map<String, byte[]> storage;
                public InMemory() {
                    this(new HashMap<String, byte[]>());
                }
                public InMemory(Map<String, byte[]> storage) {
                    this.storage = storage;
                }
                public Sink write(@MaybeNull Manifest manifest) throws IOException {
                    if (manifest != null) {
                        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                        try {
                            manifest.write(outputStream);
                        } finally {
                            outputStream.close();
                        }
                        storage.put(JarFile.MANIFEST_NAME, outputStream.toByteArray());
                    }
                    return this;
                }
                public void store(Map<TypeDescription, byte[]> binaryRepresentations) {
                    for (Map.Entry<TypeDescription, byte[]> entry : binaryRepresentations.entrySet()) {
                        storage.put(entry.getKey().getInternalName() + ClassFileLocator.CLASS_FILE_EXTENSION, entry.getValue());
                    }
                }
                public void store(ClassFileVersion classFileVersion, Map<TypeDescription, byte[]> binaryRepresentations) throws IOException {
                    for (Map.Entry<TypeDescription, byte[]> entry : binaryRepresentations.entrySet()) {
                        storage.put(ClassFileLocator.META_INF_VERSIONS + classFileVersion.getJavaVersion() + "/" + entry.getKey().getInternalName() + ClassFileLocator.CLASS_FILE_EXTENSION, entry.getValue());
                    }
                }
                public void retain(Source.Element element) throws IOException {
                    String name = element.getName();
                    if (!name.endsWith("/")) {
                        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                        try {
                            InputStream inputStream = element.getInputStream();
                            try {
                                byte[] buffer = new byte[1024];
                                int length;
                                while ((length = inputStream.read(buffer)) != -1) {
                                    outputStream.write(buffer, 0, length);
                                }
                            } finally {
                                inputStream.close();
                            }
                        } finally {
                            outputStream.close();
                        }
                        storage.put(element.getName(), outputStream.toByteArray());
                    }
                }
                public void close() {
                }
                public Map<String, byte[]> getStorage() {
                    return storage;
                }
                public Map<String, byte[]> toTypeMap() {
                    Map<String, byte[]> binaryRepresentations = new HashMap<String, byte[]>();
                    for (Map.Entry<String, byte[]> entry : storage.entrySet()) {
                        if (entry.getKey().endsWith(ClassFileLocator.CLASS_FILE_EXTENSION) && !entry.getKey().startsWith(ClassFileLocator.META_INF_VERSIONS)) {
                            binaryRepresentations.put(entry.getKey().substring(0, entry.getKey().length() - ClassFileLocator.CLASS_FILE_EXTENSION.length()).replace('/', '.'), entry.getValue());
                        }
                    }
                    return binaryRepresentations;
                }
                public Map<String, byte[]> toTypeMap(ClassFileVersion classFileVersion) {
                    Map<String, byte[]> binaryRepresentations = new HashMap<String, byte[]>();
                    Map<String, Integer> versions = new HashMap<String, Integer>();
                    for (Map.Entry<String, byte[]> entry : storage.entrySet()) {
                        if (entry.getKey().endsWith(ClassFileLocator.CLASS_FILE_EXTENSION)) {
                            String suffix;
                            int version;
                            if (entry.getKey().startsWith(ClassFileLocator.META_INF_VERSIONS)) {
                                suffix = entry.getKey().substring(entry.getKey().indexOf('/', ClassFileLocator.META_INF_VERSIONS.length()) + 1);
                                try {
                                    int candidate = Integer.parseInt(entry.getKey().substring(ClassFileLocator.META_INF_VERSIONS.length(), entry.getKey().indexOf('/', ClassFileLocator.META_INF_VERSIONS.length())));
                                    if (candidate < 7 || candidate > classFileVersion.getJavaVersion()) {
                                        continue;
                                    }
                                    version = candidate;
                                } catch (NumberFormatException ignored) {
                                    continue;
                                }
                            } else {
                                suffix = entry.getKey();
                                version = 0;
                            }
                            Integer current = versions.get(suffix);
                            if (current == null || current < version) {
                                versions.put(suffix, version);
                                binaryRepresentations.put(suffix.substring(0, suffix.length() - ClassFileLocator.CLASS_FILE_EXTENSION.length()).replace('/', '.'), entry.getValue());
                            }
                        }
                    }
                    return binaryRepresentations;
                }
            }
            class ForFolder implements Target, Sink {
                private final File folder;
                private final boolean link;
                public ForFolder(File folder) {
                    this(folder, false);
                }
                public ForFolder(File folder, boolean link) {
                    this.folder = folder;
                    this.link = link;
                }
                private static void doStore(File folder, Map<TypeDescription, byte[]> binaryRepresentations) throws IOException {
                    for (Map.Entry<TypeDescription, byte[]> entry : binaryRepresentations.entrySet()) {
                        File target = new File(folder, entry.getKey().getInternalName() + ClassFileLocator.CLASS_FILE_EXTENSION);
                        if (!target.getParentFile().isDirectory() && !target.getParentFile().mkdirs()) {
                            throw new IOException("Could not create directory: " + target.getParent());
                        }
                        OutputStream outputStream = new FileOutputStream(target);
                        try {
                            outputStream.write(entry.getValue());
                        } finally {
                            outputStream.close();
                        }
                    }
                }
                public Sink write(@MaybeNull Manifest manifest) throws IOException {
                    if (manifest != null) {
                        File target = new File(folder, JarFile.MANIFEST_NAME);
                        if (!target.getParentFile().isDirectory() && !target.getParentFile().mkdirs()) {
                            throw new IOException("Could not create directory: " + target.getParent());
                        }
                        OutputStream outputStream = new FileOutputStream(target);
                        try {
                            manifest.write(outputStream);
                        } finally {
                            outputStream.close();
                        }
                    }
                    return this;
                }
                public void store(Map<TypeDescription, byte[]> binaryRepresentations) throws IOException {
                    doStore(folder, binaryRepresentations);
                }
                public void store(ClassFileVersion classFileVersion, Map<TypeDescription, byte[]> binaryRepresentations) throws IOException {
                    doStore(new File(folder, ClassFileLocator.META_INF_VERSIONS + classFileVersion.getJavaVersion()), binaryRepresentations);
                }
                public void retain(Source.Element element) throws IOException {
                    String name = element.getName();
                    File target = new File(folder, name);
                    if (!name.endsWith("/")) {
                        File resolved = element.resolveAs(File.class);
                        if (!target.getCanonicalPath().startsWith(folder.getCanonicalPath() + File.separatorChar)) {
                            throw new IllegalArgumentException(target + " is not a subdirectory of " + folder);
                        } else if (!target.getParentFile().isDirectory() && !target.getParentFile().mkdirs()) {
                            throw new IOException("Could not create directory: " + target.getParent());
                        } else if (resolved != null && !resolved.equals(target)) {
                            if (link) {
                                FileSystem.getInstance().link(resolved, target);
                            } else {
                                FileSystem.getInstance().copy(resolved, target);
                            }
                        } else if (!target.equals(resolved)) {
                            InputStream inputStream = element.getInputStream();
                            try {
                                OutputStream outputStream = new FileOutputStream(target);
                                try {
                                    byte[] buffer = new byte[1024];
                                    int length;
                                    while ((length = inputStream.read(buffer)) != -1) {
                                        outputStream.write(buffer, 0, length);
                                    }
                                } finally {
                                    outputStream.close();
                                }
                            } finally {
                                inputStream.close();
                            }
                        }
                    } else if (!target.isDirectory() && !target.mkdirs()) {
                        throw new IllegalStateException("Cannot create requested directory: " + target);
                    }
                }
                public void close() {
                }
            }
            class ForJarFile implements Target {
                private final File file;
                public ForJarFile(File file) {
                    this.file = file;
                }
                public Sink write(@MaybeNull Manifest manifest) throws IOException {
                    OutputStream outputStream = new FileOutputStream(file);
                    try {
                        return manifest == null ? new Sink.ForJarOutputStream(new JarOutputStream(outputStream)) : new Sink.ForJarOutputStream(new JarOutputStream(outputStream, manifest));
                    } catch (RuntimeException exception) {
                        outputStream.close();
                        throw exception;
                    } catch (IOException exception) {
                        outputStream.close();
                        throw exception;
                    } catch (Error error) {
                        outputStream.close();
                        throw error;
                    }
                }
            }
        }
        interface Dispatcher extends Closeable {
            void accept(Callable<? extends Callable<? extends Materializable>> work, boolean eager) throws IOException;
            void complete() throws IOException;
            interface Materializable {
                void materialize(Target.Sink sink, List<TypeDescription> transformed, Map<TypeDescription, List<Throwable>> failed, List<String> unresolved) throws IOException;
                class ForTransformedElement implements Materializable {
                    private final ClassFileVersion classFileVersion;
                    private final DynamicType dynamicType;
                    protected ForTransformedElement(@MaybeNull ClassFileVersion classFileVersion, DynamicType dynamicType) {
                        this.classFileVersion = classFileVersion;
                        this.dynamicType = dynamicType;
                    }
                    public void materialize(Target.Sink sink, List<TypeDescription> transformed, Map<TypeDescription, List<Throwable>> failed, List<String> unresolved) throws IOException {
                        if (classFileVersion == null) {
                            sink.store(dynamicType.getAllTypes());
                        } else {
                            sink.store(classFileVersion, dynamicType.getAllTypes());
                        }
                        transformed.add(dynamicType.getTypeDescription());
                    }
                }
                class ForRetainedElement implements Materializable {
                    private final Source.Element element;
                    protected ForRetainedElement(Source.Element element) {
                        this.element = element;
                    }
                    public void materialize(Target.Sink sink, List<TypeDescription> transformed, Map<TypeDescription, List<Throwable>> failed, List<String> unresolved) throws IOException {
                        sink.retain(element);
                    }
                }
                class ForFailedElement implements Materializable {
                    private final Source.Element element;
                    private final TypeDescription typeDescription;
                    private final List<Throwable> errored;
                    protected ForFailedElement(Source.Element element, TypeDescription typeDescription, List<Throwable> errored) {
                        this.element = element;
                        this.typeDescription = typeDescription;
                        this.errored = errored;
                    }
                    public void materialize(Target.Sink sink, List<TypeDescription> transformed, Map<TypeDescription, List<Throwable>> failed, List<String> unresolved) throws IOException {
                        sink.retain(element);
                        failed.put(typeDescription, errored);
                    }
                }
                class ForUnresolvedElement implements Materializable {
                    private final Source.Element element;
                    private final String typeName;
                    protected ForUnresolvedElement(Source.Element element, String typeName) {
                        this.element = element;
                        this.typeName = typeName;
                    }
                    public void materialize(Target.Sink sink, List<TypeDescription> transformed, Map<TypeDescription, List<Throwable>> failed, List<String> unresolved) throws IOException {
                        sink.retain(element);
                        unresolved.add(typeName);
                    }
                }
            }
            interface Factory {
                Dispatcher make(Target.Sink sink, List<TypeDescription> transformed, Map<TypeDescription, List<Throwable>> failed, List<String> unresolved);
            }
            class ForSerialTransformation implements Dispatcher {
                private final Target.Sink sink;
                private final List<TypeDescription> transformed;
                private final Map<TypeDescription, List<Throwable>> failed;
                private final List<String> unresolved;
                private final List<Callable<? extends Materializable>> preprocessings;
                protected ForSerialTransformation(Target.Sink sink, List<TypeDescription> transformed, Map<TypeDescription, List<Throwable>> failed, List<String> unresolved) {
                    this.sink = sink;
                    this.transformed = transformed;
                    this.failed = failed;
                    this.unresolved = unresolved;
                    preprocessings = new ArrayList<Callable<? extends Materializable>>();
                }
                public void accept(Callable<? extends Callable<? extends Materializable>> work, boolean eager) throws IOException {
                    try {
                        Callable<? extends Materializable> preprocessed = work.call();
                        if (eager) {
                            preprocessed.call().materialize(sink, transformed, failed, unresolved);
                        } else {
                            preprocessings.add(preprocessed);
                        }
                    } catch (Exception exception) {
                        if (exception instanceof IOException) {
                            throw (IOException) exception;
                        } else if (exception instanceof RuntimeException) {
                            throw (RuntimeException) exception;
                        } else {
                            throw new IllegalStateException(exception);
                        }
                    }
                }
                public void complete() throws IOException {
                    for (Callable<? extends Materializable> preprocessing : preprocessings) {
                        if (Thread.interrupted()) {
                            Thread.currentThread().interrupt();
                            throw new IllegalStateException("Interrupted during plugin engine completion");
                        }
                        try {
                            preprocessing.call().materialize(sink, transformed, failed, unresolved);
                        } catch (Exception exception) {
                            if (exception instanceof IOException) {
                                throw (IOException) exception;
                            } else if (exception instanceof RuntimeException) {
                                throw (RuntimeException) exception;
                            } else {
                                throw new IllegalStateException(exception);
                            }
                        }
                    }
                }
                public void close() {
                }
                public enum Factory implements Dispatcher.Factory {
                    INSTANCE;
                    public Dispatcher make(Target.Sink sink, List<TypeDescription> transformed, Map<TypeDescription, List<Throwable>> failed, List<String> unresolved) {
                        return new ForSerialTransformation(sink, transformed, failed, unresolved);
                    }
                }
            }
            class ForParallelTransformation implements Dispatcher {
                private final Target.Sink sink;
                private final List<TypeDescription> transformed;
                private final Map<TypeDescription, List<Throwable>> failed;
                private final List<String> unresolved;
                private final CompletionService<Callable<Materializable>> preprocessings;
                private final CompletionService<Materializable> materializers;
                private int deferred;
                private final Set<Future<?>> futures;
                protected ForParallelTransformation(Executor executor, Target.Sink sink, List<TypeDescription> transformed, Map<TypeDescription, List<Throwable>> failed, List<String> unresolved) {
                    this.sink = sink;
                    this.transformed = transformed;
                    this.failed = failed;
                    this.unresolved = unresolved;
                    preprocessings = new ExecutorCompletionService<Callable<Materializable>>(executor);
                    materializers = new ExecutorCompletionService<Materializable>(executor);
                    futures = new HashSet<Future<?>>();
                }
                public void accept(Callable<? extends Callable<? extends Materializable>> work, boolean eager) {
                    if (eager) {
                        futures.add(materializers.submit(new EagerWork(work)));
                    } else {
                        deferred += 1;
                        futures.add(preprocessings.submit((Callable<Callable<Materializable>>) work));
                    }
                }
                public void complete() throws IOException {
                    try {
                        List<Callable<Materializable>> preprocessings = new ArrayList<Callable<Materializable>>(deferred);
                        while (deferred-- > 0) {
                            Future<Callable<Materializable>> future = this.preprocessings.take();
                            futures.remove(future);
                            preprocessings.add(future.get());
                        }
                        for (Callable<Materializable> preprocessing : preprocessings) {
                            futures.add(materializers.submit(preprocessing));
                        }
                        while (!futures.isEmpty()) {
                            Future<Materializable> future = materializers.take();
                            futures.remove(future);
                            future.get().materialize(sink, transformed, failed, unresolved);
                        }
                    } catch (InterruptedException exception) {
                        Thread.currentThread().interrupt();
                        throw new IllegalStateException(exception);
                    } catch (ExecutionException exception) {
                        Throwable cause = exception.getCause();
                        if (cause instanceof IOException) {
                            throw (IOException) cause;
                        } else if (cause instanceof RuntimeException) {
                            throw (RuntimeException) cause;
                        } else if (cause instanceof Error) {
                            throw (Error) cause;
                        } else {
                            throw new IllegalStateException(cause);
                        }
                    }
                }
                public void close() {
                    for (Future<?> future : futures) {
                        future.cancel(true);
                    }
                }
                public static class WithThrowawayExecutorService extends ForParallelTransformation {
                    private final ExecutorService executorService;
                    protected WithThrowawayExecutorService(ExecutorService executorService, Target.Sink sink, List<TypeDescription> transformed, Map<TypeDescription, List<Throwable>> failed, List<String> unresolved) {
                        super(executorService, sink, transformed, failed, unresolved);
                        this.executorService = executorService;
                    }
                    public void close() {
                        try {
                            super.close();
                        } finally {
                            executorService.shutdown();
                        }
                    }
                    public static class Factory implements Dispatcher.Factory {
                        private final int threads;
                        public Factory(int threads) {
                            this.threads = threads;
                        }
                        public Dispatcher make(Target.Sink sink, List<TypeDescription> transformed, Map<TypeDescription, List<Throwable>> failed, List<String> unresolved) {
                            return new WithThrowawayExecutorService(Executors.newFixedThreadPool(threads), sink, transformed, failed, unresolved);
                        }
                    }
                }
                public static class Factory implements Dispatcher.Factory {
                    private final Executor executor;
                    public Factory(Executor executor) {
                        this.executor = executor;
                    }
                    public Dispatcher make(Target.Sink sink, List<TypeDescription> transformed, Map<TypeDescription, List<Throwable>> failed, List<String> unresolved) {
                        return new ForParallelTransformation(executor, sink, transformed, failed, unresolved);
                    }
                }
                protected static class EagerWork implements Callable<Materializable> {
                    private final Callable<? extends Callable<? extends Materializable>> work;
                    protected EagerWork(Callable<? extends Callable<? extends Materializable>> work) {
                        this.work = work;
                    }
                    public Materializable call() throws Exception {
                        return work.call().call();
                    }
                }
            }
        }
        class Summary {
            private final List<TypeDescription> transformed;
            private final Map<TypeDescription, List<Throwable>> failed;
            private final List<String> unresolved;
            public Summary(List<TypeDescription> transformed, Map<TypeDescription, List<Throwable>> failed, List<String> unresolved) {
                this.transformed = transformed;
                this.failed = failed;
                this.unresolved = unresolved;
            }
            public List<TypeDescription> getTransformed() {
                return transformed;
            }
            public Map<TypeDescription, List<Throwable>> getFailed() {
                return failed;
            }
            public List<String> getUnresolved() {
                return unresolved;
            }
            public int hashCode() {
                int result = transformed.hashCode();
                result = 31 * result + failed.hashCode();
                result = 31 * result + unresolved.hashCode();
                return result;
            }
            public boolean equals(@MaybeNull Object other) {
                if (this == other) {
                    return true;
                } else if (other == null || getClass() != other.getClass()) {
                    return false;
                }
                Summary summary = (Summary) other;
                return transformed.equals(summary.transformed) && failed.equals(summary.failed) && unresolved.equals(summary.unresolved);
            }
        }
        abstract class AbstractBase implements Engine {
            public Engine withErrorHandlers(ErrorHandler... errorHandler) {
                return withErrorHandlers(Arrays.asList(errorHandler));
            }
            public Engine withParallelTransformation(int threads) {
                if (threads < 1) {
                    throw new IllegalArgumentException("Number of threads must be positive: " + threads);
                }
                return with(new Dispatcher.ForParallelTransformation.WithThrowawayExecutorService.Factory(threads));
            }
            public Summary apply(File source, File target, Factory... factory) throws IOException {
                return apply(source, target, Arrays.asList(factory));
            }
            public Summary apply(File source, File target, List<? extends Factory> factories) throws IOException {
                return apply(source.isDirectory() ? new Source.ForFolder(source) : new Source.ForJarFile(source), target.isDirectory() ? new Target.ForFolder(target) : new Target.ForJarFile(target), factories);
            }
            public Summary apply(Source source, Target target, Factory... factory) throws IOException {
                return apply(source, target, Arrays.asList(factory));
            }
        }
        class Default extends AbstractBase {
            private final ByteBuddy byteBuddy;
            private final TypeStrategy typeStrategy;
            private final PoolStrategy poolStrategy;
            private final ClassFileLocator classFileLocator;
            private final ClassFileVersion classFileVersion;
            private final Listener listener;
            private final ErrorHandler errorHandler;
            private final Dispatcher.Factory dispatcherFactory;
            private final ElementMatcher.Junction<? super TypeDescription> ignoredTypeMatcher;
            public Default() {
                this(new ByteBuddy());
            }
            public Default(ByteBuddy byteBuddy) {
                this(byteBuddy, TypeStrategy.Default.REBASE);
            }
            protected Default(ByteBuddy byteBuddy, TypeStrategy typeStrategy) {
                this(byteBuddy, typeStrategy, PoolStrategy.Default.FAST, ClassFileLocator.NoOp.INSTANCE, null, Listener.NoOp.INSTANCE, new ErrorHandler.Compound(ErrorHandler.Failing.FAIL_FAST, ErrorHandler.Enforcing.ALL_TYPES_RESOLVED, ErrorHandler.Enforcing.NO_LIVE_INITIALIZERS), Dispatcher.ForSerialTransformation.Factory.INSTANCE, none());
            }
            protected Default(ByteBuddy byteBuddy, TypeStrategy typeStrategy, PoolStrategy poolStrategy, ClassFileLocator classFileLocator, @MaybeNull ClassFileVersion classFileVersion, Listener listener, ErrorHandler errorHandler, Dispatcher.Factory dispatcherFactory, ElementMatcher.Junction<? super TypeDescription> ignoredTypeMatcher) {
                this.byteBuddy = byteBuddy;
                this.typeStrategy = typeStrategy;
                this.poolStrategy = poolStrategy;
                this.classFileLocator = classFileLocator;
                this.classFileVersion = classFileVersion;
                this.listener = listener;
                this.errorHandler = errorHandler;
                this.dispatcherFactory = dispatcherFactory;
                this.ignoredTypeMatcher = ignoredTypeMatcher;
            }
            public static Engine of(EntryPoint entryPoint, ClassFileVersion classFileVersion, MethodNameTransformer methodNameTransformer) {
                return new Default(entryPoint.byteBuddy(classFileVersion), new TypeStrategy.ForEntryPoint(entryPoint, methodNameTransformer));
            }
            public static Set<String> scan(ClassLoader classLoader) throws IOException {
                Set<String> plugins = new HashSet<String>();
                Enumeration<URL> enumeration = classLoader.getResources(PLUGIN_FILE);
                while (enumeration.hasMoreElements()) {
                    BufferedReader reader = new BufferedReader(new InputStreamReader(enumeration.nextElement().openStream(), "UTF-8"));
                    try {
                        String line;
                        while ((line = reader.readLine()) != null) {
                            plugins.add(line);
                        }
                    } finally {
                        reader.close();
                    }
                }
                return plugins;
            }
            public static void main(String... argument) throws ClassNotFoundException, IOException {
                if (argument.length < 2) {
                    throw new IllegalArgumentException("Expected arguments: <source> <target> [<plugin>, ...]");
                }
                List<Plugin.Factory> factories = new ArrayList<Factory>(argument.length - 2);
                for (String plugin : Arrays.asList(argument).subList(2, argument.length)) {
                    factories.add(new Factory.UsingReflection((Class<? extends Plugin>) Class.forName(plugin)));
                }
                new Default().apply(new File(argument[0]), new File(argument[1]), factories);
            }
            public Engine with(ByteBuddy byteBuddy) {
                return new Default(byteBuddy, typeStrategy, poolStrategy, classFileLocator, classFileVersion, listener, errorHandler, dispatcherFactory, ignoredTypeMatcher);
            }
            public Engine with(TypeStrategy typeStrategy) {
                return new Default(byteBuddy, typeStrategy, poolStrategy, classFileLocator, classFileVersion, listener, errorHandler, dispatcherFactory, ignoredTypeMatcher);
            }
            public Engine with(PoolStrategy poolStrategy) {
                return new Default(byteBuddy, typeStrategy, poolStrategy, classFileLocator, classFileVersion, listener, errorHandler, dispatcherFactory, ignoredTypeMatcher);
            }
            public Engine with(ClassFileLocator classFileLocator) {
                return new Default(byteBuddy, typeStrategy, poolStrategy, new ClassFileLocator.Compound(this.classFileLocator, classFileLocator), classFileVersion, listener, errorHandler, dispatcherFactory, ignoredTypeMatcher);
            }
            public Engine with(@MaybeNull ClassFileVersion classFileVersion) {
                return new Default(byteBuddy, typeStrategy, poolStrategy, classFileLocator, classFileVersion, listener, errorHandler, dispatcherFactory, ignoredTypeMatcher);
            }
            public Engine with(Listener listener) {
                return new Default(byteBuddy, typeStrategy, poolStrategy, classFileLocator, classFileVersion, new Listener.Compound(this.listener, listener), errorHandler, dispatcherFactory, ignoredTypeMatcher);
            }
            public Engine withoutErrorHandlers() {
                return new Default(byteBuddy, typeStrategy, poolStrategy, classFileLocator, classFileVersion, listener, Listener.NoOp.INSTANCE, dispatcherFactory, ignoredTypeMatcher);
            }
            public Engine withErrorHandlers(List<? extends ErrorHandler> errorHandlers) {
                return new Default(byteBuddy, typeStrategy, poolStrategy, classFileLocator, classFileVersion, listener, new ErrorHandler.Compound(errorHandlers), dispatcherFactory, ignoredTypeMatcher);
            }
            public Engine with(Dispatcher.Factory dispatcherFactory) {
                return new Default(byteBuddy, typeStrategy, poolStrategy, classFileLocator, classFileVersion, listener, errorHandler, dispatcherFactory, ignoredTypeMatcher);
            }
            public Engine ignore(ElementMatcher<? super TypeDescription> matcher) {
                return new Default(byteBuddy, typeStrategy, poolStrategy, classFileLocator, classFileVersion, listener, errorHandler, dispatcherFactory, ignoredTypeMatcher.<TypeDescription>or(matcher));
            }
            public Summary apply(Source source, Target target, List<? extends Plugin.Factory> factories) throws IOException {
                Listener listener = new Listener.Compound(this.listener, new Listener.ForErrorHandler(errorHandler));
                List<TypeDescription> transformed = new ArrayList<TypeDescription>();
                Map<TypeDescription, List<Throwable>> failed = new LinkedHashMap<TypeDescription, List<Throwable>>();
                List<String> unresolved = new ArrayList<String>();
                Throwable rethrown = null;
                List<Plugin> plugins = new ArrayList<Plugin>(factories.size());
                List<WithInitialization> initializers = new ArrayList<WithInitialization>();
                List<WithPreprocessor> preprocessors = new ArrayList<WithPreprocessor>();
                try {
                    for (Plugin.Factory factory : factories) {
                        Plugin plugin = factory.make();
                        plugins.add(plugin);
                        if (plugin instanceof WithPreprocessor) {
                            preprocessors.add((WithPreprocessor) plugin);
                        }
                        if (plugin instanceof WithInitialization) {
                            initializers.add((WithInitialization) plugin);
                        }
                    }
                    Source.Origin origin = source.read();
                    try {
                        ClassFileLocator classFileLocator = new ClassFileLocator.Compound(origin.toClassFileLocator(classFileVersion), this.classFileLocator);
                        TypePool typePool = poolStrategy.typePool(classFileLocator);
                        Manifest manifest = origin.getManifest();
                        listener.onManifest(manifest);
                        Target.Sink sink = target.write(manifest);
                        try {
                            for (WithInitialization initializer : initializers) {
                                sink.store(initializer.initialize(classFileLocator));
                            }
                            Dispatcher dispatcher = dispatcherFactory.make(sink, transformed, failed, unresolved);
                            try {
                                for (Source.Element element : origin) {
                                    if (Thread.interrupted()) {
                                        Thread.currentThread().interrupt();
                                        throw new IllegalStateException("Thread interrupted during plugin engine application");
                                    }
                                    String name = element.getName();
                                    while (name.startsWith("/")) {
                                        name = name.substring(1);
                                    }
                                    if (name.endsWith(ClassFileLocator.CLASS_FILE_EXTENSION) && (!name.startsWith("META-INF") || name.startsWith(ClassFileLocator.META_INF_VERSIONS))) {
                                        try {
                                            ClassFileVersion classFileVersion = name.startsWith(ClassFileLocator.META_INF_VERSIONS) ? ClassFileVersion.ofJavaVersion(Integer.parseInt(name.substring(ClassFileLocator.META_INF_VERSIONS.length(), name.indexOf('/', ClassFileLocator.META_INF_VERSIONS.length())))) : null;
                                            if (classFileVersion == null || classFileVersion.isAtLeast(ClassFileVersion.JAVA_V8) && this.classFileVersion != null && this.classFileVersion.isAtLeast(ClassFileVersion.JAVA_V9) && classFileVersion.isAtMost(this.classFileVersion)) {
                                                String typeName = name.substring(name.startsWith(ClassFileLocator.META_INF_VERSIONS) ? name.indexOf('/', ClassFileLocator.META_INF_VERSIONS.length()) + 1 : 0, name.length() - ClassFileLocator.CLASS_FILE_EXTENSION.length()).replace('/', '.');
                                                dispatcher.accept(new Preprocessor(element, typeName, new SourceEntryPrependingClassFileLocator(typeName, element, classFileLocator), classFileVersion, typePool, listener, plugins, preprocessors), preprocessors.isEmpty());
                                            } else {
                                                listener.onResource(name);
                                                sink.retain(element);
                                            }
                                        } catch (NumberFormatException ignored) {
                                            listener.onResource(name);
                                            sink.retain(element);
                                        }
                                    } else if (!name.equals(JarFile.MANIFEST_NAME)) {
                                        listener.onResource(name);
                                        sink.retain(element);
                                    }
                                }
                                dispatcher.complete();
                            } finally {
                                dispatcher.close();
                            }
                            if (!failed.isEmpty()) {
                                listener.onError(failed);
                            }
                        } finally {
                            sink.close();
                        }
                    } finally {
                        origin.close();
                    }
                } finally {
                    for (Plugin plugin : plugins) {
                        try {
                            plugin.close();
                        } catch (Throwable throwable) {
                            try {
                                listener.onError(plugin, throwable);
                            } catch (Throwable chained) {
                                rethrown = rethrown == null ? chained : rethrown;
                            }
                        }
                    }
                }
                if (rethrown == null) {
                    return new Summary(transformed, failed, unresolved);
                } else if (rethrown instanceof IOException) {
                    throw (IOException) rethrown;
                } else if (rethrown instanceof RuntimeException) {
                    throw (RuntimeException) rethrown;
                } else {
                    throw new IllegalStateException(rethrown);
                }
            }
            protected static class SourceEntryPrependingClassFileLocator implements ClassFileLocator {
                private final String name;
                private final Source.Element element;
                private final ClassFileLocator delegate;
                protected SourceEntryPrependingClassFileLocator(String name, Source.Element element, ClassFileLocator delegate) {
                    this.name = name;
                    this.element = element;
                    this.delegate = delegate;
                }
                public Resolution locate(String name) throws IOException {
                    if (name.endsWith(this.name)) {
                        InputStream inputStream = element.getInputStream();
                        try {
                            return new Resolution.Explicit(StreamDrainer.DEFAULT.drain(inputStream));
                        } finally {
                            inputStream.close();
                        }
                    } else {
                        return delegate.locate(name);
                    }
                }
                public void close() throws IOException {
                    delegate.close();
                }
            }
            private class Preprocessor implements Callable<Callable<? extends Dispatcher.Materializable>> {
                private final Source.Element element;
                private final String typeName;
                private final ClassFileLocator classFileLocator;
                private final ClassFileVersion classFileVersion;
                private final TypePool typePool;
                private final Listener listener;
                private final List<Plugin> plugins;
                private final List<WithPreprocessor> preprocessors;
                private Preprocessor(Source.Element element, String typeName, ClassFileLocator classFileLocator, @MaybeNull ClassFileVersion classFileVersion, TypePool typePool, Listener listener, List<Plugin> plugins, List<WithPreprocessor> preprocessors) {
                    this.element = element;
                    this.typeName = typeName;
                    this.classFileLocator = classFileLocator;
                    this.classFileVersion = classFileVersion;
                    this.typePool = typePool;
                    this.listener = listener;
                    this.plugins = plugins;
                    this.preprocessors = preprocessors;
                }
                public Callable<Dispatcher.Materializable> call() throws Exception {
                    listener.onDiscovery(typeName);
                    TypePool.Resolution resolution = typePool.describe(typeName);
                    if (resolution.isResolved()) {
                        TypeDescription typeDescription = resolution.resolve();
                        try {
                            if (!ignoredTypeMatcher.matches(typeDescription)) {
                                for (WithPreprocessor preprocessor : preprocessors) {
                                    preprocessor.onPreprocess(typeDescription, classFileLocator);
                                }
                                return new Resolved(classFileVersion, typeDescription);
                            } else {
                                return new Ignored(typeDescription);
                            }
                        } catch (Throwable throwable) {
                            listener.onComplete(typeDescription);
                            if (throwable instanceof Exception) {
                                throw (Exception) throwable;
                            } else if (throwable instanceof Error) {
                                throw (Error) throwable;
                            } else {
                                throw new IllegalStateException(throwable);
                            }
                        }
                    } else {
                        return new Unresolved();
                    }
                }
                private class Resolved implements Callable<Dispatcher.Materializable> {
                    private final ClassFileVersion classFileVersion;
                    private final TypeDescription typeDescription;
                    private Resolved(@MaybeNull ClassFileVersion classFileVersion, TypeDescription typeDescription) {
                        this.classFileVersion = classFileVersion;
                        this.typeDescription = typeDescription;
                    }
                    public Dispatcher.Materializable call() {
                        List<Plugin> applied = new ArrayList<Plugin>(), ignored = new ArrayList<Plugin>();
                        List<Throwable> errored = new ArrayList<Throwable>();
                        try {
                            DynamicType.Builder<?> builder = typeStrategy.builder(byteBuddy, typeDescription, classFileLocator);
                            for (Plugin plugin : plugins) {
                                try {
                                    if (plugin.matches(typeDescription)) {
                                        builder = plugin.apply(builder, typeDescription, classFileLocator);
                                        listener.onTransformation(typeDescription, plugin);
                                        applied.add(plugin);
                                    } else {
                                        listener.onIgnored(typeDescription, plugin);
                                        ignored.add(plugin);
                                    }
                                } catch (Throwable throwable) {
                                    listener.onError(typeDescription, plugin, throwable);
                                    errored.add(throwable);
                                }
                            }
                            if (!errored.isEmpty()) {
                                listener.onError(typeDescription, errored);
                                return new Dispatcher.Materializable.ForFailedElement(element, typeDescription, errored);
                            } else if (!applied.isEmpty()) {
                                try {
                                    DynamicType dynamicType = builder.make(TypeResolutionStrategy.Disabled.INSTANCE, typePool);
                                    listener.onTransformation(typeDescription, applied);
                                    for (Map.Entry<TypeDescription, LoadedTypeInitializer> entry : dynamicType.getLoadedTypeInitializers().entrySet()) {
                                        if (entry.getValue().isAlive()) {
                                            listener.onLiveInitializer(typeDescription, entry.getKey());
                                        }
                                    }
                                    return new Dispatcher.Materializable.ForTransformedElement(classFileVersion, dynamicType);
                                } catch (Throwable throwable) {
                                    errored.add(throwable);
                                    listener.onError(typeDescription, errored);
                                    return new Dispatcher.Materializable.ForFailedElement(element, typeDescription, errored);
                                }
                            } else {
                                listener.onIgnored(typeDescription, ignored);
                                return new Dispatcher.Materializable.ForRetainedElement(element);
                            }
                        } finally {
                            listener.onComplete(typeDescription);
                        }
                    }
                }
                private class Ignored implements Callable<Dispatcher.Materializable> {
                    private final TypeDescription typeDescription;
                    private Ignored(TypeDescription typeDescription) {
                        this.typeDescription = typeDescription;
                    }
                    public Dispatcher.Materializable call() {
                        try {
                            listener.onIgnored(typeDescription, plugins);
                        } finally {
                            listener.onComplete(typeDescription);
                        }
                        return new Dispatcher.Materializable.ForRetainedElement(element);
                    }
                }
                private class Unresolved implements Callable<Dispatcher.Materializable> {
                    public Dispatcher.Materializable call() {
                        listener.onUnresolved(typeName);
                        return new Dispatcher.Materializable.ForUnresolvedElement(element, typeName);
                    }
                }
            }
        }
    }
    class NoOp implements Plugin, Plugin.Factory {
        public Plugin make() {
            return this;
        }
        public boolean matches(@MaybeNull TypeDescription target) {
            return false;
        }
        public DynamicType.Builder<?> apply(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassFileLocator classFileLocator) {
            throw new IllegalStateException("Cannot apply non-operational plugin");
        }
        public void close() {
        }
    }
    abstract class ForElementMatcher implements Plugin {
        private final ElementMatcher<? super TypeDescription> matcher;
        protected ForElementMatcher(ElementMatcher<? super TypeDescription> matcher) {
            this.matcher = matcher;
        }
        public boolean matches(@MaybeNull TypeDescription target) {
            return matcher.matches(target);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```