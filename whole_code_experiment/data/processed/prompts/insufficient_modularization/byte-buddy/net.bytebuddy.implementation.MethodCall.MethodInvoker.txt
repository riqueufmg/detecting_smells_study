##CONTEXT_SIZE=13238
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.implementation;
public class MethodCall implements Implementation.Composable {
    protected final MethodLocator.Factory methodLocator;
    protected final TargetHandler.Factory targetHandler;
    protected final List<ArgumentLoader.Factory> argumentLoaders;
    protected final MethodInvoker.Factory methodInvoker;
    protected final TerminationHandler.Factory terminationHandler;
    protected final Assigner assigner;
    protected final Assigner.Typing typing;
    protected MethodCall(MethodLocator.Factory methodLocator, TargetHandler.Factory targetHandler, List<ArgumentLoader.Factory> argumentLoaders, MethodInvoker.Factory methodInvoker, TerminationHandler.Factory terminationHandler, Assigner assigner, Assigner.Typing typing) {
        this.methodLocator = methodLocator;
        this.targetHandler = targetHandler;
        this.argumentLoaders = argumentLoaders;
        this.methodInvoker = methodInvoker;
        this.terminationHandler = terminationHandler;
        this.assigner = assigner;
        this.typing = typing;
    }
    public static WithoutSpecifiedTarget invoke(Method method) {
        return invoke(new MethodDescription.ForLoadedMethod(method));
    }
    public static WithoutSpecifiedTarget invoke(Constructor<?> constructor) {
        return invoke(new MethodDescription.ForLoadedConstructor(constructor));
    }
    public static WithoutSpecifiedTarget invoke(MethodDescription methodDescription) {
        return invoke(new MethodLocator.ForExplicitMethod(methodDescription));
    }
    public static WithoutSpecifiedTarget invoke(ElementMatcher<? super MethodDescription> matcher) {
        return invoke(matcher, MethodGraph.Compiler.DEFAULT);
    }
    public static WithoutSpecifiedTarget invoke(ElementMatcher<? super MethodDescription> matcher, MethodGraph.Compiler methodGraphCompiler) {
        return invoke(new MethodLocator.ForElementMatcher.Factory(matcher, methodGraphCompiler));
    }
    public static WithoutSpecifiedTarget invoke(MethodLocator.Factory methodLocator) {
        return new WithoutSpecifiedTarget(methodLocator);
    }
    public static WithoutSpecifiedTarget invokeSelf() {
        return new WithoutSpecifiedTarget(MethodLocator.ForInstrumentedMethod.INSTANCE);
    }
    public static MethodCall invokeSuper() {
        return invokeSelf().onSuper();
    }
    public static Composable call(Callable<?> callable) {
        try {
            return invoke(Callable.class.getMethod("call")).on(callable, Callable.class).withAssigner(Assigner.DEFAULT, Assigner.Typing.DYNAMIC);
        } catch (NoSuchMethodException exception) {
            throw new IllegalStateException("Could not locate Callable::call method", exception);
        }
    }
    public static Composable run(Runnable runnable) {
        try {
            return invoke(Runnable.class.getMethod("run")).on(runnable, Runnable.class).withAssigner(Assigner.DEFAULT, Assigner.Typing.DYNAMIC);
        } catch (NoSuchMethodException exception) {
            throw new IllegalStateException("Could not locate Runnable::run method", exception);
        }
    }
    public static MethodCall construct(Constructor<?> constructor) {
        return construct(new MethodDescription.ForLoadedConstructor(constructor));
    }
    public static MethodCall construct(MethodDescription methodDescription) {
        if (!methodDescription.isConstructor()) {
            throw new IllegalArgumentException("Not a constructor: " + methodDescription);
        }
        return new MethodCall(new MethodLocator.ForExplicitMethod(methodDescription), TargetHandler.ForConstructingInvocation.Factory.INSTANCE, Collections.<ArgumentLoader.Factory>emptyList(), MethodInvoker.ForContextualInvocation.Factory.INSTANCE, TerminationHandler.Simple.RETURNING, Assigner.DEFAULT, Assigner.Typing.STATIC);
    }
    public MethodCall with(Object... argument) {
        List<ArgumentLoader.Factory> argumentLoaders = new ArrayList<ArgumentLoader.Factory>(argument.length);
        for (Object anArgument : argument) {
            argumentLoaders.add(ArgumentLoader.ForStackManipulation.of(anArgument));
        }
        return with(argumentLoaders);
    }
    public MethodCall with(TypeDescription... typeDescription) {
        List<ArgumentLoader.Factory> argumentLoaders = new ArrayList<ArgumentLoader.Factory>(typeDescription.length);
        for (TypeDescription aTypeDescription : typeDescription) {
            argumentLoaders.add(new ArgumentLoader.ForStackManipulation(ClassConstant.of(aTypeDescription), Class.class));
        }
        return with(argumentLoaders);
    }
    public MethodCall with(EnumerationDescription... enumerationDescription) {
        List<ArgumentLoader.Factory> argumentLoaders = new ArrayList<ArgumentLoader.Factory>(enumerationDescription.length);
        for (EnumerationDescription anEnumerationDescription : enumerationDescription) {
            argumentLoaders.add(new ArgumentLoader.ForStackManipulation(FieldAccess.forEnumeration(anEnumerationDescription), anEnumerationDescription.getEnumerationType()));
        }
        return with(argumentLoaders);
    }
    public MethodCall with(ConstantValue... constant) {
        List<ArgumentLoader.Factory> argumentLoaders = new ArrayList<ArgumentLoader.Factory>(constant.length);
        for (ConstantValue aConstant : constant) {
            argumentLoaders.add(new ArgumentLoader.ForStackManipulation(aConstant.toStackManipulation(), aConstant.getTypeDescription()));
        }
        return with(argumentLoaders);
    }
    public MethodCall with(JavaConstant... constant) {
        return with((ConstantValue[]) constant);
    }
    public MethodCall withReference(Object... argument) {
        List<ArgumentLoader.Factory> argumentLoaders = new ArrayList<ArgumentLoader.Factory>(argument.length);
        for (Object anArgument : argument) {
            argumentLoaders.add(anArgument == null ? ArgumentLoader.ForNullConstant.INSTANCE : new ArgumentLoader.ForInstance.Factory(anArgument));
        }
        return with(argumentLoaders);
    }
    public MethodCall withArgument(int... index) {
        List<ArgumentLoader.Factory> argumentLoaders = new ArrayList<ArgumentLoader.Factory>(index.length);
        for (int anIndex : index) {
            if (anIndex < 0) {
                throw new IllegalArgumentException("Negative index: " + anIndex);
            }
            argumentLoaders.add(new ArgumentLoader.ForMethodParameter.Factory(anIndex));
        }
        return with(argumentLoaders);
    }
    public MethodCall withAllArguments() {
        return with(ArgumentLoader.ForMethodParameter.OfInstrumentedMethod.INSTANCE);
    }
    public MethodCall withArgumentArray() {
        return with(ArgumentLoader.ForMethodParameterArray.ForInstrumentedMethod.INSTANCE);
    }
    public MethodCall withArgumentArrayElements(int index) {
        if (index < 0) {
            throw new IllegalArgumentException("A parameter index cannot be negative: " + index);
        }
        return with(new ArgumentLoader.ForMethodParameterArrayElement.OfInvokedMethod(index));
    }
    public MethodCall withArgumentArrayElements(int index, int size) {
        return withArgumentArrayElements(index, 0, size);
    }
    public MethodCall withArgumentArrayElements(int index, int start, int size) {
        if (index < 0) {
            throw new IllegalArgumentException("A parameter index cannot be negative: " + index);
        } else if (start < 0) {
            throw new IllegalArgumentException("An array index cannot be negative: " + start);
        } else if (size == 0) {
            return this;
        } else if (size < 0) {
            throw new IllegalArgumentException("Size cannot be negative: " + size);
        }
        List<ArgumentLoader.Factory> argumentLoaders = new ArrayList<ArgumentLoader.Factory>(size);
        for (int position = 0; position < size; position++) {
            argumentLoaders.add(new ArgumentLoader.ForMethodParameterArrayElement.OfParameter(index, start + position));
        }
        return with(argumentLoaders);
    }
    public MethodCall withThis() {
        return with(ArgumentLoader.ForThisReference.Factory.INSTANCE);
    }
    public MethodCall withOwnType() {
        return with(ArgumentLoader.ForInstrumentedType.Factory.INSTANCE);
    }
    public MethodCall withField(String... name) {
        return withField(FieldLocator.ForClassHierarchy.Factory.INSTANCE, name);
    }
    public MethodCall withField(FieldLocator.Factory fieldLocatorFactory, String... name) {
        List<ArgumentLoader.Factory> argumentLoaders = new ArrayList<ArgumentLoader.Factory>(name.length);
        for (String aName : name) {
            argumentLoaders.add(new ArgumentLoader.ForField.Factory(aName, fieldLocatorFactory));
        }
        return with(argumentLoaders);
    }
    public MethodCall withMethodCall(MethodCall methodCall) {
        return with(new ArgumentLoader.ForMethodCall.Factory(methodCall));
    }
    public MethodCall with(StackManipulation stackManipulation, Type type) {
        return with(stackManipulation, TypeDefinition.Sort.describe(type));
    }
    public MethodCall with(StackManipulation stackManipulation, TypeDefinition typeDefinition) {
        return with(new ArgumentLoader.ForStackManipulation(stackManipulation, typeDefinition));
    }
    public MethodCall with(ArgumentLoader.Factory... argumentLoader) {
        return with(Arrays.asList(argumentLoader));
    }
    public MethodCall with(List<? extends ArgumentLoader.Factory> argumentLoaders) {
        return new MethodCall(methodLocator, targetHandler, CompoundList.of(this.argumentLoaders, argumentLoaders), methodInvoker, terminationHandler, assigner, typing);
    }
    public FieldSetting setsField(Field field) {
        return setsField(new FieldDescription.ForLoadedField(field));
    }
    public FieldSetting setsField(FieldDescription fieldDescription) {
        return new FieldSetting(new MethodCall(methodLocator, targetHandler, argumentLoaders, methodInvoker, new TerminationHandler.FieldSetting.Explicit(fieldDescription), assigner, typing));
    }
    public FieldSetting setsField(ElementMatcher<? super FieldDescription> matcher) {
        return new FieldSetting(new MethodCall(methodLocator, targetHandler, argumentLoaders, methodInvoker, new TerminationHandler.FieldSetting.Implicit(matcher), assigner, typing));
    }
    public Composable withAssigner(Assigner assigner, Assigner.Typing typing) {
        return new MethodCall(methodLocator, targetHandler, argumentLoaders, methodInvoker, terminationHandler, assigner, typing);
    }
    public Implementation andThen(Implementation implementation) {
        return new Implementation.Compound(new MethodCall(methodLocator, targetHandler, argumentLoaders, methodInvoker, TerminationHandler.Simple.DROPPING, assigner, typing), implementation);
    }
    public Composable andThen(Composable implementation) {
        return new Implementation.Compound.Composable(new MethodCall(methodLocator, targetHandler, argumentLoaders, methodInvoker, TerminationHandler.Simple.DROPPING, assigner, typing), implementation);
    }
    public InstrumentedType prepare(InstrumentedType instrumentedType) {
        for (InstrumentedType.Prepareable prepareable : argumentLoaders) {
            instrumentedType = prepareable.prepare(instrumentedType);
        }
        return targetHandler.prepare(instrumentedType);
    }
    public ByteCodeAppender appender(Target implementationTarget) {
        return new Appender(implementationTarget, terminationHandler.make(implementationTarget.getInstrumentedType()));
    }
    public interface MethodLocator {
        MethodDescription resolve(TypeDescription targetType, MethodDescription instrumentedMethod);
        interface Factory {
            MethodLocator make(TypeDescription instrumentedType);
        }
        enum ForInstrumentedMethod implements MethodLocator, Factory {
            INSTANCE;
            public MethodLocator make(TypeDescription instrumentedType) {
                return this;
            }
            public MethodDescription resolve(TypeDescription targetType, MethodDescription instrumentedMethod) {
                return instrumentedMethod;
            }
        }
        class ForExplicitMethod implements MethodLocator, Factory {
            private final MethodDescription methodDescription;
            protected ForExplicitMethod(MethodDescription methodDescription) {
                this.methodDescription = methodDescription;
            }
            public MethodLocator make(TypeDescription instrumentedType) {
                return this;
            }
            public MethodDescription resolve(TypeDescription targetType, MethodDescription instrumentedMethod) {
                return methodDescription;
            }
        }
        class ForElementMatcher implements MethodLocator {
            private final TypeDescription instrumentedType;
            private final ElementMatcher<? super MethodDescription> matcher;
            private final MethodGraph.Compiler methodGraphCompiler;
            protected ForElementMatcher(TypeDescription instrumentedType, ElementMatcher<? super MethodDescription> matcher, MethodGraph.Compiler methodGraphCompiler) {
                this.instrumentedType = instrumentedType;
                this.matcher = matcher;
                this.methodGraphCompiler = methodGraphCompiler;
            }
            public MethodDescription resolve(TypeDescription targetType, MethodDescription instrumentedMethod) {
                TypeDescription.Generic superClass = instrumentedType.getSuperClass();
                List<MethodDescription> candidates = CompoundList.<MethodDescription>of(superClass == null ? Collections.<MethodDescription>emptyList() : superClass.getDeclaredMethods().filter(isConstructor().and(matcher)), instrumentedType.getDeclaredMethods().filter(not(ElementMatchers.isVirtual()).and(matcher)), methodGraphCompiler.compile((TypeDefinition) targetType, instrumentedType).listNodes().asMethodList().filter(matcher));
                if (candidates.size() == 1) {
                    return candidates.get(0);
                } else {
                    throw new IllegalStateException(instrumentedType + " does not define exactly one virtual method or constructor for " + matcher + " but contained " + candidates.size() + " candidates: " + candidates);
                }
            }
            public static class Factory implements MethodLocator.Factory {
                private final ElementMatcher<? super MethodDescription> matcher;
                private final MethodGraph.Compiler methodGraphCompiler;
                public Factory(ElementMatcher<? super MethodDescription> matcher, MethodGraph.Compiler methodGraphCompiler) {
                    this.matcher = matcher;
                    this.methodGraphCompiler = methodGraphCompiler;
                }
                public MethodLocator make(TypeDescription instrumentedType) {
                    return new ForElementMatcher(instrumentedType, matcher, methodGraphCompiler);
                }
            }
        }
    }
    public interface ArgumentLoader {
        StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing);
        interface ArgumentProvider {
            List<ArgumentLoader> resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod);
        }
        interface Factory extends InstrumentedType.Prepareable {
            ArgumentProvider make(Implementation.Target implementationTarget);
        }
        enum ForNullConstant implements ArgumentLoader, ArgumentProvider, Factory {
            INSTANCE;
            public InstrumentedType prepare(InstrumentedType instrumentedType) {
                return instrumentedType;
            }
            public ArgumentProvider make(Implementation.Target implementationTarget) {
                return this;
            }
            public List<ArgumentLoader> resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
                return Collections.<ArgumentLoader>singletonList(this);
            }
            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
                if (target.getType().isPrimitive()) {
                    throw new IllegalStateException("Cannot assign null to " + target);
                }
                return NullConstant.INSTANCE;
            }
        }
        class ForThisReference implements ArgumentLoader, ArgumentProvider {
            private final TypeDescription instrumentedType;
            public ForThisReference(TypeDescription instrumentedType) {
                this.instrumentedType = instrumentedType;
            }
            public List<ArgumentLoader> resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
                if (instrumentedMethod.isStatic()) {
                    throw new IllegalStateException(instrumentedMethod + " is static and cannot supply an invoker instance");
                }
                return Collections.<ArgumentLoader>singletonList(this);
            }
            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
                StackManipulation stackManipulation = new StackManipulation.Compound(MethodVariableAccess.loadThis(), assigner.assign(instrumentedType.asGenericType(), target.getType(), typing));
                if (!stackManipulation.isValid()) {
                    throw new IllegalStateException("Cannot assign " + instrumentedType + " to " + target);
                }
                return stackManipulation;
            }
            public enum Factory implements ArgumentLoader.Factory {
                INSTANCE;
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType;
                }
                public ArgumentProvider make(Implementation.Target implementationTarget) {
                    return new ForThisReference(implementationTarget.getInstrumentedType());
                }
            }
        }
        class ForInstrumentedType implements ArgumentLoader, ArgumentProvider {
            private final TypeDescription instrumentedType;
            public ForInstrumentedType(TypeDescription instrumentedType) {
                this.instrumentedType = instrumentedType;
            }
            public List<ArgumentLoader> resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
                return Collections.<ArgumentLoader>singletonList(this);
            }
            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
                StackManipulation stackManipulation = new StackManipulation.Compound(ClassConstant.of(instrumentedType), assigner.assign(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Class.class), target.getType(), typing));
                if (!stackManipulation.isValid()) {
                    throw new IllegalStateException("Cannot assign Class value to " + target);
                }
                return stackManipulation;
            }
            public enum Factory implements ArgumentLoader.Factory {
                INSTANCE;
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType;
                }
                public ArgumentProvider make(Implementation.Target implementationTarget) {
                    return new ForInstrumentedType(implementationTarget.getInstrumentedType());
                }
            }
        }
        class ForMethodParameter implements ArgumentLoader {
            private final int index;
            private final MethodDescription instrumentedMethod;
            public ForMethodParameter(int index, MethodDescription instrumentedMethod) {
                this.index = index;
                this.instrumentedMethod = instrumentedMethod;
            }
            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
                ParameterDescription parameterDescription = instrumentedMethod.getParameters().get(index);
                StackManipulation stackManipulation = new StackManipulation.Compound(MethodVariableAccess.load(parameterDescription), assigner.assign(parameterDescription.getType(), target.getType(), typing));
                if (!stackManipulation.isValid()) {
                    throw new IllegalStateException("Cannot assign " + parameterDescription + " to " + target + " for " + instrumentedMethod);
                }
                return stackManipulation;
            }
            protected enum OfInstrumentedMethod implements ArgumentLoader.Factory, ArgumentProvider {
                INSTANCE;
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType;
                }
                public ArgumentProvider make(Implementation.Target implementationTarget) {
                    return this;
                }
                public List<ArgumentLoader> resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
                    List<ArgumentLoader> argumentLoaders = new ArrayList<ArgumentLoader>(instrumentedMethod.getParameters().size());
                    for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {
                        argumentLoaders.add(new ForMethodParameter(parameterDescription.getIndex(), instrumentedMethod));
                    }
                    return argumentLoaders;
                }
            }
            public static class Factory implements ArgumentLoader.Factory, ArgumentProvider {
                private final int index;
                public Factory(int index) {
                    this.index = index;
                }
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType;
                }
                public ArgumentProvider make(Implementation.Target implementationTarget) {
                    return this;
                }
                public List<ArgumentLoader> resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
                    if (index >= instrumentedMethod.getParameters().size()) {
                        throw new IllegalStateException(instrumentedMethod + " does not have a parameter with index " + index + ", " + instrumentedMethod.getParameters().size() + " defined");
                    }
                    return Collections.<ArgumentLoader>singletonList(new ForMethodParameter(index, instrumentedMethod));
                }
            }
        }
        class ForMethodParameterArray implements ArgumentLoader {
            private final ParameterList<?> parameters;
            public ForMethodParameterArray(ParameterList<?> parameters) {
                this.parameters = parameters;
            }
            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
                TypeDescription.Generic componentType;
                if (target.getType().represents(Object.class)) {
                    componentType = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class);
                } else if (target.getType().isArray()) {
                    componentType = target.getType().getComponentType();
                } else {
                    throw new IllegalStateException("Cannot set method parameter array for non-array type: " + target);
                }
                List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(parameters.size());
                for (ParameterDescription parameter : parameters) {
                    StackManipulation stackManipulation = new StackManipulation.Compound(MethodVariableAccess.load(parameter), assigner.assign(parameter.getType(), componentType, typing));
                    if (stackManipulation.isValid()) {
                        stackManipulations.add(stackManipulation);
                    } else {
                        throw new IllegalStateException("Cannot assign " + parameter + " to " + componentType);
                    }
                }
                return new StackManipulation.Compound(ArrayFactory.forType(componentType).withValues(stackManipulations));
            }
            public enum ForInstrumentedMethod implements Factory, ArgumentProvider {
                INSTANCE;
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType;
                }
                public ArgumentProvider make(Implementation.Target implementationTarget) {
                    return this;
                }
                public List<ArgumentLoader> resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
                    return Collections.<ArgumentLoader>singletonList(new ForMethodParameterArray(instrumentedMethod.getParameters()));
                }
            }
        }
        class ForMethodParameterArrayElement implements ArgumentLoader {
            private final ParameterDescription parameterDescription;
            private final int index;
            public ForMethodParameterArrayElement(ParameterDescription parameterDescription, int index) {
                this.parameterDescription = parameterDescription;
                this.index = index;
            }
            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
                StackManipulation stackManipulation = new StackManipulation.Compound(MethodVariableAccess.load(parameterDescription), IntegerConstant.forValue(index), ArrayAccess.of(parameterDescription.getType().getComponentType()).load(), assigner.assign(parameterDescription.getType().getComponentType(), target.getType(), typing));
                if (!stackManipulation.isValid()) {
                    throw new IllegalStateException("Cannot assign " + parameterDescription.getType().getComponentType() + " to " + target);
                }
                return stackManipulation;
            }
            public static class OfParameter implements ArgumentLoader.Factory, ArgumentProvider {
                private final int index;
                private final int arrayIndex;
                public OfParameter(int index, int arrayIndex) {
                    this.index = index;
                    this.arrayIndex = arrayIndex;
                }
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType;
                }
                public ArgumentProvider make(Implementation.Target implementationTarget) {
                    return this;
                }
                public List<ArgumentLoader> resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
                    if (instrumentedMethod.getParameters().size() <= index) {
                        throw new IllegalStateException(instrumentedMethod + " does not declare a parameter with index " + index + ", " + instrumentedMethod.getParameters().size() + " defined");
                    } else if (!instrumentedMethod.getParameters().get(index).getType().isArray()) {
                        throw new IllegalStateException("Cannot access an item from non-array parameter " + instrumentedMethod.getParameters().get(index) + " at index " + index);
                    }
                    return Collections.<ArgumentLoader>singletonList(new ForMethodParameterArrayElement(instrumentedMethod.getParameters().get(index), arrayIndex));
                }
            }
            public static class OfInvokedMethod implements ArgumentLoader.Factory, ArgumentProvider {
                private final int index;
                public OfInvokedMethod(int index) {
                    this.index = index;
                }
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType;
                }
                public ArgumentProvider make(Implementation.Target implementationTarget) {
                    return this;
                }
                public List<ArgumentLoader> resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
                    if (instrumentedMethod.getParameters().size() <= index) {
                        throw new IllegalStateException(instrumentedMethod + " does not declare a parameter with index " + index + ", " + instrumentedMethod.getParameters().size() + " defined");
                    } else if (!instrumentedMethod.getParameters().get(index).getType().isArray()) {
                        throw new IllegalStateException("Cannot access an item from non-array parameter " + instrumentedMethod.getParameters().get(index) + " at index " + index);
                    }
                    List<ArgumentLoader> argumentLoaders = new ArrayList<ArgumentLoader>(invokedMethod.getParameters().size());
                    for (int index = 0; index < invokedMethod.getParameters().size(); index++) {
                        argumentLoaders.add(new ForMethodParameterArrayElement(instrumentedMethod.getParameters().get(this.index), index));
                    }
                    return argumentLoaders;
                }
            }
        }
        class ForInstance implements ArgumentLoader, ArgumentProvider {
            private final FieldDescription fieldDescription;
            public ForInstance(FieldDescription fieldDescription) {
                this.fieldDescription = fieldDescription;
            }
            public List<ArgumentLoader> resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
                return Collections.<ArgumentLoader>singletonList(this);
            }
            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
                StackManipulation stackManipulation = new StackManipulation.Compound(FieldAccess.forField(fieldDescription).read(), assigner.assign(fieldDescription.getType(), target.getType(), typing));
                if (!stackManipulation.isValid()) {
                    throw new IllegalStateException("Cannot assign " + fieldDescription.getType() + " to " + target);
                }
                return stackManipulation;
            }
            protected static class Factory implements ArgumentLoader.Factory {
                private static final String FIELD_PREFIX = "methodCall";
                private final Object value;
                private final String name;
                public Factory(Object value) {
                    this.value = value;
                    name = FIELD_PREFIX + "$" + RandomString.hashOf(value);
                }
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType.withAuxiliaryField(new FieldDescription.Token(name, Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(value.getClass())), value);
                }
                public ArgumentProvider make(Implementation.Target implementationTarget) {
                    return new ForInstance(implementationTarget.getInstrumentedType().getDeclaredFields().filter(named(name)).getOnly());
                }
            }
        }
        class ForField implements ArgumentLoader {
            private final FieldDescription fieldDescription;
            private final MethodDescription instrumentedMethod;
            public ForField(FieldDescription fieldDescription, MethodDescription instrumentedMethod) {
                this.fieldDescription = fieldDescription;
                this.instrumentedMethod = instrumentedMethod;
            }
            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
                if (!fieldDescription.isStatic() && instrumentedMethod.isStatic()) {
                    throw new IllegalStateException("Cannot access non-static " + fieldDescription + " from " + instrumentedMethod);
                }
                StackManipulation stackManipulation = new StackManipulation.Compound(fieldDescription.isStatic() ? StackManipulation.Trivial.INSTANCE : MethodVariableAccess.loadThis(), FieldAccess.forField(fieldDescription).read(), assigner.assign(fieldDescription.getType(), target.getType(), typing));
                if (!stackManipulation.isValid()) {
                    throw new IllegalStateException("Cannot assign " + fieldDescription + " to " + target);
                }
                return stackManipulation;
            }
            protected static class ArgumentProvider implements ArgumentLoader.ArgumentProvider {
                private final FieldDescription fieldDescription;
                protected ArgumentProvider(FieldDescription fieldDescription) {
                    this.fieldDescription = fieldDescription;
                }
                public List<ArgumentLoader> resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
                    return Collections.<ArgumentLoader>singletonList(new ForField(fieldDescription, instrumentedMethod));
                }
            }
            protected static class Factory implements ArgumentLoader.Factory {
                private final String name;
                private final FieldLocator.Factory fieldLocatorFactory;
                public Factory(String name, FieldLocator.Factory fieldLocatorFactory) {
                    this.name = name;
                    this.fieldLocatorFactory = fieldLocatorFactory;
                }
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType;
                }
                public ArgumentLoader.ArgumentProvider make(Implementation.Target implementationTarget) {
                    FieldLocator.Resolution resolution = fieldLocatorFactory.make(implementationTarget.getInstrumentedType()).locate(name);
                    if (!resolution.isResolved()) {
                        throw new IllegalStateException("Could not locate field '" + name + "' on " + implementationTarget.getInstrumentedType());
                    }
                    return new ArgumentProvider(resolution.getField());
                }
            }
        }
        class ForMethodCall implements ArgumentLoader {
            private final Appender appender;
            private final MethodDescription methodDescription;
            private final MethodDescription instrumentedMethod;
            private final TargetHandler.Resolved targetHandler;
            public ForMethodCall(Appender appender, MethodDescription methodDescription, MethodDescription instrumentedMethod, TargetHandler.Resolved targetHandler) {
                this.appender = appender;
                this.methodDescription = methodDescription;
                this.instrumentedMethod = instrumentedMethod;
                this.targetHandler = targetHandler;
            }
            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
                StackManipulation stackManipulation = new StackManipulation.Compound(appender.toStackManipulation(instrumentedMethod, methodDescription, targetHandler), assigner.assign(methodDescription.isConstructor() ? methodDescription.getDeclaringType().asGenericType() : methodDescription.getReturnType(), target.getType(), typing));
                if (!stackManipulation.isValid()) {
                    throw new IllegalStateException("Cannot assign return type of " + methodDescription + " to " + target);
                }
                return stackManipulation;
            }
            protected static class ArgumentProvider implements ArgumentLoader.ArgumentProvider {
                private final Appender appender;
                protected ArgumentProvider(Appender appender) {
                    this.appender = appender;
                }
                public List<ArgumentLoader> resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
                    TargetHandler.Resolved targetHandler = appender.targetHandler.resolve(instrumentedMethod);
                    return Collections.<ArgumentLoader>singletonList(new ForMethodCall(appender, appender.toInvokedMethod(instrumentedMethod, targetHandler), instrumentedMethod, targetHandler));
                }
            }
            protected static class Factory implements ArgumentLoader.Factory {
                private final MethodCall methodCall;
                public Factory(MethodCall methodCall) {
                    this.methodCall = methodCall;
                }
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return methodCall.prepare(instrumentedType);
                }
                public ArgumentLoader.ArgumentProvider make(Implementation.Target implementationTarget) {
                    return new ArgumentProvider(methodCall.new Appender(implementationTarget, TerminationHandler.Simple.IGNORING));
                }
            }
        }
        class ForStackManipulation implements ArgumentLoader, ArgumentProvider, Factory {
            private final StackManipulation stackManipulation;
            private final TypeDefinition typeDefinition;
            public ForStackManipulation(StackManipulation stackManipulation, Type type) {
                this(stackManipulation, TypeDescription.Generic.Sort.describe(type));
            }
            public ForStackManipulation(StackManipulation stackManipulation, TypeDefinition typeDefinition) {
                this.stackManipulation = stackManipulation;
                this.typeDefinition = typeDefinition;
            }
            public static ArgumentLoader.Factory of(@MaybeNull Object value) {
                if (value == null) {
                    return ForNullConstant.INSTANCE;
                } else {
                    ConstantValue constant = ConstantValue.Simple.wrapOrNull(value);
                    return constant == null ? new ForInstance.Factory(value) : new ForStackManipulation(constant.toStackManipulation(), constant.getTypeDescription());
                }
            }
            public InstrumentedType prepare(InstrumentedType instrumentedType) {
                return instrumentedType;
            }
            public ArgumentProvider make(Implementation.Target implementationTarget) {
                return this;
            }
            public List<ArgumentLoader> resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
                return Collections.<ArgumentLoader>singletonList(this);
            }
            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
                StackManipulation assignment = assigner.assign(typeDefinition.asGenericType(), target.getType(), typing);
                if (!assignment.isValid()) {
                    throw new IllegalStateException("Cannot assign " + target + " to " + typeDefinition);
                }
                return new StackManipulation.Compound(stackManipulation, assignment);
            }
        }
    }
    protected interface TargetHandler {
        Resolved resolve(MethodDescription instrumentedMethod);
        interface Resolved {
            TypeDescription getTypeDescription();
            StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing);
        }
        interface Factory extends InstrumentedType.Prepareable {
            TargetHandler make(Implementation.Target implementationTarget);
        }
        class Simple implements TargetHandler, Factory, Resolved {
            private final TypeDescription typeDescription;
            private final StackManipulation stackManipulation;
            protected Simple(TypeDescription typeDescription, StackManipulation stackManipulation) {
                this.typeDescription = typeDescription;
                this.stackManipulation = stackManipulation;
            }
            public TargetHandler make(Target implementationTarget) {
                return this;
            }
            public InstrumentedType prepare(InstrumentedType instrumentedType) {
                return instrumentedType;
            }
            public Resolved resolve(MethodDescription instrumentedMethod) {
                return this;
            }
            public TypeDescription getTypeDescription() {
                return typeDescription;
            }
            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
                return stackManipulation;
            }
        }
        class ForSelfOrStaticInvocation implements TargetHandler {
            private final TypeDescription instrumentedType;
            protected ForSelfOrStaticInvocation(TypeDescription instrumentedType) {
                this.instrumentedType = instrumentedType;
            }
            public TargetHandler.Resolved resolve(MethodDescription instrumentedMethod) {
                return new Resolved(instrumentedType, instrumentedMethod);
            }
            protected static class Resolved implements TargetHandler.Resolved {
                private final TypeDescription instrumentedType;
                private final MethodDescription instrumentedMethod;
                protected Resolved(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                    this.instrumentedType = instrumentedType;
                    this.instrumentedMethod = instrumentedMethod;
                }
                public TypeDescription getTypeDescription() {
                    return instrumentedType;
                }
                public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
                    if (instrumentedMethod.isStatic() && !invokedMethod.isStatic() && !invokedMethod.isConstructor()) {
                        throw new IllegalStateException("Cannot invoke " + invokedMethod + " from " + instrumentedMethod);
                    } else if (invokedMethod.isConstructor() && (!instrumentedMethod.isConstructor() || !instrumentedType.equals(invokedMethod.getDeclaringType().asErasure()) && (instrumentedType.getSuperClass() == null || !instrumentedType.getSuperClass().asErasure().equals(invokedMethod.getDeclaringType().asErasure())))) {
                        throw new IllegalStateException("Cannot invoke " + invokedMethod + " from " + instrumentedMethod + " in " + instrumentedType);
                    }
                    return new StackManipulation.Compound(invokedMethod.isStatic() ? StackManipulation.Trivial.INSTANCE : MethodVariableAccess.loadThis(), invokedMethod.isConstructor() ? Duplication.SINGLE : StackManipulation.Trivial.INSTANCE);
                }
            }
            protected enum Factory implements TargetHandler.Factory {
                INSTANCE;
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType;
                }
                public TargetHandler make(Implementation.Target implementationTarget) {
                    return new ForSelfOrStaticInvocation(implementationTarget.getInstrumentedType());
                }
            }
        }
        class ForConstructingInvocation implements TargetHandler, Resolved {
            private final TypeDescription instrumentedType;
            protected ForConstructingInvocation(TypeDescription instrumentedType) {
                this.instrumentedType = instrumentedType;
            }
            public Resolved resolve(MethodDescription instrumentedMethod) {
                return this;
            }
            public TypeDescription getTypeDescription() {
                return instrumentedType;
            }
            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
                return new StackManipulation.Compound(TypeCreation.of(invokedMethod.getDeclaringType().asErasure()), Duplication.SINGLE);
            }
            enum Factory implements TargetHandler.Factory {
                INSTANCE;
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType;
                }
                public TargetHandler make(Implementation.Target implementationTarget) {
                    return new ForConstructingInvocation(implementationTarget.getInstrumentedType());
                }
            }
        }
        class ForValue implements TargetHandler, Resolved {
            private final FieldDescription.InDefinedShape fieldDescription;
            protected ForValue(FieldDescription.InDefinedShape fieldDescription) {
                this.fieldDescription = fieldDescription;
            }
            public Resolved resolve(MethodDescription instrumentedMethod) {
                return this;
            }
            public TypeDescription getTypeDescription() {
                return fieldDescription.getType().asErasure();
            }
            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
                StackManipulation stackManipulation = assigner.assign(fieldDescription.getType(), invokedMethod.getDeclaringType().asGenericType(), typing);
                if (!stackManipulation.isValid()) {
                    throw new IllegalStateException("Cannot invoke " + invokedMethod + " on " + fieldDescription);
                }
                return new StackManipulation.Compound(FieldAccess.forField(fieldDescription).read(), stackManipulation);
            }
            protected static class Factory implements TargetHandler.Factory {
                private static final String FIELD_PREFIX = "invocationTarget";
                private final Object target;
                private final TypeDescription.Generic fieldType;
                private final String name;
                protected Factory(Object target, TypeDescription.Generic fieldType) {
                    this.target = target;
                    this.fieldType = fieldType;
                    name = FIELD_PREFIX + "$" + RandomString.hashOf(target);
                }
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType.withAuxiliaryField(new FieldDescription.Token(name, Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_VOLATILE | Opcodes.ACC_SYNTHETIC, fieldType), target);
                }
                public TargetHandler make(Implementation.Target implementationTarget) {
                    return new ForValue(implementationTarget.getInstrumentedType().getDeclaredFields().filter(named(name)).getOnly());
                }
            }
        }
        class ForField implements TargetHandler, Resolved {
            private final FieldDescription fieldDescription;
            protected ForField(FieldDescription fieldDescription) {
                this.fieldDescription = fieldDescription;
            }
            public Resolved resolve(MethodDescription instrumentedMethod) {
                return this;
            }
            public TypeDescription getTypeDescription() {
                return fieldDescription.getType().asErasure();
            }
            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
                if (!invokedMethod.isMethod() || !invokedMethod.isVirtual() || !invokedMethod.isVisibleTo(fieldDescription.getType().asErasure())) {
                    throw new IllegalStateException("Cannot invoke " + invokedMethod + " on " + fieldDescription);
                }
                StackManipulation stackManipulation = assigner.assign(fieldDescription.getType(), invokedMethod.getDeclaringType().asGenericType(), typing);
                if (!stackManipulation.isValid()) {
                    throw new IllegalStateException("Cannot invoke " + invokedMethod + " on " + fieldDescription);
                }
                return new StackManipulation.Compound(invokedMethod.isStatic() || fieldDescription.isStatic() ? StackManipulation.Trivial.INSTANCE : MethodVariableAccess.loadThis(), FieldAccess.forField(fieldDescription).read(), stackManipulation);
            }
            protected interface Location {
                FieldDescription resolve(TypeDescription instrumentedType);
                class ForImplicitField implements Location {
                    private final String name;
                    private final FieldLocator.Factory fieldLocatorFactory;
                    protected ForImplicitField(String name, FieldLocator.Factory fieldLocatorFactory) {
                        this.name = name;
                        this.fieldLocatorFactory = fieldLocatorFactory;
                    }
                    public FieldDescription resolve(TypeDescription instrumentedType) {
                        FieldLocator.Resolution resolution = fieldLocatorFactory.make(instrumentedType).locate(name);
                        if (!resolution.isResolved()) {
                            throw new IllegalStateException("Could not locate field name " + name + " on " + instrumentedType);
                        }
                        return resolution.getField();
                    }
                }
                class ForExplicitField implements Location {
                    private final FieldDescription fieldDescription;
                    protected ForExplicitField(FieldDescription fieldDescription) {
                        this.fieldDescription = fieldDescription;
                    }
                    public FieldDescription resolve(TypeDescription instrumentedType) {
                        return fieldDescription;
                    }
                }
            }
            protected static class Factory implements TargetHandler.Factory {
                private final Location location;
                protected Factory(Location location) {
                    this.location = location;
                }
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return instrumentedType;
                }
                public TargetHandler make(Implementation.Target implementationTarget) {
                    FieldDescription fieldDescription = location.resolve(implementationTarget.getInstrumentedType());
                    if (!fieldDescription.isStatic() && !implementationTarget.getInstrumentedType().isAssignableTo(fieldDescription.getDeclaringType().asErasure())) {
                        throw new IllegalStateException("Cannot access " + fieldDescription + " from " + implementationTarget.getInstrumentedType());
                    }
                    return new ForField(fieldDescription);
                }
            }
        }
        class ForMethodParameter implements TargetHandler, Factory {
            private final int index;
            protected ForMethodParameter(int index) {
                this.index = index;
            }
            public InstrumentedType prepare(InstrumentedType instrumentedType) {
                return instrumentedType;
            }
            public TargetHandler make(Implementation.Target implementationTarget) {
                return this;
            }
            public TargetHandler.Resolved resolve(MethodDescription instrumentedMethod) {
                if (index >= instrumentedMethod.getParameters().size()) {
                    throw new IllegalArgumentException(instrumentedMethod + " does not have a parameter with index " + index);
                }
                return new Resolved(instrumentedMethod.getParameters().get(index));
            }
            protected static class Resolved implements TargetHandler.Resolved {
                private final ParameterDescription parameterDescription;
                protected Resolved(ParameterDescription parameterDescription) {
                    this.parameterDescription = parameterDescription;
                }
                public TypeDescription getTypeDescription() {
                    return parameterDescription.getType().asErasure();
                }
                public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
                    StackManipulation stackManipulation = assigner.assign(parameterDescription.getType(), invokedMethod.getDeclaringType().asGenericType(), typing);
                    if (!stackManipulation.isValid()) {
                        throw new IllegalStateException("Cannot invoke " + invokedMethod + " on " + parameterDescription.getType());
                    }
                    return new StackManipulation.Compound(MethodVariableAccess.load(parameterDescription), stackManipulation);
                }
            }
        }
        class ForMethodCall implements TargetHandler {
            private final Appender appender;
            protected ForMethodCall(Appender appender) {
                this.appender = appender;
            }
            public TargetHandler.Resolved resolve(MethodDescription instrumentedMethod) {
                TargetHandler.Resolved targetHandler = appender.targetHandler.resolve(instrumentedMethod);
                return new Resolved(appender, appender.toInvokedMethod(instrumentedMethod, targetHandler), instrumentedMethod, targetHandler);
            }
            protected static class Resolved implements TargetHandler.Resolved {
                private final Appender appender;
                private final MethodDescription methodDescription;
                private final MethodDescription instrumentedMethod;
                private final TargetHandler.Resolved targetHandler;
                protected Resolved(Appender appender, MethodDescription methodDescription, MethodDescription instrumentedMethod, TargetHandler.Resolved targetHandler) {
                    this.appender = appender;
                    this.methodDescription = methodDescription;
                    this.instrumentedMethod = instrumentedMethod;
                    this.targetHandler = targetHandler;
                }
                public TypeDescription getTypeDescription() {
                    return methodDescription.isConstructor() ? methodDescription.getDeclaringType().asErasure() : methodDescription.getReturnType().asErasure();
                }
                public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
                    StackManipulation stackManipulation = assigner.assign(methodDescription.isConstructor() ? methodDescription.getDeclaringType().asGenericType() : methodDescription.getReturnType(), invokedMethod.getDeclaringType().asGenericType(), typing);
                    if (!stackManipulation.isValid()) {
                        throw new IllegalStateException("Cannot invoke " + invokedMethod + " on " + (methodDescription.isConstructor() ? methodDescription.getDeclaringType() : methodDescription.getReturnType()));
                    }
                    return new StackManipulation.Compound(appender.toStackManipulation(instrumentedMethod, methodDescription, targetHandler), stackManipulation);
                }
            }
            protected static class Factory implements TargetHandler.Factory {
                private final MethodCall methodCall;
                public Factory(MethodCall methodCall) {
                    this.methodCall = methodCall;
                }
                public InstrumentedType prepare(InstrumentedType instrumentedType) {
                    return methodCall.prepare(instrumentedType);
                }
                public TargetHandler make(Implementation.Target implementationTarget) {
                    return new ForMethodCall(methodCall.new Appender(implementationTarget, TerminationHandler.Simple.IGNORING));
                }
            }
        }
    }
    protected interface MethodInvoker {
        StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget);
        interface Factory {
            MethodInvoker make(TypeDescription instrumentedType);
        }
        class ForContextualInvocation implements MethodInvoker {
            private final TypeDescription instrumentedType;
            protected ForContextualInvocation(TypeDescription instrumentedType) {
                this.instrumentedType = instrumentedType;
            }
            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget) {
                if (invokedMethod.isVirtual() && !invokedMethod.isInvokableOn(instrumentedType)) {
                    throw new IllegalStateException("Cannot invoke " + invokedMethod + " on " + instrumentedType);
                }
                return invokedMethod.isVirtual() ? MethodInvocation.invoke(invokedMethod).virtual(instrumentedType) : MethodInvocation.invoke(invokedMethod);
            }
            enum Factory implements MethodInvoker.Factory {
                INSTANCE;
                public MethodInvoker make(TypeDescription instrumentedType) {
                    return new ForContextualInvocation(instrumentedType);
                }
            }
        }
        class ForVirtualInvocation implements MethodInvoker {
            private final TypeDescription typeDescription;
            protected ForVirtualInvocation(TypeDescription typeDescription) {
                this.typeDescription = typeDescription;
            }
            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget) {
                if (!invokedMethod.isInvokableOn(typeDescription)) {
                    throw new IllegalStateException("Cannot invoke " + invokedMethod + " on " + typeDescription);
                }
                return MethodInvocation.invoke(invokedMethod).virtual(typeDescription);
            }
            protected enum WithImplicitType implements MethodInvoker, MethodInvoker.Factory {
                INSTANCE;
                public MethodInvoker make(TypeDescription instrumentedType) {
                    return this;
                }
                public StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget) {
                    if (!invokedMethod.isAccessibleTo(implementationTarget.getInstrumentedType()) || !invokedMethod.isVirtual()) {
                        throw new IllegalStateException("Cannot invoke " + invokedMethod + " virtually");
                    }
                    return MethodInvocation.invoke(invokedMethod);
                }
            }
            protected static class Factory implements MethodInvoker.Factory {
                private final TypeDescription typeDescription;
                protected Factory(TypeDescription typeDescription) {
                    this.typeDescription = typeDescription;
                }
                public MethodInvoker make(TypeDescription instrumentedType) {
                    if (!typeDescription.asErasure().isAccessibleTo(instrumentedType)) {
                        throw new IllegalStateException(typeDescription + " is not accessible to " + instrumentedType);
                    }
                    return new ForVirtualInvocation(typeDescription);
                }
            }
        }
        class ForSuperMethodInvocation implements MethodInvoker {
            private final TypeDescription instrumentedType;
            protected ForSuperMethodInvocation(TypeDescription instrumentedType) {
                this.instrumentedType = instrumentedType;
            }
            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget) {
                if (!invokedMethod.isInvokableOn(implementationTarget.getOriginType().asErasure())) {
                    throw new IllegalStateException("Cannot invoke " + invokedMethod + " as super method of " + instrumentedType);
                }
                StackManipulation stackManipulation = implementationTarget.invokeDominant(invokedMethod.asSignatureToken()).withCheckedCompatibilityTo(invokedMethod.asTypeToken());
                if (!stackManipulation.isValid()) {
                    throw new IllegalStateException("Cannot invoke " + invokedMethod + " as a super method");
                }
                return stackManipulation;
            }
            enum Factory implements MethodInvoker.Factory {
                INSTANCE;
                public MethodInvoker make(TypeDescription instrumentedType) {
                    if (instrumentedType.getSuperClass() == null) {
                        throw new IllegalStateException("Cannot invoke super method for " + instrumentedType);
                    }
                    return new ForSuperMethodInvocation(instrumentedType);
                }
            }
        }
        class ForDefaultMethodInvocation implements MethodInvoker {
            private final TypeDescription instrumentedType;
            protected ForDefaultMethodInvocation(TypeDescription instrumentedType) {
                this.instrumentedType = instrumentedType;
            }
            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget) {
                if (!invokedMethod.isInvokableOn(instrumentedType)) {
                    throw new IllegalStateException("Cannot invoke " + invokedMethod + " as default method of " + instrumentedType);
                }
                StackManipulation stackManipulation = implementationTarget.invokeDefault(invokedMethod.asSignatureToken(), invokedMethod.getDeclaringType().asErasure()).withCheckedCompatibilityTo(invokedMethod.asTypeToken());
                if (!stackManipulation.isValid()) {
                    throw new IllegalStateException("Cannot invoke " + invokedMethod + " on " + instrumentedType);
                }
                return stackManipulation;
            }
            enum Factory implements MethodInvoker.Factory {
                INSTANCE;
                public MethodInvoker make(TypeDescription instrumentedType) {
                    return new ForDefaultMethodInvocation(instrumentedType);
                }
            }
        }
    }
    protected interface TerminationHandler {
        StackManipulation prepare();
        StackManipulation toStackManipulation(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing);
        interface Factory {
            TerminationHandler make(TypeDescription instrumentedType);
        }
        enum Simple implements TerminationHandler, Factory {
            RETURNING {
                public StackManipulation toStackManipulation(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
                    StackManipulation stackManipulation = assigner.assign(invokedMethod.isConstructor() ? invokedMethod.getDeclaringType().asGenericType() : invokedMethod.getReturnType(), instrumentedMethod.getReturnType(), typing);
                    if (!stackManipulation.isValid()) {
                        throw new IllegalStateException("Cannot return " + invokedMethod.getReturnType() + " from " + instrumentedMethod);
                    }
                    return new StackManipulation.Compound(stackManipulation, MethodReturn.of(instrumentedMethod.getReturnType()));
                }
            }
            , DROPPING {
                public StackManipulation toStackManipulation(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
                    return Removal.of(invokedMethod.isConstructor() ? invokedMethod.getDeclaringType() : invokedMethod.getReturnType());
                }
            }
            , IGNORING {
                public StackManipulation toStackManipulation(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
                    return StackManipulation.Trivial.INSTANCE;
                }
            }
            ;
            public TerminationHandler make(TypeDescription instrumentedType) {
                return this;
            }
            public StackManipulation prepare() {
                return StackManipulation.Trivial.INSTANCE;
            }
        }
        class FieldSetting implements TerminationHandler {
            private final FieldDescription fieldDescription;
            protected FieldSetting(FieldDescription fieldDescription) {
                this.fieldDescription = fieldDescription;
            }
            public StackManipulation prepare() {
                return fieldDescription.isStatic() ? StackManipulation.Trivial.INSTANCE : MethodVariableAccess.loadThis();
            }
            public StackManipulation toStackManipulation(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
                StackManipulation stackManipulation = assigner.assign(invokedMethod.isConstructor() ? invokedMethod.getDeclaringType().asGenericType() : invokedMethod.getReturnType(), fieldDescription.getType(), typing);
                if (!stackManipulation.isValid()) {
                    throw new IllegalStateException("Cannot assign result of " + invokedMethod + " to " + fieldDescription);
                }
                return new StackManipulation.Compound(stackManipulation, FieldAccess.forField(fieldDescription).write());
            }
            protected static class Explicit implements TerminationHandler.Factory {
                private final FieldDescription fieldDescription;
                protected Explicit(FieldDescription fieldDescription) {
                    this.fieldDescription = fieldDescription;
                }
                public TerminationHandler make(TypeDescription instrumentedType) {
                    if (!fieldDescription.isStatic() && !instrumentedType.isAssignableTo(fieldDescription.getDeclaringType().asErasure())) {
                        throw new IllegalStateException("Cannot set " + fieldDescription + " from " + instrumentedType);
                    } else if (!fieldDescription.isVisibleTo(instrumentedType)) {
                        throw new IllegalStateException("Cannot access " + fieldDescription + " from " + instrumentedType);
                    }
                    return new FieldSetting(fieldDescription);
                }
            }
            protected static class Implicit implements TerminationHandler.Factory {
                private final ElementMatcher<? super FieldDescription> matcher;
                protected Implicit(ElementMatcher<? super FieldDescription> matcher) {
                    this.matcher = matcher;
                }
                public TerminationHandler make(TypeDescription instrumentedType) {
                    TypeDefinition current = instrumentedType;
                    do {
                        FieldList<?> candidates = current.getDeclaredFields().filter(isVisibleTo(instrumentedType).and(matcher));
                        if (candidates.size() == 1) {
                            return new FieldSetting(candidates.getOnly());
                        } else if (candidates.size() == 2) {
                            throw new IllegalStateException(matcher + " is ambiguous and resolved: " + candidates);
                        }
                        current = current.getSuperClass();
                    } while (current != null);
                    throw new IllegalStateException(matcher + " does not locate any accessible fields for " + instrumentedType);
                }
            }
        }
    }
    public static class WithoutSpecifiedTarget extends MethodCall {
        protected WithoutSpecifiedTarget(MethodLocator.Factory methodLocator) {
            super(methodLocator, TargetHandler.ForSelfOrStaticInvocation.Factory.INSTANCE, Collections.<ArgumentLoader.Factory>emptyList(), MethodInvoker.ForContextualInvocation.Factory.INSTANCE, TerminationHandler.Simple.RETURNING, Assigner.DEFAULT, Assigner.Typing.STATIC);
        }
        public MethodCall on(Object target) {
            return on(target, (Class) target.getClass());
        }
        public <T> MethodCall on(T target, Class<? super T> type) {
            return new MethodCall(methodLocator, new TargetHandler.ForValue.Factory(target, TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(type)), argumentLoaders, new MethodInvoker.ForVirtualInvocation.Factory(TypeDescription.ForLoadedType.of(type)), terminationHandler, assigner, typing);
        }
        public MethodCall on(StackManipulation stackManipulation, Class<?> type) {
            return on(stackManipulation, TypeDescription.ForLoadedType.of(type));
        }
        public MethodCall on(StackManipulation stackManipulation, TypeDescription typeDescription) {
            return new MethodCall(methodLocator, new TargetHandler.Simple(typeDescription, stackManipulation), argumentLoaders, new MethodInvoker.ForVirtualInvocation.Factory(typeDescription), terminationHandler, assigner, typing);
        }
        public MethodCall onArgument(int index) {
            if (index < 0) {
                throw new IllegalArgumentException("An argument index cannot be negative: " + index);
            }
            return new MethodCall(methodLocator, new TargetHandler.ForMethodParameter(index), argumentLoaders, MethodInvoker.ForVirtualInvocation.WithImplicitType.INSTANCE, terminationHandler, assigner, typing);
        }
        public MethodCall onField(String name) {
            return onField(name, FieldLocator.ForClassHierarchy.Factory.INSTANCE);
        }
        public MethodCall onField(String name, FieldLocator.Factory fieldLocatorFactory) {
            return new MethodCall(methodLocator, new TargetHandler.ForField.Factory(new TargetHandler.ForField.Location.ForImplicitField(name, fieldLocatorFactory)), argumentLoaders, MethodInvoker.ForVirtualInvocation.WithImplicitType.INSTANCE, terminationHandler, assigner, typing);
        }
        public MethodCall onField(Field field) {
            return onField(new FieldDescription.ForLoadedField(field));
        }
        public MethodCall onField(FieldDescription fieldDescription) {
            return new MethodCall(methodLocator, new TargetHandler.ForField.Factory(new TargetHandler.ForField.Location.ForExplicitField(fieldDescription)), argumentLoaders, MethodInvoker.ForVirtualInvocation.WithImplicitType.INSTANCE, terminationHandler, assigner, typing);
        }
        public MethodCall onMethodCall(MethodCall methodCall) {
            return new MethodCall(methodLocator, new TargetHandler.ForMethodCall.Factory(methodCall), argumentLoaders, MethodInvoker.ForVirtualInvocation.WithImplicitType.INSTANCE, terminationHandler, assigner, typing);
        }
        public MethodCall onSuper() {
            return new MethodCall(methodLocator, TargetHandler.ForSelfOrStaticInvocation.Factory.INSTANCE, argumentLoaders, MethodInvoker.ForSuperMethodInvocation.Factory.INSTANCE, terminationHandler, assigner, typing);
        }
        public MethodCall onDefault() {
            return new MethodCall(methodLocator, TargetHandler.ForSelfOrStaticInvocation.Factory.INSTANCE, argumentLoaders, MethodInvoker.ForDefaultMethodInvocation.Factory.INSTANCE, terminationHandler, assigner, typing);
        }
    }
    public static class FieldSetting implements Composable {
        private final MethodCall methodCall;
        protected FieldSetting(MethodCall methodCall) {
            this.methodCall = methodCall;
        }
        public Composable withAssigner(Assigner assigner, Assigner.Typing typing) {
            return new FieldSetting((MethodCall) methodCall.withAssigner(assigner, typing));
        }
        public InstrumentedType prepare(InstrumentedType instrumentedType) {
            return methodCall.prepare(instrumentedType);
        }
        public ByteCodeAppender appender(Target implementationTarget) {
            return new ByteCodeAppender.Compound(methodCall.appender(implementationTarget), Appender.INSTANCE);
        }
        public Implementation andThen(Implementation implementation) {
            return new Compound(methodCall, implementation);
        }
        public Composable andThen(Composable implementation) {
            return new Compound.Composable(methodCall, implementation);
        }
        protected enum Appender implements ByteCodeAppender {
            INSTANCE;
            public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
                if (!instrumentedMethod.getReturnType().represents(void.class)) {
                    throw new IllegalStateException("Instrumented method " + instrumentedMethod + " does not return void for field setting method call");
                }
                return new Size(MethodReturn.VOID.apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());
            }
        }
    }
    protected class Appender implements ByteCodeAppender {
        private final Implementation.Target implementationTarget;
        private final MethodLocator methodLocator;
        private final List<ArgumentLoader.ArgumentProvider> argumentProviders;
        private final MethodInvoker methodInvoker;
        private final TargetHandler targetHandler;
        private final TerminationHandler terminationHandler;
        protected Appender(Target implementationTarget, TerminationHandler terminationHandler) {
            this.implementationTarget = implementationTarget;
            methodLocator = MethodCall.this.methodLocator.make(implementationTarget.getInstrumentedType());
            argumentProviders = new ArrayList<ArgumentLoader.ArgumentProvider>(argumentLoaders.size());
            for (ArgumentLoader.Factory factory : argumentLoaders) {
                argumentProviders.add(factory.make(implementationTarget));
            }
            methodInvoker = MethodCall.this.methodInvoker.make(implementationTarget.getInstrumentedType());
            targetHandler = MethodCall.this.targetHandler.make(implementationTarget);
            this.terminationHandler = terminationHandler;
        }
        public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
            TargetHandler.Resolved targetHandler = this.targetHandler.resolve(instrumentedMethod);
            return new Size(new StackManipulation.Compound(terminationHandler.prepare(), toStackManipulation(instrumentedMethod, toInvokedMethod(instrumentedMethod, targetHandler), targetHandler)).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());
        }
        protected MethodDescription toInvokedMethod(MethodDescription instrumentedMethod, TargetHandler.Resolved targetHandler) {
            return methodLocator.resolve(targetHandler.getTypeDescription(), instrumentedMethod);
        }
        protected StackManipulation toStackManipulation(MethodDescription instrumentedMethod, MethodDescription invokedMethod, TargetHandler.Resolved targetHandler) {
            List<ArgumentLoader> argumentLoaders = new ArrayList<ArgumentLoader>();
            for (ArgumentLoader.ArgumentProvider argumentProvider : argumentProviders) {
                argumentLoaders.addAll(argumentProvider.resolve(instrumentedMethod, invokedMethod));
            }
            ParameterList<?> parameters = invokedMethod.getParameters();
            if (parameters.size() != argumentLoaders.size()) {
                throw new IllegalStateException(invokedMethod + " does not accept " + argumentLoaders.size() + " arguments");
            }
            Iterator<? extends ParameterDescription> parameterIterator = parameters.iterator();
            List<StackManipulation> argumentInstructions = new ArrayList<StackManipulation>(argumentLoaders.size());
            for (ArgumentLoader argumentLoader : argumentLoaders) {
                argumentInstructions.add(argumentLoader.toStackManipulation(parameterIterator.next(), assigner, typing));
            }
            return new StackManipulation.Compound(targetHandler.toStackManipulation(invokedMethod, assigner, typing), new StackManipulation.Compound(argumentInstructions), methodInvoker.toStackManipulation(invokedMethod, implementationTarget), terminationHandler.toStackManipulation(invokedMethod, instrumentedMethod, assigner, typing));
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```