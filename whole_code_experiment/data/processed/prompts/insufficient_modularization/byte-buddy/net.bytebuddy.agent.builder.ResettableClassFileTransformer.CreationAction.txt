##CONTEXT_SIZE=3252
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.agent.builder;
public interface ResettableClassFileTransformer extends ClassFileTransformer {
    Iterator<AgentBuilder.Transformer> iterator(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain);
    boolean reset(Instrumentation instrumentation, AgentBuilder.RedefinitionStrategy redefinitionStrategy);
    boolean reset(Instrumentation instrumentation, AgentBuilder.RedefinitionStrategy redefinitionStrategy, AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator);
    boolean reset(Instrumentation instrumentation, AgentBuilder.RedefinitionStrategy redefinitionStrategy, AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy);
    boolean reset(Instrumentation instrumentation, AgentBuilder.RedefinitionStrategy redefinitionStrategy, AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator, AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy);
    boolean reset(Instrumentation instrumentation, AgentBuilder.RedefinitionStrategy redefinitionStrategy, AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy, AgentBuilder.RedefinitionStrategy.Listener redefinitionListener);
    boolean reset(Instrumentation instrumentation, AgentBuilder.RedefinitionStrategy redefinitionStrategy, AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator, AgentBuilder.RedefinitionStrategy.Listener redefinitionListener);
    boolean reset(Instrumentation instrumentation, AgentBuilder.RedefinitionStrategy redefinitionStrategy, AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy, AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator, AgentBuilder.RedefinitionStrategy.Listener redefinitionListener);
    boolean reset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, AgentBuilder.RedefinitionStrategy redefinitionStrategy, AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy, AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator, AgentBuilder.RedefinitionStrategy.Listener redefinitionListener);
    interface Substitutable extends ResettableClassFileTransformer {
        void substitute(ResettableClassFileTransformer classFileTransformer);
        ResettableClassFileTransformer unwrap();
    }
    abstract class AbstractBase implements ResettableClassFileTransformer {
        public boolean reset(Instrumentation instrumentation, AgentBuilder.RedefinitionStrategy redefinitionStrategy) {
            return reset(instrumentation, redefinitionStrategy, AgentBuilder.RedefinitionStrategy.BatchAllocator.ForTotal.INSTANCE);
        }
        public boolean reset(Instrumentation instrumentation, AgentBuilder.RedefinitionStrategy redefinitionStrategy, AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator) {
            return reset(instrumentation, redefinitionStrategy, redefinitionBatchAllocator, AgentBuilder.RedefinitionStrategy.Listener.NoOp.INSTANCE);
        }
        public boolean reset(Instrumentation instrumentation, AgentBuilder.RedefinitionStrategy redefinitionStrategy, AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy) {
            return reset(instrumentation, redefinitionStrategy, redefinitionDiscoveryStrategy, AgentBuilder.RedefinitionStrategy.Listener.NoOp.INSTANCE);
        }
        public boolean reset(Instrumentation instrumentation, AgentBuilder.RedefinitionStrategy redefinitionStrategy, AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator, AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy) {
            return reset(instrumentation, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, AgentBuilder.RedefinitionStrategy.Listener.NoOp.INSTANCE);
        }
        public boolean reset(Instrumentation instrumentation, AgentBuilder.RedefinitionStrategy redefinitionStrategy, AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy, AgentBuilder.RedefinitionStrategy.Listener redefinitionListener) {
            return reset(instrumentation, redefinitionStrategy, redefinitionDiscoveryStrategy, AgentBuilder.RedefinitionStrategy.BatchAllocator.ForTotal.INSTANCE, redefinitionListener);
        }
        public boolean reset(Instrumentation instrumentation, AgentBuilder.RedefinitionStrategy redefinitionStrategy, AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator, AgentBuilder.RedefinitionStrategy.Listener redefinitionListener) {
            return reset(instrumentation, redefinitionStrategy, AgentBuilder.RedefinitionStrategy.DiscoveryStrategy.SinglePass.INSTANCE, redefinitionBatchAllocator, redefinitionListener);
        }
        public boolean reset(Instrumentation instrumentation, AgentBuilder.RedefinitionStrategy redefinitionStrategy, AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy, AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator, AgentBuilder.RedefinitionStrategy.Listener redefinitionListener) {
            return reset(instrumentation, this, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener);
        }
    }
    abstract class WithDelegation extends AbstractBase {
        protected final ResettableClassFileTransformer classFileTransformer;
        protected WithDelegation(ResettableClassFileTransformer classFileTransformer) {
            this.classFileTransformer = classFileTransformer;
        }
        private static <T> T doPrivileged(PrivilegedAction<T> action) {
            return action.run();
        }
        public static ResettableClassFileTransformer of(ResettableClassFileTransformer classFileTransformer, Callback<?> callback) {
            return WithCallback.DISPATCHER.make(classFileTransformer, callback);
        }
        public Iterator<AgentBuilder.Transformer> iterator(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain) {
            return classFileTransformer.iterator(typeDescription, classLoader, module, classBeingRedefined, protectionDomain);
        }
        public boolean reset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, AgentBuilder.RedefinitionStrategy redefinitionStrategy, AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy, AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator, AgentBuilder.RedefinitionStrategy.Listener redefinitionListener) {
            return this.classFileTransformer.reset(instrumentation, classFileTransformer, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener);
        }
        protected static class Substitutable extends AbstractBase implements ResettableClassFileTransformer.Substitutable {
            private static final Factory DISPATCHER = doPrivileged(Factory.CreationAction.INSTANCE);
            protected volatile ResettableClassFileTransformer classFileTransformer;
            protected Substitutable(ResettableClassFileTransformer classFileTransformer) {
                this.classFileTransformer = classFileTransformer;
            }
            public static Substitutable of(ResettableClassFileTransformer classFileTransformer) {
                return DISPATCHER.make(classFileTransformer);
            }
            public void substitute(ResettableClassFileTransformer classFileTransformer) {
                while (classFileTransformer instanceof Substitutable) {
                    classFileTransformer = ((Substitutable) classFileTransformer).unwrap();
                }
                this.classFileTransformer = classFileTransformer;
            }
            public ResettableClassFileTransformer unwrap() {
                return classFileTransformer;
            }
            public Iterator<AgentBuilder.Transformer> iterator(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain) {
                return classFileTransformer.iterator(typeDescription, classLoader, module, classBeingRedefined, protectionDomain);
            }
            public boolean reset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, AgentBuilder.RedefinitionStrategy redefinitionStrategy, AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy, AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator, AgentBuilder.RedefinitionStrategy.Listener redefinitionListener) {
                return this.classFileTransformer.reset(instrumentation, classFileTransformer, redefinitionStrategy, redefinitionDiscoveryStrategy, redefinitionBatchAllocator, redefinitionListener);
            }
            public byte[] transform(@MaybeNull ClassLoader classLoader, @MaybeNull String internalName, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain, byte[] binaryRepresentation) throws IllegalClassFormatException {
                return classFileTransformer.transform(classLoader, internalName, classBeingRedefined, protectionDomain, binaryRepresentation);
            }
            interface Factory {
                Substitutable make(ResettableClassFileTransformer classFileTransformer);
                enum CreationAction implements PrivilegedAction<Factory> {
                    INSTANCE;
                    public Factory run() {
                        try {
                            return new ForJava9CapableVm(new ByteBuddy().with(TypeValidation.DISABLED).subclass(WithDelegation.Substitutable.class, ConstructorStrategy.Default.IMITATE_SUPER_CLASS_OPENING).name(WithDelegation.Substitutable.class.getName() + "$ByteBuddy$ModuleSupport").method(named("transform").and(takesArgument(0, JavaType.MODULE.load()))).intercept(MethodCall.invoke(ClassFileTransformer.class.getMethod("transform", JavaType.MODULE.load(), ClassLoader.class, String.class, Class.class, ProtectionDomain.class, byte[].class)).onField("classFileTransformer").withAllArguments()).make().load(WithDelegation.Substitutable.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER_PERSISTENT.with(WithDelegation.Substitutable.class.getProtectionDomain())).getLoaded().getConstructor(ResettableClassFileTransformer.class));
                        } catch (Exception ignored) {
                            return ForLegacyVm.INSTANCE;
                        }
                    }
                }
                class ForJava9CapableVm implements Factory {
                    private final Constructor<? extends Substitutable> substitutable;
                    protected ForJava9CapableVm(Constructor<? extends Substitutable> substitutable) {
                        this.substitutable = substitutable;
                    }
                    public Substitutable make(ResettableClassFileTransformer classFileTransformer) {
                        try {
                            return substitutable.newInstance(classFileTransformer);
                        } catch (IllegalAccessException exception) {
                            throw new IllegalStateException("Cannot access " + substitutable, exception);
                        } catch (InstantiationException exception) {
                            throw new IllegalStateException("Cannot instantiate " + substitutable.getDeclaringClass(), exception);
                        } catch (InvocationTargetException exception) {
                            throw new IllegalStateException("Cannot invoke " + substitutable, exception.getTargetException());
                        }
                    }
                }
                enum ForLegacyVm implements Factory {
                    INSTANCE;
                    public Substitutable make(ResettableClassFileTransformer classFileTransformer) {
                        return new WithDelegation.Substitutable(classFileTransformer);
                    }
                }
            }
        }
        protected static class WithCallback<T> extends WithDelegation {
            private static final Factory DISPATCHER = doPrivileged(Factory.CreationAction.INSTANCE);
            private final Callback<T> callback;
            protected WithCallback(ResettableClassFileTransformer classFileTransformer, Callback<T> callback) {
                super(classFileTransformer);
                this.callback = callback;
            }
            public byte[] transform(@MaybeNull ClassLoader classLoader, @MaybeNull String internalName, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain, byte[] binaryRepresentation) throws IllegalClassFormatException {
                T value = callback.onBeforeTransform(null, classLoader, internalName, classBeingRedefined, protectionDomain, binaryRepresentation);
                try {
                    return classFileTransformer.transform(classLoader, internalName, classBeingRedefined, protectionDomain, binaryRepresentation);
                } finally {
                    callback.onAfterTransform(value, null, classLoader, internalName, classBeingRedefined, protectionDomain, binaryRepresentation);
                }
            }
            protected byte[] transform(Object rawModule, @MaybeNull ClassLoader classLoader, @MaybeNull String internalName, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain, byte[] binaryRepresentation) throws IllegalClassFormatException {
                JavaModule module = JavaModule.of(rawModule);
                T value = callback.onBeforeTransform(module, classLoader, internalName, classBeingRedefined, protectionDomain, binaryRepresentation);
                try {
                    return doTransform(rawModule, classLoader, internalName, classBeingRedefined, protectionDomain, binaryRepresentation);
                } finally {
                    callback.onAfterTransform(value, module, classLoader, internalName, classBeingRedefined, protectionDomain, binaryRepresentation);
                }
            }
            protected byte[] doTransform(Object rawModule, @MaybeNull ClassLoader classLoader, @MaybeNull String internalName, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain, byte[] binaryRepresentation) throws IllegalClassFormatException {
                throw new UnsupportedOperationException();
            }
            interface Factory {
                ResettableClassFileTransformer make(ResettableClassFileTransformer classFileTransformer, Callback<?> callback);
                enum CreationAction implements PrivilegedAction<Factory> {
                    INSTANCE;
                    public Factory run() {
                        try {
                            return new Factory.ForJava9CapableVm(new ByteBuddy().with(TypeValidation.DISABLED).subclass(WithCallback.class, ConstructorStrategy.Default.IMITATE_SUPER_CLASS_OPENING).name(WithCallback.class.getName() + "$ByteBuddy$ModuleSupport").method(named("transform").and(takesArguments(JavaType.MODULE.load(), ClassLoader.class, String.class, Class.class, ProtectionDomain.class, byte[].class))).intercept(MethodCall.invoke(WithCallback.class.getDeclaredMethod("transform", Object.class, ClassLoader.class, String.class, Class.class, ProtectionDomain.class, byte[].class)).withAllArguments()).method(named("doTransform").and(takesArguments(Object.class, ClassLoader.class, String.class, Class.class, ProtectionDomain.class, byte[].class))).intercept(MethodCall.invoke(ClassFileTransformer.class.getMethod("transform", JavaType.MODULE.load(), ClassLoader.class, String.class, Class.class, ProtectionDomain.class, byte[].class)).onField("classFileTransformer").withAllArguments().withAssigner(Assigner.DEFAULT, Assigner.Typing.DYNAMIC)).make().load(WithCallback.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER_PERSISTENT.with(WithCallback.class.getProtectionDomain())).getLoaded().getConstructor(ResettableClassFileTransformer.class, Callback.class));
                        } catch (Exception ignored) {
                            return Factory.ForLegacyVm.INSTANCE;
                        }
                    }
                }
                class ForJava9CapableVm implements Factory {
                    private final Constructor<? extends ResettableClassFileTransformer> withCallback;
                    protected ForJava9CapableVm(Constructor<? extends ResettableClassFileTransformer> withCallback) {
                        this.withCallback = withCallback;
                    }
                    public ResettableClassFileTransformer make(ResettableClassFileTransformer classFileTransformer, Callback<?> callback) {
                        try {
                            return withCallback.newInstance(classFileTransformer, callback);
                        } catch (IllegalAccessException exception) {
                            throw new IllegalStateException("Cannot access " + withCallback, exception);
                        } catch (InstantiationException exception) {
                            throw new IllegalStateException("Cannot instantiate " + withCallback.getDeclaringClass(), exception);
                        } catch (InvocationTargetException exception) {
                            throw new IllegalStateException("Cannot invoke " + withCallback, exception.getTargetException());
                        }
                    }
                }
                enum ForLegacyVm implements Factory {
                    INSTANCE;
                    public ResettableClassFileTransformer make(ResettableClassFileTransformer classFileTransformer, Callback<?> callback) {
                        return new WithCallback(classFileTransformer, callback);
                    }
                }
            }
        }
        public interface Callback<T> {
            T onBeforeTransform(@MaybeNull JavaModule module, @MaybeNull ClassLoader classLoader, @MaybeNull String internalName, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain, byte[] binaryRepresentation) throws IllegalClassFormatException;
            void onAfterTransform(@MaybeNull T value, @MaybeNull JavaModule module, @MaybeNull ClassLoader classLoader, @MaybeNull String internalName, @MaybeNull Class<?> classBeingRedefined, @MaybeNull ProtectionDomain protectionDomain, byte[] binaryRepresentation) throws IllegalClassFormatException;
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```