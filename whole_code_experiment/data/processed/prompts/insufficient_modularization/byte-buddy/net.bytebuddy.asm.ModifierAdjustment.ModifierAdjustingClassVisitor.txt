##CONTEXT_SIZE=2013
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.asm;
public class ModifierAdjustment extends AsmVisitorWrapper.AbstractBase {
    private final List<Adjustment<TypeDescription>> typeAdjustments;
    private final List<Adjustment<FieldDescription.InDefinedShape>> fieldAdjustments;
    private final List<Adjustment<MethodDescription>> methodAdjustments;
    public ModifierAdjustment() {
        this(Collections.<Adjustment<TypeDescription>>emptyList(), Collections.<Adjustment<FieldDescription.InDefinedShape>>emptyList(), Collections.<Adjustment<MethodDescription>>emptyList());
    }
    protected ModifierAdjustment(List<Adjustment<TypeDescription>> typeAdjustments, List<Adjustment<FieldDescription.InDefinedShape>> fieldAdjustments, List<Adjustment<MethodDescription>> methodAdjustments) {
        this.typeAdjustments = typeAdjustments;
        this.fieldAdjustments = fieldAdjustments;
        this.methodAdjustments = methodAdjustments;
    }
    public ModifierAdjustment withTypeModifiers(ModifierContributor.ForType... modifierContributor) {
        return withTypeModifiers(Arrays.asList(modifierContributor));
    }
    public ModifierAdjustment withTypeModifiers(List<? extends ModifierContributor.ForType> modifierContributors) {
        return withTypeModifiers(any(), modifierContributors);
    }
    public ModifierAdjustment withTypeModifiers(ElementMatcher<? super TypeDescription> matcher, ModifierContributor.ForType... modifierContributor) {
        return withTypeModifiers(matcher, Arrays.asList(modifierContributor));
    }
    public ModifierAdjustment withTypeModifiers(ElementMatcher<? super TypeDescription> matcher, List<? extends ModifierContributor.ForType> modifierContributors) {
        return new ModifierAdjustment(CompoundList.of(new Adjustment<TypeDescription>(matcher, ModifierContributor.Resolver.of(modifierContributors)), typeAdjustments), fieldAdjustments, methodAdjustments);
    }
    public ModifierAdjustment withFieldModifiers(ModifierContributor.ForField... modifierContributor) {
        return withFieldModifiers(Arrays.asList(modifierContributor));
    }
    public ModifierAdjustment withFieldModifiers(List<? extends ModifierContributor.ForField> modifierContributors) {
        return withFieldModifiers(any(), modifierContributors);
    }
    public ModifierAdjustment withFieldModifiers(ElementMatcher<? super FieldDescription.InDefinedShape> matcher, ModifierContributor.ForField... modifierContributor) {
        return withFieldModifiers(matcher, Arrays.asList(modifierContributor));
    }
    public ModifierAdjustment withFieldModifiers(ElementMatcher<? super FieldDescription.InDefinedShape> matcher, List<? extends ModifierContributor.ForField> modifierContributors) {
        return new ModifierAdjustment(typeAdjustments, CompoundList.of(new Adjustment<FieldDescription.InDefinedShape>(matcher, ModifierContributor.Resolver.of(modifierContributors)), fieldAdjustments), methodAdjustments);
    }
    public ModifierAdjustment withMethodModifiers(ModifierContributor.ForMethod... modifierContributor) {
        return withMethodModifiers(Arrays.asList(modifierContributor));
    }
    public ModifierAdjustment withMethodModifiers(List<? extends ModifierContributor.ForMethod> modifierContributors) {
        return withMethodModifiers(any(), modifierContributors);
    }
    public ModifierAdjustment withMethodModifiers(ElementMatcher<? super MethodDescription> matcher, ModifierContributor.ForMethod... modifierContributor) {
        return withMethodModifiers(matcher, Arrays.asList(modifierContributor));
    }
    public ModifierAdjustment withMethodModifiers(ElementMatcher<? super MethodDescription> matcher, List<? extends ModifierContributor.ForMethod> modifierContributors) {
        return withInvokableModifiers(isMethod().and(matcher), modifierContributors);
    }
    public ModifierAdjustment withConstructorModifiers(ModifierContributor.ForMethod... modifierContributor) {
        return withConstructorModifiers(Arrays.asList(modifierContributor));
    }
    public ModifierAdjustment withConstructorModifiers(List<? extends ModifierContributor.ForMethod> modifierContributors) {
        return withConstructorModifiers(any(), modifierContributors);
    }
    public ModifierAdjustment withConstructorModifiers(ElementMatcher<? super MethodDescription> matcher, ModifierContributor.ForMethod... modifierContributor) {
        return withConstructorModifiers(matcher, Arrays.asList(modifierContributor));
    }
    public ModifierAdjustment withConstructorModifiers(ElementMatcher<? super MethodDescription> matcher, List<? extends ModifierContributor.ForMethod> modifierContributors) {
        return withInvokableModifiers(isConstructor().and(matcher), modifierContributors);
    }
    public ModifierAdjustment withInvokableModifiers(ModifierContributor.ForMethod... modifierContributor) {
        return withInvokableModifiers(Arrays.asList(modifierContributor));
    }
    public ModifierAdjustment withInvokableModifiers(List<? extends ModifierContributor.ForMethod> modifierContributors) {
        return withInvokableModifiers(any(), modifierContributors);
    }
    public ModifierAdjustment withInvokableModifiers(ElementMatcher<? super MethodDescription> matcher, ModifierContributor.ForMethod... modifierContributor) {
        return withInvokableModifiers(matcher, Arrays.asList(modifierContributor));
    }
    public ModifierAdjustment withInvokableModifiers(ElementMatcher<? super MethodDescription> matcher, List<? extends ModifierContributor.ForMethod> modifierContributors) {
        return new ModifierAdjustment(typeAdjustments, fieldAdjustments, CompoundList.of(new Adjustment<MethodDescription>(matcher, ModifierContributor.Resolver.of(modifierContributors)), methodAdjustments));
    }
    public ModifierAdjustingClassVisitor wrap(TypeDescription instrumentedType, ClassVisitor classVisitor, Implementation.Context implementationContext, TypePool typePool, FieldList<FieldDescription.InDefinedShape> fields, MethodList<?> methods, int writerFlags, int readerFlags) {
        Map<String, FieldDescription.InDefinedShape> mappedFields = new HashMap<String, FieldDescription.InDefinedShape>();
        for (FieldDescription.InDefinedShape fieldDescription : fields) {
            mappedFields.put(fieldDescription.getInternalName() + fieldDescription.getDescriptor(), fieldDescription);
        }
        Map<String, MethodDescription> mappedMethods = new HashMap<String, MethodDescription>();
        for (MethodDescription methodDescription : CompoundList.<MethodDescription>of(methods, new MethodDescription.Latent.TypeInitializer(instrumentedType))) {
            mappedMethods.put(methodDescription.getInternalName() + methodDescription.getDescriptor(), methodDescription);
        }
        return new ModifierAdjustingClassVisitor(classVisitor, typeAdjustments, fieldAdjustments, methodAdjustments, instrumentedType, mappedFields, mappedMethods);
    }
    protected static class Adjustment<T> implements ElementMatcher<T> {
        private final ElementMatcher<? super T> matcher;
        private final ModifierContributor.Resolver<?> resolver;
        protected Adjustment(ElementMatcher<? super T> matcher, ModifierContributor.Resolver<?> resolver) {
            this.matcher = matcher;
            this.resolver = resolver;
        }
        public boolean matches(@MaybeNull T target) {
            return matcher.matches(target);
        }
        protected int resolve(int modifiers) {
            return resolver.resolve(modifiers);
        }
    }
    protected static class ModifierAdjustingClassVisitor extends ClassVisitor {
        private final List<Adjustment<TypeDescription>> typeAdjustments;
        private final List<Adjustment<FieldDescription.InDefinedShape>> fieldAdjustments;
        private final List<Adjustment<MethodDescription>> methodAdjustments;
        private final TypeDescription instrumentedType;
        private final Map<String, FieldDescription.InDefinedShape> fields;
        private final Map<String, MethodDescription> methods;
        protected ModifierAdjustingClassVisitor(ClassVisitor classVisitor, List<Adjustment<TypeDescription>> typeAdjustments, List<Adjustment<FieldDescription.InDefinedShape>> fieldAdjustments, List<Adjustment<MethodDescription>> methodAdjustments, TypeDescription instrumentedType, Map<String, FieldDescription.InDefinedShape> fields, Map<String, MethodDescription> methods) {
            super(OpenedClassReader.ASM_API, classVisitor);
            this.typeAdjustments = typeAdjustments;
            this.fieldAdjustments = fieldAdjustments;
            this.methodAdjustments = methodAdjustments;
            this.instrumentedType = instrumentedType;
            this.fields = fields;
            this.methods = methods;
        }
        public void visit(int version, int modifiers, String internalName, @MaybeNull String signature, @MaybeNull String superClassName, @MaybeNull String[] interfaceName) {
            for (Adjustment<TypeDescription> adjustment : typeAdjustments) {
                if (adjustment.matches(instrumentedType)) {
                    modifiers = adjustment.resolve(modifiers);
                    break;
                }
            }
            super.visit(version, modifiers, internalName, signature, superClassName, interfaceName);
        }
        public void visitInnerClass(String internalName, @MaybeNull String outerName, @MaybeNull String innerName, int modifiers) {
            if (instrumentedType.getInternalName().equals(internalName)) {
                for (Adjustment<TypeDescription> adjustment : typeAdjustments) {
                    if (adjustment.matches(instrumentedType)) {
                        modifiers = adjustment.resolve(modifiers);
                        break;
                    }
                }
            }
            super.visitInnerClass(internalName, outerName, innerName, modifiers);
        }
        public FieldVisitor visitField(int modifiers, String internalName, String descriptor, @MaybeNull String signature, @MaybeNull Object value) {
            FieldDescription.InDefinedShape fieldDescription = fields.get(internalName + descriptor);
            if (fieldDescription != null) {
                for (Adjustment<FieldDescription.InDefinedShape> adjustment : fieldAdjustments) {
                    if (adjustment.matches(fieldDescription)) {
                        modifiers = adjustment.resolve(modifiers);
                        break;
                    }
                }
            }
            return super.visitField(modifiers, internalName, descriptor, signature, value);
        }
        public MethodVisitor visitMethod(int modifiers, String internalName, String descriptor, @MaybeNull String signature, @MaybeNull String[] exception) {
            MethodDescription methodDescription = methods.get(internalName + descriptor);
            if (methodDescription != null) {
                for (Adjustment<MethodDescription> adjustment : methodAdjustments) {
                    if (adjustment.matches(methodDescription)) {
                        modifiers = adjustment.resolve(modifiers);
                        break;
                    }
                }
            }
            return super.visitMethod(modifiers, internalName, descriptor, signature, exception);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```