##CONTEXT_SIZE=10371
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.asm;
public abstract class ClassVisitorFactory<T> {
    private static final String DELEGATE = "delegate";
    private static final String LABELS = "labels";
    private static final String WRAP = "wrap";
    private final Class<?> type;
    protected ClassVisitorFactory(Class<?> type) {
        this.type = type;
    }
    public Class<?> getType() {
        return type;
    }
    public static <S> ClassVisitorFactory<S> of(Class<S> classVisitor) {
        return of(classVisitor, new ByteBuddy().with(TypeValidation.DISABLED));
    }
    public static <S> ClassVisitorFactory<S> of(Class<S> classVisitor, ByteBuddy byteBuddy) {
        return doPrivileged(new CreateClassVisitorFactory<S>(classVisitor, byteBuddy));
    }
    private static <T> T doPrivileged(PrivilegedAction<T> action) {
        return action.run();
    }
    private static DynamicType.Builder<?> toVisitorBuilder(ByteBuddy byteBuddy, Class<?> sourceVisitor, Class<?> targetVisitor, @MaybeNull Class<?> sourceTypePath, @MaybeNull Class<?> targetTypePath, Implementation appendix) throws Exception {
        DynamicType.Builder<?> builder = byteBuddy.subclass(sourceVisitor, ConstructorStrategy.Default.NO_CONSTRUCTORS).defineField(DELEGATE, targetVisitor, Visibility.PRIVATE, FieldManifestation.FINAL).defineConstructor(Visibility.PUBLIC).withParameters(targetVisitor).intercept(MethodCall.invoke(sourceVisitor.getDeclaredConstructor(int.class)).with(OpenedClassReader.ASM_API).andThen(FieldAccessor.ofField(DELEGATE).setsArgumentAt(0)).andThen(appendix)).defineMethod(WRAP, sourceVisitor, Visibility.PUBLIC, Ownership.STATIC).withParameters(targetVisitor).intercept(new Implementation.Simple(new NullCheckedConstruction(targetVisitor)));
        if (sourceTypePath == null || targetTypePath == null) {
            return builder;
        } else {
            return builder.defineMethod(TypePathTranslator.NAME, targetTypePath, Visibility.PRIVATE, Ownership.STATIC).withParameters(sourceTypePath).intercept(new Implementation.Simple(new TypePathTranslator(sourceTypePath, targetTypePath)));
        }
    }
    private static DynamicType.Builder<?> toMethodVisitorBuilder(ByteBuddy byteBuddy, Class<?> sourceVisitor, Class<?> targetVisitor, @MaybeNull Class<?> sourceTypePath, @MaybeNull Class<?> targetTypePath, @MaybeNull Class<?> sourceLabel, @MaybeNull Class<?> targetLabel, @MaybeNull Class<?> sourceType, @MaybeNull Class<?> targetType, @MaybeNull Class<?> sourceHandle, @MaybeNull Class<?> targetHandle, @MaybeNull Class<?> sourceConstantDynamic, @MaybeNull Class<?> targetConstantDynamic) throws Exception {
        DynamicType.Builder<?> builder = toVisitorBuilder(byteBuddy, sourceVisitor, targetVisitor, sourceTypePath, targetTypePath, FieldAccessor.ofField(LABELS).setsValue(new StackManipulation.Compound(TypeCreation.of(TypeDescription.ForLoadedType.of(HashMap.class)), Duplication.SINGLE, MethodInvocation.invoke(TypeDescription.ForLoadedType.of(HashMap.class).getDeclaredMethods().filter(ElementMatchers.<MethodDescription.InDefinedShape>isConstructor().and(ElementMatchers.<MethodDescription.InDefinedShape>takesArguments(0))).getOnly())), Map.class));
        if (sourceLabel != null && targetLabel != null) {
            builder = builder.defineField(LABELS, Map.class, Visibility.PRIVATE, FieldManifestation.FINAL).defineMethod(LabelTranslator.NAME, targetLabel, Visibility.PRIVATE).withParameters(sourceLabel).intercept(new Implementation.Simple(new LabelTranslator(targetLabel))).defineMethod(LabelArrayTranslator.NAME, TypeDescription.ArrayProjection.of(TypeDescription.ForLoadedType.ForLoadedType.of(targetLabel)), Visibility.PRIVATE).withParameters(TypeDescription.ArrayProjection.of(TypeDescription.ForLoadedType.ForLoadedType.of(sourceLabel))).intercept(new Implementation.Simple(new LabelArrayTranslator(sourceLabel, targetLabel))).defineMethod(FrameTranslator.NAME, Object[].class, Visibility.PRIVATE).withParameters(Object[].class).intercept(new Implementation.Simple(new FrameTranslator(sourceLabel, targetLabel)));
        }
        if (sourceHandle != null && targetHandle != null) {
            builder = builder.defineMethod(HandleTranslator.NAME, targetHandle, Visibility.PRIVATE, Ownership.STATIC).withParameters(sourceHandle).intercept(new Implementation.Simple(new HandleTranslator(sourceHandle, targetHandle)));
        }
        if (sourceConstantDynamic != null && targetConstantDynamic != null && sourceHandle != null && targetHandle != null) {
            builder = builder.defineMethod(ConstantDynamicTranslator.NAME, targetConstantDynamic, Visibility.PRIVATE, Ownership.STATIC).withParameters(sourceConstantDynamic).intercept(new Implementation.Simple(new ConstantDynamicTranslator(sourceConstantDynamic, targetConstantDynamic, sourceHandle, targetHandle)));
        }
        return builder.defineMethod(ConstantTranslator.NAME, Object.class, Visibility.PRIVATE, Ownership.STATIC).withParameters(Object.class).intercept(new Implementation.Simple(new ConstantTranslator(sourceHandle, targetHandle, sourceType, targetType, sourceConstantDynamic, targetConstantDynamic))).defineMethod(ConstantArrayTranslator.NAME, Object[].class, Visibility.PRIVATE, Ownership.STATIC).withParameters(Object[].class).intercept(new Implementation.Simple(new ConstantArrayTranslator()));
    }
    private static MethodCall.ArgumentLoader.Factory toConvertedParameter(TypeDescription source, Class<?> target, String method, int offset, boolean virtual) {
        return new MethodCall.ArgumentLoader.ForStackManipulation(new StackManipulation.Compound(virtual ? MethodVariableAccess.loadThis() : StackManipulation.Trivial.INSTANCE, MethodVariableAccess.REFERENCE.loadFrom(offset), MethodInvocation.invoke(source.getDeclaredMethods().filter(named(method)).getOnly())), target);
    }
    private static DynamicType toAttributeWrapper(DynamicType.Builder<?> builder, Class<?> source, Class<?> target, TypeDescription sourceWrapper, TypeDescription targetWrapper) throws Exception {
        return builder.defineField(DELEGATE, target, Visibility.PUBLIC, FieldManifestation.FINAL).defineConstructor(Visibility.PUBLIC).withParameters(target).intercept(MethodCall.invoke(source.getDeclaredConstructor(String.class)).onSuper().with(new StackManipulation.Compound(MethodVariableAccess.REFERENCE.loadFrom(1), FieldAccess.forField(new FieldDescription.ForLoadedField(target.getField("type"))).read()), String.class).andThen(FieldAccessor.ofField(DELEGATE).setsArgumentAt(0))).defineMethod(AttributeTranslator.NAME, source, Visibility.PUBLIC, Ownership.STATIC).withParameters(target).intercept(new Implementation.Simple(new AttributeTranslator(source, target, sourceWrapper, targetWrapper))).method(isProtected()).intercept(ExceptionMethod.throwing(UnsupportedOperationException.class)).method(named("isUnknown")).intercept(MethodCall.invoke(target.getMethod("isUnknown")).onField(DELEGATE)).method(named("isCodeAttribute")).intercept(MethodCall.invoke(target.getMethod("isCodeAttribute")).onField(DELEGATE)).make();
    }
    public abstract T wrap(ClassVisitor classVisitor);
    public abstract ClassVisitor unwrap(T classVisitor);
    protected static class NullCheckedConstruction implements ByteCodeAppender {
        private final Class<?> type;
        protected NullCheckedConstruction(Class<?> type) {
            this.type = type;
        }
        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            Label label = new Label();
            methodVisitor.visitJumpInsn(Opcodes.IFNULL, label);
            methodVisitor.visitTypeInsn(Opcodes.NEW, implementationContext.getInstrumentedType().getInternalName());
            methodVisitor.visitInsn(Opcodes.DUP);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, implementationContext.getInstrumentedType().getInternalName(), MethodDescription.CONSTRUCTOR_INTERNAL_NAME, Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(type)), false);
            methodVisitor.visitInsn(Opcodes.ARETURN);
            methodVisitor.visitLabel(label);
            implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());
            methodVisitor.visitInsn(Opcodes.ACONST_NULL);
            methodVisitor.visitInsn(Opcodes.ARETURN);
            return new Size(3, 1);
        }
    }
    protected static class LabelTranslator implements ByteCodeAppender {
        protected static final String NAME = "label";
        private final Class<?> target;
        protected LabelTranslator(Class<?> target) {
            this.target = target;
        }
        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
            Label nullCheck = new Label(), end = new Label();
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, nullCheck);
            methodVisitor.visitInsn(Opcodes.ACONST_NULL);
            methodVisitor.visitInsn(Opcodes.ARETURN);
            methodVisitor.visitLabel(nullCheck);
            implementationContext.getFrameGeneration().same(methodVisitor, CompoundList.of(implementationContext.getInstrumentedType(), instrumentedMethod.getParameters().asTypeList()));
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitFieldInsn(Opcodes.GETFIELD, implementationContext.getInstrumentedType().getInternalName(), LABELS, Type.getDescriptor(Map.class));
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(Map.class), "get", Type.getMethodDescriptor(Type.getType(Object.class), Type.getType(Object.class)), true);
            methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(target));
            methodVisitor.visitVarInsn(Opcodes.ASTORE, 2);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);
            methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, end);
            methodVisitor.visitTypeInsn(Opcodes.NEW, Type.getInternalName(target));
            methodVisitor.visitInsn(Opcodes.DUP);
            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, Type.getInternalName(target), MethodDescription.CONSTRUCTOR_INTERNAL_NAME, "()V", false);
            methodVisitor.visitVarInsn(Opcodes.ASTORE, 2);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitFieldInsn(Opcodes.GETFIELD, implementationContext.getInstrumentedType().getInternalName(), LABELS, Type.getDescriptor(Map.class));
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);
            methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(Map.class), "put", Type.getMethodDescriptor(Type.getType(Object.class), Type.getType(Object.class), Type.getType(Object.class)), true);
            methodVisitor.visitInsn(Opcodes.POP);
            methodVisitor.visitLabel(end);
            implementationContext.getFrameGeneration().append(methodVisitor, Collections.<TypeDefinition>singletonList(TypeDescription.ForLoadedType.of(target)), CompoundList.of(implementationContext.getInstrumentedType(), instrumentedMethod.getParameters().asTypeList()));
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);
            methodVisitor.visitInsn(Opcodes.ARETURN);
            return new Size(3, 3);
        }
    }
    protected static class LabelArrayTranslator implements ByteCodeAppender {
        protected static final String NAME = "labels";
        private final Class<?> sourceLabel;
        private final Class<?> targetLabel;
        protected LabelArrayTranslator(Class<?> sourceLabel, Class<?> targetLabel) {
            this.sourceLabel = sourceLabel;
            this.targetLabel = targetLabel;
        }
        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
            Label nullCheck = new Label(), loop = new Label(), end = new Label();
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, nullCheck);
            methodVisitor.visitInsn(Opcodes.ACONST_NULL);
            methodVisitor.visitInsn(Opcodes.ARETURN);
            methodVisitor.visitLabel(nullCheck);
            implementationContext.getFrameGeneration().same(methodVisitor, CompoundList.of(implementationContext.getInstrumentedType(), instrumentedMethod.getParameters().asTypeList()));
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitInsn(Opcodes.ARRAYLENGTH);
            methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, Type.getInternalName(targetLabel));
            methodVisitor.visitVarInsn(Opcodes.ASTORE, 2);
            methodVisitor.visitInsn(Opcodes.ICONST_0);
            methodVisitor.visitVarInsn(Opcodes.ISTORE, 3);
            methodVisitor.visitLabel(loop);
            implementationContext.getFrameGeneration().append(methodVisitor, Arrays.asList(TypeDescription.ArrayProjection.of(TypeDescription.ForLoadedType.of(targetLabel)), TypeDescription.ForLoadedType.of(int.class)), CompoundList.of(implementationContext.getInstrumentedType(), instrumentedMethod.getParameters().asTypeList()));
            methodVisitor.visitVarInsn(Opcodes.ILOAD, 3);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitInsn(Opcodes.ARRAYLENGTH);
            methodVisitor.visitJumpInsn(Opcodes.IF_ICMPGE, end);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);
            methodVisitor.visitVarInsn(Opcodes.ILOAD, 3);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitVarInsn(Opcodes.ILOAD, 3);
            methodVisitor.visitInsn(Opcodes.AALOAD);
            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, implementationContext.getInstrumentedType().getInternalName(), LabelTranslator.NAME, Type.getMethodDescriptor(Type.getType(targetLabel), Type.getType(sourceLabel)), false);
            methodVisitor.visitInsn(Opcodes.AASTORE);
            methodVisitor.visitIincInsn(3, 1);
            methodVisitor.visitJumpInsn(Opcodes.GOTO, loop);
            methodVisitor.visitLabel(end);
            implementationContext.getFrameGeneration().chop(methodVisitor, 1, CompoundList.of(Collections.singletonList(implementationContext.getInstrumentedType()), instrumentedMethod.getParameters().asTypeList(), Collections.singletonList(TypeDescription.ArrayProjection.of(TypeDescription.ForLoadedType.of(targetLabel)))));
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);
            methodVisitor.visitInsn(Opcodes.ARETURN);
            return new Size(5, 4);
        }
    }
    protected static class HandleTranslator implements ByteCodeAppender {
        protected static final String NAME = "handle";
        private final Class<?> sourceHandle;
        private final Class<?> targetHandle;
        protected HandleTranslator(Class<?> sourceHandle, Class<?> targetHandle) {
            this.sourceHandle = sourceHandle;
            this.targetHandle = targetHandle;
        }
        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
            Label nullCheck = new Label();
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, nullCheck);
            methodVisitor.visitInsn(Opcodes.ACONST_NULL);
            methodVisitor.visitInsn(Opcodes.ARETURN);
            methodVisitor.visitLabel(nullCheck);
            implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());
            methodVisitor.visitTypeInsn(Opcodes.NEW, Type.getInternalName(targetHandle));
            methodVisitor.visitInsn(Opcodes.DUP);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(sourceHandle), "getTag", Type.getMethodDescriptor(Type.INT_TYPE), false);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(sourceHandle), "getOwner", Type.getMethodDescriptor(Type.getType(String.class)), false);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(sourceHandle), "getName", Type.getMethodDescriptor(Type.getType(String.class)), false);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(sourceHandle), "getDesc", Type.getMethodDescriptor(Type.getType(String.class)), false);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(sourceHandle), "isInterface", Type.getMethodDescriptor(Type.BOOLEAN_TYPE), false);
            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, Type.getInternalName(targetHandle), MethodDescription.CONSTRUCTOR_INTERNAL_NAME, Type.getMethodDescriptor(Type.VOID_TYPE, Type.INT_TYPE, Type.getType(String.class), Type.getType(String.class), Type.getType(String.class), Type.BOOLEAN_TYPE), false);
            methodVisitor.visitInsn(Opcodes.ARETURN);
            return new Size(7, 1);
        }
    }
    protected static class ConstantDynamicTranslator implements ByteCodeAppender {
        protected static final String NAME = "constantDyanmic";
        private final Class<?> sourceConstantDynamic;
        private final Class<?> targetConstantDynamic;
        private final Class<?> sourceHandle;
        private final Class<?> targetHandle;
        protected ConstantDynamicTranslator(Class<?> sourceConstantDynamic, Class<?> targetConstantDynamic, Class<?> sourceHandle, Class<?> targetHandle) {
            this.sourceConstantDynamic = sourceConstantDynamic;
            this.targetConstantDynamic = targetConstantDynamic;
            this.sourceHandle = sourceHandle;
            this.targetHandle = targetHandle;
        }
        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
            Label loop = new Label(), end = new Label();
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(sourceConstantDynamic), "getBootstrapMethodArgumentCount", Type.getMethodDescriptor(Type.INT_TYPE), false);
            methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, Type.getInternalName(Object.class));
            methodVisitor.visitVarInsn(Opcodes.ASTORE, 1);
            methodVisitor.visitInsn(Opcodes.ICONST_0);
            methodVisitor.visitVarInsn(Opcodes.ISTORE, 2);
            methodVisitor.visitLabel(loop);
            implementationContext.getFrameGeneration().append(methodVisitor, Arrays.asList(TypeDescription.ForLoadedType.of(Object[].class), TypeDescription.ForLoadedType.of(int.class)), instrumentedMethod.getParameters().asTypeList());
            methodVisitor.visitVarInsn(Opcodes.ILOAD, 2);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitInsn(Opcodes.ARRAYLENGTH);
            methodVisitor.visitJumpInsn(Opcodes.IF_ICMPGE, end);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitVarInsn(Opcodes.ILOAD, 2);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitVarInsn(Opcodes.ILOAD, 2);
            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(sourceConstantDynamic), "getBootstrapMethodArgument", Type.getMethodDescriptor(Type.getType(Object.class), Type.INT_TYPE), false);
            methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, implementationContext.getInstrumentedType().getInternalName(), "ldc", Type.getMethodDescriptor(Type.getType(Object.class), Type.getType(Object.class)), false);
            methodVisitor.visitInsn(Opcodes.AASTORE);
            methodVisitor.visitIincInsn(2, 1);
            methodVisitor.visitJumpInsn(Opcodes.GOTO, loop);
            methodVisitor.visitLabel(end);
            implementationContext.getFrameGeneration().chop(methodVisitor, 1, CompoundList.of(instrumentedMethod.getParameters().asTypeList(), TypeDescription.ForLoadedType.of(Object[].class)));
            methodVisitor.visitTypeInsn(Opcodes.NEW, Type.getInternalName(targetConstantDynamic));
            methodVisitor.visitInsn(Opcodes.DUP);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(sourceConstantDynamic), "getName", Type.getMethodDescriptor(Type.getType(String.class)), false);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(sourceConstantDynamic), "getDescriptor", Type.getMethodDescriptor(Type.getType(String.class)), false);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(sourceConstantDynamic), "getBootstrapMethod", Type.getMethodDescriptor(Type.getType(sourceHandle)), false);
            methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, implementationContext.getInstrumentedType().getInternalName(), HandleTranslator.NAME, Type.getMethodDescriptor(Type.getType(targetHandle), Type.getType(sourceHandle)), false);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, Type.getInternalName(targetConstantDynamic), MethodDescription.CONSTRUCTOR_INTERNAL_NAME, Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(String.class), Type.getType(String.class), Type.getType(targetHandle), Type.getType(Object[].class)), false);
            methodVisitor.visitInsn(Opcodes.ARETURN);
            methodVisitor.visitMaxs(6, 3);
            return new Size(6, 3);
        }
    }
    protected static class ConstantTranslator implements ByteCodeAppender {
        protected static final String NAME = "constant";
        private final Class<?> sourceHandle;
        private final Class<?> targetHandle;
        private final Class<?> sourceType;
        private final Class<?> targetType;
        private final Class<?> sourceConstantDynamic;
        private final Class<?> targetConstantDynamic;
        protected ConstantTranslator(@MaybeNull Class<?> sourceHandle, @MaybeNull Class<?> targetHandle, @MaybeNull Class<?> sourceType, @MaybeNull Class<?> targetType, @MaybeNull Class<?> sourceConstantDynamic, @MaybeNull Class<?> targetConstantDynamic) {
            this.sourceHandle = sourceHandle;
            this.targetHandle = targetHandle;
            this.sourceType = sourceType;
            this.targetType = targetType;
            this.sourceConstantDynamic = sourceConstantDynamic;
            this.targetConstantDynamic = targetConstantDynamic;
        }
        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
            Label noType = new Label(), noHandle = new Label(), noConstantDynamic = new Label();
            if (sourceType != null && targetType != null) {
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
                methodVisitor.visitTypeInsn(Opcodes.INSTANCEOF, Type.getInternalName(sourceType));
                methodVisitor.visitJumpInsn(Opcodes.IFEQ, noType);
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(sourceType));
                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(sourceType), "getDescriptor", Type.getMethodDescriptor(Type.getType(String.class)), false);
                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(targetType), "getType", Type.getMethodDescriptor(Type.getType(targetType), Type.getType(String.class)), false);
                methodVisitor.visitInsn(Opcodes.ARETURN);
                methodVisitor.visitLabel(noType);
                implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());
            }
            if (sourceHandle != null && targetHandle != null) {
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
                methodVisitor.visitTypeInsn(Opcodes.INSTANCEOF, Type.getInternalName(sourceHandle));
                methodVisitor.visitJumpInsn(Opcodes.IFEQ, noHandle);
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(sourceHandle));
                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, implementationContext.getInstrumentedType().getInternalName(), HandleTranslator.NAME, Type.getMethodDescriptor(Type.getType(targetHandle), Type.getType(sourceHandle)), false);
                methodVisitor.visitInsn(Opcodes.ARETURN);
                methodVisitor.visitLabel(noHandle);
                implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());
            }
            if (sourceConstantDynamic != null && targetConstantDynamic != null) {
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
                methodVisitor.visitTypeInsn(Opcodes.INSTANCEOF, Type.getInternalName(sourceConstantDynamic));
                methodVisitor.visitJumpInsn(Opcodes.IFEQ, noConstantDynamic);
                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(sourceConstantDynamic));
                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, implementationContext.getInstrumentedType().getInternalName(), ConstantDynamicTranslator.NAME, Type.getMethodDescriptor(Type.getType(targetConstantDynamic), Type.getType(sourceConstantDynamic)), false);
                methodVisitor.visitInsn(Opcodes.ARETURN);
                methodVisitor.visitLabel(noConstantDynamic);
                implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());
            }
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitInsn(Opcodes.ARETURN);
            return new Size(1, 1);
        }
    }
    protected static class ConstantArrayTranslator implements ByteCodeAppender {
        protected static final String NAME = "constants";
        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
            Label nullCheck = new Label(), loop = new Label(), end = new Label();
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, nullCheck);
            methodVisitor.visitInsn(Opcodes.ACONST_NULL);
            methodVisitor.visitInsn(Opcodes.ARETURN);
            methodVisitor.visitLabel(nullCheck);
            implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitInsn(Opcodes.ARRAYLENGTH);
            methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, Type.getInternalName(Object.class));
            methodVisitor.visitVarInsn(Opcodes.ASTORE, 1);
            methodVisitor.visitInsn(Opcodes.ICONST_0);
            methodVisitor.visitVarInsn(Opcodes.ISTORE, 2);
            methodVisitor.visitLabel(loop);
            implementationContext.getFrameGeneration().append(methodVisitor, Arrays.asList(TypeDescription.ForLoadedType.of(Object[].class), TypeDescription.ForLoadedType.of(int.class)), instrumentedMethod.getParameters().asTypeList());
            methodVisitor.visitVarInsn(Opcodes.ILOAD, 2);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitInsn(Opcodes.ARRAYLENGTH);
            methodVisitor.visitJumpInsn(Opcodes.IF_ICMPGE, end);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitVarInsn(Opcodes.ILOAD, 2);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitVarInsn(Opcodes.ILOAD, 2);
            methodVisitor.visitInsn(Opcodes.AALOAD);
            methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, implementationContext.getInstrumentedType().getInternalName(), ConstantTranslator.NAME, Type.getMethodDescriptor(Type.getType(Object.class), Type.getType(Object.class)), false);
            methodVisitor.visitInsn(Opcodes.AASTORE);
            methodVisitor.visitIincInsn(2, 1);
            methodVisitor.visitJumpInsn(Opcodes.GOTO, loop);
            methodVisitor.visitLabel(end);
            implementationContext.getFrameGeneration().chop(methodVisitor, 1, CompoundList.of(instrumentedMethod.getParameters().asTypeList(), TypeDescription.ForLoadedType.of(Object[].class)));
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitInsn(Opcodes.ARETURN);
            return new Size(4, 3);
        }
    }
    protected static class FrameTranslator implements ByteCodeAppender {
        protected static final String NAME = "frames";
        private final Class<?> sourceLabel;
        private final Class<?> targetLabel;
        protected FrameTranslator(Class<?> sourceLabel, Class<?> targetLabel) {
            this.sourceLabel = sourceLabel;
            this.targetLabel = targetLabel;
        }
        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
            Label nullCheck = new Label(), loop = new Label(), store = new Label(), end = new Label(), label = new Label();
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, nullCheck);
            methodVisitor.visitInsn(Opcodes.ACONST_NULL);
            methodVisitor.visitInsn(Opcodes.ARETURN);
            methodVisitor.visitLabel(nullCheck);
            implementationContext.getFrameGeneration().same(methodVisitor, CompoundList.of(implementationContext.getInstrumentedType(), instrumentedMethod.getParameters().asTypeList()));
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitInsn(Opcodes.ARRAYLENGTH);
            methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, Type.getInternalName(Object.class));
            methodVisitor.visitVarInsn(Opcodes.ASTORE, 2);
            methodVisitor.visitInsn(Opcodes.ICONST_0);
            methodVisitor.visitVarInsn(Opcodes.ISTORE, 3);
            methodVisitor.visitLabel(loop);
            implementationContext.getFrameGeneration().append(methodVisitor, Arrays.asList(TypeDescription.ForLoadedType.of(Object[].class), TypeDescription.ForLoadedType.of(int.class)), CompoundList.of(implementationContext.getInstrumentedType(), instrumentedMethod.getParameters().asTypeList()));
            methodVisitor.visitVarInsn(Opcodes.ILOAD, 3);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitInsn(Opcodes.ARRAYLENGTH);
            methodVisitor.visitJumpInsn(Opcodes.IF_ICMPGE, end);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);
            methodVisitor.visitVarInsn(Opcodes.ILOAD, 3);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitVarInsn(Opcodes.ILOAD, 3);
            methodVisitor.visitInsn(Opcodes.AALOAD);
            methodVisitor.visitTypeInsn(Opcodes.INSTANCEOF, Type.getInternalName(sourceLabel));
            methodVisitor.visitJumpInsn(Opcodes.IFEQ, label);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitVarInsn(Opcodes.ILOAD, 3);
            methodVisitor.visitInsn(Opcodes.AALOAD);
            methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(sourceLabel));
            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, implementationContext.getInstrumentedType().getInternalName(), LabelTranslator.NAME, Type.getMethodDescriptor(Type.getType(targetLabel), Type.getType(sourceLabel)), false);
            methodVisitor.visitJumpInsn(Opcodes.GOTO, store);
            methodVisitor.visitLabel(label);
            implementationContext.getFrameGeneration().full(methodVisitor, Arrays.asList(TypeDescription.ForLoadedType.of(Object[].class), TypeDescription.ForLoadedType.of(int.class)), CompoundList.of(Collections.singletonList(implementationContext.getInstrumentedType()), instrumentedMethod.getParameters().asTypeList(), Arrays.asList(TypeDescription.ForLoadedType.of(Object[].class), TypeDescription.ForLoadedType.of(int.class))));
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);
            methodVisitor.visitVarInsn(Opcodes.ILOAD, 3);
            methodVisitor.visitInsn(Opcodes.AALOAD);
            methodVisitor.visitLabel(store);
            implementationContext.getFrameGeneration().full(methodVisitor, Arrays.asList(TypeDescription.ForLoadedType.of(Object[].class), TypeDescription.ForLoadedType.of(int.class), TypeDescription.ForLoadedType.of(Object.class)), CompoundList.of(Collections.singletonList(implementationContext.getInstrumentedType()), instrumentedMethod.getParameters().asTypeList(), Arrays.asList(TypeDescription.ForLoadedType.of(Object[].class), TypeDescription.ForLoadedType.of(int.class))));
            methodVisitor.visitInsn(Opcodes.AASTORE);
            methodVisitor.visitIincInsn(3, 1);
            methodVisitor.visitJumpInsn(Opcodes.GOTO, loop);
            methodVisitor.visitLabel(end);
            implementationContext.getFrameGeneration().chop(methodVisitor, 1, CompoundList.of(Collections.singletonList(implementationContext.getInstrumentedType()), instrumentedMethod.getParameters().asTypeList(), Collections.singletonList(TypeDescription.ForLoadedType.of(Object[].class))));
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);
            methodVisitor.visitInsn(Opcodes.ARETURN);
            return new Size(5, 4);
        }
    }
    protected static class TypePathTranslator implements ByteCodeAppender {
        protected static final String NAME = "typePath";
        private final Class<?> sourceTypePath;
        private final Class<?> targetTypePath;
        protected TypePathTranslator(Class<?> sourceTypePath, Class<?> targetTypePath) {
            this.sourceTypePath = sourceTypePath;
            this.targetTypePath = targetTypePath;
        }
        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
            Label nullCheck = new Label(), end = new Label();
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, nullCheck);
            methodVisitor.visitInsn(Opcodes.ACONST_NULL);
            methodVisitor.visitJumpInsn(Opcodes.GOTO, end);
            implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());
            methodVisitor.visitLabel(nullCheck);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(sourceTypePath), "toString", Type.getMethodDescriptor(Type.getType(String.class)), false);
            methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(targetTypePath), "fromString", Type.getMethodDescriptor(Type.getType(targetTypePath), Type.getType(String.class)), false);
            methodVisitor.visitLabel(end);
            implementationContext.getFrameGeneration().same1(methodVisitor, TypeDescription.ForLoadedType.of(targetTypePath), instrumentedMethod.getParameters().asTypeList());
            methodVisitor.visitInsn(Opcodes.ARETURN);
            return new Size(1, 2);
        }
    }
    protected static class AttributeTranslator implements ByteCodeAppender {
        protected static final String NAME = "attribute";
        private final Class<?> sourceAttribute;
        private final Class<?> targetAttribute;
        private final TypeDescription sourceWrapper;
        private final TypeDescription targetWrapper;
        protected AttributeTranslator(Class<?> sourceAttribute, Class<?> targetAttribute, TypeDescription sourceWrapper, TypeDescription targetWrapper) {
            this.sourceAttribute = sourceAttribute;
            this.targetAttribute = targetAttribute;
            this.sourceWrapper = sourceWrapper;
            this.targetWrapper = targetWrapper;
        }
        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
            Label nullCheck = new Label(), wrapperCheck = new Label();
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, nullCheck);
            methodVisitor.visitInsn(Opcodes.ACONST_NULL);
            methodVisitor.visitInsn(Opcodes.ARETURN);
            methodVisitor.visitLabel(nullCheck);
            implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitTypeInsn(Opcodes.INSTANCEOF, targetWrapper.getInternalName());
            methodVisitor.visitJumpInsn(Opcodes.IFEQ, wrapperCheck);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, targetWrapper.getInternalName());
            methodVisitor.visitFieldInsn(Opcodes.GETFIELD, targetWrapper.getInternalName(), DELEGATE, Type.getDescriptor(sourceAttribute));
            methodVisitor.visitInsn(Opcodes.ARETURN);
            methodVisitor.visitLabel(wrapperCheck);
            implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());
            methodVisitor.visitTypeInsn(Opcodes.NEW, sourceWrapper.getInternalName());
            methodVisitor.visitInsn(Opcodes.DUP);
            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);
            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, sourceWrapper.getInternalName(), MethodDescription.CONSTRUCTOR_INTERNAL_NAME, Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(targetAttribute)), false);
            methodVisitor.visitInsn(Opcodes.ARETURN);
            return new Size(3, 1);
        }
    }
    protected static class CreateClassVisitorFactory<S> implements PrivilegedAction<ClassVisitorFactory<S>> {
        private final Class<S> classVisitor;
        private final ByteBuddy byteBuddy;
        protected CreateClassVisitorFactory(Class<S> classVisitor, ByteBuddy byteBuddy) {
            this.classVisitor = classVisitor;
            this.byteBuddy = byteBuddy;
        }
        public ClassVisitorFactory<S> run() {
            if (!ClassVisitor.class.getSimpleName().equals(classVisitor.getSimpleName())) {
                throw new IllegalArgumentException("Expected a class named " + ClassVisitor.class.getSimpleName() + ": " + classVisitor);
            }
            try {
                String prefix = classVisitor.getPackage().getName();
                Map<Class<?>, Class<?>> utilities = new HashMap<Class<?>, Class<?>>();
                for (Class<?> type : Arrays.<Class<?>>asList(Attribute.class, Label.class, Type.class, TypePath.class, Handle.class, ConstantDynamic.class)) {
                    Class<?> utility;
                    try {
                        utility = Class.forName(prefix + "." + type.getSimpleName(), false, classVisitor.getClassLoader());
                    } catch (ClassNotFoundException ignored) {
                        continue;
                    }
                    utilities.put(type, utility);
                }
                if (utilities.containsKey(Label.class)) {
                    utilities.put(Label[].class, Class.forName("[L" + utilities.get(Label.class).getName() + ";", false, classVisitor.getClassLoader()));
                }
                Map<Class<?>, Class<?>> equivalents = new HashMap<Class<?>, Class<?>>();
                Map<Class<?>, DynamicType.Builder<?>> builders = new HashMap<Class<?>, DynamicType.Builder<?>>();
                for (Class<?> type : Arrays.<Class<?>>asList(ClassVisitor.class, AnnotationVisitor.class, ModuleVisitor.class, RecordComponentVisitor.class, FieldVisitor.class, MethodVisitor.class)) {
                    Class<?> equivalent;
                    try {
                        equivalent = Class.forName(prefix + "." + type.getSimpleName(), false, classVisitor.getClassLoader());
                    } catch (ClassNotFoundException ignored) {
                        continue;
                    }
                    DynamicType.Builder<?> wrapper, unwrapper;
                    if (type == MethodVisitor.class) {
                        wrapper = toMethodVisitorBuilder(byteBuddy, type, equivalent, TypePath.class, utilities.get(TypePath.class), Label.class, utilities.get(Label.class), Type.class, utilities.get(Type.class), Handle.class, utilities.get(Handle.class), ConstantDynamic.class, utilities.get(ConstantDynamic.class));
                        unwrapper = toMethodVisitorBuilder(byteBuddy, equivalent, type, utilities.get(TypePath.class), TypePath.class, utilities.get(Label.class), Label.class, utilities.get(Type.class), Type.class, utilities.get(Handle.class), Handle.class, utilities.get(ConstantDynamic.class), ConstantDynamic.class);
                    } else {
                        wrapper = toVisitorBuilder(byteBuddy, type, equivalent, TypePath.class, utilities.get(TypePath.class), new Implementation.Simple(MethodReturn.VOID));
                        unwrapper = toVisitorBuilder(byteBuddy, equivalent, type, utilities.get(TypePath.class), TypePath.class, new Implementation.Simple(MethodReturn.VOID));
                    }
                    equivalents.put(type, equivalent);
                    builders.put(type, wrapper);
                    builders.put(equivalent, unwrapper);
                }
                List<DynamicType> dynamicTypes = new ArrayList<DynamicType>();
                Map<Class<?>, TypeDescription> generated = new HashMap<Class<?>, TypeDescription>();
                DynamicType sourceAttribute, targetAttribute;
                if (utilities.containsKey(Attribute.class)) {
                    DynamicType.Builder<?> source = byteBuddy.subclass(Attribute.class, ConstructorStrategy.Default.NO_CONSTRUCTORS);
                    DynamicType.Builder<?> target = byteBuddy.subclass(utilities.get(Attribute.class), ConstructorStrategy.Default.NO_CONSTRUCTORS);
                    sourceAttribute = toAttributeWrapper(source, Attribute.class, utilities.get(Attribute.class), source.toTypeDescription(), target.toTypeDescription());
                    dynamicTypes.add(sourceAttribute);
                    targetAttribute = toAttributeWrapper(target, utilities.get(Attribute.class), Attribute.class, target.toTypeDescription(), source.toTypeDescription());
                    dynamicTypes.add(targetAttribute);
                } else {
                    sourceAttribute = null;
                    targetAttribute = null;
                }
                for (Map.Entry<Class<?>, Class<?>> entry : equivalents.entrySet()) {
                    DynamicType.Builder<?> wrapper = builders.get(entry.getKey()), unwrapper = builders.get(entry.getValue());
                    for (Method method : entry.getKey().getMethods()) {
                        if (method.getDeclaringClass() == Object.class) {
                            continue;
                        }
                        Class<?>[] parameter = method.getParameterTypes(), match = new Class<?>[parameter.length];
                        List<MethodCall.ArgumentLoader.Factory> left = new ArrayList<MethodCall.ArgumentLoader.Factory>(parameter.length);
                        List<MethodCall.ArgumentLoader.Factory> right = new ArrayList<MethodCall.ArgumentLoader.Factory>(match.length);
                        boolean unsupported = false, unresolved = false;
                        int offset = 1;
                        for (int index = 0; index < parameter.length; index++) {
                            if (entry.getKey() == MethodVisitor.class && parameter[index] == Label.class) {
                                match[index] = utilities.get(Label.class);
                                left.add(toConvertedParameter(builders.get(entry.getKey()).toTypeDescription(), match[index], LabelTranslator.NAME, offset, true));
                                right.add(toConvertedParameter(builders.get(entry.getValue()).toTypeDescription(), parameter[index], LabelTranslator.NAME, offset, true));
                            } else if (entry.getKey() == MethodVisitor.class && parameter[index] == Label[].class) {
                                match[index] = utilities.get(Label[].class);
                                left.add(toConvertedParameter(builders.get(entry.getKey()).toTypeDescription(), match[index], LabelArrayTranslator.NAME, offset, true));
                                right.add(toConvertedParameter(builders.get(entry.getValue()).toTypeDescription(), parameter[index], LabelArrayTranslator.NAME, offset, true));
                            } else if (parameter[index] == TypePath.class) {
                                match[index] = utilities.get(TypePath.class);
                                left.add(toConvertedParameter(builders.get(entry.getKey()).toTypeDescription(), match[index], TypePathTranslator.NAME, offset, false));
                                right.add(toConvertedParameter(builders.get(entry.getValue()).toTypeDescription(), parameter[index], TypePathTranslator.NAME, offset, false));
                            } else if (entry.getKey() == MethodVisitor.class && parameter[index] == Handle.class) {
                                match[index] = utilities.get(Handle.class);
                                left.add(toConvertedParameter(builders.get(entry.getKey()).toTypeDescription(), match[index], HandleTranslator.NAME, offset, false));
                                right.add(toConvertedParameter(builders.get(entry.getValue()).toTypeDescription(), parameter[index], HandleTranslator.NAME, offset, false));
                            } else if (entry.getKey() == MethodVisitor.class && parameter[index] == Object.class) {
                                match[index] = Object.class;
                                left.add(toConvertedParameter(builders.get(entry.getKey()).toTypeDescription(), Object.class, ConstantTranslator.NAME, offset, false));
                                right.add(toConvertedParameter(builders.get(entry.getValue()).toTypeDescription(), Object.class, ConstantTranslator.NAME, offset, false));
                            } else if (entry.getKey() == MethodVisitor.class && parameter[index] == Object[].class) {
                                match[index] = Object[].class;
                                if (method.getName().equals("visitFrame")) {
                                    left.add(toConvertedParameter(builders.get(entry.getKey()).toTypeDescription(), Object[].class, FrameTranslator.NAME, offset, true));
                                    right.add(toConvertedParameter(builders.get(entry.getValue()).toTypeDescription(), Object[].class, FrameTranslator.NAME, offset, true));
                                } else {
                                    left.add(toConvertedParameter(builders.get(entry.getKey()).toTypeDescription(), Object[].class, ConstantArrayTranslator.NAME, offset, false));
                                    right.add(toConvertedParameter(builders.get(entry.getValue()).toTypeDescription(), Object[].class, ConstantArrayTranslator.NAME, offset, false));
                                }
                            } else if (parameter[index] == Attribute.class) {
                                match[index] = utilities.get(Attribute.class);
                                if (sourceAttribute != null && targetAttribute != null) {
                                    left.add(toConvertedParameter(targetAttribute.getTypeDescription(), utilities.get(Attribute.class), AttributeTranslator.NAME, offset, false));
                                    right.add(toConvertedParameter(sourceAttribute.getTypeDescription(), Attribute.class, AttributeTranslator.NAME, offset, false));
                                } else {
                                    unsupported = true;
                                }
                            } else {
                                match[index] = parameter[index];
                                left.add(new MethodCall.ArgumentLoader.ForMethodParameter.Factory(index));
                                right.add(new MethodCall.ArgumentLoader.ForMethodParameter.Factory(index));
                            }
                            if (match[index] == null) {
                                unresolved = true;
                                break;
                            }
                            offset += parameter[index] == long.class || parameter[index] == double.class ? 2 : 1;
                        }
                        Method target;
                        if (unresolved) {
                            target = null;
                            unsupported = true;
                        } else {
                            try {
                                target = entry.getValue().getMethod(method.getName(), match);
                            } catch (NoSuchMethodException ignored) {
                                target = null;
                                unsupported = true;
                            }
                        }
                        if (unsupported) {
                            wrapper = wrapper.method(is(method)).intercept(ExceptionMethod.throwing(UnsupportedOperationException.class));
                            if (target != null) {
                                unwrapper = unwrapper.method(is(target)).intercept(ExceptionMethod.throwing(UnsupportedOperationException.class));
                            }
                        } else {
                            MethodCall wrapping = MethodCall.invoke(target).onField(DELEGATE).with(left);
                            MethodCall unwrapping = MethodCall.invoke(method).onField(DELEGATE).with(right);
                            Class<?> returned = equivalents.get(method.getReturnType());
                            if (returned != null) {
                                wrapping = MethodCall.invoke(builders.get(method.getReturnType()).toTypeDescription().getDeclaredMethods().filter(named(WRAP)).getOnly()).withMethodCall(wrapping);
                                unwrapping = MethodCall.invoke(builders.get(returned).toTypeDescription().getDeclaredMethods().filter(named(WRAP)).getOnly()).withMethodCall(unwrapping);
                            }
                            wrapper = wrapper.method(is(method)).intercept(wrapping);
                            unwrapper = unwrapper.method(is(target)).intercept(unwrapping);
                        }
                    }
                    DynamicType left = wrapper.make(), right = unwrapper.make();
                    generated.put(entry.getKey(), left.getTypeDescription());
                    generated.put(entry.getValue(), right.getTypeDescription());
                    dynamicTypes.add(left);
                    dynamicTypes.add(right);
                }
                ClassLoader classLoader = new MultipleParentClassLoader.Builder(false).appendMostSpecific(ClassVisitor.class, classVisitor).build();
                @SuppressWarnings("unchecked")
                ClassVisitorFactory<S> factory = byteBuddy.subclass(ClassVisitorFactory.class, ConstructorStrategy.Default.IMITATE_SUPER_CLASS_OPENING).method(named("wrap")).intercept(MethodCall.construct(generated.get(classVisitor).getDeclaredMethods().filter(ElementMatchers.<MethodDescription.InDefinedShape>isConstructor()).getOnly()).withArgument(0)).method(named("unwrap")).intercept(MethodCall.construct(generated.get(ClassVisitor.class).getDeclaredMethods().filter(ElementMatchers.<MethodDescription.InDefinedShape>isConstructor()).getOnly()).withArgument(0).withAssigner(Assigner.DEFAULT, Assigner.Typing.DYNAMIC)).make().include(dynamicTypes).load(classLoader).getLoaded().getConstructor(Class.class).newInstance(classVisitor);
                if (classLoader instanceof MultipleParentClassLoader && classLoader != ClassVisitor.class.getClassLoader() && classLoader != classVisitor.getClassLoader() && !((MultipleParentClassLoader) classLoader).seal()) {
                    throw new IllegalStateException("Failed to seal multiple parent class loader: " + classLoader);
                }
                return factory;
            } catch (Exception exception) {
                throw new IllegalArgumentException("Failed to generate factory for " + classVisitor.getName(), exception);
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```