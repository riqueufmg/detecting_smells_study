##CONTEXT_SIZE=27575
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.dynamic.scaffold;
public interface TypeWriter<T> {
    String DUMP_PROPERTY = "net.bytebuddy.dump";
    DynamicType.Unloaded<T> make(TypeResolutionStrategy.Resolved typeResolver);
    ContextClassVisitor wrap(ClassVisitor classVisitor, int writerFlags, int readerFlags);
    interface FieldPool {
        Record target(FieldDescription fieldDescription);
        interface Record {
            boolean isImplicit();
            FieldDescription getField();
            FieldAttributeAppender getFieldAppender();
            Object resolveDefault(@MaybeNull Object defaultValue);
            void apply(ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory);
            void apply(FieldVisitor fieldVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory);
            class ForImplicitField implements Record {
                private final FieldDescription fieldDescription;
                public ForImplicitField(FieldDescription fieldDescription) {
                    this.fieldDescription = fieldDescription;
                }
                public boolean isImplicit() {
                    return true;
                }
                public FieldDescription getField() {
                    return fieldDescription;
                }
                public FieldAttributeAppender getFieldAppender() {
                    throw new IllegalStateException("An implicit field record does not expose a field appender: " + this);
                }
                public Object resolveDefault(@MaybeNull Object defaultValue) {
                    throw new IllegalStateException("An implicit field record does not expose a default value: " + this);
                }
                public void apply(ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                    FieldVisitor fieldVisitor = classVisitor.visitField(fieldDescription.getActualModifiers(), fieldDescription.getInternalName(), fieldDescription.getDescriptor(), fieldDescription.getGenericSignature(), FieldDescription.NO_DEFAULT_VALUE);
                    if (fieldVisitor != null) {
                        FieldAttributeAppender.ForInstrumentedField.INSTANCE.apply(fieldVisitor, fieldDescription, annotationValueFilterFactory.on(fieldDescription));
                        fieldVisitor.visitEnd();
                    }
                }
                public void apply(FieldVisitor fieldVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                    throw new IllegalStateException("An implicit field record is not intended for partial application: " + this);
                }
            }
            class ForExplicitField implements Record {
                private final FieldAttributeAppender attributeAppender;
                private final Object defaultValue;
                private final FieldDescription fieldDescription;
                public ForExplicitField(FieldAttributeAppender attributeAppender, @MaybeNull Object defaultValue, FieldDescription fieldDescription) {
                    this.attributeAppender = attributeAppender;
                    this.defaultValue = defaultValue;
                    this.fieldDescription = fieldDescription;
                }
                public boolean isImplicit() {
                    return false;
                }
                public FieldDescription getField() {
                    return fieldDescription;
                }
                public FieldAttributeAppender getFieldAppender() {
                    return attributeAppender;
                }
                public Object resolveDefault(@MaybeNull Object defaultValue) {
                    return this.defaultValue == null ? defaultValue : this.defaultValue;
                }
                public void apply(ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                    FieldVisitor fieldVisitor = classVisitor.visitField(fieldDescription.getActualModifiers(), fieldDescription.getInternalName(), fieldDescription.getDescriptor(), fieldDescription.getGenericSignature(), resolveDefault(FieldDescription.NO_DEFAULT_VALUE));
                    if (fieldVisitor != null) {
                        attributeAppender.apply(fieldVisitor, fieldDescription, annotationValueFilterFactory.on(fieldDescription));
                        fieldVisitor.visitEnd();
                    }
                }
                public void apply(FieldVisitor fieldVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                    attributeAppender.apply(fieldVisitor, fieldDescription, annotationValueFilterFactory.on(fieldDescription));
                }
            }
        }
        enum Disabled implements FieldPool {
            INSTANCE;
            public Record target(FieldDescription fieldDescription) {
                throw new IllegalStateException("Cannot look up field from disabled pool");
            }
        }
    }
    interface MethodPool {
        Record target(MethodDescription methodDescription);
        interface Record {
            Sort getSort();
            MethodDescription getMethod();
            Visibility getVisibility();
            Record prepend(ByteCodeAppender byteCodeAppender);
            void apply(ClassVisitor classVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory);
            void applyHead(MethodVisitor methodVisitor);
            void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory);
            void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory);
            ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext);
            enum Sort {
                SKIPPED(false, false), DEFINED(true, false), IMPLEMENTED(true, true);
                private final boolean define;
                private final boolean implement;
                Sort(boolean define, boolean implement) {
                    this.define = define;
                    this.implement = implement;
                }
                public boolean isDefined() {
                    return define;
                }
                public boolean isImplemented() {
                    return implement;
                }
            }
            class ForNonImplementedMethod implements Record {
                private final MethodDescription methodDescription;
                public ForNonImplementedMethod(MethodDescription methodDescription) {
                    this.methodDescription = methodDescription;
                }
                public void apply(ClassVisitor classVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                }
                public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                    throw new IllegalStateException("Cannot apply body for non-implemented method on " + methodDescription);
                }
                public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                }
                public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                    throw new IllegalStateException("Cannot apply code for non-implemented method on " + methodDescription);
                }
                public void applyHead(MethodVisitor methodVisitor) {
                    throw new IllegalStateException("Cannot apply head for non-implemented method on " + methodDescription);
                }
                public MethodDescription getMethod() {
                    return methodDescription;
                }
                public Visibility getVisibility() {
                    return methodDescription.getVisibility();
                }
                public Sort getSort() {
                    return Sort.SKIPPED;
                }
                public Record prepend(ByteCodeAppender byteCodeAppender) {
                    return new ForDefinedMethod.WithBody(methodDescription, new ByteCodeAppender.Compound(byteCodeAppender, new ByteCodeAppender.Simple(DefaultValue.of(methodDescription.getReturnType()), MethodReturn.of(methodDescription.getReturnType()))));
                }
            }
            abstract class ForDefinedMethod implements Record {
                public void apply(ClassVisitor classVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                    MethodVisitor methodVisitor = classVisitor.visitMethod(getMethod().getActualModifiers(getSort().isImplemented(), getVisibility()), getMethod().getInternalName(), getMethod().getDescriptor(), getMethod().getGenericSignature(), getMethod().getExceptionTypes().asErasures().toInternalNames());
                    if (methodVisitor != null) {
                        ParameterList<?> parameterList = getMethod().getParameters();
                        if (parameterList.hasExplicitMetaData()) {
                            for (ParameterDescription parameterDescription : parameterList) {
                                methodVisitor.visitParameter(parameterDescription.getName(), parameterDescription.getModifiers());
                            }
                        }
                        applyHead(methodVisitor);
                        applyBody(methodVisitor, implementationContext, annotationValueFilterFactory);
                        methodVisitor.visitEnd();
                    }
                }
                public static class WithBody extends ForDefinedMethod {
                    private final MethodDescription methodDescription;
                    private final ByteCodeAppender byteCodeAppender;
                    private final MethodAttributeAppender methodAttributeAppender;
                    private final Visibility visibility;
                    public WithBody(MethodDescription methodDescription, ByteCodeAppender byteCodeAppender) {
                        this(methodDescription, byteCodeAppender, MethodAttributeAppender.NoOp.INSTANCE, methodDescription.getVisibility());
                    }
                    public WithBody(MethodDescription methodDescription, ByteCodeAppender byteCodeAppender, MethodAttributeAppender methodAttributeAppender, Visibility visibility) {
                        this.methodDescription = methodDescription;
                        this.byteCodeAppender = byteCodeAppender;
                        this.methodAttributeAppender = methodAttributeAppender;
                        this.visibility = visibility;
                    }
                    public MethodDescription getMethod() {
                        return methodDescription;
                    }
                    public Sort getSort() {
                        return Sort.IMPLEMENTED;
                    }
                    public Visibility getVisibility() {
                        return visibility;
                    }
                    public void applyHead(MethodVisitor methodVisitor) {
                    }
                    public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                        applyAttributes(methodVisitor, annotationValueFilterFactory);
                        methodVisitor.visitCode();
                        ByteCodeAppender.Size size = applyCode(methodVisitor, implementationContext);
                        methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());
                    }
                    public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                        methodAttributeAppender.apply(methodVisitor, methodDescription, annotationValueFilterFactory.on(methodDescription));
                    }
                    public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                        return byteCodeAppender.apply(methodVisitor, implementationContext, methodDescription);
                    }
                    public Record prepend(ByteCodeAppender byteCodeAppender) {
                        return new WithBody(methodDescription, new ByteCodeAppender.Compound(byteCodeAppender, this.byteCodeAppender), methodAttributeAppender, visibility);
                    }
                }
                public static class WithoutBody extends ForDefinedMethod {
                    private final MethodDescription methodDescription;
                    private final MethodAttributeAppender methodAttributeAppender;
                    private final Visibility visibility;
                    public WithoutBody(MethodDescription methodDescription, MethodAttributeAppender methodAttributeAppender, Visibility visibility) {
                        this.methodDescription = methodDescription;
                        this.methodAttributeAppender = methodAttributeAppender;
                        this.visibility = visibility;
                    }
                    public MethodDescription getMethod() {
                        return methodDescription;
                    }
                    public Sort getSort() {
                        return Sort.DEFINED;
                    }
                    public Visibility getVisibility() {
                        return visibility;
                    }
                    public void applyHead(MethodVisitor methodVisitor) {
                    }
                    public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                        applyAttributes(methodVisitor, annotationValueFilterFactory);
                    }
                    public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                        methodAttributeAppender.apply(methodVisitor, methodDescription, annotationValueFilterFactory.on(methodDescription));
                    }
                    public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                        throw new IllegalStateException("Cannot apply code for abstract method on " + methodDescription);
                    }
                    public Record prepend(ByteCodeAppender byteCodeAppender) {
                        throw new IllegalStateException("Cannot prepend code for abstract method on " + methodDescription);
                    }
                }
                public static class WithAnnotationDefaultValue extends ForDefinedMethod {
                    private final MethodDescription methodDescription;
                    private final AnnotationValue<?, ?> annotationValue;
                    private final MethodAttributeAppender methodAttributeAppender;
                    public WithAnnotationDefaultValue(MethodDescription methodDescription, AnnotationValue<?, ?> annotationValue, MethodAttributeAppender methodAttributeAppender) {
                        this.methodDescription = methodDescription;
                        this.annotationValue = annotationValue;
                        this.methodAttributeAppender = methodAttributeAppender;
                    }
                    public MethodDescription getMethod() {
                        return methodDescription;
                    }
                    public Sort getSort() {
                        return Sort.DEFINED;
                    }
                    public Visibility getVisibility() {
                        return methodDescription.getVisibility();
                    }
                    public void applyHead(MethodVisitor methodVisitor) {
                        if (!methodDescription.isDefaultValue(annotationValue)) {
                            throw new IllegalStateException("Cannot set " + annotationValue + " as default for " + methodDescription);
                        }
                        AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();
                        AnnotationAppender.Default.apply(annotationVisitor, methodDescription.getReturnType().asErasure(), AnnotationAppender.NO_NAME, annotationValue.resolve());
                        annotationVisitor.visitEnd();
                    }
                    public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                        methodAttributeAppender.apply(methodVisitor, methodDescription, annotationValueFilterFactory.on(methodDescription));
                    }
                    public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                        throw new IllegalStateException("Cannot apply attributes for default value on " + methodDescription);
                    }
                    public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                        throw new IllegalStateException("Cannot apply code for default value on " + methodDescription);
                    }
                    public Record prepend(ByteCodeAppender byteCodeAppender) {
                        throw new IllegalStateException("Cannot prepend code for default value on " + methodDescription);
                    }
                }
                public static class OfVisibilityBridge extends ForDefinedMethod implements ByteCodeAppender {
                    private final MethodDescription visibilityBridge;
                    private final MethodDescription bridgeTarget;
                    private final TypeDescription bridgeType;
                    private final MethodAttributeAppender attributeAppender;
                    protected OfVisibilityBridge(MethodDescription visibilityBridge, MethodDescription bridgeTarget, TypeDescription bridgeType, MethodAttributeAppender attributeAppender) {
                        this.visibilityBridge = visibilityBridge;
                        this.bridgeTarget = bridgeTarget;
                        this.bridgeType = bridgeType;
                        this.attributeAppender = attributeAppender;
                    }
                    public static Record of(TypeDescription instrumentedType, MethodDescription bridgeTarget, MethodAttributeAppender attributeAppender) {
                        TypeDefinition bridgeType = null;
                        if (bridgeTarget.isDefaultMethod()) {
                            TypeDescription declaringType = bridgeTarget.getDeclaringType().asErasure();
                            for (TypeDescription interfaceType : instrumentedType.getInterfaces().asErasures().filter(isSubTypeOf(declaringType))) {
                                if (bridgeType == null || declaringType.isAssignableTo(bridgeType.asErasure())) {
                                    bridgeType = interfaceType;
                                }
                            }
                        }
                        if (bridgeType == null) {
                            bridgeType = instrumentedType.getSuperClass();
                            if (bridgeType == null) {
                                bridgeType = TypeDescription.ForLoadedType.of(Object.class);
                            }
                        }
                        return new OfVisibilityBridge(new VisibilityBridge(instrumentedType, bridgeTarget), bridgeTarget, bridgeType.asErasure(), attributeAppender);
                    }
                    public MethodDescription getMethod() {
                        return visibilityBridge;
                    }
                    public Sort getSort() {
                        return Sort.IMPLEMENTED;
                    }
                    public Visibility getVisibility() {
                        return bridgeTarget.getVisibility();
                    }
                    public Record prepend(ByteCodeAppender byteCodeAppender) {
                        return new ForDefinedMethod.WithBody(visibilityBridge, new ByteCodeAppender.Compound(this, byteCodeAppender), attributeAppender, bridgeTarget.getVisibility());
                    }
                    public void applyHead(MethodVisitor methodVisitor) {
                    }
                    public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                        applyAttributes(methodVisitor, annotationValueFilterFactory);
                        methodVisitor.visitCode();
                        ByteCodeAppender.Size size = applyCode(methodVisitor, implementationContext);
                        methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());
                    }
                    public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                        attributeAppender.apply(methodVisitor, visibilityBridge, annotationValueFilterFactory.on(visibilityBridge));
                    }
                    public Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                        return apply(methodVisitor, implementationContext, visibilityBridge);
                    }
                    public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
                        return new ByteCodeAppender.Simple(MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(), MethodInvocation.invoke(bridgeTarget).special(bridgeType), MethodReturn.of(instrumentedMethod.getReturnType())).apply(methodVisitor, implementationContext, instrumentedMethod);
                    }
                    protected static class VisibilityBridge extends MethodDescription.InDefinedShape.AbstractBase {
                        private final TypeDescription instrumentedType;
                        private final MethodDescription bridgeTarget;
                        protected VisibilityBridge(TypeDescription instrumentedType, MethodDescription bridgeTarget) {
                            this.instrumentedType = instrumentedType;
                            this.bridgeTarget = bridgeTarget;
                        }
                        public TypeDescription getDeclaringType() {
                            return instrumentedType;
                        }
                        public ParameterList<ParameterDescription.InDefinedShape> getParameters() {
                            return new ParameterList.Explicit.ForTypes(this, bridgeTarget.getParameters().asTypeList().asRawTypes());
                        }
                        public TypeDescription.Generic getReturnType() {
                            return bridgeTarget.getReturnType().asRawType();
                        }
                        public TypeList.Generic getExceptionTypes() {
                            return bridgeTarget.getExceptionTypes().asRawTypes();
                        }
                        public AnnotationValue<?, ?> getDefaultValue() {
                            return AnnotationValue.UNDEFINED;
                        }
                        public TypeList.Generic getTypeVariables() {
                            return new TypeList.Generic.Empty();
                        }
                        public AnnotationList getDeclaredAnnotations() {
                            return bridgeTarget.getDeclaredAnnotations();
                        }
                        public int getModifiers() {
                            return (bridgeTarget.getModifiers() | Opcodes.ACC_SYNTHETIC | Opcodes.ACC_BRIDGE) & ~Opcodes.ACC_NATIVE;
                        }
                        public String getInternalName() {
                            return bridgeTarget.getName();
                        }
                    }
                }
            }
            class AccessBridgeWrapper implements Record {
                private final Record delegate;
                private final TypeDescription instrumentedType;
                private final MethodDescription bridgeTarget;
                private final Set<MethodDescription.TypeToken> bridgeTypes;
                private final MethodAttributeAppender attributeAppender;
                protected AccessBridgeWrapper(Record delegate, TypeDescription instrumentedType, MethodDescription bridgeTarget, Set<MethodDescription.TypeToken> bridgeTypes, MethodAttributeAppender attributeAppender) {
                    this.delegate = delegate;
                    this.instrumentedType = instrumentedType;
                    this.bridgeTarget = bridgeTarget;
                    this.bridgeTypes = bridgeTypes;
                    this.attributeAppender = attributeAppender;
                }
                public static Record of(Record delegate, TypeDescription instrumentedType, MethodDescription bridgeTarget, Set<MethodDescription.TypeToken> bridgeTypes, MethodAttributeAppender attributeAppender) {
                    Set<MethodDescription.TypeToken> compatibleBridgeTypes = new HashSet<MethodDescription.TypeToken>();
                    for (MethodDescription.TypeToken bridgeType : bridgeTypes) {
                        if (bridgeTarget.isBridgeCompatible(bridgeType)) {
                            compatibleBridgeTypes.add(bridgeType);
                        }
                    }
                    return compatibleBridgeTypes.isEmpty() || (instrumentedType.isInterface() && !delegate.getSort().isImplemented()) ? delegate : new AccessBridgeWrapper(delegate, instrumentedType, bridgeTarget, compatibleBridgeTypes, attributeAppender);
                }
                public Sort getSort() {
                    return delegate.getSort();
                }
                public MethodDescription getMethod() {
                    return bridgeTarget;
                }
                public Visibility getVisibility() {
                    return delegate.getVisibility();
                }
                public Record prepend(ByteCodeAppender byteCodeAppender) {
                    return new AccessBridgeWrapper(delegate.prepend(byteCodeAppender), instrumentedType, bridgeTarget, bridgeTypes, attributeAppender);
                }
                public void apply(ClassVisitor classVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                    delegate.apply(classVisitor, implementationContext, annotationValueFilterFactory);
                    for (MethodDescription.TypeToken bridgeType : bridgeTypes) {
                        MethodDescription.InDefinedShape bridgeMethod = new AccessorBridge(bridgeTarget, bridgeType, instrumentedType);
                        MethodDescription.InDefinedShape bridgeTarget = new BridgeTarget(this.bridgeTarget, instrumentedType);
                        MethodVisitor methodVisitor = classVisitor.visitMethod(bridgeMethod.getActualModifiers(true, getVisibility()), bridgeMethod.getInternalName(), bridgeMethod.getDescriptor(), MethodDescription.NON_GENERIC_SIGNATURE, bridgeMethod.getExceptionTypes().asErasures().toInternalNames());
                        if (methodVisitor != null) {
                            attributeAppender.apply(methodVisitor, bridgeMethod, annotationValueFilterFactory.on(instrumentedType));
                            methodVisitor.visitCode();
                            ByteCodeAppender.Size size = new ByteCodeAppender.Simple(MethodVariableAccess.allArgumentsOf(bridgeMethod).asBridgeOf(bridgeTarget).prependThisReference(), MethodInvocation.invoke(bridgeTarget).virtual(instrumentedType), bridgeTarget.getReturnType().asErasure().isAssignableTo(bridgeMethod.getReturnType().asErasure()) ? StackManipulation.Trivial.INSTANCE : TypeCasting.to(bridgeMethod.getReturnType().asErasure()), MethodReturn.of(bridgeMethod.getReturnType())).apply(methodVisitor, implementationContext, bridgeMethod);
                            methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());
                            methodVisitor.visitEnd();
                        }
                    }
                }
                public void applyHead(MethodVisitor methodVisitor) {
                    delegate.applyHead(methodVisitor);
                }
                public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                    delegate.applyBody(methodVisitor, implementationContext, annotationValueFilterFactory);
                }
                public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                    delegate.applyAttributes(methodVisitor, annotationValueFilterFactory);
                }
                public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                    return delegate.applyCode(methodVisitor, implementationContext);
                }
                protected static class AccessorBridge extends MethodDescription.InDefinedShape.AbstractBase {
                    private final MethodDescription bridgeTarget;
                    private final MethodDescription.TypeToken bridgeType;
                    private final TypeDescription instrumentedType;
                    protected AccessorBridge(MethodDescription bridgeTarget, TypeToken bridgeType, TypeDescription instrumentedType) {
                        this.bridgeTarget = bridgeTarget;
                        this.bridgeType = bridgeType;
                        this.instrumentedType = instrumentedType;
                    }
                    public TypeDescription getDeclaringType() {
                        return instrumentedType;
                    }
                    public ParameterList<ParameterDescription.InDefinedShape> getParameters() {
                        return new ParameterList.Explicit.ForTypes(this, bridgeType.getParameterTypes());
                    }
                    public TypeDescription.Generic getReturnType() {
                        return bridgeType.getReturnType().asGenericType();
                    }
                    public TypeList.Generic getExceptionTypes() {
                        return bridgeTarget.getExceptionTypes().accept(TypeDescription.Generic.Visitor.TypeErasing.INSTANCE);
                    }
                    public AnnotationValue<?, ?> getDefaultValue() {
                        return AnnotationValue.UNDEFINED;
                    }
                    public TypeList.Generic getTypeVariables() {
                        return new TypeList.Generic.Empty();
                    }
                    public AnnotationList getDeclaredAnnotations() {
                        return new AnnotationList.Empty();
                    }
                    public int getModifiers() {
                        return (bridgeTarget.getModifiers() | Opcodes.ACC_BRIDGE | Opcodes.ACC_SYNTHETIC) & ~(Opcodes.ACC_ABSTRACT | Opcodes.ACC_NATIVE);
                    }
                    public String getInternalName() {
                        return bridgeTarget.getInternalName();
                    }
                }
                protected static class BridgeTarget extends MethodDescription.InDefinedShape.AbstractBase {
                    private final MethodDescription bridgeTarget;
                    private final TypeDescription instrumentedType;
                    protected BridgeTarget(MethodDescription bridgeTarget, TypeDescription instrumentedType) {
                        this.bridgeTarget = bridgeTarget;
                        this.instrumentedType = instrumentedType;
                    }
                    public TypeDescription getDeclaringType() {
                        return instrumentedType;
                    }
                    public ParameterList<ParameterDescription.InDefinedShape> getParameters() {
                        return new ParameterList.ForTokens(this, bridgeTarget.getParameters().asTokenList(is(instrumentedType)));
                    }
                    public TypeDescription.Generic getReturnType() {
                        return bridgeTarget.getReturnType();
                    }
                    public TypeList.Generic getExceptionTypes() {
                        return bridgeTarget.getExceptionTypes();
                    }
                    public AnnotationValue<?, ?> getDefaultValue() {
                        return bridgeTarget.getDefaultValue();
                    }
                    public TypeList.Generic getTypeVariables() {
                        return bridgeTarget.getTypeVariables();
                    }
                    public AnnotationList getDeclaredAnnotations() {
                        return bridgeTarget.getDeclaredAnnotations();
                    }
                    public int getModifiers() {
                        return bridgeTarget.getModifiers();
                    }
                    public String getInternalName() {
                        return bridgeTarget.getInternalName();
                    }
                }
            }
        }
    }
    interface RecordComponentPool {
        Record target(RecordComponentDescription recordComponentDescription);
        interface Record {
            boolean isImplicit();
            RecordComponentDescription getRecordComponent();
            RecordComponentAttributeAppender getRecordComponentAppender();
            void apply(ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory);
            void apply(RecordComponentVisitor recordComponentVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory);
            class ForImplicitRecordComponent implements Record {
                private final RecordComponentDescription recordComponentDescription;
                public ForImplicitRecordComponent(RecordComponentDescription recordComponentDescription) {
                    this.recordComponentDescription = recordComponentDescription;
                }
                public boolean isImplicit() {
                    return true;
                }
                public RecordComponentDescription getRecordComponent() {
                    return recordComponentDescription;
                }
                public RecordComponentAttributeAppender getRecordComponentAppender() {
                    throw new IllegalStateException("An implicit field record does not expose a field appender: " + this);
                }
                public void apply(ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                    RecordComponentVisitor recordComponentVisitor = classVisitor.visitRecordComponent(recordComponentDescription.getActualName(), recordComponentDescription.getDescriptor(), recordComponentDescription.getGenericSignature());
                    if (recordComponentVisitor != null) {
                        RecordComponentAttributeAppender.ForInstrumentedRecordComponent.INSTANCE.apply(recordComponentVisitor, recordComponentDescription, annotationValueFilterFactory.on(recordComponentDescription));
                        recordComponentVisitor.visitEnd();
                    }
                }
                public void apply(RecordComponentVisitor recordComponentVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                    throw new IllegalStateException("An implicit field record is not intended for partial application: " + this);
                }
            }
            class ForExplicitRecordComponent implements Record {
                private final RecordComponentAttributeAppender attributeAppender;
                private final RecordComponentDescription recordComponentDescription;
                public ForExplicitRecordComponent(RecordComponentAttributeAppender attributeAppender, RecordComponentDescription recordComponentDescription) {
                    this.attributeAppender = attributeAppender;
                    this.recordComponentDescription = recordComponentDescription;
                }
                public boolean isImplicit() {
                    return false;
                }
                public RecordComponentDescription getRecordComponent() {
                    return recordComponentDescription;
                }
                public RecordComponentAttributeAppender getRecordComponentAppender() {
                    return attributeAppender;
                }
                public void apply(ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                    RecordComponentVisitor recordComponentVisitor = classVisitor.visitRecordComponent(recordComponentDescription.getActualName(), recordComponentDescription.getDescriptor(), recordComponentDescription.getGenericSignature());
                    if (recordComponentVisitor != null) {
                        attributeAppender.apply(recordComponentVisitor, recordComponentDescription, annotationValueFilterFactory.on(recordComponentDescription));
                        recordComponentVisitor.visitEnd();
                    }
                }
                public void apply(RecordComponentVisitor recordComponentVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                    attributeAppender.apply(recordComponentVisitor, recordComponentDescription, annotationValueFilterFactory.on(recordComponentDescription));
                }
            }
        }
        enum Disabled implements RecordComponentPool {
            INSTANCE;
            public Record target(RecordComponentDescription recordComponentDescription) {
                throw new IllegalStateException("Cannot look up record component from disabled pool");
            }
        }
    }
    abstract class Default<S> implements TypeWriter<S> {
        private static final String NO_REFERENCE = null;
        protected static final String DUMP_FOLDER;
        static {
            String dumpFolder;
            try {
                dumpFolder = doPrivileged(new GetSystemPropertyAction(DUMP_PROPERTY));
            } catch (RuntimeException exception) {
                dumpFolder = null;
            }
            DUMP_FOLDER = dumpFolder;
        }
        protected final TypeDescription instrumentedType;
        protected final ClassFileVersion classFileVersion;
        protected final FieldPool fieldPool;
        protected final RecordComponentPool recordComponentPool;
        protected final List<? extends DynamicType> auxiliaryTypes;
        protected final FieldList<FieldDescription.InDefinedShape> fields;
        protected final MethodList<?> methods;
        protected final MethodList<?> instrumentedMethods;
        protected final RecordComponentList<RecordComponentDescription.InDefinedShape> recordComponents;
        protected final LoadedTypeInitializer loadedTypeInitializer;
        protected final TypeInitializer typeInitializer;
        protected final TypeAttributeAppender typeAttributeAppender;
        protected final AsmVisitorWrapper asmVisitorWrapper;
        protected final AnnotationValueFilter.Factory annotationValueFilterFactory;
        protected final AnnotationRetention annotationRetention;
        protected final AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy;
        protected final Implementation.Context.Factory implementationContextFactory;
        protected final TypeValidation typeValidation;
        protected final AsmClassReader.Factory classReaderFactory;
        protected final AsmClassWriter.Factory classWriterFactory;
        protected final TypePool typePool;
        protected Default(TypeDescription instrumentedType, ClassFileVersion classFileVersion, FieldPool fieldPool, RecordComponentPool recordComponentPool, List<? extends DynamicType> auxiliaryTypes, FieldList<FieldDescription.InDefinedShape> fields, MethodList<?> methods, MethodList<?> instrumentedMethods, RecordComponentList<RecordComponentDescription.InDefinedShape> recordComponents, LoadedTypeInitializer loadedTypeInitializer, TypeInitializer typeInitializer, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, AsmClassReader.Factory classReaderFactory, AsmClassWriter.Factory classWriterFactory, TypePool typePool) {
            this.instrumentedType = instrumentedType;
            this.classFileVersion = classFileVersion;
            this.fieldPool = fieldPool;
            this.recordComponentPool = recordComponentPool;
            this.auxiliaryTypes = auxiliaryTypes;
            this.fields = fields;
            this.methods = methods;
            this.instrumentedMethods = instrumentedMethods;
            this.recordComponents = recordComponents;
            this.loadedTypeInitializer = loadedTypeInitializer;
            this.typeInitializer = typeInitializer;
            this.typeAttributeAppender = typeAttributeAppender;
            this.asmVisitorWrapper = asmVisitorWrapper;
            this.auxiliaryTypeNamingStrategy = auxiliaryTypeNamingStrategy;
            this.annotationValueFilterFactory = annotationValueFilterFactory;
            this.annotationRetention = annotationRetention;
            this.implementationContextFactory = implementationContextFactory;
            this.typeValidation = typeValidation;
            this.classReaderFactory = classReaderFactory;
            this.classWriterFactory = classWriterFactory;
            this.typePool = typePool;
        }
        private static <T> T doPrivileged(PrivilegedAction<T> action) {
            return action.run();
        }
        private static <T> T doPrivileged(PrivilegedExceptionAction<T> action) throws Exception {
            return action.run();
        }
        public static <U> TypeWriter<U> forCreation(MethodRegistry.Compiled methodRegistry, List<? extends DynamicType> auxiliaryTypes, FieldPool fieldPool, RecordComponentPool recordComponentPool, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, ClassFileVersion classFileVersion, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, AsmClassReader.Factory classReaderFactory, AsmClassWriter.Factory classWriterFactory, TypePool typePool) {
            return new ForCreation<U>(methodRegistry.getInstrumentedType(), classFileVersion, fieldPool, methodRegistry, recordComponentPool, auxiliaryTypes, methodRegistry.getInstrumentedType().getDeclaredFields(), methodRegistry.getMethods(), methodRegistry.getInstrumentedMethods(), methodRegistry.getInstrumentedType().getRecordComponents(), methodRegistry.getLoadedTypeInitializer(), methodRegistry.getTypeInitializer(), typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classReaderFactory, classWriterFactory, typePool);
        }
        public static <U> TypeWriter<U> forRedefinition(MethodRegistry.Prepared methodRegistry, List<? extends DynamicType> auxiliaryTypes, FieldPool fieldPool, RecordComponentPool recordComponentPool, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, ClassFileVersion classFileVersion, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, AsmClassReader.Factory classReaderFactory, AsmClassWriter.Factory classWriterFactory, TypePool typePool, TypeDescription originalType, ClassFileLocator classFileLocator) {
            return new ForInlining.WithFullProcessing<U>(methodRegistry.getInstrumentedType(), classFileVersion, fieldPool, recordComponentPool, auxiliaryTypes, methodRegistry.getInstrumentedType().getDeclaredFields(), methodRegistry.getMethods(), methodRegistry.getInstrumentedMethods(), methodRegistry.getInstrumentedType().getRecordComponents(), methodRegistry.getLoadedTypeInitializer(), methodRegistry.getTypeInitializer(), typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classReaderFactory, classWriterFactory, typePool, originalType, classFileLocator, methodRegistry, SubclassImplementationTarget.Factory.LEVEL_TYPE, MethodRebaseResolver.Disabled.INSTANCE);
        }
        public static <U> TypeWriter<U> forRebasing(MethodRegistry.Prepared methodRegistry, List<? extends DynamicType> auxiliaryTypes, FieldPool fieldPool, RecordComponentPool recordComponentPool, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, ClassFileVersion classFileVersion, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, AsmClassReader.Factory classReaderFactory, AsmClassWriter.Factory classWriterFactory, TypePool typePool, TypeDescription originalType, ClassFileLocator classFileLocator, MethodRebaseResolver methodRebaseResolver) {
            return new ForInlining.WithFullProcessing<U>(methodRegistry.getInstrumentedType(), classFileVersion, fieldPool, recordComponentPool, CompoundList.of(auxiliaryTypes, methodRebaseResolver.getAuxiliaryTypes()), methodRegistry.getInstrumentedType().getDeclaredFields(), methodRegistry.getMethods(), methodRegistry.getInstrumentedMethods(), methodRegistry.getInstrumentedType().getRecordComponents(), methodRegistry.getLoadedTypeInitializer(), methodRegistry.getTypeInitializer(), typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classReaderFactory, classWriterFactory, typePool, originalType, classFileLocator, methodRegistry, new RebaseImplementationTarget.Factory(methodRebaseResolver), methodRebaseResolver);
        }
        public static <U> TypeWriter<U> forDecoration(TypeDescription instrumentedType, ClassFileVersion classFileVersion, List<? extends DynamicType> auxiliaryTypes, List<? extends MethodDescription> methods, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, AsmClassReader.Factory classReaderFactory, AsmClassWriter.Factory classWriterFactory, TypePool typePool, ClassFileLocator classFileLocator) {
            return new ForInlining.WithDecorationOnly<U>(instrumentedType, classFileVersion, auxiliaryTypes, new MethodList.Explicit<MethodDescription>(methods), typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classReaderFactory, classWriterFactory, typePool, classFileLocator);
        }
        public DynamicType.Unloaded<S> make(TypeResolutionStrategy.Resolved typeResolutionStrategy) {
            ClassDumpAction.Dispatcher dispatcher = DUMP_FOLDER == null ? ClassDumpAction.Dispatcher.Disabled.INSTANCE : new ClassDumpAction.Dispatcher.Enabled(DUMP_FOLDER, System.currentTimeMillis());
            UnresolvedType unresolvedType = create(typeResolutionStrategy.injectedInto(typeInitializer), dispatcher);
            dispatcher.dump(instrumentedType, false, unresolvedType.getBinaryRepresentation());
            return unresolvedType.toDynamicType(typeResolutionStrategy);
        }
        protected abstract UnresolvedType create(TypeInitializer typeInitializer, ClassDumpAction.Dispatcher dispatcher);
        protected class UnresolvedType {
            private final byte[] binaryRepresentation;
            private final List<? extends DynamicType> auxiliaryTypes;
            protected UnresolvedType(byte[] binaryRepresentation, List<? extends DynamicType> auxiliaryTypes) {
                this.binaryRepresentation = binaryRepresentation;
                this.auxiliaryTypes = auxiliaryTypes;
            }
            protected DynamicType.Unloaded<S> toDynamicType(TypeResolutionStrategy.Resolved typeResolutionStrategy) {
                return new DynamicType.Default.Unloaded<S>(instrumentedType, binaryRepresentation, loadedTypeInitializer, CompoundList.of(Default.this.auxiliaryTypes, auxiliaryTypes), typeResolutionStrategy);
            }
            protected byte[] getBinaryRepresentation() {
                return binaryRepresentation;
            }
        }
        protected static class SignatureKey {
            private final String internalName;
            private final String descriptor;
            public SignatureKey(String internalName, String descriptor) {
                this.internalName = internalName;
                this.descriptor = descriptor;
            }
            public boolean equals(@MaybeNull Object other) {
                if (this == other)
                    return true;
                if (other == null || getClass() != other.getClass())
                    return false;
                SignatureKey that = (SignatureKey) other;
                return internalName.equals(that.internalName) && descriptor.equals(that.descriptor);
            }
            public int hashCode() {
                return 17 + internalName.hashCode() + 31 * descriptor.hashCode();
            }
        }
        protected static class ValidatingClassVisitor extends ClassVisitor {
            private static final String NO_PARAMETERS = "()";
            private static final String RETURNS_VOID = "V";
            private static final String STRING_DESCRIPTOR = "Ljava/lang/String;";
            private static final FieldVisitor IGNORE_FIELD = null;
            private static final MethodVisitor IGNORE_METHOD = null;
            private Constraint constraint;
            protected ValidatingClassVisitor(ClassVisitor classVisitor) {
                super(OpenedClassReader.ASM_API, classVisitor);
            }
            protected static ClassVisitor of(ClassVisitor classVisitor, TypeValidation typeValidation) {
                return typeValidation.isEnabled() ? new ValidatingClassVisitor(classVisitor) : classVisitor;
            }
            public void visit(int version, int modifiers, String name, @MaybeNull String signature, @MaybeNull String superName, @MaybeNull String[] interfaceInternalName) {
                ClassFileVersion classFileVersion = ClassFileVersion.ofMinorMajor(version);
                List<Constraint> constraints = new ArrayList<Constraint>();
                constraints.add(new Constraint.ForClassFileVersion(classFileVersion));
                if (name.equals(ModuleDescription.MODULE_CLASS_NAME)) {
                    constraints.add(Constraint.ForModuleType.INSTANCE);
                } else if (name.endsWith('/' + PackageDescription.PACKAGE_CLASS_NAME)) {
                    constraints.add(Constraint.ForPackageType.INSTANCE);
                } else if ((modifiers & Opcodes.ACC_ANNOTATION) != 0) {
                    if (!classFileVersion.isAtLeast(ClassFileVersion.JAVA_V5)) {
                        throw new IllegalStateException("Cannot define an annotation type for class file version " + classFileVersion);
                    }
                    constraints.add(classFileVersion.isAtLeast(ClassFileVersion.JAVA_V8) ? Constraint.ForAnnotation.JAVA_8 : Constraint.ForAnnotation.CLASSIC);
                } else if ((modifiers & Opcodes.ACC_INTERFACE) != 0) {
                    constraints.add(classFileVersion.isAtLeast(ClassFileVersion.JAVA_V8) ? Constraint.ForInterface.JAVA_8 : Constraint.ForInterface.CLASSIC);
                } else if ((modifiers & Opcodes.ACC_ABSTRACT) != 0) {
                    constraints.add(Constraint.ForClass.ABSTRACT);
                } else {
                    constraints.add(Constraint.ForClass.MANIFEST);
                }
                boolean record;
                if ((modifiers & Opcodes.ACC_RECORD) != 0) {
                    constraints.add(Constraint.ForRecord.INSTANCE);
                    record = true;
                } else {
                    record = false;
                }
                constraint = new Constraint.Compound(constraints);
                constraint.assertType(modifiers, superName, interfaceInternalName != null, signature != null);
                if (record) {
                    constraint.assertRecord();
                }
                super.visit(version, modifiers, name, signature, superName, interfaceInternalName);
            }
            public void visitPermittedSubclass(String permittedSubclass) {
                constraint.assertPermittedSubclass();
                super.visitPermittedSubclass(permittedSubclass);
            }
            public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
                constraint.assertAnnotation();
                return super.visitAnnotation(descriptor, visible);
            }
            public AnnotationVisitor visitTypeAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
                constraint.assertTypeAnnotation();
                return super.visitTypeAnnotation(typeReference, typePath, descriptor, visible);
            }
            public void visitNestHost(String nestHost) {
                constraint.assertNestMate();
                super.visitNestHost(nestHost);
            }
            public void visitNestMember(String nestMember) {
                constraint.assertNestMate();
                super.visitNestMember(nestMember);
            }
            public FieldVisitor visitField(int modifiers, String name, String descriptor, @MaybeNull String signature, @MaybeNull Object value) {
                if (value != null) {
                    Class<?> type;
                    switch(descriptor.charAt(0)) {
                        case 'Z':
                        case 'B':
                        case 'C':
                        case 'S':
                        case 'I':
                            type = Integer.class;
                            break;
                        case 'J':
                            type = Long.class;
                            break;
                        case 'F':
                            type = Float.class;
                            break;
                        case 'D':
                            type = Double.class;
                            break;
                        default:
                            if (!descriptor.equals(STRING_DESCRIPTOR)) {
                                throw new IllegalStateException("Cannot define a default value for type of field " + name);
                            }
                            type = String.class;
                    }
                    if (!type.isInstance(value)) {
                        throw new IllegalStateException("Field " + name + " defines an incompatible default value " + value + " (" + value.getClass().getName() + ")");
                    } else if (type == Integer.class) {
                        boolean outOfRange;
                        switch(descriptor.charAt(0)) {
                            case 'Z':
                                outOfRange = (Integer) value < 0 || (Integer) value > 1;
                                break;
                            case 'B':
                                outOfRange = (Integer) value < Byte.MIN_VALUE || (Integer) value > Byte.MAX_VALUE;
                                break;
                            case 'S':
                                outOfRange = (Integer) value < Short.MIN_VALUE || (Integer) value > Short.MAX_VALUE;
                                break;
                            case 'C':
                                outOfRange = (Integer) value < Character.MIN_VALUE || (Integer) value > Character.MAX_VALUE;
                                break;
                            default:
                                outOfRange = false;
                        }
                        if (outOfRange) {
                            throw new IllegalStateException("Field " + name + " defines an incompatible default value " + value);
                        }
                    }
                }
                constraint.assertField(name, (modifiers & Opcodes.ACC_PUBLIC) != 0, (modifiers & Opcodes.ACC_STATIC) != 0, (modifiers & Opcodes.ACC_FINAL) != 0, signature != null);
                FieldVisitor fieldVisitor = super.visitField(modifiers, name, descriptor, signature, value);
                return fieldVisitor == null ? IGNORE_FIELD : new ValidatingFieldVisitor(fieldVisitor);
            }
            public MethodVisitor visitMethod(int modifiers, String name, String descriptor, @MaybeNull String signature, @MaybeNull String[] exceptionInternalName) {
                constraint.assertMethod(name, (modifiers & Opcodes.ACC_ABSTRACT) != 0, (modifiers & Opcodes.ACC_PUBLIC) != 0, (modifiers & Opcodes.ACC_PRIVATE) != 0, (modifiers & Opcodes.ACC_STATIC) != 0, !name.equals(MethodDescription.CONSTRUCTOR_INTERNAL_NAME) && !name.equals(MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME) && (modifiers & (Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC)) == 0, name.equals(MethodDescription.CONSTRUCTOR_INTERNAL_NAME), !descriptor.startsWith(NO_PARAMETERS) || descriptor.endsWith(RETURNS_VOID), signature != null);
                MethodVisitor methodVisitor = super.visitMethod(modifiers, name, descriptor, signature, exceptionInternalName);
                return methodVisitor == null ? IGNORE_METHOD : new ValidatingMethodVisitor(methodVisitor, name);
            }
            protected interface Constraint {
                void assertType(int modifier, @MaybeNull String superClassInternalName, boolean definesInterfaces, boolean isGeneric);
                void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric);
                void assertMethod(String name, boolean isAbstract, boolean isPublic, boolean isPrivate, boolean isStatic, boolean isVirtual, boolean isConstructor, boolean isDefaultValueIncompatible, boolean isGeneric);
                void assertAnnotation();
                void assertTypeAnnotation();
                void assertDefaultValue(String name);
                void assertDefaultMethodCall();
                void assertTypeInConstantPool();
                void assertMethodTypeInConstantPool();
                void assertHandleInConstantPool();
                void assertInvokeDynamic();
                void assertSubRoutine();
                void assertDynamicValueInConstantPool();
                void assertNestMate();
                void assertRecord();
                void assertPermittedSubclass();
                enum ForClass implements Constraint {
                    MANIFEST(true), ABSTRACT(false);
                    private final boolean manifestType;
                    ForClass(boolean manifestType) {
                        this.manifestType = manifestType;
                    }
                    public void assertType(int modifier, @MaybeNull String superClassInternalName, boolean definesInterfaces, boolean isGeneric) {
                    }
                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
                    }
                    public void assertMethod(String name, boolean isAbstract, boolean isPublic, boolean isPrivate, boolean isStatic, boolean isVirtual, boolean isConstructor, boolean isDefaultValueIncompatible, boolean isGeneric) {
                        if (isAbstract && manifestType) {
                            throw new IllegalStateException("Cannot define abstract method '" + name + "' for non-abstract class");
                        }
                    }
                    public void assertAnnotation() {
                    }
                    public void assertTypeAnnotation() {
                    }
                    public void assertDefaultValue(String name) {
                        throw new IllegalStateException("Cannot define default value for '" + name + "' for non-annotation type");
                    }
                    public void assertDefaultMethodCall() {
                    }
                    public void assertTypeInConstantPool() {
                    }
                    public void assertMethodTypeInConstantPool() {
                    }
                    public void assertHandleInConstantPool() {
                    }
                    public void assertInvokeDynamic() {
                    }
                    public void assertSubRoutine() {
                    }
                    public void assertDynamicValueInConstantPool() {
                    }
                    public void assertNestMate() {
                    }
                    public void assertRecord() {
                    }
                    public void assertPermittedSubclass() {
                    }
                }
                enum ForModuleType implements Constraint {
                    INSTANCE;
                    public void assertType(int modifier, String superClassInternalName, boolean definesInterfaces, boolean isGeneric) {
                        if (modifier != Opcodes.ACC_MODULE) {
                            throw new IllegalStateException("Module must only define module modifier");
                        } else if (superClassInternalName != null) {
                            throw new IllegalStateException("A module cannot define a super class");
                        }
                    }
                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
                        throw new IllegalStateException("Cannot define a field for a module description type");
                    }
                    public void assertMethod(String name, boolean isAbstract, boolean isPublic, boolean isPrivate, boolean isStatic, boolean isVirtual, boolean isConstructor, boolean isDefaultValueIncompatible, boolean isGeneric) {
                        throw new IllegalStateException("Cannot define a method for a module description type");
                    }
                    public void assertAnnotation() {
                    }
                    public void assertTypeAnnotation() {
                        throw new IllegalStateException("Cannot define a type annotation for a module description type");
                    }
                    public void assertDefaultValue(String name) {
                    }
                    public void assertDefaultMethodCall() {
                    }
                    public void assertTypeInConstantPool() {
                    }
                    public void assertMethodTypeInConstantPool() {
                    }
                    public void assertHandleInConstantPool() {
                    }
                    public void assertInvokeDynamic() {
                    }
                    public void assertSubRoutine() {
                    }
                    public void assertDynamicValueInConstantPool() {
                    }
                    public void assertNestMate() {
                        throw new IllegalStateException("Cannot define a nest mate for a module description type");
                    }
                    public void assertRecord() {
                        throw new IllegalStateException("Cannot define a record entry for a module description type");
                    }
                    public void assertPermittedSubclass() {
                        throw new IllegalStateException("Cannot permitt a subclass for a module description type");
                    }
                }
                enum ForPackageType implements Constraint {
                    INSTANCE;
                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
                        throw new IllegalStateException("Cannot define a field for a package description type");
                    }
                    public void assertMethod(String name, boolean isAbstract, boolean isPublic, boolean isPrivate, boolean isStatic, boolean isVirtual, boolean isConstructor, boolean isNoDefaultValue, boolean isGeneric) {
                        throw new IllegalStateException("Cannot define a method for a package description type");
                    }
                    public void assertAnnotation() {
                    }
                    public void assertTypeAnnotation() {
                    }
                    public void assertDefaultValue(String name) {
                    }
                    public void assertDefaultMethodCall() {
                    }
                    public void assertTypeInConstantPool() {
                    }
                    public void assertMethodTypeInConstantPool() {
                    }
                    public void assertHandleInConstantPool() {
                    }
                    public void assertInvokeDynamic() {
                    }
                    public void assertSubRoutine() {
                    }
                    public void assertType(int modifier, @MaybeNull String superClassInternalName, boolean definesInterfaces, boolean isGeneric) {
                        if (modifier != PackageDescription.PACKAGE_MODIFIERS) {
                            throw new IllegalStateException("A package description type must define " + PackageDescription.PACKAGE_MODIFIERS + " as modifier");
                        } else if (!Type.getInternalName(Object.class).equals(superClassInternalName)) {
                            throw new IllegalStateException("A package class must inherit from java.lang.Object");
                        } else if (definesInterfaces) {
                            throw new IllegalStateException("Cannot implement interface for package type");
                        }
                    }
                    public void assertDynamicValueInConstantPool() {
                    }
                    public void assertNestMate() {
                    }
                    public void assertRecord() {
                    }
                    public void assertPermittedSubclass() {
                    }
                }
                enum ForInterface implements Constraint {
                    CLASSIC(true), JAVA_8(false);
                    private final boolean classic;
                    ForInterface(boolean classic) {
                        this.classic = classic;
                    }
                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
                        if (!isStatic || !isPublic || !isFinal) {
                            throw new IllegalStateException("Cannot only define public, static, final field '" + name + "' for interface type");
                        }
                    }
                    public void assertMethod(String name, boolean isAbstract, boolean isPublic, boolean isPrivate, boolean isStatic, boolean isVirtual, boolean isConstructor, boolean isDefaultValueIncompatible, boolean isGeneric) {
                        if (!name.equals(MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME)) {
                            if (isConstructor) {
                                throw new IllegalStateException("Cannot define constructor for interface type");
                            } else if (classic && !isPublic) {
                                throw new IllegalStateException("Cannot define non-public method '" + name + "' for interface type");
                            } else if (classic && !isVirtual) {
                                throw new IllegalStateException("Cannot define non-virtual method '" + name + "' for a pre-Java 8 interface type");
                            } else if (classic && !isAbstract) {
                                throw new IllegalStateException("Cannot define default method '" + name + "' for pre-Java 8 interface type");
                            }
                        }
                    }
                    public void assertAnnotation() {
                    }
                    public void assertTypeAnnotation() {
                    }
                    public void assertDefaultValue(String name) {
                        throw new IllegalStateException("Cannot define default value for '" + name + "' for non-annotation type");
                    }
                    public void assertDefaultMethodCall() {
                    }
                    public void assertType(int modifier, @MaybeNull String superClassInternalName, boolean definesInterfaces, boolean isGeneric) {
                        if (!Type.getInternalName(Object.class).equals(superClassInternalName)) {
                            throw new IllegalStateException("An interface must inherit from java.lang.Object");
                        }
                    }
                    public void assertTypeInConstantPool() {
                    }
                    public void assertMethodTypeInConstantPool() {
                    }
                    public void assertHandleInConstantPool() {
                    }
                    public void assertInvokeDynamic() {
                    }
                    public void assertSubRoutine() {
                    }
                    public void assertDynamicValueInConstantPool() {
                    }
                    public void assertNestMate() {
                    }
                    public void assertRecord() {
                    }
                    public void assertPermittedSubclass() {
                    }
                }
                enum ForRecord implements Constraint {
                    INSTANCE;
                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
                    }
                    public void assertMethod(String name, boolean isAbstract, boolean isPublic, boolean isPrivate, boolean isStatic, boolean isVirtual, boolean isConstructor, boolean isDefaultValueIncompatible, boolean isGeneric) {
                    }
                    public void assertAnnotation() {
                    }
                    public void assertTypeAnnotation() {
                    }
                    public void assertDefaultValue(String name) {
                    }
                    public void assertDefaultMethodCall() {
                    }
                    public void assertType(int modifier, @MaybeNull String superClassInternalName, boolean definesInterfaces, boolean isGeneric) {
                        if ((modifier & Opcodes.ACC_ABSTRACT) != 0) {
                            throw new IllegalStateException("Cannot define a record class as abstract");
                        } else if (!"java/lang/Record".equals(superClassInternalName)) {
                            throw new IllegalStateException("A record must inherit from java.lang.Record");
                        }
                    }
                    public void assertTypeInConstantPool() {
                    }
                    public void assertMethodTypeInConstantPool() {
                    }
                    public void assertHandleInConstantPool() {
                    }
                    public void assertInvokeDynamic() {
                    }
                    public void assertSubRoutine() {
                    }
                    public void assertDynamicValueInConstantPool() {
                    }
                    public void assertNestMate() {
                    }
                    public void assertRecord() {
                    }
                    public void assertPermittedSubclass() {
                    }
                }
                enum ForAnnotation implements Constraint {
                    CLASSIC(true), JAVA_8(false);
                    private final boolean classic;
                    ForAnnotation(boolean classic) {
                        this.classic = classic;
                    }
                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
                        if (!isStatic || !isPublic || !isFinal) {
                            throw new IllegalStateException("Cannot only define public, static, final field '" + name + "' for interface type");
                        }
                    }
                    public void assertMethod(String name, boolean isAbstract, boolean isPublic, boolean isPrivate, boolean isStatic, boolean isVirtual, boolean isConstructor, boolean isDefaultValueIncompatible, boolean isGeneric) {
                        if (!name.equals(MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME)) {
                            if (isConstructor) {
                                throw new IllegalStateException("Cannot define constructor for interface type");
                            } else if (classic && !isVirtual) {
                                throw new IllegalStateException("Cannot define non-virtual method '" + name + "' for a pre-Java 8 annotation type");
                            } else if (!isStatic && isDefaultValueIncompatible) {
                                throw new IllegalStateException("Cannot define method '" + name + "' with the given signature as an annotation type method");
                            }
                        }
                    }
                    public void assertAnnotation() {
                    }
                    public void assertTypeAnnotation() {
                    }
                    public void assertDefaultValue(String name) {
                    }
                    public void assertDefaultMethodCall() {
                    }
                    public void assertType(int modifier, String superClassInternalName, boolean definesInterfaces, boolean isGeneric) {
                        if ((modifier & Opcodes.ACC_INTERFACE) == 0) {
                            throw new IllegalStateException("Cannot define annotation type without interface modifier");
                        }
                    }
                    public void assertTypeInConstantPool() {
                    }
                    public void assertMethodTypeInConstantPool() {
                    }
                    public void assertHandleInConstantPool() {
                    }
                    public void assertInvokeDynamic() {
                    }
                    public void assertSubRoutine() {
                    }
                    public void assertDynamicValueInConstantPool() {
                    }
                    public void assertNestMate() {
                    }
                    public void assertRecord() {
                    }
                    public void assertPermittedSubclass() {
                    }
                }
                class ForClassFileVersion implements Constraint {
                    private final ClassFileVersion classFileVersion;
                    protected ForClassFileVersion(ClassFileVersion classFileVersion) {
                        this.classFileVersion = classFileVersion;
                    }
                    public void assertType(int modifiers, @MaybeNull String superClassInternalName, boolean definesInterfaces, boolean isGeneric) {
                        if ((modifiers & Opcodes.ACC_ANNOTATION) != 0 && !classFileVersion.isAtLeast(ClassFileVersion.JAVA_V5)) {
                            throw new IllegalStateException("Cannot define annotation type for class file version " + classFileVersion);
                        } else if (isGeneric && !classFileVersion.isAtLeast(ClassFileVersion.JAVA_V4)) {
                            throw new IllegalStateException("Cannot define a generic type for class file version " + classFileVersion);
                        }
                    }
                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
                        if (isGeneric && !classFileVersion.isAtLeast(ClassFileVersion.JAVA_V4)) {
                            throw new IllegalStateException("Cannot define generic field '" + name + "' for class file version " + classFileVersion);
                        }
                    }
                    public void assertMethod(String name, boolean isAbstract, boolean isPublic, boolean isPrivate, boolean isStatic, boolean isVirtual, boolean isConstructor, boolean isDefaultValueIncompatible, boolean isGeneric) {
                        if (isGeneric && !classFileVersion.isAtLeast(ClassFileVersion.JAVA_V4)) {
                            throw new IllegalStateException("Cannot define generic method '" + name + "' for class file version " + classFileVersion);
                        } else if (!isVirtual && isAbstract) {
                            throw new IllegalStateException("Cannot define static or non-virtual method '" + name + "' to be abstract");
                        }
                    }
                    public void assertAnnotation() {
                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V5)) {
                            throw new IllegalStateException("Cannot write annotations for class file version " + classFileVersion);
                        }
                    }
                    public void assertTypeAnnotation() {
                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V5)) {
                            throw new IllegalStateException("Cannot write type annotations for class file version " + classFileVersion);
                        }
                    }
                    public void assertDefaultValue(String name) {
                    }
                    public void assertDefaultMethodCall() {
                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V8)) {
                            throw new IllegalStateException("Cannot invoke default method for class file version " + classFileVersion);
                        }
                    }
                    public void assertTypeInConstantPool() {
                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V5)) {
                            throw new IllegalStateException("Cannot write type to constant pool for class file version " + classFileVersion);
                        }
                    }
                    public void assertMethodTypeInConstantPool() {
                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V7)) {
                            throw new IllegalStateException("Cannot write method type to constant pool for class file version " + classFileVersion);
                        }
                    }
                    public void assertHandleInConstantPool() {
                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V7)) {
                            throw new IllegalStateException("Cannot write method handle to constant pool for class file version " + classFileVersion);
                        }
                    }
                    public void assertInvokeDynamic() {
                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V7)) {
                            throw new IllegalStateException("Cannot write invoke dynamic instruction for class file version " + classFileVersion);
                        }
                    }
                    public void assertSubRoutine() {
                        if (classFileVersion.isGreaterThan(ClassFileVersion.JAVA_V5)) {
                            throw new IllegalStateException("Cannot write subroutine for class file version " + classFileVersion);
                        }
                    }
                    public void assertDynamicValueInConstantPool() {
                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V11)) {
                            throw new IllegalStateException("Cannot write dynamic constant for class file version " + classFileVersion);
                        }
                    }
                    public void assertNestMate() {
                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V11)) {
                            throw new IllegalStateException("Cannot define nest mate for class file version " + classFileVersion);
                        }
                    }
                    public void assertRecord() {
                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V14)) {
                            throw new IllegalStateException("Cannot define record for class file version " + classFileVersion);
                        }
                    }
                    public void assertPermittedSubclass() {
                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V17)) {
                            throw new IllegalStateException("Cannot define permitted subclasses for class file version " + classFileVersion);
                        }
                    }
                }
                class Compound implements Constraint {
                    private final List<Constraint> constraints;
                    public Compound(List<? extends Constraint> constraints) {
                        this.constraints = new ArrayList<Constraint>();
                        for (Constraint constraint : constraints) {
                            if (constraint instanceof Compound) {
                                this.constraints.addAll(((Compound) constraint).constraints);
                            } else {
                                this.constraints.add(constraint);
                            }
                        }
                    }
                    public void assertType(int modifier, @MaybeNull String superClassInternalName, boolean definesInterfaces, boolean isGeneric) {
                        for (Constraint constraint : constraints) {
                            constraint.assertType(modifier, superClassInternalName, definesInterfaces, isGeneric);
                        }
                    }
                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
                        for (Constraint constraint : constraints) {
                            constraint.assertField(name, isPublic, isStatic, isFinal, isGeneric);
                        }
                    }
                    public void assertMethod(String name, boolean isAbstract, boolean isPublic, boolean isPrivate, boolean isStatic, boolean isVirtual, boolean isConstructor, boolean isDefaultValueIncompatible, boolean isGeneric) {
                        for (Constraint constraint : constraints) {
                            constraint.assertMethod(name, isAbstract, isPublic, isPrivate, isStatic, isVirtual, isConstructor, isDefaultValueIncompatible, isGeneric);
                        }
                    }
                    public void assertDefaultValue(String name) {
                        for (Constraint constraint : constraints) {
                            constraint.assertDefaultValue(name);
                        }
                    }
                    public void assertDefaultMethodCall() {
                        for (Constraint constraint : constraints) {
                            constraint.assertDefaultMethodCall();
                        }
                    }
                    public void assertAnnotation() {
                        for (Constraint constraint : constraints) {
                            constraint.assertAnnotation();
                        }
                    }
                    public void assertTypeAnnotation() {
                        for (Constraint constraint : constraints) {
                            constraint.assertTypeAnnotation();
                        }
                    }
                    public void assertTypeInConstantPool() {
                        for (Constraint constraint : constraints) {
                            constraint.assertTypeInConstantPool();
                        }
                    }
                    public void assertMethodTypeInConstantPool() {
                        for (Constraint constraint : constraints) {
                            constraint.assertMethodTypeInConstantPool();
                        }
                    }
                    public void assertHandleInConstantPool() {
                        for (Constraint constraint : constraints) {
                            constraint.assertHandleInConstantPool();
                        }
                    }
                    public void assertInvokeDynamic() {
                        for (Constraint constraint : constraints) {
                            constraint.assertInvokeDynamic();
                        }
                    }
                    public void assertSubRoutine() {
                        for (Constraint constraint : constraints) {
                            constraint.assertSubRoutine();
                        }
                    }
                    public void assertDynamicValueInConstantPool() {
                        for (Constraint constraint : constraints) {
                            constraint.assertDynamicValueInConstantPool();
                        }
                    }
                    public void assertNestMate() {
                        for (Constraint constraint : constraints) {
                            constraint.assertNestMate();
                        }
                    }
                    public void assertRecord() {
                        for (Constraint constraint : constraints) {
                            constraint.assertRecord();
                        }
                    }
                    public void assertPermittedSubclass() {
                        for (Constraint constraint : constraints) {
                            constraint.assertPermittedSubclass();
                        }
                    }
                }
            }
            protected class ValidatingFieldVisitor extends FieldVisitor {
                protected ValidatingFieldVisitor(FieldVisitor fieldVisitor) {
                    super(OpenedClassReader.ASM_API, fieldVisitor);
                }
                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
                    constraint.assertAnnotation();
                    return super.visitAnnotation(descriptor, visible);
                }
            }
            protected class ValidatingMethodVisitor extends MethodVisitor {
                private final String name;
                protected ValidatingMethodVisitor(MethodVisitor methodVisitor, String name) {
                    super(OpenedClassReader.ASM_API, methodVisitor);
                    this.name = name;
                }
                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
                    constraint.assertAnnotation();
                    return super.visitAnnotation(descriptor, visible);
                }
                public AnnotationVisitor visitAnnotationDefault() {
                    constraint.assertDefaultValue(name);
                    return super.visitAnnotationDefault();
                }
                public void visitLdcInsn(Object value) {
                    if (value instanceof Type) {
                        Type type = (Type) value;
                        switch(type.getSort()) {
                            case Type.OBJECT:
                            case Type.ARRAY:
                                constraint.assertTypeInConstantPool();
                                break;
                            case Type.METHOD:
                                constraint.assertMethodTypeInConstantPool();
                                break;
                        }
                    } else if (value instanceof Handle) {
                        constraint.assertHandleInConstantPool();
                    } else if (value instanceof ConstantDynamic) {
                        constraint.assertDynamicValueInConstantPool();
                    }
                    super.visitLdcInsn(value);
                }
                public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {
                    if (isInterface && opcode == Opcodes.INVOKESPECIAL) {
                        constraint.assertDefaultMethodCall();
                    }
                    super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
                }
                public void visitInvokeDynamicInsn(String name, String descriptor, Handle bootstrapMethod, Object... bootstrapArgument) {
                    constraint.assertInvokeDynamic();
                    for (Object constant : bootstrapArgument) {
                        if (constant instanceof ConstantDynamic) {
                            constraint.assertDynamicValueInConstantPool();
                        }
                    }
                    super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethod, bootstrapArgument);
                }
                public void visitJumpInsn(int opcode, Label label) {
                    if (opcode == Opcodes.JSR) {
                        constraint.assertSubRoutine();
                    }
                    super.visitJumpInsn(opcode, label);
                }
            }
        }
        public abstract static class ForInlining<U> extends Default<U> {
            private static final FieldVisitor IGNORE_FIELD = null;
            private static final MethodVisitor IGNORE_METHOD = null;
            private static final RecordComponentVisitor IGNORE_RECORD_COMPONENT = null;
            private static final AnnotationVisitor IGNORE_ANNOTATION = null;
            protected final TypeDescription originalType;
            protected final ClassFileLocator classFileLocator;
            protected ForInlining(TypeDescription instrumentedType, ClassFileVersion classFileVersion, FieldPool fieldPool, RecordComponentPool recordComponentPool, List<? extends DynamicType> auxiliaryTypes, FieldList<FieldDescription.InDefinedShape> fields, MethodList<?> methods, MethodList<?> instrumentedMethods, RecordComponentList<RecordComponentDescription.InDefinedShape> recordComponents, LoadedTypeInitializer loadedTypeInitializer, TypeInitializer typeInitializer, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, AsmClassReader.Factory classReaderFactory, AsmClassWriter.Factory classWriterFactory, TypePool typePool, TypeDescription originalType, ClassFileLocator classFileLocator) {
                super(instrumentedType, classFileVersion, fieldPool, recordComponentPool, auxiliaryTypes, fields, methods, instrumentedMethods, recordComponents, loadedTypeInitializer, typeInitializer, typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classReaderFactory, classWriterFactory, typePool);
                this.originalType = originalType;
                this.classFileLocator = classFileLocator;
            }
            public ContextClassVisitor wrap(ClassVisitor classVisitor, int writerFlags, int readerFlags) {
                ContextRegistry contextRegistry = new ContextRegistry();
                return new RegistryContextClassVisitor(writeTo(ValidatingClassVisitor.of(classVisitor, typeValidation), typeInitializer, contextRegistry, asmVisitorWrapper.mergeWriter(writerFlags), asmVisitorWrapper.mergeReader(readerFlags)), contextRegistry);
            }
            protected UnresolvedType create(TypeInitializer typeInitializer, ClassDumpAction.Dispatcher dispatcher) {
                try {
                    int writerFlags = asmVisitorWrapper.mergeWriter(AsmVisitorWrapper.NO_FLAGS);
                    int readerFlags = asmVisitorWrapper.mergeReader(AsmVisitorWrapper.NO_FLAGS);
                    byte[] binaryRepresentation = classFileLocator.locate(originalType.getName()).resolve();
                    dispatcher.dump(instrumentedType, true, binaryRepresentation);
                    AsmClassReader classReader = classReaderFactory.make(binaryRepresentation);
                    AsmClassWriter classWriter = classWriterFactory.make(writerFlags, classReader, typePool);
                    ContextRegistry contextRegistry = new ContextRegistry();
                    classReader.accept(writeTo(ValidatingClassVisitor.of(classWriter.getVisitor(), typeValidation), typeInitializer, contextRegistry, writerFlags, readerFlags), readerFlags);
                    return new UnresolvedType(classWriter.getBinaryRepresentation(), contextRegistry.getAuxiliaryTypes());
                } catch (IOException exception) {
                    throw new RuntimeException("The class file could not be written", exception);
                }
            }
            protected abstract ClassVisitor writeTo(ClassVisitor classVisitor, TypeInitializer typeInitializer, ContextRegistry contextRegistry, int writerFlags, int readerFlags);
            protected class RegistryContextClassVisitor extends ContextClassVisitor {
                private final ContextRegistry contextRegistry;
                protected RegistryContextClassVisitor(ClassVisitor classVisitor, ContextRegistry contextRegistry) {
                    super(classVisitor);
                    this.contextRegistry = contextRegistry;
                }
                public List<DynamicType> getAuxiliaryTypes() {
                    return CompoundList.of(auxiliaryTypes, contextRegistry.getAuxiliaryTypes());
                }
                public LoadedTypeInitializer getLoadedTypeInitializer() {
                    return loadedTypeInitializer;
                }
            }
            protected static class ContextRegistry {
                private Implementation.Context.ExtractableView implementationContext;
                public void setImplementationContext(Implementation.Context.ExtractableView implementationContext) {
                    this.implementationContext = implementationContext;
                }
                public List<DynamicType> getAuxiliaryTypes() {
                    return implementationContext.getAuxiliaryTypes();
                }
            }
            protected static class WithFullProcessing<V> extends ForInlining<V> {
                private static final Object[] EMPTY = new Object[0];
                private final MethodRegistry.Prepared methodRegistry;
                private final Implementation.Target.Factory implementationTargetFactory;
                private final MethodRebaseResolver methodRebaseResolver;
                protected WithFullProcessing(TypeDescription instrumentedType, ClassFileVersion classFileVersion, FieldPool fieldPool, RecordComponentPool recordComponentPool, List<? extends DynamicType> auxiliaryTypes, FieldList<FieldDescription.InDefinedShape> fields, MethodList<?> methods, MethodList<?> instrumentedMethods, RecordComponentList<RecordComponentDescription.InDefinedShape> recordComponents, LoadedTypeInitializer loadedTypeInitializer, TypeInitializer typeInitializer, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, AsmClassReader.Factory classReaderFactory, AsmClassWriter.Factory classWriterFactory, TypePool typePool, TypeDescription originalType, ClassFileLocator classFileLocator, MethodRegistry.Prepared methodRegistry, Implementation.Target.Factory implementationTargetFactory, MethodRebaseResolver methodRebaseResolver) {
                    super(instrumentedType, classFileVersion, fieldPool, recordComponentPool, auxiliaryTypes, fields, methods, instrumentedMethods, recordComponents, loadedTypeInitializer, typeInitializer, typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classReaderFactory, classWriterFactory, typePool, originalType, classFileLocator);
                    this.methodRegistry = methodRegistry;
                    this.implementationTargetFactory = implementationTargetFactory;
                    this.methodRebaseResolver = methodRebaseResolver;
                }
                protected ClassVisitor writeTo(ClassVisitor classVisitor, TypeInitializer typeInitializer, ContextRegistry contextRegistry, int writerFlags, int readerFlags) {
                    classVisitor = new RedefinitionClassVisitor(classVisitor, typeInitializer, contextRegistry, writerFlags, readerFlags);
                    return originalType.getName().equals(instrumentedType.getName()) ? classVisitor : new OpenedClassRemapper(classVisitor, new SimpleRemapper(OpenedClassReader.ASM_API, originalType.getInternalName(), instrumentedType.getInternalName()));
                }
                protected static class OpenedClassRemapper extends ClassRemapper {
                    protected OpenedClassRemapper(ClassVisitor classVisitor, Remapper remapper) {
                        super(OpenedClassReader.ASM_API, classVisitor, remapper);
                    }
                }
                protected interface InitializationHandler {
                    void complete(ClassVisitor classVisitor, Implementation.Context.ExtractableView implementationContext);
                    class Creating extends TypeInitializer.Drain.Default implements InitializationHandler {
                        protected Creating(TypeDescription instrumentedType, MethodPool methodPool, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                            super(instrumentedType, methodPool, annotationValueFilterFactory);
                        }
                        public void complete(ClassVisitor classVisitor, Implementation.Context.ExtractableView implementationContext) {
                            implementationContext.drain(this, classVisitor, annotationValueFilterFactory);
                        }
                    }
                    abstract class Appending extends MethodVisitor implements InitializationHandler, TypeInitializer.Drain {
                        protected final TypeDescription instrumentedType;
                        protected final MethodPool.Record record;
                        protected final AnnotationValueFilter.Factory annotationValueFilterFactory;
                        protected final FrameWriter frameWriter;
                        protected int stackSize;
                        protected int localVariableLength;
                        protected Appending(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool.Record record, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
                            super(OpenedClassReader.ASM_API, methodVisitor);
                            this.instrumentedType = instrumentedType;
                            this.record = record;
                            this.annotationValueFilterFactory = annotationValueFilterFactory;
                            if (!requireFrames) {
                                frameWriter = FrameWriter.NoOp.INSTANCE;
                            } else if (expandFrames) {
                                frameWriter = FrameWriter.Expanding.INSTANCE;
                            } else {
                                frameWriter = new FrameWriter.Active();
                            }
                        }
                        protected static InitializationHandler of(boolean enabled, MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool methodPool, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
                            return enabled ? withDrain(methodVisitor, instrumentedType, methodPool, annotationValueFilterFactory, requireFrames, expandFrames) : withoutDrain(methodVisitor, instrumentedType, methodPool, annotationValueFilterFactory, requireFrames, expandFrames);
                        }
                        private static WithDrain withDrain(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool methodPool, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
                            MethodPool.Record record = methodPool.target(new MethodDescription.Latent.TypeInitializer(instrumentedType));
                            return record.getSort().isImplemented() ? new WithDrain.WithActiveRecord(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames) : new WithDrain.WithoutActiveRecord(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);
                        }
                        private static WithoutDrain withoutDrain(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool methodPool, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
                            MethodPool.Record record = methodPool.target(new MethodDescription.Latent.TypeInitializer(instrumentedType));
                            return record.getSort().isImplemented() ? new WithoutDrain.WithActiveRecord(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames) : new WithoutDrain.WithoutActiveRecord(methodVisitor, instrumentedType, record, annotationValueFilterFactory);
                        }
                        public void visitCode() {
                            record.applyAttributes(mv, annotationValueFilterFactory);
                            super.visitCode();
                            onStart();
                        }
                        protected abstract void onStart();
                        public void visitFrame(int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
                            super.visitFrame(type, localVariableLength, localVariable, stackSize, stack);
                            frameWriter.onFrame(type, localVariableLength);
                        }
                        public void visitMaxs(int stackSize, int localVariableLength) {
                            this.stackSize = stackSize;
                            this.localVariableLength = localVariableLength;
                        }
                        public abstract void visitEnd();
                        public void apply(ClassVisitor classVisitor, TypeInitializer typeInitializer, Implementation.Context implementationContext) {
                            ByteCodeAppender.Size size = typeInitializer.apply(mv, implementationContext, new MethodDescription.Latent.TypeInitializer(instrumentedType));
                            stackSize = Math.max(stackSize, size.getOperandStackSize());
                            localVariableLength = Math.max(localVariableLength, size.getLocalVariableSize());
                            onComplete(implementationContext);
                        }
                        protected abstract void onComplete(Implementation.Context implementationContext);
                        public void complete(ClassVisitor classVisitor, Implementation.Context.ExtractableView implementationContext) {
                            implementationContext.drain(this, classVisitor, annotationValueFilterFactory);
                            mv.visitMaxs(stackSize, localVariableLength);
                            mv.visitEnd();
                        }
                        protected interface FrameWriter {
                            Object[] EMPTY = new Object[0];
                            void onFrame(int type, int localVariableLength);
                            void emitFrame(MethodVisitor methodVisitor);
                            enum NoOp implements FrameWriter {
                                INSTANCE;
                                public void onFrame(int type, int localVariableLength) {
                                }
                                public void emitFrame(MethodVisitor methodVisitor) {
                                }
                            }
                            enum Expanding implements FrameWriter {
                                INSTANCE;
                                public void onFrame(int type, int localVariableLength) {
                                }
                                public void emitFrame(MethodVisitor methodVisitor) {
                                    methodVisitor.visitFrame(Opcodes.F_NEW, EMPTY.length, EMPTY, EMPTY.length, EMPTY);
                                    methodVisitor.visitInsn(Opcodes.NOP);
                                }
                            }
                            class Active implements FrameWriter {
                                private int currentLocalVariableLength;
                                public void onFrame(int type, int localVariableLength) {
                                    switch(type) {
                                        case Opcodes.F_SAME:
                                        case Opcodes.F_SAME1:
                                            break;
                                        case Opcodes.F_APPEND:
                                            currentLocalVariableLength += localVariableLength;
                                            break;
                                        case Opcodes.F_CHOP:
                                            currentLocalVariableLength -= localVariableLength;
                                            break;
                                        case Opcodes.F_NEW:
                                        case Opcodes.F_FULL:
                                            currentLocalVariableLength = localVariableLength;
                                            break;
                                        default:
                                            throw new IllegalStateException("Unexpected frame type: " + type);
                                    }
                                }
                                public void emitFrame(MethodVisitor methodVisitor) {
                                    if (currentLocalVariableLength == 0) {
                                        methodVisitor.visitFrame(Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY);
                                    } else if (currentLocalVariableLength > 3) {
                                        methodVisitor.visitFrame(Opcodes.F_FULL, EMPTY.length, EMPTY, EMPTY.length, EMPTY);
                                    } else {
                                        methodVisitor.visitFrame(Opcodes.F_CHOP, currentLocalVariableLength, EMPTY, EMPTY.length, EMPTY);
                                    }
                                    methodVisitor.visitInsn(Opcodes.NOP);
                                    currentLocalVariableLength = 0;
                                }
                            }
                        }
                        protected abstract static class WithoutDrain extends Appending {
                            protected WithoutDrain(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool.Record record, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
                                super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);
                            }
                            protected void onStart() {
                            }
                            public void visitEnd() {
                            }
                            protected static class WithoutActiveRecord extends WithoutDrain {
                                protected WithoutActiveRecord(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool.Record record, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                                    super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, false, false);
                                }
                                protected void onComplete(Implementation.Context implementationContext) {
                                }
                            }
                            protected static class WithActiveRecord extends WithoutDrain {
                                private final Label label;
                                protected WithActiveRecord(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool.Record record, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
                                    super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);
                                    label = new Label();
                                }
                                public void visitInsn(int opcode) {
                                    if (opcode == Opcodes.RETURN) {
                                        mv.visitJumpInsn(Opcodes.GOTO, label);
                                    } else {
                                        super.visitInsn(opcode);
                                    }
                                }
                                protected void onComplete(Implementation.Context implementationContext) {
                                    mv.visitLabel(label);
                                    frameWriter.emitFrame(mv);
                                    ByteCodeAppender.Size size = record.applyCode(mv, implementationContext);
                                    stackSize = Math.max(stackSize, size.getOperandStackSize());
                                    localVariableLength = Math.max(localVariableLength, size.getLocalVariableSize());
                                }
                            }
                        }
                        protected abstract static class WithDrain extends Appending {
                            protected final Label appended;
                            protected final Label original;
                            protected WithDrain(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool.Record record, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
                                super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);
                                appended = new Label();
                                original = new Label();
                            }
                            protected void onStart() {
                                mv.visitJumpInsn(Opcodes.GOTO, appended);
                                mv.visitLabel(original);
                                frameWriter.emitFrame(mv);
                            }
                            public void visitEnd() {
                                mv.visitLabel(appended);
                                frameWriter.emitFrame(mv);
                            }
                            protected void onComplete(Implementation.Context implementationContext) {
                                mv.visitJumpInsn(Opcodes.GOTO, original);
                                onAfterComplete(implementationContext);
                            }
                            protected abstract void onAfterComplete(Implementation.Context implementationContext);
                            protected static class WithoutActiveRecord extends WithDrain {
                                protected WithoutActiveRecord(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool.Record record, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
                                    super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);
                                }
                                protected void onAfterComplete(Implementation.Context implementationContext) {
                                }
                            }
                            protected static class WithActiveRecord extends WithDrain {
                                private final Label label;
                                protected WithActiveRecord(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodPool.Record record, AnnotationValueFilter.Factory annotationValueFilterFactory, boolean requireFrames, boolean expandFrames) {
                                    super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);
                                    label = new Label();
                                }
                                public void visitInsn(int opcode) {
                                    if (opcode == Opcodes.RETURN) {
                                        mv.visitJumpInsn(Opcodes.GOTO, label);
                                    } else {
                                        super.visitInsn(opcode);
                                    }
                                }
                                protected void onAfterComplete(Implementation.Context implementationContext) {
                                    mv.visitLabel(label);
                                    frameWriter.emitFrame(mv);
                                    ByteCodeAppender.Size size = record.applyCode(mv, implementationContext);
                                    stackSize = Math.max(stackSize, size.getOperandStackSize());
                                    localVariableLength = Math.max(localVariableLength, size.getLocalVariableSize());
                                }
                            }
                        }
                    }
                }
                protected class RedefinitionClassVisitor extends MetadataAwareClassVisitor {
                    private final TypeInitializer typeInitializer;
                    private final ContextRegistry contextRegistry;
                    private final int writerFlags;
                    private final int readerFlags;
                    private final LinkedHashMap<SignatureKey, FieldDescription> declarableFields;
                    private final LinkedHashMap<SignatureKey, MethodDescription> declarableMethods;
                    private final LinkedHashMap<String, RecordComponentDescription> declarableRecordComponents;
                    private final Set<String> nestMembers;
                    private final LinkedHashMap<String, TypeDescription> declaredTypes;
                    private final Set<String> permittedSubclasses;
                    private MethodPool methodPool;
                    private InitializationHandler initializationHandler;
                    private Implementation.Context.ExtractableView implementationContext;
                    private boolean retainDeprecationModifiers;
                    private final Set<SignatureKey> fieldKeys = new HashSet<SignatureKey>();
                    private final Set<SignatureKey> methodsKeys = new HashSet<SignatureKey>();
                    protected RedefinitionClassVisitor(ClassVisitor classVisitor, TypeInitializer typeInitializer, ContextRegistry contextRegistry, int writerFlags, int readerFlags) {
                        super(OpenedClassReader.ASM_API, classVisitor);
                        this.typeInitializer = typeInitializer;
                        this.contextRegistry = contextRegistry;
                        this.writerFlags = writerFlags;
                        this.readerFlags = readerFlags;
                        declarableFields = new LinkedHashMap<SignatureKey, FieldDescription>((int) Math.ceil(fields.size() / 0.75));
                        for (FieldDescription fieldDescription : fields) {
                            declarableFields.put(new SignatureKey(fieldDescription.getInternalName(), fieldDescription.getDescriptor()), fieldDescription);
                        }
                        declarableMethods = new LinkedHashMap<SignatureKey, MethodDescription>((int) Math.ceil(instrumentedMethods.size() / 0.75));
                        for (MethodDescription methodDescription : instrumentedMethods) {
                            declarableMethods.put(new SignatureKey(methodDescription.getInternalName(), methodDescription.getDescriptor()), methodDescription);
                        }
                        declarableRecordComponents = new LinkedHashMap<String, RecordComponentDescription>((int) Math.ceil(recordComponents.size() / 0.75));
                        for (RecordComponentDescription recordComponentDescription : recordComponents) {
                            declarableRecordComponents.put(recordComponentDescription.getActualName(), recordComponentDescription);
                        }
                        if (instrumentedType.isNestHost()) {
                            nestMembers = new LinkedHashSet<String>((int) Math.ceil(instrumentedType.getNestMembers().size() / 0.75));
                            for (TypeDescription typeDescription : instrumentedType.getNestMembers().filter(not(is(instrumentedType)))) {
                                nestMembers.add(typeDescription.getInternalName());
                            }
                        } else {
                            nestMembers = Collections.emptySet();
                        }
                        declaredTypes = new LinkedHashMap<String, TypeDescription>((int) Math.ceil(instrumentedType.getDeclaredTypes().size() / 0.75));
                        for (TypeDescription typeDescription : instrumentedType.getDeclaredTypes()) {
                            declaredTypes.put(typeDescription.getInternalName(), typeDescription);
                        }
                        if (instrumentedType.isSealed()) {
                            permittedSubclasses = new LinkedHashSet<String>((int) Math.ceil(instrumentedType.getPermittedSubtypes().size() / 0.75));
                            for (TypeDescription typeDescription : instrumentedType.getPermittedSubtypes()) {
                                permittedSubclasses.add(typeDescription.getInternalName());
                            }
                        } else {
                            permittedSubclasses = null;
                        }
                    }
                    public void visit(int classFileVersionNumber, int modifiers, String internalName, String genericSignature, String superClassInternalName, String[] interfaceTypeInternalName) {
                        ClassFileVersion classFileVersion = ClassFileVersion.ofMinorMajor(classFileVersionNumber);
                        methodPool = methodRegistry.compile(implementationTargetFactory, classFileVersion);
                        initializationHandler = new InitializationHandler.Creating(instrumentedType, methodPool, annotationValueFilterFactory);
                        implementationContext = implementationContextFactory.make(instrumentedType, auxiliaryTypeNamingStrategy, typeInitializer, classFileVersion, WithFullProcessing.this.classFileVersion, (writerFlags & ClassWriter.COMPUTE_FRAMES) == 0 && classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6) ? ((readerFlags & ClassReader.EXPAND_FRAMES) == 0 ? Implementation.Context.FrameGeneration.GENERATE : Implementation.Context.FrameGeneration.EXPAND) : Implementation.Context.FrameGeneration.DISABLED);
                        retainDeprecationModifiers = classFileVersion.isLessThan(ClassFileVersion.JAVA_V5);
                        contextRegistry.setImplementationContext(implementationContext);
                        cv = asmVisitorWrapper.wrap(instrumentedType, cv, implementationContext, typePool, fields, methods, writerFlags, readerFlags);
                        cv.visit(classFileVersionNumber, instrumentedType.getActualModifiers((modifiers & Opcodes.ACC_SUPER) != 0 && !instrumentedType.isInterface()) | resolveDeprecationModifiers(modifiers) | (((modifiers & Opcodes.ACC_FINAL) != 0 && instrumentedType.isAnonymousType()) ? Opcodes.ACC_FINAL : ModifierContributor.EMPTY_MASK) | (instrumentedType.isModuleType() ? Opcodes.ACC_MODULE : ModifierContributor.EMPTY_MASK), instrumentedType.getInternalName(), TypeDescription.AbstractBase.RAW_TYPES ? genericSignature : instrumentedType.getGenericSignature(), instrumentedType.getSuperClass() == null ? (instrumentedType.isInterface() ? TypeDescription.ForLoadedType.of(Object.class).getInternalName() : NO_REFERENCE) : instrumentedType.getSuperClass().asErasure().getInternalName(), instrumentedType.getInterfaces().asErasures().toInternalNames());
                    }
                    protected ModuleVisitor onVisitModule(String name, int modifiers, @MaybeNull String version) {
                        onModule();
                        return null;
                    }
                    protected void onModule() {
                        ModuleDescription moduleDescription = instrumentedType.toModuleDescription();
                        if (moduleDescription != null) {
                            moduleDescription.accept(cv);
                        }
                    }
                    protected void onVisitNestHost(String nestHost) {
                        onNestHost();
                    }
                    protected void onNestHost() {
                        if (!instrumentedType.isNestHost()) {
                            cv.visitNestHost(instrumentedType.getNestHost().getInternalName());
                        }
                    }
                    protected void onVisitPermittedSubclass(String permittedSubclass) {
                        if (permittedSubclasses != null && permittedSubclasses.remove(permittedSubclass)) {
                            cv.visitPermittedSubclass(permittedSubclass);
                        }
                    }
                    protected void onVisitOuterClass(String owner, @MaybeNull String name, @MaybeNull String descriptor) {
                        try {
                            onOuterType();
                        } catch (Throwable ignored) {
                            cv.visitOuterClass(owner, name, descriptor);
                        }
                    }
                    protected void onOuterType() {
                        MethodDescription.InDefinedShape enclosingMethod = instrumentedType.getEnclosingMethod();
                        if (enclosingMethod != null) {
                            cv.visitOuterClass(enclosingMethod.getDeclaringType().getInternalName(), enclosingMethod.getInternalName(), enclosingMethod.getDescriptor());
                        } else if (instrumentedType.isLocalType() || instrumentedType.isAnonymousType()) {
                            cv.visitOuterClass(instrumentedType.getEnclosingType().getInternalName(), NO_REFERENCE, NO_REFERENCE);
                        }
                    }
                    protected void onAfterAttributes() {
                        typeAttributeAppender.apply(cv, instrumentedType, annotationValueFilterFactory.on(instrumentedType));
                    }
                    protected AnnotationVisitor onVisitTypeAnnotation(int typeReference, TypePath typePath, String descriptor, boolean visible) {
                        return annotationRetention.isEnabled() ? cv.visitTypeAnnotation(typeReference, typePath, descriptor, visible) : IGNORE_ANNOTATION;
                    }
                    protected AnnotationVisitor onVisitAnnotation(String descriptor, boolean visible) {
                        return annotationRetention.isEnabled() ? cv.visitAnnotation(descriptor, visible) : IGNORE_ANNOTATION;
                    }
                    protected RecordComponentVisitor onVisitRecordComponent(String name, String descriptor, @MaybeNull String genericSignature) {
                        RecordComponentDescription recordComponentDescription = declarableRecordComponents.remove(name);
                        if (recordComponentDescription != null) {
                            RecordComponentPool.Record record = recordComponentPool.target(recordComponentDescription);
                            if (!record.isImplicit()) {
                                return redefine(record, genericSignature);
                            }
                        }
                        return cv.visitRecordComponent(name, descriptor, genericSignature);
                    }
                    protected RecordComponentVisitor redefine(RecordComponentPool.Record record, @MaybeNull String genericSignature) {
                        RecordComponentDescription recordComponentDescription = record.getRecordComponent();
                        RecordComponentVisitor recordComponentVisitor = cv.visitRecordComponent(recordComponentDescription.getActualName(), recordComponentDescription.getDescriptor(), TypeDescription.AbstractBase.RAW_TYPES ? genericSignature : recordComponentDescription.getGenericSignature());
                        return recordComponentVisitor == null ? IGNORE_RECORD_COMPONENT : new AttributeObtainingRecordComponentVisitor(recordComponentVisitor, record);
                    }
                    protected FieldVisitor onVisitField(int modifiers, String internalName, String descriptor, @MaybeNull String genericSignature, @MaybeNull Object value) {
                        SignatureKey key = new SignatureKey(internalName, descriptor);
                        fieldKeys.add(key);
                        FieldDescription fieldDescription = declarableFields.remove(key);
                        if (fieldDescription != null) {
                            FieldPool.Record record = fieldPool.target(fieldDescription);
                            if (!record.isImplicit()) {
                                return redefine(record, value, modifiers, genericSignature);
                            }
                        }
                        return cv.visitField(modifiers, internalName, descriptor, genericSignature, value);
                    }
                    protected FieldVisitor redefine(FieldPool.Record record, @MaybeNull Object value, int modifiers, @MaybeNull String genericSignature) {
                        FieldDescription instrumentedField = record.getField();
                        FieldVisitor fieldVisitor = cv.visitField(instrumentedField.getActualModifiers() | resolveDeprecationModifiers(modifiers), instrumentedField.getInternalName(), instrumentedField.getDescriptor(), TypeDescription.AbstractBase.RAW_TYPES ? genericSignature : instrumentedField.getGenericSignature(), record.resolveDefault(value));
                        return fieldVisitor == null ? IGNORE_FIELD : new AttributeObtainingFieldVisitor(fieldVisitor, record);
                    }
                    protected MethodVisitor onVisitMethod(int modifiers, String internalName, String descriptor, @MaybeNull String genericSignature, @MaybeNull String[] exceptionName) {
                        if (internalName.equals(MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME)) {
                            MethodVisitor methodVisitor = cv.visitMethod(modifiers, internalName, descriptor, genericSignature, exceptionName);
                            return methodVisitor == null ? IGNORE_METHOD : (MethodVisitor) (initializationHandler = InitializationHandler.Appending.of(implementationContext.isEnabled(), methodVisitor, instrumentedType, methodPool, annotationValueFilterFactory, (writerFlags & ClassWriter.COMPUTE_FRAMES) == 0 && implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V6), (readerFlags & ClassReader.EXPAND_FRAMES) != 0));
                        } else {
                            SignatureKey key = new SignatureKey(internalName, descriptor);
                            methodsKeys.add(key);
                            MethodDescription methodDescription = declarableMethods.remove(key);
                            return methodDescription == null ? cv.visitMethod(modifiers, internalName, descriptor, genericSignature, exceptionName) : redefine(methodDescription, (modifiers & Opcodes.ACC_ABSTRACT) != 0, modifiers, genericSignature);
                        }
                    }
                    protected MethodVisitor redefine(MethodDescription methodDescription, boolean abstractOrigin, int modifiers, @MaybeNull String genericSignature) {
                        MethodPool.Record record = methodPool.target(methodDescription);
                        if (!record.getSort().isDefined()) {
                            return cv.visitMethod(methodDescription.getActualModifiers() | resolveDeprecationModifiers(modifiers), methodDescription.getInternalName(), methodDescription.getDescriptor(), TypeDescription.AbstractBase.RAW_TYPES ? genericSignature : methodDescription.getGenericSignature(), methodDescription.getExceptionTypes().asErasures().toInternalNames());
                        }
                        MethodDescription implementedMethod = record.getMethod();
                        MethodVisitor methodVisitor = cv.visitMethod(ModifierContributor.Resolver.of(Collections.singleton(record.getVisibility())).resolve(implementedMethod.getActualModifiers(record.getSort().isImplemented())) | resolveDeprecationModifiers(modifiers), implementedMethod.getInternalName(), implementedMethod.getDescriptor(), TypeDescription.AbstractBase.RAW_TYPES ? genericSignature : implementedMethod.getGenericSignature(), implementedMethod.getExceptionTypes().asErasures().toInternalNames());
                        if (methodVisitor == null) {
                            return IGNORE_METHOD;
                        } else if (abstractOrigin) {
                            return new AttributeObtainingMethodVisitor(methodVisitor, record);
                        } else if (methodDescription.isNative()) {
                            MethodRebaseResolver.Resolution resolution = methodRebaseResolver.resolve(implementedMethod.asDefined());
                            if (resolution.isRebased()) {
                                MethodVisitor rebasedMethodVisitor = super.visitMethod(resolution.getResolvedMethod().getActualModifiers() | resolveDeprecationModifiers(modifiers), resolution.getResolvedMethod().getInternalName(), resolution.getResolvedMethod().getDescriptor(), TypeDescription.AbstractBase.RAW_TYPES ? genericSignature : implementedMethod.getGenericSignature(), resolution.getResolvedMethod().getExceptionTypes().asErasures().toInternalNames());
                                if (rebasedMethodVisitor != null) {
                                    rebasedMethodVisitor.visitEnd();
                                }
                            }
                            return new AttributeObtainingMethodVisitor(methodVisitor, record);
                        } else {
                            return new CodePreservingMethodVisitor(methodVisitor, record, methodRebaseResolver.resolve(implementedMethod.asDefined()));
                        }
                    }
                    protected void onVisitInnerClass(String internalName, @MaybeNull String outerName, @MaybeNull String innerName, int modifiers) {
                        if (!internalName.equals(instrumentedType.getInternalName())) {
                            TypeDescription declaredType = declaredTypes.remove(internalName);
                            if (declaredType == null) {
                                cv.visitInnerClass(internalName, outerName, innerName, modifiers);
                            } else {
                                cv.visitInnerClass(internalName, declaredType.isMemberType() || outerName != null && innerName == null && declaredType.isAnonymousType() ? instrumentedType.getInternalName() : NO_REFERENCE, declaredType.isAnonymousType() ? NO_REFERENCE : declaredType.getSimpleName(), declaredType.getModifiers());
                            }
                        }
                    }
                    protected void onVisitNestMember(String nestMember) {
                        if (instrumentedType.isNestHost() && nestMembers.remove(nestMember)) {
                            cv.visitNestMember(nestMember);
                        }
                    }
                    protected void onVisitEnd() {
                        for (String nestMember : nestMembers) {
                            cv.visitNestMember(nestMember);
                        }
                        if (permittedSubclasses != null) {
                            for (String permittedSubclass : permittedSubclasses) {
                                cv.visitPermittedSubclass(permittedSubclass);
                            }
                        }
                        TypeDescription declaringType = instrumentedType.getDeclaringType();
                        if (declaringType != null) {
                            cv.visitInnerClass(instrumentedType.getInternalName(), declaringType.getInternalName(), instrumentedType.getSimpleName(), instrumentedType.getModifiers());
                        } else if (instrumentedType.isLocalType()) {
                            cv.visitInnerClass(instrumentedType.getInternalName(), NO_REFERENCE, instrumentedType.getSimpleName(), instrumentedType.getModifiers());
                        } else if (instrumentedType.isAnonymousType()) {
                            cv.visitInnerClass(instrumentedType.getInternalName(), NO_REFERENCE, NO_REFERENCE, instrumentedType.getModifiers());
                        }
                        for (TypeDescription typeDescription : declaredTypes.values()) {
                            cv.visitInnerClass(typeDescription.getInternalName(), typeDescription.isMemberType() ? instrumentedType.getInternalName() : NO_REFERENCE, typeDescription.isAnonymousType() ? NO_REFERENCE : typeDescription.getSimpleName(), typeDescription.getModifiers());
                        }
                        for (RecordComponentDescription recordComponent : declarableRecordComponents.values()) {
                            recordComponentPool.target(recordComponent).apply(cv, annotationValueFilterFactory);
                        }
                        for (FieldDescription fieldDescription : declarableFields.values()) {
                            fieldPool.target(fieldDescription).apply(new DeduplicatingClassVisitor(cv), annotationValueFilterFactory);
                        }
                        for (MethodDescription methodDescription : declarableMethods.values()) {
                            methodPool.target(methodDescription).apply(new DeduplicatingClassVisitor(cv), implementationContext, annotationValueFilterFactory);
                        }
                        initializationHandler.complete(cv, implementationContext);
                        cv.visitEnd();
                    }
                    private int resolveDeprecationModifiers(int modifiers) {
                        return retainDeprecationModifiers && (modifiers & Opcodes.ACC_DEPRECATED) != 0 ? Opcodes.ACC_DEPRECATED : ModifierContributor.EMPTY_MASK;
                    }
                    protected class DeduplicatingClassVisitor extends ClassVisitor {
                        protected DeduplicatingClassVisitor(ClassVisitor classVisitor) {
                            super(OpenedClassReader.ASM_API, classVisitor);
                        }
                        public FieldVisitor visitField(int access, String internalName, String descriptor, @MaybeNull String signature, @MaybeNull Object value) {
                            if (fieldKeys.contains(new SignatureKey(internalName, descriptor))) {
                                throw new IllegalStateException("Field already defined: " + internalName + descriptor);
                            }
                            return super.visitField(access, internalName, descriptor, signature, value);
                        }
                        public MethodVisitor visitMethod(int access, String internalName, String descriptor, @MaybeNull String signature, @MaybeNull String[] exception) {
                            if (methodsKeys.contains(new SignatureKey(internalName, descriptor))) {
                                if ((access & Opcodes.ACC_BRIDGE) != 0) {
                                    return null;
                                } else {
                                    throw new IllegalStateException("Method already defined: " + internalName + descriptor);
                                }
                            }
                            return super.visitMethod(access, internalName, descriptor, signature, exception);
                        }
                    }
                    protected class AttributeObtainingFieldVisitor extends FieldVisitor {
                        private final FieldPool.Record record;
                        protected AttributeObtainingFieldVisitor(FieldVisitor fieldVisitor, FieldPool.Record record) {
                            super(OpenedClassReader.ASM_API, fieldVisitor);
                            this.record = record;
                        }
                        public AnnotationVisitor visitTypeAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
                            return annotationRetention.isEnabled() ? super.visitTypeAnnotation(typeReference, typePath, descriptor, visible) : IGNORE_ANNOTATION;
                        }
                        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
                            return annotationRetention.isEnabled() ? super.visitAnnotation(descriptor, visible) : IGNORE_ANNOTATION;
                        }
                        public void visitEnd() {
                            record.apply(fv, annotationValueFilterFactory);
                            super.visitEnd();
                        }
                    }
                    protected class AttributeObtainingRecordComponentVisitor extends RecordComponentVisitor {
                        private final RecordComponentPool.Record record;
                        protected AttributeObtainingRecordComponentVisitor(RecordComponentVisitor recordComponentVisitor, RecordComponentPool.Record record) {
                            super(OpenedClassReader.ASM_API, recordComponentVisitor);
                            this.record = record;
                        }
                        public AnnotationVisitor visitTypeAnnotation(int typeReference, TypePath typePath, String descriptor, boolean visible) {
                            return annotationRetention.isEnabled() ? super.visitTypeAnnotation(typeReference, typePath, descriptor, visible) : IGNORE_ANNOTATION;
                        }
                        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
                            return annotationRetention.isEnabled() ? super.visitAnnotation(descriptor, visible) : IGNORE_ANNOTATION;
                        }
                        public void visitEnd() {
                            record.apply(getDelegate(), annotationValueFilterFactory);
                            super.visitEnd();
                        }
                    }
                    protected class CodePreservingMethodVisitor extends MethodVisitor {
                        private final MethodVisitor actualMethodVisitor;
                        private final MethodPool.Record record;
                        private final MethodRebaseResolver.Resolution resolution;
                        protected CodePreservingMethodVisitor(MethodVisitor actualMethodVisitor, MethodPool.Record record, MethodRebaseResolver.Resolution resolution) {
                            super(OpenedClassReader.ASM_API, actualMethodVisitor);
                            this.actualMethodVisitor = actualMethodVisitor;
                            this.record = record;
                            this.resolution = resolution;
                            record.applyHead(actualMethodVisitor);
                        }
                        public AnnotationVisitor visitAnnotationDefault() {
                            return IGNORE_ANNOTATION;
                        }
                        public AnnotationVisitor visitTypeAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
                            return annotationRetention.isEnabled() ? super.visitTypeAnnotation(typeReference, typePath, descriptor, visible) : IGNORE_ANNOTATION;
                        }
                        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
                            return annotationRetention.isEnabled() ? super.visitAnnotation(descriptor, visible) : IGNORE_ANNOTATION;
                        }
                        public void visitAnnotableParameterCount(int count, boolean visible) {
                            if (annotationRetention.isEnabled()) {
                                super.visitAnnotableParameterCount(count, visible);
                            }
                        }
                        public AnnotationVisitor visitParameterAnnotation(int index, String descriptor, boolean visible) {
                            return annotationRetention.isEnabled() ? super.visitParameterAnnotation(index, descriptor, visible) : IGNORE_ANNOTATION;
                        }
                        public void visitCode() {
                            record.applyBody(actualMethodVisitor, implementationContext, annotationValueFilterFactory);
                            actualMethodVisitor.visitEnd();
                            if (resolution.isRebased()) {
                                mv = cv.visitMethod(resolution.getResolvedMethod().getActualModifiers(), resolution.getResolvedMethod().getInternalName(), resolution.getResolvedMethod().getDescriptor(), resolution.getResolvedMethod().getGenericSignature(), resolution.getResolvedMethod().getExceptionTypes().asErasures().toInternalNames());
                                super.visitCode();
                                if (!resolution.getAppendedParameters().isEmpty() && implementationContext.getFrameGeneration().isActive()) {
                                    if (implementationContext.getFrameGeneration() == Implementation.Context.FrameGeneration.GENERATE && resolution.getAppendedParameters().size() < 4) {
                                        super.visitFrame(Opcodes.F_CHOP, resolution.getAppendedParameters().size(), EMPTY, EMPTY.length, EMPTY);
                                    } else {
                                        Object[] frame = new Object[resolution.getResolvedMethod().getParameters().size() - resolution.getAppendedParameters().size() + 1];
                                        frame[0] = Opcodes.UNINITIALIZED_THIS;
                                        for (int index = 1; index < frame.length; index++) {
                                            TypeDefinition typeDefinition = resolution.getResolvedMethod().getParameters().get(index - 1).getType();
                                            if (typeDefinition.represents(boolean.class) || typeDefinition.represents(byte.class) || typeDefinition.represents(short.class) || typeDefinition.represents(char.class) || typeDefinition.represents(int.class)) {
                                                frame[index] = Opcodes.INTEGER;
                                            } else if (typeDefinition.represents(long.class)) {
                                                frame[index] = Opcodes.LONG;
                                            } else if (typeDefinition.represents(float.class)) {
                                                frame[index] = Opcodes.FLOAT;
                                            } else if (typeDefinition.represents(double.class)) {
                                                frame[index] = Opcodes.DOUBLE;
                                            } else {
                                                frame[index] = typeDefinition.asErasure().getInternalName();
                                            }
                                        }
                                        super.visitFrame((readerFlags & ClassReader.EXPAND_FRAMES) == 0 ? Opcodes.F_FULL : Opcodes.F_NEW, frame.length, frame, EMPTY.length, EMPTY);
                                    }
                                    super.visitInsn(Opcodes.NOP);
                                }
                            } else {
                                mv = IGNORE_METHOD;
                                super.visitCode();
                            }
                        }
                        public void visitMaxs(int stackSize, int localVariableLength) {
                            super.visitMaxs(stackSize, Math.max(localVariableLength, resolution.getResolvedMethod().getStackSize()));
                        }
                    }
                    protected class AttributeObtainingMethodVisitor extends MethodVisitor {
                        private final MethodVisitor actualMethodVisitor;
                        private final MethodPool.Record record;
                        protected AttributeObtainingMethodVisitor(MethodVisitor actualMethodVisitor, MethodPool.Record record) {
                            super(OpenedClassReader.ASM_API, actualMethodVisitor);
                            this.actualMethodVisitor = actualMethodVisitor;
                            this.record = record;
                            record.applyHead(actualMethodVisitor);
                        }
                        public AnnotationVisitor visitAnnotationDefault() {
                            return IGNORE_ANNOTATION;
                        }
                        public AnnotationVisitor visitTypeAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
                            return annotationRetention.isEnabled() ? super.visitTypeAnnotation(typeReference, typePath, descriptor, visible) : IGNORE_ANNOTATION;
                        }
                        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
                            return annotationRetention.isEnabled() ? super.visitAnnotation(descriptor, visible) : IGNORE_ANNOTATION;
                        }
                        public void visitAnnotableParameterCount(int count, boolean visible) {
                            if (annotationRetention.isEnabled()) {
                                super.visitAnnotableParameterCount(count, visible);
                            }
                        }
                        public AnnotationVisitor visitParameterAnnotation(int index, String descriptor, boolean visible) {
                            return annotationRetention.isEnabled() ? super.visitParameterAnnotation(index, descriptor, visible) : IGNORE_ANNOTATION;
                        }
                        public void visitCode() {
                            mv = IGNORE_METHOD;
                        }
                        public void visitEnd() {
                            record.applyBody(actualMethodVisitor, implementationContext, annotationValueFilterFactory);
                            actualMethodVisitor.visitEnd();
                        }
                    }
                }
            }
            protected static class WithDecorationOnly<V> extends ForInlining<V> {
                protected WithDecorationOnly(TypeDescription instrumentedType, ClassFileVersion classFileVersion, List<? extends DynamicType> auxiliaryTypes, MethodList<?> methods, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, AsmClassReader.Factory classReaderFactory, AsmClassWriter.Factory classWriterFactory, TypePool typePool, ClassFileLocator classFileLocator) {
                    super(instrumentedType, classFileVersion, FieldPool.Disabled.INSTANCE, RecordComponentPool.Disabled.INSTANCE, auxiliaryTypes, new LazyFieldList(instrumentedType), methods, new MethodList.Empty<MethodDescription>(), new RecordComponentList.Empty<RecordComponentDescription.InDefinedShape>(), LoadedTypeInitializer.NoOp.INSTANCE, TypeInitializer.None.INSTANCE, typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classReaderFactory, classWriterFactory, typePool, instrumentedType, classFileLocator);
                }
                protected ClassVisitor writeTo(ClassVisitor classVisitor, TypeInitializer typeInitializer, ContextRegistry contextRegistry, int writerFlags, int readerFlags) {
                    if (typeInitializer.isDefined()) {
                        throw new UnsupportedOperationException("Cannot apply a type initializer for a decoration");
                    }
                    return new DecorationClassVisitor(classVisitor, contextRegistry, writerFlags, readerFlags);
                }
                protected static class LazyFieldList extends FieldList.AbstractBase<FieldDescription.InDefinedShape> {
                    private final TypeDescription instrumentedType;
                    protected LazyFieldList(TypeDescription instrumentedType) {
                        this.instrumentedType = instrumentedType;
                    }
                    public FieldDescription.InDefinedShape get(int index) {
                        return instrumentedType.getDeclaredFields().get(index);
                    }
                    public int size() {
                        return instrumentedType.getDeclaredFields().size();
                    }
                }
                protected class DecorationClassVisitor extends MetadataAwareClassVisitor implements TypeInitializer.Drain {
                    private final ContextRegistry contextRegistry;
                    private final int writerFlags;
                    private final int readerFlags;
                    private Implementation.Context.ExtractableView implementationContext;
                    protected DecorationClassVisitor(ClassVisitor classVisitor, ContextRegistry contextRegistry, int writerFlags, int readerFlags) {
                        super(OpenedClassReader.ASM_API, classVisitor);
                        this.contextRegistry = contextRegistry;
                        this.writerFlags = writerFlags;
                        this.readerFlags = readerFlags;
                    }
                    public void visit(int classFileVersionNumber, int modifiers, String internalName, String genericSignature, String superClassInternalName, String[] interfaceTypeInternalName) {
                        ClassFileVersion classFileVersion = ClassFileVersion.ofMinorMajor(classFileVersionNumber);
                        implementationContext = implementationContextFactory.make(instrumentedType, auxiliaryTypeNamingStrategy, typeInitializer, classFileVersion, WithDecorationOnly.this.classFileVersion, (writerFlags & ClassWriter.COMPUTE_FRAMES) == 0 && classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6) ? ((readerFlags & ClassReader.EXPAND_FRAMES) == 0 ? Implementation.Context.FrameGeneration.GENERATE : Implementation.Context.FrameGeneration.EXPAND) : Implementation.Context.FrameGeneration.DISABLED);
                        contextRegistry.setImplementationContext(implementationContext);
                        cv = asmVisitorWrapper.wrap(instrumentedType, cv, implementationContext, typePool, fields, methods, writerFlags, readerFlags);
                        cv.visit(classFileVersionNumber, modifiers, internalName, genericSignature, superClassInternalName, interfaceTypeInternalName);
                    }
                    protected AnnotationVisitor onVisitTypeAnnotation(int typeReference, TypePath typePath, String descriptor, boolean visible) {
                        return annotationRetention.isEnabled() ? cv.visitTypeAnnotation(typeReference, typePath, descriptor, visible) : IGNORE_ANNOTATION;
                    }
                    protected AnnotationVisitor onVisitAnnotation(String descriptor, boolean visible) {
                        return annotationRetention.isEnabled() ? cv.visitAnnotation(descriptor, visible) : IGNORE_ANNOTATION;
                    }
                    protected void onAfterAttributes() {
                        typeAttributeAppender.apply(cv, instrumentedType, annotationValueFilterFactory.on(instrumentedType));
                    }
                    protected void onVisitEnd() {
                        implementationContext.drain(this, cv, annotationValueFilterFactory);
                        cv.visitEnd();
                    }
                    public void apply(ClassVisitor classVisitor, TypeInitializer typeInitializer, Implementation.Context implementationContext) {
                    }
                }
            }
        }
        public static class ForCreation<U> extends Default<U> {
            private final MethodPool methodPool;
            protected ForCreation(TypeDescription instrumentedType, ClassFileVersion classFileVersion, FieldPool fieldPool, MethodPool methodPool, RecordComponentPool recordComponentPool, List<? extends DynamicType> auxiliaryTypes, FieldList<FieldDescription.InDefinedShape> fields, MethodList<?> methods, MethodList<?> instrumentedMethods, RecordComponentList<RecordComponentDescription.InDefinedShape> recordComponents, LoadedTypeInitializer loadedTypeInitializer, TypeInitializer typeInitializer, TypeAttributeAppender typeAttributeAppender, AsmVisitorWrapper asmVisitorWrapper, AnnotationValueFilter.Factory annotationValueFilterFactory, AnnotationRetention annotationRetention, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, Implementation.Context.Factory implementationContextFactory, TypeValidation typeValidation, AsmClassReader.Factory classReaderFactory, AsmClassWriter.Factory classWriterFactory, TypePool typePool) {
                super(instrumentedType, classFileVersion, fieldPool, recordComponentPool, auxiliaryTypes, fields, methods, instrumentedMethods, recordComponents, loadedTypeInitializer, typeInitializer, typeAttributeAppender, asmVisitorWrapper, annotationValueFilterFactory, annotationRetention, auxiliaryTypeNamingStrategy, implementationContextFactory, typeValidation, classReaderFactory, classWriterFactory, typePool);
                this.methodPool = methodPool;
            }
            public ContextClassVisitor wrap(ClassVisitor classVisitor, int writerFlags, int readerFlags) {
                Implementation.Context.ExtractableView implementationContext = implementationContextFactory.make(instrumentedType, auxiliaryTypeNamingStrategy, typeInitializer, classFileVersion, classFileVersion, (writerFlags & ClassWriter.COMPUTE_FRAMES) == 0 && classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6) ? ((readerFlags & ClassReader.EXPAND_FRAMES) == 0 ? Implementation.Context.FrameGeneration.GENERATE : Implementation.Context.FrameGeneration.EXPAND) : Implementation.Context.FrameGeneration.DISABLED);
                return new ImplementationContextClassVisitor(new CreationClassVisitor(asmVisitorWrapper.wrap(instrumentedType, ValidatingClassVisitor.of(classVisitor, typeValidation), implementationContext, typePool, fields, methods, asmVisitorWrapper.mergeWriter(writerFlags), asmVisitorWrapper.mergeReader(readerFlags)), implementationContext, instrumentedType.toModuleDescription()), implementationContext);
            }
            protected UnresolvedType create(TypeInitializer typeInitializer, ClassDumpAction.Dispatcher dispatcher) {
                int writerFlags = asmVisitorWrapper.mergeWriter(AsmVisitorWrapper.NO_FLAGS), readerFlags = asmVisitorWrapper.mergeReader(AsmVisitorWrapper.NO_FLAGS);
                AsmClassWriter classWriter = classWriterFactory.make(writerFlags, typePool);
                Implementation.Context.ExtractableView implementationContext = implementationContextFactory.make(instrumentedType, auxiliaryTypeNamingStrategy, typeInitializer, classFileVersion, classFileVersion, (writerFlags & ClassWriter.COMPUTE_FRAMES) == 0 && classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6) ? ((readerFlags & ClassReader.EXPAND_FRAMES) == 0 ? Implementation.Context.FrameGeneration.GENERATE : Implementation.Context.FrameGeneration.EXPAND) : Implementation.Context.FrameGeneration.DISABLED);
                ClassVisitor classVisitor = asmVisitorWrapper.wrap(instrumentedType, ValidatingClassVisitor.of(classWriter.getVisitor(), typeValidation), implementationContext, typePool, fields, methods, writerFlags, readerFlags);
                classVisitor.visit(classFileVersion.getMinorMajorVersion(), instrumentedType.getActualModifiers(!instrumentedType.isInterface()), instrumentedType.getInternalName(), instrumentedType.getGenericSignature(), instrumentedType.getName().equals(ModuleDescription.MODULE_CLASS_NAME) ? null : (instrumentedType.getSuperClass() == null ? TypeDescription.ForLoadedType.of(Object.class) : instrumentedType.getSuperClass().asErasure()).getInternalName(), instrumentedType.getInterfaces().asErasures().toInternalNames());
                ModuleDescription moduleDescription = instrumentedType.toModuleDescription();
                if (moduleDescription != null) {
                    moduleDescription.accept(classVisitor);
                }
                if (!instrumentedType.isNestHost()) {
                    classVisitor.visitNestHost(instrumentedType.getNestHost().getInternalName());
                }
                MethodDescription.InDefinedShape enclosingMethod = instrumentedType.getEnclosingMethod();
                if (enclosingMethod != null) {
                    classVisitor.visitOuterClass(enclosingMethod.getDeclaringType().getInternalName(), enclosingMethod.getInternalName(), enclosingMethod.getDescriptor());
                } else if (instrumentedType.isLocalType() || instrumentedType.isAnonymousType()) {
                    classVisitor.visitOuterClass(instrumentedType.getEnclosingType().getInternalName(), NO_REFERENCE, NO_REFERENCE);
                }
                typeAttributeAppender.apply(classVisitor, instrumentedType, annotationValueFilterFactory.on(instrumentedType));
                if (instrumentedType.isNestHost()) {
                    for (TypeDescription typeDescription : instrumentedType.getNestMembers().filter(not(is(instrumentedType)))) {
                        classVisitor.visitNestMember(typeDescription.getInternalName());
                    }
                }
                for (TypeDescription typeDescription : instrumentedType.getPermittedSubtypes()) {
                    classVisitor.visitPermittedSubclass(typeDescription.getInternalName());
                }
                TypeDescription declaringType = instrumentedType.getDeclaringType();
                if (declaringType != null) {
                    classVisitor.visitInnerClass(instrumentedType.getInternalName(), declaringType.getInternalName(), instrumentedType.getSimpleName(), instrumentedType.getModifiers());
                } else if (instrumentedType.isLocalType()) {
                    classVisitor.visitInnerClass(instrumentedType.getInternalName(), NO_REFERENCE, instrumentedType.getSimpleName(), instrumentedType.getModifiers());
                } else if (instrumentedType.isAnonymousType()) {
                    classVisitor.visitInnerClass(instrumentedType.getInternalName(), NO_REFERENCE, NO_REFERENCE, instrumentedType.getModifiers());
                }
                for (TypeDescription typeDescription : instrumentedType.getDeclaredTypes()) {
                    classVisitor.visitInnerClass(typeDescription.getInternalName(), typeDescription.isMemberType() ? instrumentedType.getInternalName() : NO_REFERENCE, typeDescription.isAnonymousType() ? NO_REFERENCE : typeDescription.getSimpleName(), typeDescription.getModifiers());
                }
                for (RecordComponentDescription recordComponentDescription : recordComponents) {
                    recordComponentPool.target(recordComponentDescription).apply(classVisitor, annotationValueFilterFactory);
                }
                for (FieldDescription fieldDescription : fields) {
                    fieldPool.target(fieldDescription).apply(classVisitor, annotationValueFilterFactory);
                }
                for (MethodDescription methodDescription : instrumentedMethods) {
                    methodPool.target(methodDescription).apply(classVisitor, implementationContext, annotationValueFilterFactory);
                }
                implementationContext.drain(new TypeInitializer.Drain.Default(instrumentedType, methodPool, annotationValueFilterFactory), classVisitor, annotationValueFilterFactory);
                classVisitor.visitEnd();
                return new UnresolvedType(classWriter.getBinaryRepresentation(), implementationContext.getAuxiliaryTypes());
            }
            protected class CreationClassVisitor extends MetadataAwareClassVisitor {
                private final Implementation.Context.ExtractableView implementationContext;
                private final ModuleDescription moduleDescription;
                private final Set<String> declaredTypes = new HashSet<String>();
                private final Set<SignatureKey> visitedFields = new HashSet<SignatureKey>();
                private final Set<SignatureKey> visitedMethods = new HashSet<SignatureKey>();
                protected CreationClassVisitor(ClassVisitor classVisitor, Implementation.Context.ExtractableView implementationContext, @MaybeNull ModuleDescription moduleDescription) {
                    super(OpenedClassReader.ASM_API, classVisitor);
                    this.implementationContext = implementationContext;
                    this.moduleDescription = moduleDescription;
                }
                protected void onModule() {
                    if (moduleDescription != null) {
                        moduleDescription.accept(cv);
                    }
                }
                protected ModuleVisitor onVisitModule(String name, int modifiers, @MaybeNull String version) {
                    return moduleDescription == null ? null : new PatchingModuleVisitor(cv.visitModule(moduleDescription.getActualName(), moduleDescription.getModifiers(), moduleDescription.getVersion()), moduleDescription);
                }
                protected void onAfterAttributes() {
                    typeAttributeAppender.apply(cv, instrumentedType, annotationValueFilterFactory.on(instrumentedType));
                }
                protected void onVisitInnerClass(String internalName, @MaybeNull String outerName, @MaybeNull String innerName, int modifiers) {
                    declaredTypes.add(internalName);
                    super.onVisitInnerClass(internalName, outerName, innerName, modifiers);
                }
                protected FieldVisitor onVisitField(int modifiers, String name, String descriptor, @MaybeNull String signature, @MaybeNull Object value) {
                    visitedFields.add(new SignatureKey(name, descriptor));
                    return super.onVisitField(modifiers, name, descriptor, signature, value);
                }
                protected MethodVisitor onVisitMethod(int modifiers, String internalName, String descriptor, @MaybeNull String signature, @MaybeNull String[] exception) {
                    visitedMethods.add(new SignatureKey(internalName, descriptor));
                    return super.onVisitMethod(modifiers, internalName, descriptor, signature, exception);
                }
                protected void onVisitEnd() {
                    for (TypeDescription typeDescription : instrumentedType.getDeclaredTypes()) {
                        if (!declaredTypes.contains(typeDescription.getInternalName())) {
                            cv.visitInnerClass(typeDescription.getInternalName(), typeDescription.isMemberType() ? instrumentedType.getInternalName() : NO_REFERENCE, typeDescription.isAnonymousType() ? NO_REFERENCE : typeDescription.getSimpleName(), typeDescription.getModifiers());
                        }
                    }
                    for (FieldDescription fieldDescription : fields) {
                        if (!visitedFields.contains(new SignatureKey(fieldDescription.getName(), fieldDescription.getDescriptor()))) {
                            fieldPool.target(fieldDescription).apply(cv, annotationValueFilterFactory);
                        }
                    }
                    for (MethodDescription methodDescription : instrumentedMethods) {
                        if (!visitedMethods.contains(new SignatureKey(methodDescription.getInternalName(), methodDescription.getDescriptor()))) {
                            methodPool.target(methodDescription).apply(cv, implementationContext, annotationValueFilterFactory);
                        }
                    }
                    implementationContext.drain(new TypeInitializer.Drain.Default(instrumentedType, methodPool, annotationValueFilterFactory), cv, annotationValueFilterFactory);
                    super.onVisitEnd();
                }
            }
            protected static class PatchingModuleVisitor extends ModuleVisitor {
                private String mainClass;
                private final Set<String> packages;
                private final Map<String, ModuleDescription.Requires> requires;
                private final Map<String, ModuleDescription.Exports> exports;
                private final Map<String, ModuleDescription.Opens> opens;
                private final Set<String> uses;
                private final Map<String, Set<String>> provides;
                protected PatchingModuleVisitor(ModuleVisitor moduleVisitor, ModuleDescription moduleDescription) {
                    super(OpenedClassReader.ASM_API, moduleVisitor);
                    mainClass = moduleDescription.getMainClass();
                    if (mainClass != null) {
                        mainClass = mainClass.replace('.', '/');
                    }
                    packages = new LinkedHashSet<String>();
                    for (String aPackage : moduleDescription.getPackages()) {
                        packages.add(aPackage.replace('.', '/'));
                    }
                    requires = new LinkedHashMap<String, ModuleDescription.Requires>(moduleDescription.getRequires());
                    exports = new LinkedHashMap<String, ModuleDescription.Exports>();
                    for (Map.Entry<String, ModuleDescription.Exports> entry : moduleDescription.getExports().entrySet()) {
                        exports.put(entry.getKey().replace('.', '/'), entry.getValue());
                    }
                    opens = new LinkedHashMap<String, ModuleDescription.Opens>();
                    for (Map.Entry<String, ModuleDescription.Opens> entry : moduleDescription.getOpens().entrySet()) {
                        opens.put(entry.getKey().replace('.', '/'), entry.getValue());
                    }
                    uses = new LinkedHashSet<String>();
                    for (String use : moduleDescription.getUses()) {
                        uses.add(use.replace('.', '/'));
                    }
                    provides = new LinkedHashMap<String, Set<String>>();
                    for (Map.Entry<String, ModuleDescription.Provides> entry : moduleDescription.getProvides().entrySet()) {
                        Set<String> providers = new LinkedHashSet<String>();
                        for (String provider : entry.getValue().getProviders()) {
                            providers.add(provider.replace('.', '/'));
                        }
                        provides.put(entry.getKey().replace('.', '/'), providers);
                    }
                }
                public void visitMainClass(String mainClass) {
                    if (this.mainClass != null) {
                        super.visitMainClass(this.mainClass);
                        this.mainClass = null;
                    }
                }
                public void visitPackage(String aPackage) {
                    super.visitPackage(aPackage);
                    packages.remove(aPackage);
                }
                public void visitRequire(String module, int modifiers, @MaybeNull String version) {
                    ModuleDescription.Requires requires = this.requires.remove(module);
                    if (requires != null) {
                        super.visitRequire(module, requires.getModifiers(), requires.getVersion());
                    } else {
                        super.visitRequire(module, modifiers, version);
                    }
                }
                public void visitExport(String aPackage, int modifiers, @MaybeNull String... module) {
                    ModuleDescription.Exports exports = this.exports.remove(aPackage);
                    if (exports != null) {
                        super.visitExport(aPackage, exports.getModifiers(), exports.getTargets().isEmpty() ? null : exports.getTargets().toArray(new String[0]));
                    } else {
                        super.visitExport(aPackage, modifiers, module);
                    }
                }
                public void visitOpen(String aPackage, int modifiers, @MaybeNull String... module) {
                    ModuleDescription.Opens opens = this.opens.remove(aPackage);
                    if (opens != null) {
                        super.visitOpen(aPackage, opens.getModifiers(), opens.getTargets().isEmpty() ? null : opens.getTargets().toArray(new String[0]));
                    } else {
                        super.visitOpen(aPackage, modifiers, module);
                    }
                }
                public void visitUse(String service) {
                    uses.remove(service);
                    super.visitUse(service);
                }
                public void visitProvide(String service, String... provider) {
                    Set<String> providers = this.provides.remove(service);
                    if (providers != null) {
                        super.visitProvide(service, providers.toArray(new String[0]));
                    } else {
                        super.visitProvide(service, provider);
                    }
                }
                public void visitEnd() {
                    if (mainClass != null) {
                        super.visitMainClass(mainClass);
                    }
                    for (String aPackage : packages) {
                        super.visitPackage(aPackage);
                    }
                    for (Map.Entry<String, ModuleDescription.Requires> entry : requires.entrySet()) {
                        super.visitRequire(entry.getKey(), entry.getValue().getModifiers(), entry.getValue().getVersion());
                    }
                    for (Map.Entry<String, ModuleDescription.Exports> entry : exports.entrySet()) {
                        super.visitExport(entry.getKey(), entry.getValue().getModifiers(), entry.getValue().getTargets().isEmpty() ? null : entry.getValue().getTargets().toArray(new String[0]));
                    }
                    for (Map.Entry<String, ModuleDescription.Opens> entry : opens.entrySet()) {
                        super.visitOpen(entry.getKey(), entry.getValue().getModifiers(), entry.getValue().getTargets().isEmpty() ? null : entry.getValue().getTargets().toArray(new String[0]));
                    }
                    for (String use : uses) {
                        super.visitUse(use);
                    }
                    for (Map.Entry<String, Set<String>> entry : provides.entrySet()) {
                        super.visitProvide(entry.getKey(), entry.getValue().isEmpty() ? null : entry.getValue().toArray(new String[0]));
                    }
                    super.visitEnd();
                }
            }
            protected class ImplementationContextClassVisitor extends ContextClassVisitor {
                private final Implementation.Context.ExtractableView implementationContext;
                protected ImplementationContextClassVisitor(ClassVisitor classVisitor, Implementation.Context.ExtractableView implementationContext) {
                    super(classVisitor);
                    this.implementationContext = implementationContext;
                }
                public List<DynamicType> getAuxiliaryTypes() {
                    return CompoundList.of(auxiliaryTypes, implementationContext.getAuxiliaryTypes());
                }
                public LoadedTypeInitializer getLoadedTypeInitializer() {
                    return loadedTypeInitializer;
                }
            }
        }
        protected static class ClassDumpAction implements PrivilegedExceptionAction<Void> {
            private static final Void NOTHING = null;
            private final String target;
            private final TypeDescription instrumentedType;
            private final boolean original;
            private final long suffix;
            private final byte[] binaryRepresentation;
            protected ClassDumpAction(String target, TypeDescription instrumentedType, boolean original, long suffix, byte[] binaryRepresentation) {
                this.target = target;
                this.instrumentedType = instrumentedType;
                this.original = original;
                this.suffix = suffix;
                this.binaryRepresentation = binaryRepresentation;
            }
            public Void run() throws Exception {
                OutputStream outputStream = new FileOutputStream(new File(target, instrumentedType.getName() + (original ? "-original." : ".") + suffix + ClassFileLocator.CLASS_FILE_EXTENSION));
                try {
                    outputStream.write(binaryRepresentation);
                    return NOTHING;
                } finally {
                    outputStream.close();
                }
            }
            protected interface Dispatcher {
                void dump(TypeDescription instrumentedType, boolean original, byte[] binaryRepresentation);
                enum Disabled implements Dispatcher {
                    INSTANCE;
                    public void dump(TypeDescription instrumentedType, boolean original, byte[] binaryRepresentation) {
                    }
                }
                class Enabled implements Dispatcher {
                    private final String folder;
                    private final long timestamp;
                    protected Enabled(String folder, long timestamp) {
                        this.folder = folder;
                        this.timestamp = timestamp;
                    }
                    public void dump(TypeDescription instrumentedType, boolean original, byte[] binaryRepresentation) {
                        try {
                            doPrivileged(new ClassDumpAction(folder, instrumentedType, original, timestamp, binaryRepresentation));
                        } catch (Exception exception) {
                            exception.printStackTrace();
                        }
                    }
                }
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```