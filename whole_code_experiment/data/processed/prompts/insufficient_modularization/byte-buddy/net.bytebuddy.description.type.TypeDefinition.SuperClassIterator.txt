##CONTEXT_SIZE=838
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.description.type;
public interface TypeDefinition extends NamedElement, ModifierReviewable.ForTypeDefinition, Iterable<TypeDefinition> {
    String RAW_TYPES_PROPERTY = "net.bytebuddy.raw";
    TypeDescription.Generic asGenericType();
    TypeDescription asErasure();
    TypeDescription.Generic getSuperClass();
    TypeList.Generic getInterfaces();
    FieldList<?> getDeclaredFields();
    MethodList<?> getDeclaredMethods();
    TypeDefinition getComponentType();
    RecordComponentList<?> getRecordComponents();
    Sort getSort();
    String getTypeName();
    StackSize getStackSize();
    boolean isArray();
    boolean isRecord();
    boolean isPrimitive();
    boolean represents(Type type);
    enum Sort {
        NON_GENERIC,
        GENERIC_ARRAY,
        PARAMETERIZED,
        WILDCARD,
        VARIABLE,
        VARIABLE_SYMBOLIC;
        private static final AnnotatedType ANNOTATED_TYPE = doPrivileged(JavaDispatcher.of(AnnotatedType.class));
        private static <T> T doPrivileged(PrivilegedAction<T> action) {
            return action.run();
        }
        public static TypeDescription.Generic describe(Type type) {
            return describe(type, TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE);
        }
        public static TypeDescription.Generic describeAnnotated(AnnotatedElement annotatedType) {
            if (!ANNOTATED_TYPE.isInstance(annotatedType)) {
                throw new IllegalArgumentException("Not an instance of AnnotatedType: " + annotatedType);
            }
            return describe(ANNOTATED_TYPE.getType(annotatedType), new TypeDescription.Generic.AnnotationReader.Delegator.Simple(annotatedType));
        }
        protected static TypeDescription.Generic describe(Type type, TypeDescription.Generic.AnnotationReader annotationReader) {
            if (type instanceof Class<?>) {
                return new TypeDescription.Generic.OfNonGenericType.ForLoadedType((Class<?>) type, annotationReader);
            } else if (type instanceof GenericArrayType) {
                return new TypeDescription.Generic.OfGenericArray.ForLoadedType((GenericArrayType) type, annotationReader);
            } else if (type instanceof ParameterizedType) {
                return new TypeDescription.Generic.OfParameterizedType.ForLoadedType((ParameterizedType) type, annotationReader);
            } else if (type instanceof TypeVariable) {
                return new TypeDescription.Generic.OfTypeVariable.ForLoadedType((TypeVariable<?>) type, annotationReader);
            } else if (type instanceof WildcardType) {
                return new TypeDescription.Generic.OfWildcardType.ForLoadedType((WildcardType) type, annotationReader);
            } else {
                throw new IllegalArgumentException("Unknown type: " + type);
            }
        }
        protected static TypeDescription.Generic describeOrNull(@MaybeNull Type type, TypeDescription.Generic.AnnotationReader annotationReader) {
            if (type == null) {
                throw new TypeNotPresentException("<unknown>", null);
            }
            return describe(type, annotationReader);
        }
        public boolean isNonGeneric() {
            return this == NON_GENERIC;
        }
        public boolean isParameterized() {
            return this == PARAMETERIZED;
        }
        public boolean isGenericArray() {
            return this == GENERIC_ARRAY;
        }
        public boolean isWildcard() {
            return this == WILDCARD;
        }
        public boolean isTypeVariable() {
            return this == VARIABLE || this == VARIABLE_SYMBOLIC;
        }
        protected interface AnnotatedType {
            boolean isInstance(AnnotatedElement value);
            Type getType(AnnotatedElement value);
        }
    }
    class SuperClassIterator implements Iterator<TypeDefinition> {
        private TypeDefinition nextClass;
        public SuperClassIterator(TypeDefinition initialType) {
            nextClass = initialType;
        }
        public boolean hasNext() {
            return nextClass != null;
        }
        public TypeDefinition next() {
            if (!hasNext()) {
                throw new NoSuchElementException("End of type hierarchy");
            }
            try {
                return nextClass;
            } finally {
                nextClass = nextClass.getSuperClass();
            }
        }
        public void remove() {
            throw new UnsupportedOperationException("remove");
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```