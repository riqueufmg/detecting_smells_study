##CONTEXT_SIZE=10573
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.utility;
public interface JavaConstant extends ConstantValue {
    Object toDescription();
    <T> T accept(Visitor<T> visitor);
    interface Visitor<T> {
        T onValue(Simple<?> constant);
        T onType(Simple<TypeDescription> constant);
        T onMethodType(MethodType constant);
        T onMethodHandle(MethodHandle constant);
        T onDynamic(Dynamic constant);
        enum NoOp implements Visitor<JavaConstant> {
            INSTANCE;
            public JavaConstant onValue(Simple<?> constant) {
                return constant;
            }
            public JavaConstant onType(Simple<TypeDescription> constant) {
                return constant;
            }
            public JavaConstant onMethodType(MethodType constant) {
                return constant;
            }
            public JavaConstant onMethodHandle(MethodHandle constant) {
                return constant;
            }
            public JavaConstant onDynamic(Dynamic constant) {
                return constant;
            }
        }
    }
    abstract class Simple<T> implements JavaConstant {
        protected static final Dispatcher CONSTANT_DESC = doPrivileged(JavaDispatcher.of(Dispatcher.class));
        protected static final Dispatcher.OfClassDesc CLASS_DESC = doPrivileged(JavaDispatcher.of(Dispatcher.OfClassDesc.class));
        protected static final Dispatcher.OfMethodTypeDesc METHOD_TYPE_DESC = doPrivileged(JavaDispatcher.of(Dispatcher.OfMethodTypeDesc.class));
        protected static final Dispatcher.OfMethodHandleDesc METHOD_HANDLE_DESC = doPrivileged(JavaDispatcher.of(Dispatcher.OfMethodHandleDesc.class));
        protected static final Dispatcher.OfDirectMethodHandleDesc DIRECT_METHOD_HANDLE_DESC = doPrivileged(JavaDispatcher.of(Dispatcher.OfDirectMethodHandleDesc.class));
        protected static final Dispatcher.OfDirectMethodHandleDesc.ForKind DIRECT_METHOD_HANDLE_DESC_KIND = doPrivileged(JavaDispatcher.of(Dispatcher.OfDirectMethodHandleDesc.ForKind.class));
        protected static final Dispatcher.OfDynamicConstantDesc DYNAMIC_CONSTANT_DESC = doPrivileged(JavaDispatcher.of(Dispatcher.OfDynamicConstantDesc.class));
        protected final T value;
        private final TypeDescription typeDescription;
        protected Simple(T value, TypeDescription typeDescription) {
            this.value = value;
            this.typeDescription = typeDescription;
        }
        private static <T> T doPrivileged(PrivilegedAction<T> action) {
            return action.run();
        }
        public static JavaConstant ofAsm(TypePool typePool, Object value) {
            if (value instanceof Integer) {
                return new OfTrivialValue.ForInteger((Integer) value);
            } else if (value instanceof Long) {
                return new OfTrivialValue.ForLong((Long) value);
            } else if (value instanceof Float) {
                return new OfTrivialValue.ForFloat((Float) value);
            } else if (value instanceof Double) {
                return new OfTrivialValue.ForDouble((Double) value);
            } else if (value instanceof String) {
                return new OfTrivialValue.ForString((String) value);
            } else if (value instanceof Type) {
                Type type = (Type) value;
                if (type.getSort() == Type.METHOD) {
                    return MethodType.ofAsm(typePool, type);
                } else if (type.getSort() == Type.ARRAY) {
                    StringBuilder stringBuilder = new StringBuilder();
                    for (int index = 0; index < type.getDimensions(); index++) {
                        stringBuilder.append(type.getDescriptor());
                    }
                    return of(typePool.describe(stringBuilder.toString()).resolve());
                } else {
                    return of(typePool.describe(type.getClassName()).resolve());
                }
            } else if (value instanceof Handle) {
                return MethodHandle.ofAsm(typePool, (Handle) value);
            } else if (value instanceof ConstantDynamic) {
                return Dynamic.ofAsm(typePool, (ConstantDynamic) value);
            } else {
                throw new IllegalArgumentException("Not an ASM constant: " + value);
            }
        }
        public static JavaConstant ofLoaded(Object value) {
            JavaConstant constant = ofLoadedOrNull(value);
            if (constant == null) {
                throw new IllegalArgumentException("Not a constant: " + value);
            } else {
                return constant;
            }
        }
        protected static JavaConstant ofLoadedOrNull(Object value) {
            if (value instanceof Integer) {
                return new OfTrivialValue.ForInteger((Integer) value);
            } else if (value instanceof Long) {
                return new OfTrivialValue.ForLong((Long) value);
            } else if (value instanceof Float) {
                return new OfTrivialValue.ForFloat((Float) value);
            } else if (value instanceof Double) {
                return new OfTrivialValue.ForDouble((Double) value);
            } else if (value instanceof String) {
                return new OfTrivialValue.ForString((String) value);
            } else if (value instanceof Class<?>) {
                return JavaConstant.Simple.of(TypeDescription.ForLoadedType.of((Class<?>) value));
            } else if (JavaType.METHOD_HANDLE.isInstance(value)) {
                return MethodHandle.ofLoaded(value);
            } else if (JavaType.METHOD_TYPE.isInstance(value)) {
                return MethodType.ofLoaded(value);
            } else {
                return null;
            }
        }
        public static JavaConstant ofDescription(Object value, @MaybeNull ClassLoader classLoader) {
            return ofDescription(value, ClassFileLocator.ForClassLoader.of(classLoader));
        }
        public static JavaConstant ofDescription(Object value, ClassFileLocator classFileLocator) {
            return ofDescription(value, TypePool.Default.WithLazyResolution.of(classFileLocator));
        }
        public static JavaConstant ofDescription(Object value, TypePool typePool) {
            if (value instanceof Integer) {
                return new JavaConstant.Simple.OfTrivialValue.ForInteger((Integer) value);
            } else if (value instanceof Long) {
                return new JavaConstant.Simple.OfTrivialValue.ForLong((Long) value);
            } else if (value instanceof Float) {
                return new JavaConstant.Simple.OfTrivialValue.ForFloat((Float) value);
            } else if (value instanceof Double) {
                return new JavaConstant.Simple.OfTrivialValue.ForDouble((Double) value);
            } else if (value instanceof String) {
                return new JavaConstant.Simple.OfTrivialValue.ForString((String) value);
            } else if (CLASS_DESC.isInstance(value)) {
                Type type = Type.getType(CLASS_DESC.descriptorString(value));
                return JavaConstant.Simple.OfTypeDescription.of(typePool.describe(type.getSort() == Type.ARRAY ? type.getInternalName().replace('/', '.') : type.getClassName()).resolve());
            } else if (METHOD_TYPE_DESC.isInstance(value)) {
                Object[] parameterTypes = METHOD_TYPE_DESC.parameterArray(value);
                List<TypeDescription> typeDescriptions = new ArrayList<TypeDescription>(parameterTypes.length);
                for (Object parameterType : parameterTypes) {
                    Type type = Type.getType(CLASS_DESC.descriptorString(parameterType));
                    typeDescriptions.add(typePool.describe(type.getSort() == Type.ARRAY ? type.getInternalName().replace('/', '.') : type.getClassName()).resolve());
                }
                Type type = Type.getType(CLASS_DESC.descriptorString(METHOD_TYPE_DESC.returnType(value)));
                return MethodType.of(typePool.describe(type.getSort() == Type.ARRAY ? type.getInternalName().replace('/', '.') : type.getClassName()).resolve(), typeDescriptions);
            } else if (DIRECT_METHOD_HANDLE_DESC.isInstance(value)) {
                Object[] parameterTypes = METHOD_TYPE_DESC.parameterArray(METHOD_HANDLE_DESC.invocationType(value));
                List<TypeDescription> typeDescriptions = new ArrayList<TypeDescription>(parameterTypes.length);
                for (Object parameterType : parameterTypes) {
                    Type type = Type.getType(CLASS_DESC.descriptorString(parameterType));
                    typeDescriptions.add(typePool.describe(type.getSort() == Type.ARRAY ? type.getInternalName().replace('/', '.') : type.getClassName()).resolve());
                }
                Type type = Type.getType(CLASS_DESC.descriptorString(METHOD_TYPE_DESC.returnType(METHOD_HANDLE_DESC.invocationType(value))));
                return new MethodHandle(MethodHandle.HandleType.of(DIRECT_METHOD_HANDLE_DESC.refKind(value)), typePool.describe(Type.getType(CLASS_DESC.descriptorString(DIRECT_METHOD_HANDLE_DESC.owner(value))).getClassName()).resolve(), DIRECT_METHOD_HANDLE_DESC.methodName(value), DIRECT_METHOD_HANDLE_DESC.refKind(value) == Opcodes.H_NEWINVOKESPECIAL ? TypeDescription.ForLoadedType.of(void.class) : typePool.describe(type.getSort() == Type.ARRAY ? type.getInternalName().replace('/', '.') : type.getClassName()).resolve(), typeDescriptions);
            } else if (DYNAMIC_CONSTANT_DESC.isInstance(value)) {
                Type methodType = Type.getMethodType(DIRECT_METHOD_HANDLE_DESC.lookupDescriptor(DYNAMIC_CONSTANT_DESC.bootstrapMethod(value)));
                List<TypeDescription> parameterTypes = new ArrayList<TypeDescription>(methodType.getArgumentTypes().length);
                for (Type type : methodType.getArgumentTypes()) {
                    parameterTypes.add(typePool.describe(type.getSort() == Type.ARRAY ? type.getInternalName().replace('/', '.') : type.getClassName()).resolve());
                }
                Object[] constant = DYNAMIC_CONSTANT_DESC.bootstrapArgs(value);
                List<JavaConstant> arguments = new ArrayList<JavaConstant>(constant.length);
                for (Object aConstant : constant) {
                    arguments.add(ofDescription(aConstant, typePool));
                }
                Type type = Type.getType(CLASS_DESC.descriptorString(DYNAMIC_CONSTANT_DESC.constantType(value)));
                return new Dynamic(DYNAMIC_CONSTANT_DESC.constantName(value), typePool.describe(type.getSort() == Type.ARRAY ? type.getInternalName().replace('/', '.') : type.getClassName()).resolve(), new MethodHandle(MethodHandle.HandleType.of(DIRECT_METHOD_HANDLE_DESC.refKind(DYNAMIC_CONSTANT_DESC.bootstrapMethod(value))), typePool.describe(Type.getType(CLASS_DESC.descriptorString(DIRECT_METHOD_HANDLE_DESC.owner(DYNAMIC_CONSTANT_DESC.bootstrapMethod(value)))).getClassName()).resolve(), DIRECT_METHOD_HANDLE_DESC.methodName(DYNAMIC_CONSTANT_DESC.bootstrapMethod(value)), typePool.describe(methodType.getReturnType().getSort() == Type.ARRAY ? methodType.getReturnType().getInternalName().replace('/', '.') : methodType.getReturnType().getClassName()).resolve(), parameterTypes), arguments);
            } else {
                throw new IllegalArgumentException("Not a resolvable constant description or not expressible as a constant pool value: " + value);
            }
        }
        public static JavaConstant of(TypeDescription typeDescription) {
            if (typeDescription.isPrimitive()) {
                throw new IllegalArgumentException("A primitive type cannot be represented as a type constant: " + typeDescription);
            }
            return new JavaConstant.Simple.OfTypeDescription(typeDescription);
        }
        public static JavaConstant wrap(Object value) {
            if (value instanceof JavaConstant) {
                return (JavaConstant) value;
            } else if (value instanceof TypeDescription) {
                return of((TypeDescription) value);
            } else {
                return ofLoaded(value);
            }
        }
        public static List<JavaConstant> wrap(List<?> values) {
            List<JavaConstant> constants = new ArrayList<JavaConstant>(values.size());
            for (Object value : values) {
                constants.add(wrap(value));
            }
            return constants;
        }
        public T getValue() {
            return value;
        }
        public TypeDescription getTypeDescription() {
            return typeDescription;
        }
        public int hashCode() {
            return value.hashCode();
        }
        public boolean equals(@MaybeNull Object object) {
            if (this == object)
                return true;
            if (object == null || getClass() != object.getClass())
                return false;
            return value.equals(((JavaConstant.Simple<?>) object).value);
        }
        public String toString() {
            return value.toString();
        }
        protected abstract static class OfTrivialValue<S> extends JavaConstant.Simple<S> {
            protected OfTrivialValue(S value, TypeDescription typeDescription) {
                super(value, typeDescription);
            }
            public Object toDescription() {
                return value;
            }
            public <T> T accept(Visitor<T> visitor) {
                return visitor.onValue(this);
            }
            protected static class ForInteger extends OfTrivialValue<Integer> {
                public ForInteger(Integer value) {
                    super(value, TypeDescription.ForLoadedType.of(int.class));
                }
                public StackManipulation toStackManipulation() {
                    return IntegerConstant.forValue(value);
                }
            }
            protected static class ForLong extends OfTrivialValue<Long> {
                public ForLong(Long value) {
                    super(value, TypeDescription.ForLoadedType.of(long.class));
                }
                public StackManipulation toStackManipulation() {
                    return LongConstant.forValue(value);
                }
            }
            protected static class ForFloat extends OfTrivialValue<Float> {
                public ForFloat(Float value) {
                    super(value, TypeDescription.ForLoadedType.of(float.class));
                }
                public StackManipulation toStackManipulation() {
                    return FloatConstant.forValue(value);
                }
            }
            protected static class ForDouble extends OfTrivialValue<Double> {
                public ForDouble(Double value) {
                    super(value, TypeDescription.ForLoadedType.of(double.class));
                }
                public StackManipulation toStackManipulation() {
                    return DoubleConstant.forValue(value);
                }
            }
            protected static class ForString extends OfTrivialValue<String> {
                public ForString(String value) {
                    super(value, TypeDescription.ForLoadedType.of(String.class));
                }
                public StackManipulation toStackManipulation() {
                    return new TextConstant(value);
                }
            }
        }
        protected static class OfTypeDescription extends JavaConstant.Simple<TypeDescription> {
            protected OfTypeDescription(TypeDescription value) {
                super(value, TypeDescription.ForLoadedType.of(Class.class));
            }
            public Object toDescription() {
                return CLASS_DESC.ofDescriptor(value.getDescriptor());
            }
            public StackManipulation toStackManipulation() {
                return ClassConstant.of(value);
            }
            public <T> T accept(Visitor<T> visitor) {
                return visitor.onType(this);
            }
        }
        protected interface Dispatcher {
            boolean isInstance(Object instance);
            Object[] toArray(int length);
            interface OfClassDesc extends Dispatcher {
                Object ofDescriptor(String descriptor);
                String descriptorString(Object value);
            }
            interface OfMethodTypeDesc extends Dispatcher {
                Object of(@JavaDispatcher.Proxied("java.lang.constant.ClassDesc") Object returnType, @JavaDispatcher.Proxied("java.lang.constant.ClassDesc") Object[] parameterType);
                Object ofDescriptor(String descriptor);
                Object returnType(Object value);
                Object[] parameterArray(Object value);
            }
            interface OfMethodHandleDesc extends Dispatcher {
                Object of(@JavaDispatcher.Proxied("java.lang.constant.DirectMethodHandleDesc$Kind") Object kind, @JavaDispatcher.Proxied("java.lang.constant.ClassDesc") Object owner, String name, String descriptor);
                Object invocationType(Object value);
            }
            interface OfDirectMethodHandleDesc extends Dispatcher {
                int refKind(Object value);
                String methodName(Object value);
                Object owner(Object value);
                String lookupDescriptor(Object value);
                interface ForKind {
                    Object valueOf(int identifier, boolean isInterface);
                }
            }
            interface OfDynamicConstantDesc extends Dispatcher {
                Object ofCanonical(@JavaDispatcher.Proxied("java.lang.constant.DirectMethodHandleDesc") Object bootstrap, String constantName, @JavaDispatcher.Proxied("java.lang.constant.ClassDesc") Object type, @JavaDispatcher.Proxied("java.lang.constant.ConstantDesc") Object[] argument);
                Object[] bootstrapArgs(Object value);
                String constantName(Object value);
                Object constantType(Object value);
                Object bootstrapMethod(Object value);
            }
        }
    }
    class MethodType implements JavaConstant {
        private static final Dispatcher DISPATCHER = doPrivileged(JavaDispatcher.of(Dispatcher.class));
        private final TypeDescription returnType;
        private final List<? extends TypeDescription> parameterTypes;
        protected MethodType(TypeDescription returnType, List<? extends TypeDescription> parameterTypes) {
            this.returnType = returnType;
            this.parameterTypes = parameterTypes;
        }
        private static <T> T doPrivileged(PrivilegedAction<T> action) {
            return action.run();
        }
        public static MethodType ofAsm(TypePool typePool, Type methodType) {
            if (methodType.getSort() != Type.METHOD) {
                throw new IllegalArgumentException("Not a method type description: " + methodType);
            }
            List<TypeDescription> parameterTypes = new ArrayList<TypeDescription>(methodType.getArgumentCount());
            for (Type type : methodType.getArgumentTypes()) {
                if (type.getSort() == Type.ARRAY) {
                    StringBuilder stringBuilder = new StringBuilder();
                    for (int index = 0; index < type.getDimensions(); index++) {
                        stringBuilder.append('[');
                    }
                    parameterTypes.add(typePool.describe(stringBuilder.append(type.getDescriptor().replace('/', '.')).toString()).resolve());
                } else {
                    parameterTypes.add(typePool.describe(type.getClassName()).resolve());
                }
            }
            TypeDescription returnType;
            if (methodType.getReturnType().getSort() == Type.ARRAY) {
                StringBuilder stringBuilder = new StringBuilder();
                for (int index = 0; index < methodType.getReturnType().getDimensions(); index++) {
                    stringBuilder.append('[');
                }
                returnType = typePool.describe(stringBuilder.append(methodType.getReturnType().getDescriptor().replace('/', '.')).toString()).resolve();
            } else {
                returnType = typePool.describe(methodType.getReturnType().getClassName()).resolve();
            }
            return new MethodType(returnType, parameterTypes);
        }
        public static MethodType ofLoaded(Object methodType) {
            if (!JavaType.METHOD_TYPE.isInstance(methodType)) {
                throw new IllegalArgumentException("Expected method type object: " + methodType);
            }
            return of(DISPATCHER.returnType(methodType), DISPATCHER.parameterArray(methodType));
        }
        public static MethodType of(Class<?> returnType, Class<?>... parameterType) {
            return of(TypeDescription.ForLoadedType.of(returnType), new TypeList.ForLoadedTypes(parameterType));
        }
        public static MethodType of(TypeDescription returnType, TypeDescription... parameterType) {
            return new MethodType(returnType, Arrays.asList(parameterType));
        }
        public static MethodType of(TypeDescription returnType, List<? extends TypeDescription> parameterTypes) {
            return new MethodType(returnType, parameterTypes);
        }
        public static MethodType of(Method method) {
            return of(new MethodDescription.ForLoadedMethod(method));
        }
        public static MethodType of(Constructor<?> constructor) {
            return of(new MethodDescription.ForLoadedConstructor(constructor));
        }
        public static MethodType of(MethodDescription methodDescription) {
            return new MethodType((methodDescription.isConstructor() ? methodDescription.getDeclaringType() : methodDescription.getReturnType()).asErasure(), methodDescription.isStatic() || methodDescription.isConstructor() ? methodDescription.getParameters().asTypeList().asErasures() : CompoundList.of(methodDescription.getDeclaringType().asErasure(), methodDescription.getParameters().asTypeList().asErasures()));
        }
        public static MethodType ofSignature(Method method) {
            return ofSignature(new MethodDescription.ForLoadedMethod(method));
        }
        public static MethodType ofSignature(Constructor<?> constructor) {
            return ofSignature(new MethodDescription.ForLoadedConstructor(constructor));
        }
        public static MethodType ofSignature(MethodDescription methodDescription) {
            return new MethodType(methodDescription.getReturnType().asErasure(), methodDescription.getParameters().asTypeList().asErasures());
        }
        public static MethodType ofSetter(Field field) {
            return ofSetter(new FieldDescription.ForLoadedField(field));
        }
        public static MethodType ofSetter(FieldDescription fieldDescription) {
            return new MethodType(TypeDescription.ForLoadedType.of(void.class), fieldDescription.isStatic() ? Collections.singletonList(fieldDescription.getType().asErasure()) : Arrays.asList(fieldDescription.getDeclaringType().asErasure(), fieldDescription.getType().asErasure()));
        }
        public static MethodType ofGetter(Field field) {
            return ofGetter(new FieldDescription.ForLoadedField(field));
        }
        public static MethodType ofGetter(FieldDescription fieldDescription) {
            return new MethodType(fieldDescription.getType().asErasure(), fieldDescription.isStatic() ? Collections.<TypeDescription>emptyList() : Collections.singletonList(fieldDescription.getDeclaringType().asErasure()));
        }
        public static MethodType ofConstant(Object instance) {
            return ofConstant(instance.getClass());
        }
        public static MethodType ofConstant(Class<?> type) {
            return ofConstant(TypeDescription.ForLoadedType.of(type));
        }
        public static MethodType ofConstant(TypeDescription typeDescription) {
            return new MethodType(typeDescription, Collections.<TypeDescription>emptyList());
        }
        public TypeDescription getReturnType() {
            return returnType;
        }
        public TypeList getParameterTypes() {
            return new TypeList.Explicit(parameterTypes);
        }
        public String getDescriptor() {
            StringBuilder stringBuilder = new StringBuilder("(");
            for (TypeDescription parameterType : parameterTypes) {
                stringBuilder.append(parameterType.getDescriptor());
            }
            return stringBuilder.append(')').append(returnType.getDescriptor()).toString();
        }
        public Object toDescription() {
            Object[] parameterType = JavaConstant.Simple.CLASS_DESC.toArray(parameterTypes.size());
            for (int index = 0; index < parameterTypes.size(); index++) {
                parameterType[index] = JavaConstant.Simple.CLASS_DESC.ofDescriptor(parameterTypes.get(index).getDescriptor());
            }
            return JavaConstant.Simple.METHOD_TYPE_DESC.of(JavaConstant.Simple.CLASS_DESC.ofDescriptor(returnType.getDescriptor()), parameterType);
        }
        public <T> T accept(Visitor<T> visitor) {
            return visitor.onMethodType(this);
        }
        public TypeDescription getTypeDescription() {
            return JavaType.METHOD_TYPE.getTypeStub();
        }
        public StackManipulation toStackManipulation() {
            return new JavaConstantValue(this);
        }
        public int hashCode() {
            int result = returnType.hashCode();
            result = 31 * result + parameterTypes.hashCode();
            return result;
        }
        public boolean equals(@MaybeNull Object other) {
            if (this == other) {
                return true;
            }
            if (!(other instanceof MethodType)) {
                return false;
            }
            MethodType methodType = (MethodType) other;
            return parameterTypes.equals(methodType.parameterTypes) && returnType.equals(methodType.returnType);
        }
        public String toString() {
            StringBuilder stringBuilder = new StringBuilder().append('(');
            boolean first = true;
            for (TypeDescription typeDescription : parameterTypes) {
                if (first) {
                    first = false;
                } else {
                    stringBuilder.append(',');
                }
                stringBuilder.append(typeDescription.getSimpleName());
            }
            return stringBuilder.append(')').append(returnType.getSimpleName()).toString();
        }
        protected interface Dispatcher {
            Class<?> returnType(Object methodType);
            Class<?>[] parameterArray(Object methodType);
        }
    }
    class MethodHandle implements JavaConstant {
        protected static final MethodHandleInfo METHOD_HANDLE_INFO = doPrivileged(JavaDispatcher.of(MethodHandleInfo.class));
        protected static final MethodType METHOD_TYPE = doPrivileged(JavaDispatcher.of(MethodType.class));
        protected static final MethodHandles METHOD_HANDLES = doPrivileged(JavaDispatcher.of(MethodHandles.class));
        protected static final MethodHandles.Lookup METHOD_HANDLES_LOOKUP = doPrivileged(JavaDispatcher.of(MethodHandles.Lookup.class));
        private final HandleType handleType;
        private final TypeDescription ownerType;
        private final String name;
        private final TypeDescription returnType;
        private final List<? extends TypeDescription> parameterTypes;
        public MethodHandle(HandleType handleType, TypeDescription ownerType, String name, TypeDescription returnType, List<? extends TypeDescription> parameterTypes) {
            this.handleType = handleType;
            this.ownerType = ownerType;
            this.name = name;
            this.returnType = returnType;
            this.parameterTypes = parameterTypes;
        }
        private static <T> T doPrivileged(PrivilegedAction<T> action) {
            return action.run();
        }
        public static MethodHandle ofAsm(TypePool typePool, Handle handle) {
            Type methodType = Type.getMethodType(handle.getDesc());
            List<TypeDescription> parameterTypes = new ArrayList<TypeDescription>(methodType.getArgumentCount());
            for (Type type : methodType.getArgumentTypes()) {
                if (type.getSort() == Type.ARRAY) {
                    StringBuilder stringBuilder = new StringBuilder();
                    for (int index = 0; index < type.getDimensions(); index++) {
                        stringBuilder.append('[');
                    }
                    parameterTypes.add(typePool.describe(stringBuilder.append(type.getDescriptor().replace('/', '.')).toString()).resolve());
                } else {
                    parameterTypes.add(typePool.describe(type.getClassName()).resolve());
                }
            }
            TypeDescription returnType;
            if (methodType.getReturnType().getSort() == Type.ARRAY) {
                StringBuilder stringBuilder = new StringBuilder();
                for (int index = 0; index < methodType.getReturnType().getDimensions(); index++) {
                    stringBuilder.append('[');
                }
                returnType = typePool.describe(stringBuilder.append(methodType.getReturnType().getDescriptor().replace('/', '.')).toString()).resolve();
            } else {
                returnType = typePool.describe(methodType.getReturnType().getClassName()).resolve();
            }
            return new MethodHandle(HandleType.of(handle.getTag()), typePool.describe(handle.getOwner().replace('/', '.')).resolve(), handle.getName(), returnType, parameterTypes);
        }
        public static MethodHandle ofLoaded(Object methodHandle) {
            return ofLoaded(methodHandle, METHOD_HANDLES.publicLookup());
        }
        public static MethodHandle ofLoaded(Object methodHandle, Object lookup) {
            if (!JavaType.METHOD_HANDLE.isInstance(methodHandle)) {
                throw new IllegalArgumentException("Expected method handle object: " + methodHandle);
            } else if (!JavaType.METHOD_HANDLES_LOOKUP.isInstance(lookup)) {
                throw new IllegalArgumentException("Expected method handle lookup object: " + lookup);
            }
            Object methodHandleInfo = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V8).isAtMost(ClassFileVersion.JAVA_V7) ? METHOD_HANDLE_INFO.revealDirect(methodHandle) : METHOD_HANDLES_LOOKUP.revealDirect(lookup, methodHandle);
            Object methodType = METHOD_HANDLE_INFO.getMethodType(methodHandleInfo);
            return new MethodHandle(HandleType.of(METHOD_HANDLE_INFO.getReferenceKind(methodHandleInfo)), TypeDescription.ForLoadedType.of(METHOD_HANDLE_INFO.getDeclaringClass(methodHandleInfo)), METHOD_HANDLE_INFO.getName(methodHandleInfo), TypeDescription.ForLoadedType.of(METHOD_TYPE.returnType(methodType)), new TypeList.ForLoadedTypes(METHOD_TYPE.parameterArray(methodType)));
        }
        public static MethodHandle of(Method method) {
            return of(new MethodDescription.ForLoadedMethod(method));
        }
        public static MethodHandle of(Constructor<?> constructor) {
            return of(new MethodDescription.ForLoadedConstructor(constructor));
        }
        public static MethodHandle of(MethodDescription.InDefinedShape methodDescription) {
            return new MethodHandle(HandleType.of(methodDescription), methodDescription.getDeclaringType(), methodDescription.getInternalName(), methodDescription.getReturnType().asErasure(), methodDescription.getParameters().asTypeList().asErasures());
        }
        public static MethodHandle ofSpecial(Method method, Class<?> type) {
            return ofSpecial(new MethodDescription.ForLoadedMethod(method), TypeDescription.ForLoadedType.of(type));
        }
        public static MethodHandle ofSpecial(MethodDescription.InDefinedShape methodDescription, TypeDescription typeDescription) {
            if (!methodDescription.isSpecializableFor(typeDescription)) {
                throw new IllegalArgumentException("Cannot specialize " + methodDescription + " for " + typeDescription);
            }
            return new MethodHandle(HandleType.ofSpecial(methodDescription), typeDescription, methodDescription.getInternalName(), methodDescription.getReturnType().asErasure(), methodDescription.getParameters().asTypeList().asErasures());
        }
        public static MethodHandle ofGetter(Field field) {
            return ofGetter(new FieldDescription.ForLoadedField(field));
        }
        public static MethodHandle ofGetter(FieldDescription.InDefinedShape fieldDescription) {
            return new MethodHandle(HandleType.ofGetter(fieldDescription), fieldDescription.getDeclaringType().asErasure(), fieldDescription.getInternalName(), fieldDescription.getType().asErasure(), Collections.<TypeDescription>emptyList());
        }
        public static MethodHandle ofSetter(Field field) {
            return ofSetter(new FieldDescription.ForLoadedField(field));
        }
        public static MethodHandle ofSetter(FieldDescription.InDefinedShape fieldDescription) {
            return new MethodHandle(HandleType.ofSetter(fieldDescription), fieldDescription.getDeclaringType().asErasure(), fieldDescription.getInternalName(), TypeDescription.ForLoadedType.of(void.class), Collections.singletonList(fieldDescription.getType().asErasure()));
        }
        public static Class<?> lookupType(Object callerClassLookup) {
            return METHOD_HANDLES_LOOKUP.lookupClass(callerClassLookup);
        }
        public Object toDescription() {
            return JavaConstant.Simple.METHOD_HANDLE_DESC.of(JavaConstant.Simple.DIRECT_METHOD_HANDLE_DESC_KIND.valueOf(handleType.getIdentifier(), ownerType.isInterface()), JavaConstant.Simple.CLASS_DESC.ofDescriptor(ownerType.getDescriptor()), name, getDescriptor());
        }
        public <T> T accept(Visitor<T> visitor) {
            return visitor.onMethodHandle(this);
        }
        public TypeDescription getTypeDescription() {
            return JavaType.METHOD_HANDLE.getTypeStub();
        }
        public StackManipulation toStackManipulation() {
            return new JavaConstantValue(this);
        }
        public HandleType getHandleType() {
            return handleType;
        }
        public TypeDescription getOwnerType() {
            return ownerType;
        }
        public String getName() {
            return name;
        }
        public TypeDescription getReturnType() {
            return returnType;
        }
        public TypeList getParameterTypes() {
            return new TypeList.Explicit(parameterTypes);
        }
        public String getDescriptor() {
            switch(handleType) {
                case GET_FIELD:
                case GET_STATIC_FIELD:
                    return returnType.getDescriptor();
                case PUT_FIELD:
                case PUT_STATIC_FIELD:
                    return parameterTypes.get(0).getDescriptor();
                default:
                    StringBuilder stringBuilder = new StringBuilder().append('(');
                    for (TypeDescription parameterType : parameterTypes) {
                        stringBuilder.append(parameterType.getDescriptor());
                    }
                    return stringBuilder.append(')').append(returnType.getDescriptor()).toString();
            }
        }
        public int hashCode() {
            int result = handleType.hashCode();
            result = 31 * result + ownerType.hashCode();
            result = 31 * result + name.hashCode();
            result = 31 * result + returnType.hashCode();
            result = 31 * result + parameterTypes.hashCode();
            return result;
        }
        public boolean equals(@MaybeNull Object other) {
            if (this == other) {
                return true;
            } else if (!(other instanceof MethodHandle)) {
                return false;
            }
            MethodHandle methodHandle = (MethodHandle) other;
            return handleType == methodHandle.handleType && name.equals(methodHandle.name) && ownerType.equals(methodHandle.ownerType) && parameterTypes.equals(methodHandle.parameterTypes) && returnType.equals(methodHandle.returnType);
        }
        public String toString() {
            StringBuilder stringBuilder = new StringBuilder().append(handleType.name()).append(ownerType.isInterface() && !handleType.isField() && handleType != HandleType.INVOKE_INTERFACE ? "@interface" : "").append('/').append(ownerType.getSimpleName()).append("::").append(name).append('(');
            boolean first = true;
            for (TypeDescription typeDescription : parameterTypes) {
                if (first) {
                    first = false;
                } else {
                    stringBuilder.append(',');
                }
                stringBuilder.append(typeDescription.getSimpleName());
            }
            return stringBuilder.append(')').append(returnType.getSimpleName()).toString();
        }
        public enum HandleType {
            INVOKE_VIRTUAL(Opcodes.H_INVOKEVIRTUAL, false),
            INVOKE_STATIC(Opcodes.H_INVOKESTATIC, false),
            INVOKE_SPECIAL(Opcodes.H_INVOKESPECIAL, false),
            INVOKE_INTERFACE(Opcodes.H_INVOKEINTERFACE, false),
            INVOKE_SPECIAL_CONSTRUCTOR(Opcodes.H_NEWINVOKESPECIAL, false),
            PUT_FIELD(Opcodes.H_PUTFIELD, true),
            GET_FIELD(Opcodes.H_GETFIELD, true),
            PUT_STATIC_FIELD(Opcodes.H_PUTSTATIC, true),
            GET_STATIC_FIELD(Opcodes.H_GETSTATIC, true);
            private final int identifier;
            private final boolean field;
            HandleType(int identifier, boolean field) {
                this.identifier = identifier;
                this.field = field;
            }
            protected static HandleType of(MethodDescription.InDefinedShape methodDescription) {
                if (methodDescription.isTypeInitializer()) {
                    throw new IllegalArgumentException("Cannot create handle of type initializer " + methodDescription);
                } else if (methodDescription.isStatic()) {
                    return INVOKE_STATIC;
                } else if (methodDescription.isConstructor()) {
                    return INVOKE_SPECIAL_CONSTRUCTOR;
                } else if (methodDescription.isPrivate()) {
                    return INVOKE_SPECIAL;
                } else if (methodDescription.getDeclaringType().isInterface()) {
                    return INVOKE_INTERFACE;
                } else {
                    return INVOKE_VIRTUAL;
                }
            }
            protected static HandleType of(int identifier) {
                for (HandleType handleType : HandleType.values()) {
                    if (handleType.getIdentifier() == identifier) {
                        return handleType;
                    }
                }
                throw new IllegalArgumentException("Unknown handle type: " + identifier);
            }
            protected static HandleType ofSpecial(MethodDescription.InDefinedShape methodDescription) {
                if (methodDescription.isStatic() || methodDescription.isAbstract()) {
                    throw new IllegalArgumentException("Cannot invoke " + methodDescription + " via invokespecial");
                }
                return methodDescription.isConstructor() ? INVOKE_SPECIAL_CONSTRUCTOR : INVOKE_SPECIAL;
            }
            protected static HandleType ofGetter(FieldDescription.InDefinedShape fieldDescription) {
                return fieldDescription.isStatic() ? GET_STATIC_FIELD : GET_FIELD;
            }
            protected static HandleType ofSetter(FieldDescription.InDefinedShape fieldDescription) {
                return fieldDescription.isStatic() ? PUT_STATIC_FIELD : PUT_FIELD;
            }
            public int getIdentifier() {
                return identifier;
            }
            public boolean isField() {
                return field;
            }
        }
        protected interface MethodHandleInfo {
            String getName(Object value);
            Class<?> getDeclaringClass(Object value);
            int getReferenceKind(Object value);
            Object getMethodType(Object value);
            Object revealDirect(@JavaDispatcher.Proxied("java.lang.invoke.MethodHandle") Object handle);
        }
        protected interface MethodType {
            Class<?> returnType(Object value);
            Class<?>[] parameterArray(Object value);
        }
        protected interface MethodHandles {
            Object publicLookup();
            interface Lookup {
                Class<?> lookupClass(Object value);
                Object revealDirect(Object value, @JavaDispatcher.Proxied("java.lang.invoke.MethodHandle") Object handle);
            }
        }
    }
    class Dynamic implements JavaConstant {
        public static final String DEFAULT_NAME = "_";
        private final String name;
        private final TypeDescription typeDescription;
        private final MethodHandle bootstrap;
        private final List<JavaConstant> arguments;
        public Dynamic(String name, TypeDescription typeDescription, MethodHandle bootstrap, List<JavaConstant> arguments) {
            this.name = name;
            this.typeDescription = typeDescription;
            this.bootstrap = bootstrap;
            this.arguments = arguments;
        }
        public static Dynamic ofAsm(TypePool typePool, ConstantDynamic constantDynamic) {
            Type type = Type.getType(constantDynamic.getDescriptor());
            TypeDescription describedType;
            if (type.getSort() == Type.ARRAY) {
                StringBuilder stringBuilder = new StringBuilder();
                for (int index = 0; index < type.getDimensions(); index++) {
                    stringBuilder.append('[');
                }
                describedType = typePool.describe(stringBuilder.append(type.getElementType().getDescriptor().replace('/', '.')).toString()).resolve();
            } else {
                describedType = typePool.describe(type.getClassName()).resolve();
            }
            List<JavaConstant> constants = new ArrayList<JavaConstant>(constantDynamic.getBootstrapMethodArgumentCount());
            for (int index = 0; index < constantDynamic.getBootstrapMethodArgumentCount(); index++) {
                constants.add(JavaConstant.Simple.ofAsm(typePool, constantDynamic.getBootstrapMethodArgument(index)));
            }
            return new Dynamic(constantDynamic.getName(), describedType, MethodHandle.ofAsm(typePool, constantDynamic.getBootstrapMethod()), constants);
        }
        public static Dynamic ofNullConstant() {
            return new Dynamic(DEFAULT_NAME, TypeDescription.ForLoadedType.of(Object.class), new MethodHandle(MethodHandle.HandleType.INVOKE_STATIC, JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(), "nullConstant", TypeDescription.ForLoadedType.of(Object.class), Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), TypeDescription.ForLoadedType.of(String.class), TypeDescription.ForLoadedType.of(Class.class))), Collections.<JavaConstant>emptyList());
        }
        public static JavaConstant ofPrimitiveType(Class<?> type) {
            return ofPrimitiveType(TypeDescription.ForLoadedType.of(type));
        }
        public static JavaConstant ofPrimitiveType(TypeDescription typeDescription) {
            if (!typeDescription.isPrimitive()) {
                throw new IllegalArgumentException("Not a primitive type: " + typeDescription);
            }
            return new Dynamic(typeDescription.getDescriptor(), TypeDescription.ForLoadedType.of(Class.class), new MethodHandle(MethodHandle.HandleType.INVOKE_STATIC, JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(), "primitiveClass", TypeDescription.ForLoadedType.of(Class.class), Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), TypeDescription.ForLoadedType.of(String.class), TypeDescription.ForLoadedType.of(Class.class))), Collections.<JavaConstant>emptyList());
        }
        public static JavaConstant ofEnumeration(Enum<?> enumeration) {
            return ofEnumeration(new EnumerationDescription.ForLoadedEnumeration(enumeration));
        }
        public static JavaConstant ofEnumeration(EnumerationDescription enumerationDescription) {
            return new Dynamic(enumerationDescription.getValue(), enumerationDescription.getEnumerationType(), new MethodHandle(MethodHandle.HandleType.INVOKE_STATIC, JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(), "enumConstant", TypeDescription.ForLoadedType.of(Enum.class), Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), TypeDescription.ForLoadedType.of(String.class), TypeDescription.ForLoadedType.of(Class.class))), Collections.<JavaConstant>emptyList());
        }
        public static Dynamic ofField(Field field) {
            return ofField(new FieldDescription.ForLoadedField(field));
        }
        public static Dynamic ofField(FieldDescription.InDefinedShape fieldDescription) {
            if (!fieldDescription.isStatic() || !fieldDescription.isFinal()) {
                throw new IllegalArgumentException("Field must be static and final: " + fieldDescription);
            }
            boolean selfDeclared = fieldDescription.getType().isPrimitive() ? fieldDescription.getType().asErasure().asBoxed().equals(fieldDescription.getType().asErasure()) : fieldDescription.getDeclaringType().equals(fieldDescription.getType().asErasure());
            return new Dynamic(fieldDescription.getInternalName(), fieldDescription.getType().asErasure(), new MethodHandle(MethodHandle.HandleType.INVOKE_STATIC, JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(), "getStaticFinal", TypeDescription.ForLoadedType.of(Object.class), selfDeclared ? Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), TypeDescription.ForLoadedType.of(String.class), TypeDescription.ForLoadedType.of(Class.class)) : Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), TypeDescription.ForLoadedType.of(String.class), TypeDescription.ForLoadedType.of(Class.class), TypeDescription.ForLoadedType.of(Class.class))), selfDeclared ? Collections.<JavaConstant>emptyList() : Collections.singletonList(JavaConstant.Simple.of(fieldDescription.getDeclaringType())));
        }
        public static Dynamic ofInvocation(Method method, Object... constant) {
            return ofInvocation(method, Arrays.asList(constant));
        }
        public static Dynamic ofInvocation(Method method, List<?> constants) {
            return ofInvocation(new MethodDescription.ForLoadedMethod(method), constants);
        }
        public static Dynamic ofInvocation(Constructor<?> constructor, Object... constant) {
            return ofInvocation(constructor, Arrays.asList(constant));
        }
        public static Dynamic ofInvocation(Constructor<?> constructor, List<?> constants) {
            return ofInvocation(new MethodDescription.ForLoadedConstructor(constructor), constants);
        }
        public static Dynamic ofInvocation(MethodDescription.InDefinedShape methodDescription, Object... constant) {
            return ofInvocation(methodDescription, Arrays.asList(constant));
        }
        public static Dynamic ofInvocation(MethodDescription.InDefinedShape methodDescription, List<?> constants) {
            if (!methodDescription.isConstructor() && methodDescription.getReturnType().represents(void.class)) {
                throw new IllegalArgumentException("Bootstrap method is no constructor or non-void static factory: " + methodDescription);
            } else if (methodDescription.isVarArgs() ? methodDescription.getParameters().size() + (methodDescription.isStatic() || methodDescription.isConstructor() ? 0 : 1) > constants.size() + 1 : methodDescription.getParameters().size() + (methodDescription.isStatic() || methodDescription.isConstructor() ? 0 : 1) != constants.size()) {
                throw new IllegalArgumentException("Cannot assign " + constants + " to " + methodDescription);
            }
            List<TypeDescription> parameters = (methodDescription.isStatic() || methodDescription.isConstructor() ? methodDescription.getParameters().asTypeList().asErasures() : CompoundList.of(methodDescription.getDeclaringType(), methodDescription.getParameters().asTypeList().asErasures()));
            Iterator<TypeDescription> iterator;
            if (methodDescription.isVarArgs()) {
                iterator = CompoundList.of(parameters.subList(0, parameters.size() - 1), Collections.nCopies(constants.size() - parameters.size() + 1, parameters.get(parameters.size() - 1).getComponentType())).iterator();
            } else {
                iterator = parameters.iterator();
            }
            List<JavaConstant> arguments = new ArrayList<JavaConstant>(constants.size() + 1);
            arguments.add(MethodHandle.of(methodDescription));
            for (Object constant : constants) {
                JavaConstant argument = JavaConstant.Simple.wrap(constant);
                if (!argument.getTypeDescription().isAssignableTo(iterator.next())) {
                    throw new IllegalArgumentException("Cannot assign " + constants + " to " + methodDescription);
                }
                arguments.add(argument);
            }
            return new Dynamic(DEFAULT_NAME, methodDescription.isConstructor() ? methodDescription.getDeclaringType() : methodDescription.getReturnType().asErasure(), new MethodHandle(MethodHandle.HandleType.INVOKE_STATIC, JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(), "invoke", TypeDescription.ForLoadedType.of(Object.class), Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), TypeDescription.ForLoadedType.of(String.class), TypeDescription.ForLoadedType.of(Class.class), JavaType.METHOD_HANDLE.getTypeStub(), TypeDescription.ArrayProjection.of(TypeDescription.ForLoadedType.of(Object.class)))), arguments);
        }
        public static JavaConstant ofVarHandle(Field field) {
            return ofVarHandle(new FieldDescription.ForLoadedField(field));
        }
        public static JavaConstant ofVarHandle(FieldDescription.InDefinedShape fieldDescription) {
            return new Dynamic(fieldDescription.getInternalName(), JavaType.VAR_HANDLE.getTypeStub(), new MethodHandle(MethodHandle.HandleType.INVOKE_STATIC, JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(), fieldDescription.isStatic() ? "staticFieldVarHandle" : "fieldVarHandle", JavaType.VAR_HANDLE.getTypeStub(), Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), TypeDescription.ForLoadedType.of(String.class), TypeDescription.ForLoadedType.of(Class.class), TypeDescription.ForLoadedType.of(Class.class), TypeDescription.ForLoadedType.of(Class.class))), Arrays.asList(JavaConstant.Simple.of(fieldDescription.getDeclaringType()), JavaConstant.Simple.of(fieldDescription.getType().asErasure())));
        }
        public static JavaConstant ofArrayVarHandle(Class<?> type) {
            return ofArrayVarHandle(TypeDescription.ForLoadedType.of(type));
        }
        public static JavaConstant ofArrayVarHandle(TypeDescription typeDescription) {
            if (!typeDescription.isArray()) {
                throw new IllegalArgumentException("Not an array type: " + typeDescription);
            }
            return new Dynamic(DEFAULT_NAME, JavaType.VAR_HANDLE.getTypeStub(), new MethodHandle(MethodHandle.HandleType.INVOKE_STATIC, JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(), "arrayVarHandle", JavaType.VAR_HANDLE.getTypeStub(), Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), TypeDescription.ForLoadedType.of(String.class), TypeDescription.ForLoadedType.of(Class.class), TypeDescription.ForLoadedType.of(Class.class))), Collections.singletonList(JavaConstant.Simple.of(typeDescription)));
        }
        public static Dynamic bootstrap(String name, Method method, Object... constant) {
            return bootstrap(name, method, Arrays.asList(constant));
        }
        public static Dynamic bootstrap(String name, Method method, List<?> constants) {
            return bootstrap(name, new MethodDescription.ForLoadedMethod(method), constants);
        }
        public static Dynamic bootstrap(String name, Constructor<?> constructor, Object... constant) {
            return bootstrap(name, constructor, Arrays.asList(constant));
        }
        public static Dynamic bootstrap(String name, Constructor<?> constructor, List<?> constants) {
            return bootstrap(name, new MethodDescription.ForLoadedConstructor(constructor), constants);
        }
        public static Dynamic bootstrap(String name, MethodDescription.InDefinedShape bootstrapMethod, Object... constant) {
            return bootstrap(name, bootstrapMethod, Arrays.asList(constant));
        }
        public static Dynamic bootstrap(String name, MethodDescription.InDefinedShape bootstrap, List<?> arguments) {
            if (name.length() == 0 || name.contains(".")) {
                throw new IllegalArgumentException("Not a valid field name: " + name);
            }
            List<JavaConstant> constants = new ArrayList<JavaConstant>(arguments.size());
            for (Object argument : arguments) {
                constants.add(JavaConstant.Simple.wrap(argument));
            }
            if (!bootstrap.isConstantBootstrap(TypeList.Explicit.of(constants))) {
                throw new IllegalArgumentException("Not a valid bootstrap method " + bootstrap + " for " + arguments);
            }
            return new Dynamic(name, bootstrap.isConstructor() ? bootstrap.getDeclaringType() : bootstrap.getReturnType().asErasure(), new MethodHandle(bootstrap.isConstructor() ? MethodHandle.HandleType.INVOKE_SPECIAL_CONSTRUCTOR : MethodHandle.HandleType.INVOKE_STATIC, bootstrap.getDeclaringType(), bootstrap.getInternalName(), bootstrap.getReturnType().asErasure(), bootstrap.getParameters().asTypeList().asErasures()), constants);
        }
        public String getName() {
            return name;
        }
        public MethodHandle getBootstrap() {
            return bootstrap;
        }
        public List<JavaConstant> getArguments() {
            return arguments;
        }
        public JavaConstant withType(Class<?> type) {
            return withType(TypeDescription.ForLoadedType.of(type));
        }
        public JavaConstant withType(TypeDescription typeDescription) {
            if (typeDescription.represents(void.class)) {
                throw new IllegalArgumentException("Constant value cannot represent void");
            } else if (getBootstrap().getName().equals(MethodDescription.CONSTRUCTOR_INTERNAL_NAME) ? !getTypeDescription().isAssignableTo(typeDescription) : (!typeDescription.asBoxed().isInHierarchyWith(getTypeDescription().asBoxed()))) {
                throw new IllegalArgumentException(typeDescription + " is not compatible with bootstrapped type " + getTypeDescription());
            }
            return new Dynamic(getName(), typeDescription, getBootstrap(), getArguments());
        }
        public Object toDescription() {
            Object[] argument = JavaConstant.Simple.CONSTANT_DESC.toArray(arguments.size());
            for (int index = 0; index < argument.length; index++) {
                argument[index] = arguments.get(index).toDescription();
            }
            return JavaConstant.Simple.DYNAMIC_CONSTANT_DESC.ofCanonical(JavaConstant.Simple.METHOD_HANDLE_DESC.of(JavaConstant.Simple.DIRECT_METHOD_HANDLE_DESC_KIND.valueOf(bootstrap.getHandleType().getIdentifier(), bootstrap.getOwnerType().isInterface()), JavaConstant.Simple.CLASS_DESC.ofDescriptor(bootstrap.getOwnerType().getDescriptor()), bootstrap.getName(), bootstrap.getDescriptor()), getName(), JavaConstant.Simple.CLASS_DESC.ofDescriptor(typeDescription.getDescriptor()), argument);
        }
        public <T> T accept(Visitor<T> visitor) {
            return visitor.onDynamic(this);
        }
        public TypeDescription getTypeDescription() {
            return typeDescription;
        }
        public StackManipulation toStackManipulation() {
            return new JavaConstantValue(this);
        }
        public int hashCode() {
            int result = name.hashCode();
            result = 31 * result + typeDescription.hashCode();
            result = 31 * result + bootstrap.hashCode();
            result = 31 * result + arguments.hashCode();
            return result;
        }
        public boolean equals(@MaybeNull Object object) {
            if (this == object)
                return true;
            if (object == null || getClass() != object.getClass())
                return false;
            Dynamic dynamic = (Dynamic) object;
            if (!name.equals(dynamic.name))
                return false;
            if (!typeDescription.equals(dynamic.typeDescription))
                return false;
            if (!bootstrap.equals(dynamic.bootstrap))
                return false;
            return arguments.equals(dynamic.arguments);
        }
        public String toString() {
            StringBuilder stringBuilder = new StringBuilder().append(bootstrap.getOwnerType().getSimpleName()).append("::").append(bootstrap.getName()).append('(').append(name.equals(DEFAULT_NAME) ? "" : name).append('/');
            boolean first = true;
            for (JavaConstant constant : arguments) {
                if (first) {
                    first = false;
                } else {
                    stringBuilder.append(',');
                }
                stringBuilder.append(constant.toString());
            }
            return stringBuilder.append(')').append(typeDescription.getSimpleName()).toString();
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```