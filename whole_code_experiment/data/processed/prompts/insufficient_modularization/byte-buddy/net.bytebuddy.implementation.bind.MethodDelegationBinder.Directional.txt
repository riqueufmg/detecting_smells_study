##CONTEXT_SIZE=3092
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.implementation.bind;
public interface MethodDelegationBinder {
    Record compile(MethodDescription candidate);
    interface Record {
        MethodBinding bind(Implementation.Target implementationTarget, MethodDescription source, TerminationHandler terminationHandler, MethodInvoker methodInvoker, Assigner assigner);
        enum Illegal implements Record {
            INSTANCE;
            public MethodBinding bind(Implementation.Target implementationTarget, MethodDescription source, TerminationHandler terminationHandler, MethodInvoker methodInvoker, Assigner assigner) {
                return MethodBinding.Illegal.INSTANCE;
            }
        }
    }
    interface MethodInvoker {
        StackManipulation invoke(MethodDescription methodDescription);
        enum Simple implements MethodInvoker {
            INSTANCE;
            public StackManipulation invoke(MethodDescription methodDescription) {
                return MethodInvocation.invoke(methodDescription);
            }
        }
        class Virtual implements MethodInvoker {
            private final TypeDescription typeDescription;
            public Virtual(TypeDescription typeDescription) {
                this.typeDescription = typeDescription;
            }
            public StackManipulation invoke(MethodDescription methodDescription) {
                return MethodInvocation.invoke(methodDescription).virtual(typeDescription);
            }
        }
    }
    interface ParameterBinding<T> extends StackManipulation {
        T getIdentificationToken();
        enum Illegal implements ParameterBinding<Void> {
            INSTANCE;
            public Void getIdentificationToken() {
                throw new IllegalStateException("An illegal binding does not define an identification token");
            }
            public boolean isValid() {
                return false;
            }
            public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                throw new IllegalStateException("An illegal parameter binding must not be applied");
            }
        }
        class Anonymous implements ParameterBinding<Object> {
            private final Object anonymousToken;
            private final StackManipulation delegate;
            public Anonymous(StackManipulation delegate) {
                this.delegate = delegate;
                anonymousToken = new Object();
            }
            public Object getIdentificationToken() {
                return anonymousToken;
            }
            public boolean isValid() {
                return delegate.isValid();
            }
            public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                return delegate.apply(methodVisitor, implementationContext);
            }
        }
        class Unique<T> implements ParameterBinding<T> {
            private final T identificationToken;
            private final StackManipulation delegate;
            public Unique(StackManipulation delegate, T identificationToken) {
                this.delegate = delegate;
                this.identificationToken = identificationToken;
            }
            public static <S> Unique<S> of(StackManipulation delegate, S identificationToken) {
                return new Unique<S>(delegate, identificationToken);
            }
            public T getIdentificationToken() {
                return identificationToken;
            }
            public boolean isValid() {
                return delegate.isValid();
            }
            public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                return delegate.apply(methodVisitor, implementationContext);
            }
        }
    }
    interface MethodBinding extends StackManipulation {
        Integer getTargetParameterIndex(Object parameterBindingToken);
        MethodDescription getTarget();
        enum Illegal implements MethodBinding {
            INSTANCE;
            public Integer getTargetParameterIndex(Object parameterBindingToken) {
                throw new IllegalStateException("Method is not bound");
            }
            public MethodDescription getTarget() {
                throw new IllegalStateException("Method is not bound");
            }
            public boolean isValid() {
                return false;
            }
            public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                throw new IllegalStateException("Cannot delegate to an unbound method");
            }
        }
        class Builder {
            private final MethodInvoker methodInvoker;
            private final MethodDescription candidate;
            private final List<StackManipulation> parameterStackManipulations;
            private final LinkedHashMap<Object, Integer> registeredTargetIndices;
            private int nextParameterIndex;
            public Builder(MethodInvoker methodInvoker, MethodDescription candidate) {
                this.methodInvoker = methodInvoker;
                this.candidate = candidate;
                parameterStackManipulations = new ArrayList<StackManipulation>(candidate.getParameters().size());
                registeredTargetIndices = new LinkedHashMap<Object, Integer>();
                nextParameterIndex = 0;
            }
            public boolean append(ParameterBinding<?> parameterBinding) {
                parameterStackManipulations.add(parameterBinding);
                return registeredTargetIndices.put(parameterBinding.getIdentificationToken(), nextParameterIndex++) == null;
            }
            public MethodBinding build(StackManipulation terminatingManipulation) {
                if (candidate.getParameters().size() != nextParameterIndex) {
                    throw new IllegalStateException("The number of parameters bound does not equal the target's number of parameters");
                }
                return new Build(candidate, registeredTargetIndices, methodInvoker.invoke(candidate), parameterStackManipulations, terminatingManipulation);
            }
            protected static class Build implements MethodBinding {
                private final MethodDescription target;
                private final Map<?, Integer> registeredTargetIndices;
                private final StackManipulation methodInvocation;
                private final List<StackManipulation> parameterStackManipulations;
                private final StackManipulation terminatingStackManipulation;
                protected Build(MethodDescription target, Map<?, Integer> registeredTargetIndices, StackManipulation methodInvocation, List<StackManipulation> parameterStackManipulations, StackManipulation terminatingStackManipulation) {
                    this.target = target;
                    this.registeredTargetIndices = new HashMap<Object, Integer>(registeredTargetIndices);
                    this.methodInvocation = methodInvocation;
                    this.parameterStackManipulations = new ArrayList<StackManipulation>(parameterStackManipulations);
                    this.terminatingStackManipulation = terminatingStackManipulation;
                }
                public boolean isValid() {
                    boolean result = methodInvocation.isValid() && terminatingStackManipulation.isValid();
                    Iterator<StackManipulation> assignment = parameterStackManipulations.iterator();
                    while (result && assignment.hasNext()) {
                        result = assignment.next().isValid();
                    }
                    return result;
                }
                public Integer getTargetParameterIndex(Object parameterBindingToken) {
                    return registeredTargetIndices.get(parameterBindingToken);
                }
                public MethodDescription getTarget() {
                    return target;
                }
                public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
                    return new Compound(CompoundList.of(parameterStackManipulations, Arrays.asList(methodInvocation, terminatingStackManipulation))).apply(methodVisitor, implementationContext);
                }
            }
        }
    }
    interface BindingResolver {
        MethodBinding resolve(AmbiguityResolver ambiguityResolver, MethodDescription source, List<MethodBinding> targets);
        enum Default implements BindingResolver {
            INSTANCE;
            private static final int ONLY = 0;
            private static final int LEFT = 0;
            private static final int RIGHT = 1;
            public MethodBinding resolve(AmbiguityResolver ambiguityResolver, MethodDescription source, List<MethodBinding> targets) {
                return doResolve(ambiguityResolver, source, new ArrayList<MethodBinding>(targets));
            }
            private MethodBinding doResolve(AmbiguityResolver ambiguityResolver, MethodDescription source, List<MethodBinding> targets) {
                switch(targets.size()) {
                    case 1:
                        return targets.get(ONLY);
                    case 2:
                        {
                            MethodBinding left = targets.get(LEFT);
                            MethodBinding right = targets.get(RIGHT);
                            switch(ambiguityResolver.resolve(source, left, right)) {
                                case LEFT:
                                    return left;
                                case RIGHT:
                                    return right;
                                case AMBIGUOUS:
                                case UNKNOWN:
                                    throw new IllegalArgumentException("Cannot resolve ambiguous delegation of " + source + " to " + left.getTarget() + " or " + right.getTarget());
                                default:
                                    throw new AssertionError();
                            }
                        }
                    default:
                        {
                            MethodBinding left = targets.get(LEFT);
                            MethodBinding right = targets.get(RIGHT);
                            switch(ambiguityResolver.resolve(source, left, right)) {
                                case LEFT:
                                    targets.remove(RIGHT);
                                    return doResolve(ambiguityResolver, source, targets);
                                case RIGHT:
                                    targets.remove(LEFT);
                                    return doResolve(ambiguityResolver, source, targets);
                                case AMBIGUOUS:
                                case UNKNOWN:
                                    targets.remove(RIGHT);
                                    targets.remove(LEFT);
                                    MethodBinding subResult = doResolve(ambiguityResolver, source, targets);
                                    switch(ambiguityResolver.resolve(source, left, subResult).merge(ambiguityResolver.resolve(source, right, subResult))) {
                                        case RIGHT:
                                            return subResult;
                                        case LEFT:
                                        case AMBIGUOUS:
                                        case UNKNOWN:
                                            throw new IllegalArgumentException("Cannot resolve ambiguous delegation of " + source + " to " + left.getTarget() + " or " + right.getTarget());
                                        default:
                                            throw new AssertionError();
                                    }
                                default:
                                    throw new IllegalStateException("Unexpected amount of targets: " + targets.size());
                            }
                        }
                }
            }
        }
        enum Unique implements BindingResolver {
            INSTANCE;
            private static final int ONLY = 0;
            public MethodBinding resolve(AmbiguityResolver ambiguityResolver, MethodDescription source, List<MethodBinding> targets) {
                if (targets.size() == 1) {
                    return targets.get(ONLY);
                } else {
                    throw new IllegalStateException(source + " allowed for more than one binding: " + targets);
                }
            }
        }
        class StreamWriting implements BindingResolver {
            private final BindingResolver delegate;
            private final PrintStream printStream;
            public StreamWriting(BindingResolver delegate, PrintStream printStream) {
                this.delegate = delegate;
                this.printStream = printStream;
            }
            public static BindingResolver toSystemOut() {
                return toSystemOut(Default.INSTANCE);
            }
            public static BindingResolver toSystemOut(BindingResolver bindingResolver) {
                return new StreamWriting(bindingResolver, System.out);
            }
            public static BindingResolver toSystemError() {
                return toSystemError(Default.INSTANCE);
            }
            public static BindingResolver toSystemError(BindingResolver bindingResolver) {
                return new StreamWriting(bindingResolver, System.err);
            }
            public MethodBinding resolve(AmbiguityResolver ambiguityResolver, MethodDescription source, List<MethodBinding> targets) {
                MethodBinding methodBinding = delegate.resolve(ambiguityResolver, source, targets);
                printStream.println("Binding " + source + " as delegation to " + methodBinding.getTarget());
                return methodBinding;
            }
        }
    }
    interface AmbiguityResolver {
        AmbiguityResolver DEFAULT = new MethodDelegationBinder.AmbiguityResolver.Compound(BindingPriority.Resolver.INSTANCE, DeclaringTypeResolver.INSTANCE, ArgumentTypeResolver.INSTANCE, MethodNameEqualityResolver.INSTANCE, ParameterLengthResolver.INSTANCE);
        Resolution resolve(MethodDescription source, MethodBinding left, MethodBinding right);
        enum Resolution {
            UNKNOWN(true), LEFT(false), RIGHT(false), AMBIGUOUS(true);
            private final boolean unresolved;
            Resolution(boolean unresolved) {
                this.unresolved = unresolved;
            }
            public boolean isUnresolved() {
                return unresolved;
            }
            public Resolution merge(Resolution other) {
                switch(this) {
                    case UNKNOWN:
                        return other;
                    case AMBIGUOUS:
                        return AMBIGUOUS;
                    case LEFT:
                    case RIGHT:
                        return other == UNKNOWN || other == this ? this : AMBIGUOUS;
                    default:
                        throw new AssertionError();
                }
            }
        }
        enum NoOp implements AmbiguityResolver {
            INSTANCE;
            public Resolution resolve(MethodDescription source, MethodBinding left, MethodBinding right) {
                return Resolution.UNKNOWN;
            }
        }
        enum Directional implements AmbiguityResolver {
            LEFT(true), RIGHT(false);
            private final boolean left;
            Directional(boolean left) {
                this.left = left;
            }
            public Resolution resolve(MethodDescription source, MethodBinding left, MethodBinding right) {
                return this.left ? Resolution.LEFT : Resolution.RIGHT;
            }
        }
        class Compound implements AmbiguityResolver {
            private final List<AmbiguityResolver> ambiguityResolvers;
            public Compound(AmbiguityResolver... ambiguityResolver) {
                this(Arrays.asList(ambiguityResolver));
            }
            public Compound(List<? extends AmbiguityResolver> ambiguityResolvers) {
                this.ambiguityResolvers = new ArrayList<AmbiguityResolver>();
                for (AmbiguityResolver ambiguityResolver : ambiguityResolvers) {
                    if (ambiguityResolver instanceof Compound) {
                        this.ambiguityResolvers.addAll(((Compound) ambiguityResolver).ambiguityResolvers);
                    } else if (!(ambiguityResolver instanceof NoOp)) {
                        this.ambiguityResolvers.add(ambiguityResolver);
                    }
                }
            }
            public Resolution resolve(MethodDescription source, MethodBinding left, MethodBinding right) {
                Resolution resolution = Resolution.UNKNOWN;
                Iterator<? extends AmbiguityResolver> iterator = ambiguityResolvers.iterator();
                while (resolution.isUnresolved() && iterator.hasNext()) {
                    resolution = iterator.next().resolve(source, left, right);
                }
                return resolution;
            }
        }
    }
    interface TerminationHandler {
        StackManipulation resolve(Assigner assigner, Assigner.Typing typing, MethodDescription source, MethodDescription target);
        enum Default implements TerminationHandler {
            RETURNING {
                public StackManipulation resolve(Assigner assigner, Assigner.Typing typing, MethodDescription source, MethodDescription target) {
                    return new StackManipulation.Compound(assigner.assign(target.isConstructor() ? target.getDeclaringType().asGenericType() : target.getReturnType(), source.getReturnType(), typing), MethodReturn.of(source.getReturnType()));
                }
            }
            , DROPPING {
                public StackManipulation resolve(Assigner assigner, Assigner.Typing typing, MethodDescription source, MethodDescription target) {
                    return Removal.of(target.isConstructor() ? target.getDeclaringType() : target.getReturnType());
                }
            }
        }
    }
    class Processor implements MethodDelegationBinder.Record {
        private final List<? extends Record> records;
        private final AmbiguityResolver ambiguityResolver;
        private final BindingResolver bindingResolver;
        public Processor(List<? extends Record> records, AmbiguityResolver ambiguityResolver, BindingResolver bindingResolver) {
            this.records = records;
            this.ambiguityResolver = ambiguityResolver;
            this.bindingResolver = bindingResolver;
        }
        public MethodBinding bind(Implementation.Target implementationTarget, MethodDescription source, TerminationHandler terminationHandler, MethodInvoker methodInvoker, Assigner assigner) {
            List<MethodBinding> targets = new ArrayList<MethodBinding>();
            for (Record record : records) {
                MethodBinding methodBinding = record.bind(implementationTarget, source, terminationHandler, methodInvoker, assigner);
                if (methodBinding.isValid()) {
                    targets.add(methodBinding);
                }
            }
            if (targets.isEmpty()) {
                throw new IllegalArgumentException("None of " + records + " allows for delegation from " + source);
            }
            return bindingResolver.resolve(ambiguityResolver, source, targets);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```