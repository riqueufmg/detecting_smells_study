##CONTEXT_SIZE=7311
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.dynamic;
public interface ClassFileLocator extends Closeable {
    String CLASS_FILE_EXTENSION = ".class";
    String META_INF_VERSIONS = "META-INF/versions/";
    Resolution locate(String name) throws IOException;
    interface Resolution {
        boolean isResolved();
        byte[] resolve();
        class Illegal implements Resolution {
            private final String typeName;
            public Illegal(String typeName) {
                this.typeName = typeName;
            }
            public boolean isResolved() {
                return false;
            }
            public byte[] resolve() {
                throw new IllegalStateException("Could not locate class file for " + typeName);
            }
        }
        class Explicit implements Resolution {
            private final byte[] binaryRepresentation;
            @SuppressFBWarnings(value = "EI_EXPOSE_REP2", justification = "The array is not modified by class contract.")
            public Explicit(byte[] binaryRepresentation) {
                this.binaryRepresentation = binaryRepresentation;
            }
            public boolean isResolved() {
                return true;
            }
            public byte[] resolve() {
                return binaryRepresentation;
            }
        }
    }
    enum NoOp implements ClassFileLocator {
        INSTANCE;
        public Resolution locate(String name) {
            return new Resolution.Illegal(name);
        }
        public void close() {
        }
    }
    abstract class MultiReleaseAware implements ClassFileLocator {
        private static final String MULTI_RELEASE_ATTRIBUTE = "Multi-Release";
        protected static final int[] NO_MULTI_RELEASE = new int[0];
        private final int[] version;
        protected MultiReleaseAware(int[] version) {
            this.version = version;
        }
        public Resolution locate(String name) throws IOException {
            String path = name.replace('.', '/') + CLASS_FILE_EXTENSION;
            for (int index = 0; index < version.length + 1; index++) {
                byte[] binaryRepresentation = doLocate(index == version.length ? path : META_INF_VERSIONS + version[index] + "/" + path);
                if (binaryRepresentation != null) {
                    return new Resolution.Explicit(binaryRepresentation);
                }
            }
            return new Resolution.Illegal(name);
        }
        protected abstract byte[] doLocate(String path) throws IOException;
    }
    class Simple implements ClassFileLocator {
        private final Map<String, byte[]> classFiles;
        public Simple(Map<String, byte[]> classFiles) {
            this.classFiles = classFiles;
        }
        public static ClassFileLocator of(String typeName, byte[] binaryRepresentation) {
            return new Simple(Collections.singletonMap(typeName, binaryRepresentation));
        }
        public static ClassFileLocator of(DynamicType dynamicType) {
            return of(dynamicType.getAllTypes());
        }
        public static ClassFileLocator of(Map<TypeDescription, byte[]> binaryRepresentations) {
            Map<String, byte[]> classFiles = new HashMap<String, byte[]>();
            for (Map.Entry<TypeDescription, byte[]> entry : binaryRepresentations.entrySet()) {
                classFiles.put(entry.getKey().getName(), entry.getValue());
            }
            return new Simple(classFiles);
        }
        public static ClassFileLocator ofResources(Map<String, byte[]> binaryRepresentations) {
            Map<String, byte[]> classFiles = new HashMap<String, byte[]>();
            for (Map.Entry<String, byte[]> entry : binaryRepresentations.entrySet()) {
                if (entry.getKey().endsWith(CLASS_FILE_EXTENSION)) {
                    classFiles.put(entry.getKey().substring(0, entry.getKey().length() - CLASS_FILE_EXTENSION.length()).replace('/', '.'), entry.getValue());
                }
            }
            return new Simple(classFiles);
        }
        public Resolution locate(String name) {
            byte[] binaryRepresentation = classFiles.get(name);
            return binaryRepresentation == null ? new Resolution.Illegal(name) : new Resolution.Explicit(binaryRepresentation);
        }
        public void close() {
        }
    }
    class ForClassLoader implements ClassFileLocator {
        private static final ClassLoader BOOT_LOADER_PROXY = doPrivileged(BootLoaderProxyCreationAction.INSTANCE);
        private final ClassLoader classLoader;
        protected ForClassLoader(ClassLoader classLoader) {
            this.classLoader = classLoader;
        }
        private static <T> T doPrivileged(PrivilegedAction<T> action) {
            return action.run();
        }
        public static ClassFileLocator ofSystemLoader() {
            return new ForClassLoader(ClassLoader.getSystemClassLoader());
        }
        public static ClassFileLocator ofPlatformLoader() {
            return of(ClassLoader.getSystemClassLoader().getParent());
        }
        public static ClassFileLocator ofBootLoader() {
            return new ForClassLoader(BOOT_LOADER_PROXY);
        }
        public static ClassFileLocator of(@MaybeNull ClassLoader classLoader) {
            return new ForClassLoader(classLoader == null ? BOOT_LOADER_PROXY : classLoader);
        }
        public static byte[] read(Class<?> type) {
            try {
                ClassLoader classLoader = type.getClassLoader();
                return locate(classLoader == null ? BOOT_LOADER_PROXY : classLoader, TypeDescription.ForLoadedType.getName(type)).resolve();
            } catch (IOException exception) {
                throw new IllegalStateException("Cannot read class file for " + type, exception);
            }
        }
        public static Map<Class<?>, byte[]> read(Class<?>... type) {
            return read(Arrays.asList(type));
        }
        public static Map<Class<?>, byte[]> read(Collection<? extends Class<?>> types) {
            Map<Class<?>, byte[]> result = new HashMap<Class<?>, byte[]>();
            for (Class<?> type : types) {
                result.put(type, read(type));
            }
            return result;
        }
        public static Map<String, byte[]> readToNames(Class<?>... type) {
            return readToNames(Arrays.asList(type));
        }
        public static Map<String, byte[]> readToNames(Collection<? extends Class<?>> types) {
            Map<String, byte[]> result = new HashMap<String, byte[]>();
            for (Class<?> type : types) {
                result.put(type.getName(), read(type));
            }
            return result;
        }
        public Resolution locate(String name) throws IOException {
            return locate(classLoader, name);
        }
        public void close() {
        }
        protected static Resolution locate(ClassLoader classLoader, String name) throws IOException {
            InputStream inputStream = classLoader.getResourceAsStream(name.replace('.', '/') + CLASS_FILE_EXTENSION);
            if (inputStream != null) {
                try {
                    return new Resolution.Explicit(StreamDrainer.DEFAULT.drain(inputStream));
                } finally {
                    inputStream.close();
                }
            } else {
                return new Resolution.Illegal(name);
            }
        }
        protected enum BootLoaderProxyCreationAction implements PrivilegedAction<ClassLoader> {
            INSTANCE;
            public ClassLoader run() {
                return new URLClassLoader(new URL[0], ClassLoadingStrategy.BOOTSTRAP_LOADER);
            }
        }
        public static class WeaklyReferenced extends WeakReference<ClassLoader> implements ClassFileLocator {
            private final int hashCode;
            protected WeaklyReferenced(ClassLoader classLoader) {
                super(classLoader);
                hashCode = System.identityHashCode(classLoader);
            }
            public static ClassFileLocator of(@MaybeNull ClassLoader classLoader) {
                return classLoader == null || classLoader == ClassLoader.getSystemClassLoader() || classLoader == ClassLoader.getSystemClassLoader().getParent() ? ForClassLoader.of(classLoader) : new WeaklyReferenced(classLoader);
            }
            public Resolution locate(String name) throws IOException {
                ClassLoader classLoader = get();
                return classLoader == null ? new Resolution.Illegal(name) : ForClassLoader.locate(classLoader, name);
            }
            public void close() {
            }
            public int hashCode() {
                return hashCode;
            }
            public boolean equals(@MaybeNull Object other) {
                if (this == other) {
                    return true;
                } else if (other == null || getClass() != other.getClass()) {
                    return false;
                }
                WeaklyReferenced weaklyReferenced = (WeaklyReferenced) other;
                ClassLoader classLoader = weaklyReferenced.get();
                return classLoader != null && get() == classLoader;
            }
        }
    }
    class ForModule implements ClassFileLocator {
        private static final Object[] NO_ARGUMENT = new Object[0];
        private final JavaModule module;
        protected ForModule(JavaModule module) {
            this.module = module;
        }
        public static ClassFileLocator ofBootLayer() {
            try {
                Map<String, ClassFileLocator> bootModules = new HashMap<String, ClassFileLocator>();
                Class<?> layerType = Class.forName("java.lang.ModuleLayer");
                Method getPackages = JavaType.MODULE.load().getMethod("getPackages");
                for (Object rawModule : (Set<?>) layerType.getMethod("modules").invoke(layerType.getMethod("boot").invoke(null))) {
                    ClassFileLocator classFileLocator = ForModule.of(JavaModule.of(rawModule));
                    for (Object packageName : (Set<?>) getPackages.invoke(rawModule, NO_ARGUMENT)) {
                        bootModules.put((String) packageName, classFileLocator);
                    }
                }
                return new PackageDiscriminating(bootModules);
            } catch (Exception exception) {
                throw new IllegalStateException("Cannot process boot layer", exception);
            }
        }
        public static ClassFileLocator of(JavaModule module) {
            return module.isNamed() ? new ForModule(module) : ForClassLoader.of(module.getClassLoader());
        }
        public Resolution locate(String name) throws IOException {
            return locate(module, name);
        }
        protected static Resolution locate(JavaModule module, String typeName) throws IOException {
            InputStream inputStream = module.getResourceAsStream(typeName.replace('.', '/') + CLASS_FILE_EXTENSION);
            if (inputStream != null) {
                try {
                    return new Resolution.Explicit(StreamDrainer.DEFAULT.drain(inputStream));
                } finally {
                    inputStream.close();
                }
            } else {
                return new Resolution.Illegal(typeName);
            }
        }
        public void close() {
        }
        public static class WeaklyReferenced extends WeakReference<Object> implements ClassFileLocator {
            private final int hashCode;
            protected WeaklyReferenced(Object module) {
                super(module);
                hashCode = System.identityHashCode(module);
            }
            public static ClassFileLocator of(JavaModule module) {
                if (module.isNamed()) {
                    return module.getClassLoader() == null || module.getClassLoader() == ClassLoader.getSystemClassLoader() || module.getClassLoader() == ClassLoader.getSystemClassLoader().getParent() ? new ForModule(module) : new WeaklyReferenced(module.unwrap());
                } else {
                    return ForClassLoader.WeaklyReferenced.of(module.getClassLoader());
                }
            }
            public Resolution locate(String name) throws IOException {
                Object module = get();
                return module == null ? new Resolution.Illegal(name) : ForModule.locate(JavaModule.of(module), name);
            }
            public void close() {
            }
            public int hashCode() {
                return hashCode;
            }
            public boolean equals(@MaybeNull Object other) {
                if (this == other) {
                    return true;
                } else if (other == null || getClass() != other.getClass()) {
                    return false;
                }
                WeaklyReferenced weaklyReferenced = (WeaklyReferenced) other;
                Object module = weaklyReferenced.get();
                return module != null && get() == module;
            }
        }
    }
    class ForJarFile extends MultiReleaseAware {
        private static final List<String> RUNTIME_LOCATIONS = Arrays.asList("lib/rt.jar", "../lib/rt.jar", "../Classes/classes.jar");
        private final JarFile jarFile;
        private final boolean close;
        public ForJarFile(JarFile jarFile) {
            this(NO_MULTI_RELEASE, jarFile, false);
        }
        protected ForJarFile(int[] version, JarFile jarFile, boolean close) {
            super(version);
            this.jarFile = jarFile;
            this.close = close;
        }
        public static ClassFileLocator of(File file) throws IOException {
            return new ForJarFile(MultiReleaseAware.NO_MULTI_RELEASE, new JarFile(file, false, ZipFile.OPEN_READ), true);
        }
        public static ClassFileLocator of(File file, ClassFileVersion classFileVersion) throws IOException {
            return of(new JarFile(file, false, ZipFile.OPEN_READ), classFileVersion, true);
        }
        public static ClassFileLocator of(JarFile jarFile, ClassFileVersion classFileVersion) throws IOException {
            return of(jarFile, classFileVersion, false);
        }
        private static ClassFileLocator of(JarFile jarFile, ClassFileVersion classFileVersion, boolean close) throws IOException {
            if (classFileVersion.getJavaVersion() < 9) {
                return new ForJarFile(jarFile);
            } else {
                Manifest manifest = jarFile.getManifest();
                int[] version;
                if (manifest != null && Boolean.parseBoolean(manifest.getMainAttributes().getValue(MultiReleaseAware.MULTI_RELEASE_ATTRIBUTE))) {
                    SortedSet<Integer> versions = new TreeSet<Integer>();
                    Enumeration<JarEntry> enumeration = jarFile.entries();
                    while (enumeration.hasMoreElements()) {
                        String name = enumeration.nextElement().getName();
                        if (name.endsWith(CLASS_FILE_EXTENSION) && name.startsWith(META_INF_VERSIONS)) {
                            try {
                                int candidate = Integer.parseInt(name.substring(META_INF_VERSIONS.length(), name.indexOf('/', META_INF_VERSIONS.length())));
                                if (candidate > 7 && candidate <= classFileVersion.getJavaVersion()) {
                                    versions.add(candidate);
                                }
                            } catch (NumberFormatException ignored) {
                            }
                        }
                    }
                    version = new int[versions.size()];
                    Iterator<Integer> iterator = versions.iterator();
                    for (int index = 0; index < versions.size(); index++) {
                        version[versions.size() - index - 1] = iterator.next();
                    }
                } else {
                    version = MultiReleaseAware.NO_MULTI_RELEASE;
                }
                return new ForJarFile(version, jarFile, close);
            }
        }
        public static ClassFileLocator ofClassPath() throws IOException {
            return ofClassPath(System.getProperty("java.class.path"));
        }
        public static ClassFileLocator ofClassPath(String classPath) throws IOException {
            ClassFileVersion classFileVersion = ClassFileVersion.ofThisVm();
            List<ClassFileLocator> classFileLocators = new ArrayList<ClassFileLocator>();
            for (String element : Pattern.compile(File.pathSeparator, Pattern.LITERAL).split(classPath)) {
                File file = new File(element);
                if (file.isDirectory()) {
                    classFileLocators.add(ForFolder.of(file, classFileVersion));
                } else if (file.isFile()) {
                    classFileLocators.add(of(file, classFileVersion));
                }
            }
            return new Compound(classFileLocators);
        }
        public static ClassFileLocator ofRuntimeJar() throws IOException {
            String javaHome = System.getProperty("java.home").replace('\\', '/');
            File runtimeJar = null;
            for (String location : RUNTIME_LOCATIONS) {
                File candidate = new File(javaHome, location);
                if (candidate.isFile()) {
                    runtimeJar = candidate;
                    break;
                }
            }
            if (runtimeJar == null) {
                throw new IllegalStateException("Runtime jar does not exist in " + javaHome + " for any of " + RUNTIME_LOCATIONS);
            }
            return of(runtimeJar);
        }
        protected byte[] doLocate(String path) throws IOException {
            ZipEntry zipEntry = jarFile.getEntry(path);
            if (zipEntry == null) {
                return null;
            } else {
                InputStream inputStream = jarFile.getInputStream(zipEntry);
                try {
                    return StreamDrainer.DEFAULT.drain(inputStream);
                } finally {
                    inputStream.close();
                }
            }
        }
        public void close() throws IOException {
            if (close) {
                jarFile.close();
            }
        }
    }
    class ForModuleFile implements ClassFileLocator {
        private static final String JMOD_FILE_EXTENSION = ".jmod";
        private static final List<String> BOOT_LOCATIONS = Arrays.asList("jmods", "../jmods", "modules");
        private final ZipFile zipFile;
        public ForModuleFile(ZipFile zipFile) {
            this.zipFile = zipFile;
        }
        public static ClassFileLocator ofBootPath() throws IOException {
            String javaHome = System.getProperty("java.home").replace('\\', '/');
            File bootPath = null;
            for (String location : BOOT_LOCATIONS) {
                File candidate = new File(javaHome, location);
                if (candidate.isDirectory()) {
                    bootPath = candidate;
                    break;
                }
            }
            if (bootPath == null) {
                throw new IllegalStateException("Boot modules do not exist in " + javaHome + " for any of " + BOOT_LOCATIONS);
            }
            return ofBootPath(bootPath);
        }
        public static ClassFileLocator ofBootPath(File bootPath) throws IOException {
            File[] module = bootPath.listFiles();
            if (module == null) {
                return NoOp.INSTANCE;
            }
            ClassFileVersion classFileVersion = ClassFileVersion.ofThisVm();
            List<ClassFileLocator> classFileLocators = new ArrayList<ClassFileLocator>(module.length);
            for (File aModule : module) {
                if (aModule.isFile()) {
                    classFileLocators.add(of(aModule));
                } else if (aModule.isDirectory()) {
                    classFileLocators.add(ForFolder.of(aModule, classFileVersion));
                }
            }
            return new Compound(classFileLocators);
        }
        public static ClassFileLocator ofModulePath() throws IOException {
            String modulePath = System.getProperty("jdk.module.path");
            return modulePath == null ? NoOp.INSTANCE : ofModulePath(modulePath);
        }
        public static ClassFileLocator ofModulePath(String modulePath) throws IOException {
            return ofModulePath(modulePath, System.getProperty("user.dir"));
        }
        public static ClassFileLocator ofModulePath(String modulePath, String baseFolder) throws IOException {
            ClassFileVersion classFileVersion = ClassFileVersion.ofThisVm();
            List<ClassFileLocator> classFileLocators = new ArrayList<ClassFileLocator>();
            for (String element : Pattern.compile(System.getProperty("path.separator"), Pattern.LITERAL).split(modulePath)) {
                File file = new File(baseFolder, element);
                if (file.isDirectory()) {
                    File[] module = file.listFiles();
                    if (module != null) {
                        for (File aModule : module) {
                            if (aModule.isDirectory()) {
                                classFileLocators.add(ForFolder.of(aModule, classFileVersion));
                            } else if (aModule.isFile()) {
                                classFileLocators.add(aModule.getName().endsWith(JMOD_FILE_EXTENSION) ? of(aModule) : ForJarFile.of(aModule, classFileVersion));
                            }
                        }
                    }
                } else if (file.isFile()) {
                    classFileLocators.add(file.getName().endsWith(JMOD_FILE_EXTENSION) ? of(file) : ForJarFile.of(file));
                }
            }
            return new Compound(classFileLocators);
        }
        public static ClassFileLocator of(File file) throws IOException {
            return new ForModuleFile(new ZipFile(file));
        }
        public Resolution locate(String name) throws IOException {
            ZipEntry zipEntry = zipFile.getEntry("classes/" + name.replace('.', '/') + CLASS_FILE_EXTENSION);
            if (zipEntry == null) {
                return new Resolution.Illegal(name);
            } else {
                InputStream inputStream = zipFile.getInputStream(zipEntry);
                try {
                    return new Resolution.Explicit(StreamDrainer.DEFAULT.drain(inputStream));
                } finally {
                    inputStream.close();
                }
            }
        }
        public void close() throws IOException {
            zipFile.close();
        }
    }
    class ForFolder extends MultiReleaseAware {
        private final File folder;
        public ForFolder(File folder) {
            this(NO_MULTI_RELEASE, folder);
        }
        protected ForFolder(int[] version, File folder) {
            super(version);
            this.folder = folder;
        }
        public static ClassFileLocator of(File folder, ClassFileVersion classFileVersion) throws IOException {
            if (classFileVersion.getJavaVersion() < 9) {
                return new ForFolder(NO_MULTI_RELEASE, folder);
            } else {
                File manifest = new File(folder, JarFile.MANIFEST_NAME);
                boolean multiRelease;
                if (manifest.exists()) {
                    InputStream inputStream = new FileInputStream(manifest);
                    try {
                        multiRelease = Boolean.parseBoolean(new Manifest(inputStream).getMainAttributes().getValue("Multi-Release"));
                    } finally {
                        inputStream.close();
                    }
                } else {
                    multiRelease = false;
                }
                int[] version;
                if (multiRelease) {
                    File[] file = new File(folder, META_INF_VERSIONS).listFiles();
                    if (file != null) {
                        SortedSet<Integer> versions = new TreeSet<Integer>();
                        for (int index = 0; index < file.length; index++) {
                            try {
                                int candidate = Integer.parseInt(file[index].getName());
                                if (candidate > 7 && candidate <= classFileVersion.getJavaVersion()) {
                                    versions.add(candidate);
                                }
                            } catch (NumberFormatException ignored) {
                            }
                        }
                        version = new int[versions.size()];
                        Iterator<Integer> iterator = versions.iterator();
                        for (int index = 0; index < versions.size(); index++) {
                            version[versions.size() - index - 1] = iterator.next();
                        }
                    } else {
                        version = NO_MULTI_RELEASE;
                    }
                } else {
                    version = NO_MULTI_RELEASE;
                }
                return new ForFolder(version, folder);
            }
        }
        protected byte[] doLocate(String path) throws IOException {
            File file = new File(folder, path);
            if (file.exists()) {
                InputStream inputStream = new FileInputStream(file);
                try {
                    return StreamDrainer.DEFAULT.drain(inputStream);
                } finally {
                    inputStream.close();
                }
            } else {
                return null;
            }
        }
        public void close() {
        }
    }
    class ForUrl implements ClassFileLocator {
        private final ClassLoader classLoader;
        public ForUrl(URL... url) {
            classLoader = doPrivileged(new ClassLoaderCreationAction(url));
        }
        public ForUrl(Collection<? extends URL> urls) {
            this(urls.toArray(new URL[0]));
        }
        private static <T> T doPrivileged(PrivilegedAction<T> action) {
            return action.run();
        }
        public Resolution locate(String name) throws IOException {
            return ForClassLoader.locate(classLoader, name);
        }
        public void close() throws IOException {
            if (classLoader instanceof Closeable) {
                ((Closeable) classLoader).close();
            }
        }
        protected static class ClassLoaderCreationAction implements PrivilegedAction<ClassLoader> {
            private final URL[] url;
            protected ClassLoaderCreationAction(URL[] url) {
                this.url = url;
            }
            public ClassLoader run() {
                return new URLClassLoader(url, ClassLoadingStrategy.BOOTSTRAP_LOADER);
            }
        }
    }
    class ForInstrumentation implements ClassFileLocator {
        private static final Dispatcher DISPATCHER = doPrivileged(JavaDispatcher.of(Dispatcher.class));
        private final Instrumentation instrumentation;
        private final ClassLoadingDelegate classLoadingDelegate;
        public ForInstrumentation(Instrumentation instrumentation, @MaybeNull ClassLoader classLoader) {
            this(instrumentation, ClassLoadingDelegate.Default.of(classLoader));
        }
        private static <T> T doPrivileged(PrivilegedAction<T> action) {
            return action.run();
        }
        public ForInstrumentation(Instrumentation instrumentation, ClassLoadingDelegate classLoadingDelegate) {
            if (!DISPATCHER.isRetransformClassesSupported(instrumentation)) {
                throw new IllegalArgumentException(instrumentation + " does not support retransformation");
            }
            this.instrumentation = instrumentation;
            this.classLoadingDelegate = classLoadingDelegate;
        }
        private static Instrumentation resolveByteBuddyAgentInstrumentation() {
            try {
                Class<?> installer = ClassLoader.getSystemClassLoader().loadClass("net.bytebuddy.agent.Installer");
                JavaModule source = JavaModule.ofType(AgentBuilder.class), target = JavaModule.ofType(installer);
                if (source != null && !source.canRead(target)) {
                    Class<?> module = Class.forName("java.lang.Module");
                    module.getMethod("addReads", module).invoke(source.unwrap(), target.unwrap());
                }
                return (Instrumentation) installer.getMethod("getInstrumentation").invoke(null);
            } catch (RuntimeException exception) {
                throw exception;
            } catch (Exception exception) {
                throw new IllegalStateException("The Byte Buddy agent is not installed or not accessible", exception);
            }
        }
        public static ClassFileLocator fromInstalledAgent(@MaybeNull ClassLoader classLoader) {
            return new ForInstrumentation(resolveByteBuddyAgentInstrumentation(), classLoader);
        }
        public static ClassFileLocator of(Instrumentation instrumentation, Class<?> type) {
            return new ForInstrumentation(instrumentation, ClassLoadingDelegate.Explicit.of(type));
        }
        public Resolution locate(String name) {
            try {
                ExtractionClassFileTransformer classFileTransformer = new ExtractionClassFileTransformer(classLoadingDelegate.getClassLoader(), name);
                DISPATCHER.addTransformer(instrumentation, classFileTransformer, true);
                try {
                    DISPATCHER.retransformClasses(instrumentation, new Class<?>[] { classLoadingDelegate.locate(name) });
                    byte[] binaryRepresentation = classFileTransformer.getBinaryRepresentation();
                    return binaryRepresentation == null ? new Resolution.Illegal(name) : new Resolution.Explicit(binaryRepresentation);
                } finally {
                    instrumentation.removeTransformer(classFileTransformer);
                }
            } catch (RuntimeException exception) {
                throw exception;
            } catch (Exception ignored) {
                return new Resolution.Illegal(name);
            }
        }
        public void close() {
        }
        protected interface Dispatcher {
            boolean isRetransformClassesSupported(Instrumentation instrumentation);
            void addTransformer(Instrumentation instrumentation, ClassFileTransformer classFileTransformer, boolean canRetransform);
            void retransformClasses(Instrumentation instrumentation, Class<?>[] type) throws UnmodifiableClassException;
        }
        public interface ClassLoadingDelegate {
            Class<?> locate(String name) throws ClassNotFoundException;
            ClassLoader getClassLoader();
            class Default implements ClassLoadingDelegate {
                private static final ClassLoader BOOT_LOADER_PROXY = doPrivileged(BootLoaderProxyCreationAction.INSTANCE);
                protected final ClassLoader classLoader;
                protected Default(ClassLoader classLoader) {
                    this.classLoader = classLoader;
                }
                public static ClassLoadingDelegate of(@MaybeNull ClassLoader classLoader) {
                    return ForDelegatingClassLoader.isDelegating(classLoader) ? new ForDelegatingClassLoader(classLoader) : new Default(classLoader == null ? BOOT_LOADER_PROXY : classLoader);
                }
                public Class<?> locate(String name) throws ClassNotFoundException {
                    return classLoader.loadClass(name);
                }
                public ClassLoader getClassLoader() {
                    return classLoader == BOOT_LOADER_PROXY ? ClassLoadingStrategy.BOOTSTRAP_LOADER : classLoader;
                }
                protected enum BootLoaderProxyCreationAction implements PrivilegedAction<ClassLoader> {
                    INSTANCE;
                    public ClassLoader run() {
                        return new URLClassLoader(new URL[0], ClassLoadingStrategy.BOOTSTRAP_LOADER);
                    }
                }
            }
            class ForDelegatingClassLoader extends Default {
                private static final String DELEGATING_CLASS_LOADER_NAME = "sun.reflect.DelegatingClassLoader";
                private static final int ONLY = 0;
                private static final Dispatcher.Initializable DISPATCHER = doPrivileged(Dispatcher.CreationAction.INSTANCE);
                protected ForDelegatingClassLoader(ClassLoader classLoader) {
                    super(classLoader);
                }
                private static <T> T doPrivileged(PrivilegedAction<T> action) {
                    return action.run();
                }
                protected static boolean isDelegating(@MaybeNull ClassLoader classLoader) {
                    return classLoader != null && classLoader.getClass().getName().equals(DELEGATING_CLASS_LOADER_NAME);
                }
                public Class<?> locate(String name) throws ClassNotFoundException {
                    Vector<Class<?>> classes;
                    try {
                        classes = DISPATCHER.initialize().extract(classLoader);
                    } catch (RuntimeException ignored) {
                        return super.locate(name);
                    }
                    if (classes.size() != 1) {
                        return super.locate(name);
                    }
                    Class<?> type = classes.get(ONLY);
                    return TypeDescription.ForLoadedType.getName(type).equals(name) ? type : super.locate(name);
                }
                protected interface Dispatcher {
                    Vector<Class<?>> extract(ClassLoader classLoader);
                    interface Initializable {
                        Dispatcher initialize();
                    }
                    enum CreationAction implements PrivilegedAction<Initializable> {
                        INSTANCE;
                        public Initializable run() {
                            try {
                                return new Dispatcher.Resolved(ClassLoader.class.getDeclaredField("classes"));
                            } catch (Exception exception) {
                                return new Dispatcher.Unresolved(exception.getMessage());
                            }
                        }
                    }
                    class Resolved implements Dispatcher, Initializable, PrivilegedAction<Dispatcher> {
                        private final Field field;
                        public Resolved(Field field) {
                            this.field = field;
                        }
                        private static <T> T doPrivileged(PrivilegedAction<T> action) {
                            return action.run();
                        }
                        public Dispatcher initialize() {
                            return doPrivileged(this);
                        }
                        public Vector<Class<?>> extract(ClassLoader classLoader) {
                            try {
                                return (Vector<Class<?>>) field.get(classLoader);
                            } catch (IllegalAccessException exception) {
                                throw new IllegalStateException("Cannot access field", exception);
                            }
                        }
                        public Dispatcher run() {
                            field.setAccessible(true);
                            return this;
                        }
                    }
                    class Unresolved implements Initializable {
                        private final String message;
                        public Unresolved(String message) {
                            this.message = message;
                        }
                        public Dispatcher initialize() {
                            throw new UnsupportedOperationException("Could not locate classes vector: " + message);
                        }
                    }
                }
            }
            class Explicit implements ClassLoadingDelegate {
                private final ClassLoadingDelegate fallbackDelegate;
                private final Map<String, Class<?>> types;
                public Explicit(@MaybeNull ClassLoader classLoader, Collection<? extends Class<?>> types) {
                    this(Default.of(classLoader), types);
                }
                public Explicit(ClassLoadingDelegate fallbackDelegate, Collection<? extends Class<?>> types) {
                    this.fallbackDelegate = fallbackDelegate;
                    this.types = new HashMap<String, Class<?>>();
                    for (Class<?> type : types) {
                        this.types.put(TypeDescription.ForLoadedType.getName(type), type);
                    }
                }
                public static ClassLoadingDelegate of(Class<?> type) {
                    return new Explicit(type.getClassLoader(), Collections.singleton(type));
                }
                public Class<?> locate(String name) throws ClassNotFoundException {
                    Class<?> type = types.get(name);
                    return type == null ? fallbackDelegate.locate(name) : type;
                }
                public ClassLoader getClassLoader() {
                    return fallbackDelegate.getClassLoader();
                }
            }
        }
        protected static class ExtractionClassFileTransformer implements ClassFileTransformer {
            private static final byte[] DO_NOT_TRANSFORM = null;
            private final ClassLoader classLoader;
            private final String typeName;
            private volatile byte[] binaryRepresentation;
            protected ExtractionClassFileTransformer(@MaybeNull ClassLoader classLoader, String typeName) {
                this.classLoader = classLoader;
                this.typeName = typeName;
            }
            public byte[] transform(@MaybeNull ClassLoader classLoader, @MaybeNull String internalName, @MaybeNull Class<?> redefinedType, @MaybeNull ProtectionDomain protectionDomain, byte[] binaryRepresentation) {
                if (internalName != null && isChildOf(this.classLoader).matches(classLoader) && typeName.equals(internalName.replace('/', '.'))) {
                    this.binaryRepresentation = binaryRepresentation.clone();
                }
                return DO_NOT_TRANSFORM;
            }
            protected byte[] getBinaryRepresentation() {
                return binaryRepresentation;
            }
        }
    }
    class PackageDiscriminating implements ClassFileLocator {
        private final Map<String, ClassFileLocator> classFileLocators;
        public PackageDiscriminating(Map<String, ClassFileLocator> classFileLocators) {
            this.classFileLocators = classFileLocators;
        }
        public Resolution locate(String name) throws IOException {
            int packageIndex = name.lastIndexOf('.');
            ClassFileLocator classFileLocator = classFileLocators.get(packageIndex == -1 ? NamedElement.EMPTY_NAME : name.substring(0, packageIndex));
            return classFileLocator == null ? new Resolution.Illegal(name) : classFileLocator.locate(name);
        }
        public void close() throws IOException {
            for (ClassFileLocator classFileLocator : classFileLocators.values()) {
                classFileLocator.close();
            }
        }
    }
    class Filtering implements ClassFileLocator {
        private final ElementMatcher<? super String> matcher;
        private final ClassFileLocator delegate;
        public Filtering(ElementMatcher<? super String> matcher, ClassFileLocator delegate) {
            this.matcher = matcher;
            this.delegate = delegate;
        }
        public Resolution locate(String name) throws IOException {
            return matcher.matches(name) ? delegate.locate(name) : new Resolution.Illegal(name);
        }
        public void close() throws IOException {
            delegate.close();
        }
    }
    class Compound implements ClassFileLocator, Closeable {
        private final List<ClassFileLocator> classFileLocators;
        public Compound(ClassFileLocator... classFileLocator) {
            this(Arrays.asList(classFileLocator));
        }
        public Compound(List<? extends ClassFileLocator> classFileLocators) {
            this.classFileLocators = new ArrayList<ClassFileLocator>();
            for (ClassFileLocator classFileLocator : classFileLocators) {
                if (classFileLocator instanceof Compound) {
                    this.classFileLocators.addAll(((Compound) classFileLocator).classFileLocators);
                } else if (!(classFileLocator instanceof NoOp)) {
                    this.classFileLocators.add(classFileLocator);
                }
            }
        }
        public Resolution locate(String name) throws IOException {
            for (ClassFileLocator classFileLocator : classFileLocators) {
                Resolution resolution = classFileLocator.locate(name);
                if (resolution.isResolved()) {
                    return resolution;
                }
            }
            return new Resolution.Illegal(name);
        }
        public void close() throws IOException {
            for (ClassFileLocator classFileLocator : classFileLocators) {
                classFileLocator.close();
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```