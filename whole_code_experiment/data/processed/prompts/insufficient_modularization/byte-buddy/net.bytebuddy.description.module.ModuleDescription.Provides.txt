##CONTEXT_SIZE=3541
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.description.module;
public interface ModuleDescription extends NamedElement, ModifierReviewable.ForModuleDescription, AnnotationSource {
    String MODULE_CLASS_NAME = "module-info";
    ModuleDescription UNDEFINED = null;
    void accept(ClassVisitor classVisitor);
    String getVersion();
    String getMainClass();
    Set<String> getPackages();
    Map<String, Exports> getExports();
    Map<String, Opens> getOpens();
    Map<String, Requires> getRequires();
    Set<String> getUses();
    Map<String, Provides> getProvides();
    interface Exports extends ModifierReviewable.OfMandatable {
        Set<String> getTargets();
        boolean isQualified();
        abstract class AbstractBase extends ModifierReviewable.AbstractBase implements Exports {
            public boolean isQualified() {
                return !getTargets().isEmpty();
            }
            public int hashCode() {
                int hashCode = getModifiers();
                return hashCode + 17 * getTargets().hashCode();
            }
            public boolean equals(Object other) {
                if (!(other instanceof Exports))
                    return false;
                Exports exports = (Exports) other;
                return getModifiers() == exports.getModifiers() && getTargets().equals(exports.getTargets());
            }
            public String toString() {
                return "Opens{" + "targets=" + getTargets() + ",modifiers=" + getModifiers() + '}';
            }
        }
        class Simple extends AbstractBase {
            private final Set<String> targets;
            protected final int modifiers;
            public Simple(Set<String> targets, int modifiers) {
                this.targets = targets;
                this.modifiers = modifiers;
            }
            public Set<String> getTargets() {
                return targets;
            }
            public int getModifiers() {
                return modifiers;
            }
        }
    }
    interface Opens extends ModifierReviewable.OfMandatable {
        Set<String> getTargets();
        boolean isQualified();
        abstract class AbstractBase extends ModifierReviewable.AbstractBase implements Opens {
            public boolean isQualified() {
                return !getTargets().isEmpty();
            }
            public int hashCode() {
                int hashCode = getModifiers();
                return hashCode + 17 * getTargets().hashCode();
            }
            public boolean equals(Object other) {
                if (!(other instanceof Opens))
                    return false;
                Opens opens = (Opens) other;
                return getModifiers() == opens.getModifiers() && getTargets().equals(opens.getTargets());
            }
            public String toString() {
                return "Opens{" + "targets=" + getTargets() + ",modifiers=" + getModifiers() + '}';
            }
        }
        class Simple extends AbstractBase {
            private final Set<String> targets;
            protected final int modifiers;
            public Simple(Set<String> targets, int modifiers) {
                this.targets = targets;
                this.modifiers = modifiers;
            }
            public Set<String> getTargets() {
                return targets;
            }
            public int getModifiers() {
                return modifiers;
            }
        }
    }
    interface Requires extends ModifierReviewable.ForModuleRequirement {
        String getVersion();
        abstract class AbstractBase extends ModifierReviewable.AbstractBase implements Requires {
            public int hashCode() {
                int hashCode = getModifiers();
                String version = getVersion();
                return version == null ? hashCode : (hashCode + 17 * version.hashCode());
            }
            public boolean equals(Object other) {
                if (!(other instanceof Requires))
                    return false;
                Requires requires = (Requires) other;
                String version = getVersion();
                return getModifiers() == requires.getModifiers() && version == null ? requires.getVersion() == null : version.equals(requires.getVersion());
            }
            public String toString() {
                String version = getVersion();
                return "Requires{" + "version=" + (version == null ? "" : '"' + version + '\'') + ",modifiers=" + getModifiers() + '}';
            }
        }
        class Simple extends AbstractBase {
            private final String version;
            private final int modifiers;
            public Simple(@MaybeNull String version, int modifiers) {
                this.version = version;
                this.modifiers = modifiers;
            }
            public String getVersion() {
                return version;
            }
            public int getModifiers() {
                return modifiers;
            }
        }
    }
    interface Provides {
        Set<String> getProviders();
        abstract class AbstractBase implements Provides {
            public int hashCode() {
                return getProviders().hashCode();
            }
            public boolean equals(Object other) {
                if (!(other instanceof Provides))
                    return false;
                Provides provides = (Provides) other;
                return getProviders().equals(provides.getProviders());
            }
            public String toString() {
                return "Provides{providers=" + getProviders() + '}';
            }
        }
        class Simple extends AbstractBase {
            private final Set<String> providers;
            public Simple(Set<String> providers) {
                this.providers = providers;
            }
            public Set<String> getProviders() {
                return providers;
            }
        }
    }
    abstract class AbstractBase extends ModifierReviewable.AbstractBase implements ModuleDescription {
        public void accept(ClassVisitor classVisitor) {
            ModuleVisitor moduleVisitor = classVisitor.visitModule(getActualName(), getModifiers(), getVersion());
            if (moduleVisitor != null) {
                String mainClass = getMainClass();
                if (mainClass != null) {
                    moduleVisitor.visitMainClass(mainClass.replace('.', '/'));
                }
                for (String aPackage : getPackages()) {
                    moduleVisitor.visitPackage(aPackage.replace('.', '/'));
                }
                for (Map.Entry<String, ModuleDescription.Requires> entry : getRequires().entrySet()) {
                    moduleVisitor.visitRequire(entry.getKey(), entry.getValue().getModifiers(), entry.getValue().getVersion());
                }
                for (Map.Entry<String, ModuleDescription.Exports> entry : getExports().entrySet()) {
                    moduleVisitor.visitExport(entry.getKey().replace('.', '/'), entry.getValue().getModifiers(), entry.getValue().getTargets().isEmpty() ? null : entry.getValue().getTargets().toArray(new String[0]));
                }
                for (Map.Entry<String, ModuleDescription.Opens> entry : getOpens().entrySet()) {
                    moduleVisitor.visitOpen(entry.getKey().replace('.', '/'), entry.getValue().getModifiers(), entry.getValue().getTargets().isEmpty() ? null : entry.getValue().getTargets().toArray(new String[0]));
                }
                for (String use : getUses()) {
                    moduleVisitor.visitUse(use.replace('.', '/'));
                }
                for (Map.Entry<String, ModuleDescription.Provides> entry : getProvides().entrySet()) {
                    String[] provider = entry.getValue().getProviders().isEmpty() ? null : new String[entry.getValue().getProviders().size()];
                    if (provider != null) {
                        Iterator<String> iterator = entry.getValue().getProviders().iterator();
                        for (int index = 0; index < provider.length; index++) {
                            provider[index] = iterator.next().replace('.', '/');
                        }
                    }
                    moduleVisitor.visitProvide(entry.getKey().replace('.', '/'), provider);
                }
                moduleVisitor.visitEnd();
            }
        }
        public int hashCode() {
            return 17 * getActualName().hashCode();
        }
        public boolean equals(Object other) {
            if (!(other instanceof ModuleDescription))
                return false;
            ModuleDescription module = (ModuleDescription) other;
            return getActualName().equals(module.getActualName());
        }
        public String toString() {
            return "module " + getActualName();
        }
    }
    class ForLoadedModule extends AbstractBase {
        protected static final Module MODULE = doPrivileged(JavaDispatcher.of(Module.class));
        protected static final ModuleDescriptor MODULE_DESCRIPTOR = doPrivileged(JavaDispatcher.of(ModuleDescriptor.class));
        protected static final ModuleDescriptor.Exports MODULE_DESCRIPTOR_EXPORTS = doPrivileged(JavaDispatcher.of(ModuleDescriptor.Exports.class));
        protected static final ModuleDescriptor.Opens MODULE_DESCRIPTOR_OPENS = doPrivileged(JavaDispatcher.of(ModuleDescriptor.Opens.class));
        protected static final ModuleDescriptor.Requires MODULE_DESCRIPTOR_REQUIRES = doPrivileged(JavaDispatcher.of(ModuleDescriptor.Requires.class));
        protected static final ModuleDescriptor.Provides MODULE_DESCRIPTOR_PROVIDES = doPrivileged(JavaDispatcher.of(ModuleDescriptor.Provides.class));
        protected static final Optional OPTIONAL = doPrivileged(JavaDispatcher.of(Optional.class));
        private final AnnotatedElement module;
        public static ModuleDescription of(Object module) {
            if (!MODULE.isInstance(module)) {
                throw new IllegalArgumentException("Not a Java module: " + module);
            } else if (!MODULE.isNamed(module)) {
                throw new IllegalArgumentException("Not a named module: " + module);
            }
            return new ForLoadedModule((AnnotatedElement) module);
        }
        private static <T> T doPrivileged(PrivilegedAction<T> action) {
            return action.run();
        }
        protected ForLoadedModule(AnnotatedElement module) {
            this.module = module;
        }
        public String getVersion() {
            return (String) OPTIONAL.orElse(MODULE_DESCRIPTOR.rawVersion(MODULE.getDescriptor(module)), null);
        }
        public String getMainClass() {
            return (String) OPTIONAL.orElse(MODULE_DESCRIPTOR.mainClass(MODULE.getDescriptor(module)), null);
        }
        public boolean isOpen() {
            return MODULE_DESCRIPTOR.isOpen(MODULE.getDescriptor(module));
        }
        public Set<String> getPackages() {
            return MODULE_DESCRIPTOR.packages(MODULE.getDescriptor(module));
        }
        public Set<String> getUses() {
            return MODULE_DESCRIPTOR.uses(MODULE.getDescriptor(module));
        }
        public Map<String, Exports> getExports() {
            Map<String, Exports> exports = new LinkedHashMap<String, Exports>();
            for (Object export : MODULE_DESCRIPTOR.exports(MODULE.getDescriptor(module))) {
                int modifiers = 0;
                for (Enum<?> modifier : MODULE_DESCRIPTOR_EXPORTS.modifiers(export)) {
                    String name = modifier.name();
                    if (name.equals("SYNTHETIC")) {
                        modifiers |= Opcodes.ACC_SYNTHETIC;
                    } else if (name.equals("MANDATED")) {
                        modifiers |= Opcodes.ACC_MANDATED;
                    } else {
                        throw new IllegalStateException("Unknown export modifier: " + name);
                    }
                }
                exports.put(MODULE_DESCRIPTOR_EXPORTS.source(export), new Exports.Simple(MODULE_DESCRIPTOR_EXPORTS.targets(export), modifiers));
            }
            return exports;
        }
        public Map<String, Opens> getOpens() {
            Map<String, Opens> opens = new LinkedHashMap<String, Opens>();
            for (Object open : MODULE_DESCRIPTOR.opens(MODULE.getDescriptor(module))) {
                int modifiers = 0;
                for (Enum<?> modifier : MODULE_DESCRIPTOR_OPENS.modifiers(open)) {
                    String name = modifier.name();
                    if (name.equals("SYNTHETIC")) {
                        modifiers |= Opcodes.ACC_SYNTHETIC;
                    } else if (name.equals("MANDATED")) {
                        modifiers |= Opcodes.ACC_MANDATED;
                    } else {
                        throw new IllegalStateException("Unknown opens modifier: " + name);
                    }
                }
                opens.put(MODULE_DESCRIPTOR_OPENS.source(open), new Opens.Simple(MODULE_DESCRIPTOR_OPENS.targets(open), modifiers));
            }
            return opens;
        }
        public Map<String, Requires> getRequires() {
            Map<String, Requires> requires = new LinkedHashMap<String, Requires>();
            for (Object require : MODULE_DESCRIPTOR.requires(MODULE.getDescriptor(module))) {
                int modifiers = 0;
                for (Enum<?> modifier : MODULE_DESCRIPTOR_REQUIRES.modifiers(require)) {
                    String name = modifier.name();
                    if (name.equals("SYNTHETIC")) {
                        modifiers |= Opcodes.ACC_SYNTHETIC;
                    } else if (name.equals("MANDATED")) {
                        modifiers |= Opcodes.ACC_MANDATED;
                    } else if (name.equals("TRANSITIVE")) {
                        modifiers |= Opcodes.ACC_TRANSITIVE;
                    } else if (name.equals("STATIC")) {
                        modifiers |= Opcodes.ACC_STATIC_PHASE;
                    } else {
                        throw new IllegalStateException("Unknown requires modifier: " + name);
                    }
                }
                requires.put(MODULE_DESCRIPTOR_REQUIRES.name(require), new Requires.Simple((String) OPTIONAL.orElse(MODULE_DESCRIPTOR_REQUIRES.rawCompiledVersion(require), null), modifiers));
            }
            return requires;
        }
        public Map<String, Provides> getProvides() {
            Map<String, Provides> provides = new LinkedHashMap<String, Provides>();
            for (Object require : MODULE_DESCRIPTOR.provides(MODULE.getDescriptor(module))) {
                provides.put(MODULE_DESCRIPTOR_PROVIDES.service(require), new Provides.Simple(new LinkedHashSet<String>(MODULE_DESCRIPTOR_PROVIDES.providers(require))));
            }
            return provides;
        }
        public int getModifiers() {
            int modifiers = 0;
            for (Enum<?> modifier : MODULE_DESCRIPTOR.modifiers(MODULE.getDescriptor(module))) {
                String name = modifier.name();
                if (name.equals("SYNTHETIC")) {
                    modifiers |= Opcodes.ACC_SYNTHETIC;
                } else if (name.equals("MANDATED")) {
                    modifiers |= Opcodes.ACC_MANDATED;
                } else if (name.equals("OPEN")) {
                    modifiers |= Opcodes.ACC_OPEN;
                } else {
                    throw new IllegalStateException("Unknown module modifier: " + name);
                }
            }
            return modifiers;
        }
        public String getActualName() {
            return MODULE_DESCRIPTOR.name(MODULE.getDescriptor(module));
        }
        public AnnotationList getDeclaredAnnotations() {
            return new AnnotationList.ForLoadedAnnotations(module.getDeclaredAnnotations());
        }
        protected interface Module {
            boolean isInstance(Object value);
            boolean isNamed(Object value);
            String getName(Object value);
            Set<String> getPackages(Object value);
            Object getDescriptor(Object value);
        }
        protected interface ModuleDescriptor {
            String name(Object value);
            Set<Enum<?>> modifiers(Object value);
            boolean isOpen(Object value);
            Set<?> requires(Object value);
            Set<?> exports(Object value);
            Set<?> opens(Object value);
            Set<String> uses(Object value);
            Set<?> provides(Object value);
            Object rawVersion(Object value);
            Object mainClass(Object value);
            Set<String> packages(Object value);
            interface Requires {
                String name(Object value);
                Set<Enum<?>> modifiers(Object value);
                Object rawCompiledVersion(Object value);
            }
            interface Exports {
                String source(Object value);
                Set<Enum<?>> modifiers(Object value);
                Set<String> targets(Object value);
            }
            interface Opens {
                String source(Object value);
                Set<Enum<?>> modifiers(Object value);
                Set<String> targets(Object value);
            }
            interface Provides {
                String service(Object value);
                List<String> providers(Object value);
            }
        }
        protected interface Optional {
            Object orElse(Object value, @MaybeNull Object fallback);
        }
    }
    class Latent extends AbstractBase {
        private final String name;
        private final int modifiers;
        private final String version;
        private final String mainClass;
        private final Set<String> packages;
        private final Map<String, ModuleDescription.Requires> requires;
        private final Map<String, ModuleDescription.Exports> exports;
        private final Map<String, ModuleDescription.Opens> opens;
        private final Set<String> uses;
        private final Map<String, ModuleDescription.Provides> provides;
        private final List<? extends AnnotationDescription> annotations;
        public Latent(String name, int modifiers, @MaybeNull String version, @MaybeNull String mainClass, Set<String> packages, Map<String, Requires> requires, Map<String, Exports> exports, Map<String, Opens> opens, Set<String> uses, Map<String, Provides> provides, List<? extends AnnotationDescription> annotations) {
            this.name = name;
            this.modifiers = modifiers;
            this.version = version;
            this.mainClass = mainClass;
            this.packages = packages;
            this.requires = requires;
            this.exports = exports;
            this.opens = opens;
            this.uses = uses;
            this.provides = provides;
            this.annotations = annotations;
        }
        public String getVersion() {
            return version;
        }
        public String getMainClass() {
            return mainClass;
        }
        public Set<String> getPackages() {
            return packages;
        }
        public Map<String, Exports> getExports() {
            return exports;
        }
        public Map<String, Opens> getOpens() {
            return opens;
        }
        public Map<String, Requires> getRequires() {
            return requires;
        }
        public Set<String> getUses() {
            return uses;
        }
        public Map<String, Provides> getProvides() {
            return provides;
        }
        public int getModifiers() {
            return modifiers;
        }
        public String getActualName() {
            return name;
        }
        public AnnotationList getDeclaredAnnotations() {
            return new AnnotationList.Explicit(annotations);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```