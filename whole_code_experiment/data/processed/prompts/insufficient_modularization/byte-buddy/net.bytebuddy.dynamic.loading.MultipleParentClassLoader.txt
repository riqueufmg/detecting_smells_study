##CONTEXT_SIZE=1506
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.dynamic.loading;
public class MultipleParentClassLoader extends InjectionClassLoader {
    static {
        doRegisterAsParallelCapable();
    }
    private static void doRegisterAsParallelCapable() {
        try {
            Method method = ClassLoader.class.getDeclaredMethod("registerAsParallelCapable");
            method.setAccessible(true);
            method.invoke(null);
        } catch (Throwable ignored) {
        }
    }
    private final List<? extends ClassLoader> parents;
    public MultipleParentClassLoader(List<? extends ClassLoader> parents) {
        this(ClassLoadingStrategy.BOOTSTRAP_LOADER, parents);
    }
    public MultipleParentClassLoader(@MaybeNull ClassLoader parent, List<? extends ClassLoader> parents) {
        this(parent, parents, true);
    }
    public MultipleParentClassLoader(@MaybeNull ClassLoader parent, List<? extends ClassLoader> parents, boolean sealed) {
        super(parent, sealed);
        this.parents = parents;
    }
    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        for (ClassLoader parent : parents) {
            try {
                Class<?> type = parent.loadClass(name);
                if (resolve) {
                    resolveClass(type);
                }
                return type;
            } catch (ClassNotFoundException ignored) {
            }
        }
        return super.loadClass(name, resolve);
    }
    public URL getResource(String name) {
        for (ClassLoader parent : parents) {
            URL url = parent.getResource(name);
            if (url != null) {
                return url;
            }
        }
        return super.getResource(name);
    }
    public Enumeration<URL> getResources(String name) throws IOException {
        List<Enumeration<URL>> enumerations = new ArrayList<Enumeration<URL>>(parents.size() + 1);
        for (ClassLoader parent : parents) {
            enumerations.add(parent.getResources(name));
        }
        enumerations.add(super.getResources(name));
        return new CompoundEnumeration(enumerations);
    }
    protected Map<String, Class<?>> doDefineClasses(Map<String, byte[]> typeDefinitions) {
        Map<String, Class<?>> types = new HashMap<String, Class<?>>();
        for (Map.Entry<String, byte[]> entry : typeDefinitions.entrySet()) {
            types.put(entry.getKey(), defineClass(entry.getKey(), entry.getValue(), 0, entry.getValue().length));
        }
        return types;
    }
    protected static class CompoundEnumeration implements Enumeration<URL> {
        private static final int FIRST = 0;
        private final List<Enumeration<URL>> enumerations;
        private Enumeration<URL> current;
        protected CompoundEnumeration(List<Enumeration<URL>> enumerations) {
            this.enumerations = enumerations;
        }
        public boolean hasMoreElements() {
            if (current != null && current.hasMoreElements()) {
                return true;
            } else if (!enumerations.isEmpty()) {
                current = enumerations.remove(FIRST);
                return hasMoreElements();
            } else {
                return false;
            }
        }
        public URL nextElement() {
            if (hasMoreElements()) {
                return current.nextElement();
            } else {
                throw new NoSuchElementException();
            }
        }
    }
    public static class Builder {
        private final boolean sealed;
        private final List<? extends ClassLoader> classLoaders;
        public Builder() {
            this(true);
        }
        public Builder(boolean sealed) {
            this(Collections.<ClassLoader>emptyList(), sealed);
        }
        private Builder(List<? extends ClassLoader> classLoaders, boolean sealed) {
            this.classLoaders = classLoaders;
            this.sealed = sealed;
        }
        public Builder append(Class<?>... type) {
            return append(Arrays.asList(type));
        }
        public Builder append(Collection<? extends Class<?>> types) {
            List<ClassLoader> classLoaders = new ArrayList<ClassLoader>(types.size());
            for (Class<?> type : types) {
                classLoaders.add(type.getClassLoader());
            }
            return append(classLoaders);
        }
        public Builder append(ClassLoader... classLoader) {
            return append(Arrays.asList(classLoader));
        }
        public Builder append(List<? extends ClassLoader> classLoaders) {
            List<ClassLoader> filtered = new ArrayList<ClassLoader>(this.classLoaders.size() + classLoaders.size());
            filtered.addAll(this.classLoaders);
            Set<ClassLoader> registered = new HashSet<ClassLoader>(this.classLoaders);
            for (ClassLoader classLoader : classLoaders) {
                if (classLoader != null && registered.add(classLoader)) {
                    filtered.add(classLoader);
                }
            }
            return new Builder(filtered, sealed);
        }
        public Builder appendMostSpecific(Class<?>... type) {
            return appendMostSpecific(Arrays.asList(type));
        }
        public Builder appendMostSpecific(Collection<? extends Class<?>> types) {
            List<ClassLoader> classLoaders = new ArrayList<ClassLoader>(types.size());
            for (Class<?> type : types) {
                classLoaders.add(type.getClassLoader());
            }
            return appendMostSpecific(classLoaders);
        }
        public Builder appendMostSpecific(ClassLoader... classLoader) {
            return appendMostSpecific(Arrays.asList(classLoader));
        }
        public Builder appendMostSpecific(List<? extends ClassLoader> classLoaders) {
            List<ClassLoader> filtered = new ArrayList<ClassLoader>(this.classLoaders.size() + classLoaders.size());
            filtered.addAll(this.classLoaders);
            consideration: for (ClassLoader classLoader : classLoaders) {
                if (classLoader == null) {
                    continue;
                }
                ClassLoader candidate = classLoader;
                do {
                    Iterator<ClassLoader> iterator = filtered.iterator();
                    while (iterator.hasNext()) {
                        ClassLoader previous = iterator.next();
                        if (previous.equals(candidate)) {
                            iterator.remove();
                        }
                    }
                } while ((candidate = candidate.getParent()) != null);
                for (ClassLoader previous : filtered) {
                    do {
                        if (previous.equals(classLoader)) {
                            continue consideration;
                        }
                    } while ((previous = previous.getParent()) != null);
                }
                filtered.add(classLoader);
            }
            return new Builder(filtered, sealed);
        }
        public Builder filter(ElementMatcher<? super ClassLoader> matcher) {
            List<ClassLoader> classLoaders = new ArrayList<ClassLoader>(this.classLoaders.size());
            for (ClassLoader classLoader : this.classLoaders) {
                if (matcher.matches(classLoader)) {
                    classLoaders.add(classLoader);
                }
            }
            return new Builder(classLoaders, sealed);
        }
        public ClassLoader build() {
            return classLoaders.size() == 1 ? classLoaders.get(0) : doBuild(ClassLoadingStrategy.BOOTSTRAP_LOADER);
        }
        public ClassLoader build(ClassLoader parent) {
            return classLoaders.isEmpty() || classLoaders.size() == 1 && classLoaders.contains(parent) ? parent : filter(not(is(parent))).doBuild(parent);
        }
        private ClassLoader doBuild(@MaybeNull ClassLoader parent) {
            return new MultipleParentClassLoader(parent, classLoaders, sealed);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```