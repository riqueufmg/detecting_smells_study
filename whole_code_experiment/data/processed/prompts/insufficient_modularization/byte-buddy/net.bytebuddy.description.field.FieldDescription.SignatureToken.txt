##CONTEXT_SIZE=2154
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.description.field;
public interface FieldDescription extends ModifierReviewable.ForFieldDescription, DeclaredByType.WithMandatoryDeclaration, ByteCodeElement.Member, ByteCodeElement.TypeDependant<FieldDescription.InDefinedShape, FieldDescription.Token> {
    Object NO_DEFAULT_VALUE = null;
    TypeDefinition getDeclaringType();
    TypeDescription.Generic getType();
    int getActualModifiers();
    SignatureToken asSignatureToken();
    interface InGenericShape extends FieldDescription {
        TypeDescription.Generic getDeclaringType();
    }
    interface InDefinedShape extends FieldDescription {
        TypeDescription getDeclaringType();
        abstract class AbstractBase extends FieldDescription.AbstractBase implements InDefinedShape {
            public InDefinedShape asDefined() {
                return this;
            }
        }
    }
    abstract class AbstractBase extends ModifierReviewable.AbstractBase implements FieldDescription {
        public String getInternalName() {
            return getName();
        }
        public String getActualName() {
            return getName();
        }
        public String getDescriptor() {
            return getType().asErasure().getDescriptor();
        }
        public String getGenericSignature() {
            TypeDescription.Generic fieldType = getType();
            try {
                return fieldType.getSort().isNonGeneric() ? NON_GENERIC_SIGNATURE : fieldType.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(new SignatureWriter())).toString();
            } catch (GenericSignatureFormatError ignored) {
                return NON_GENERIC_SIGNATURE;
            }
        }
        public boolean isVisibleTo(TypeDescription typeDescription) {
            return getDeclaringType().asErasure().isVisibleTo(typeDescription) && (isPublic() || typeDescription.equals(getDeclaringType().asErasure()) || isProtected() && getDeclaringType().asErasure().isAssignableFrom(typeDescription) || !isPrivate() && typeDescription.isSamePackage(getDeclaringType().asErasure()) || isPrivate() && typeDescription.isNestMateOf(getDeclaringType().asErasure()));
        }
        public boolean isAccessibleTo(TypeDescription typeDescription) {
            return isPublic() || typeDescription.equals(getDeclaringType().asErasure()) || !isPrivate() && typeDescription.isSamePackage(getDeclaringType().asErasure()) || isPrivate() && typeDescription.isNestMateOf(getDeclaringType().asErasure());
        }
        public int getActualModifiers() {
            return getModifiers() | (getDeclaredAnnotations().isAnnotationPresent(Deprecated.class) ? Opcodes.ACC_DEPRECATED : EMPTY_MASK);
        }
        public FieldDescription.Token asToken(ElementMatcher<? super TypeDescription> matcher) {
            return new FieldDescription.Token(getName(), getModifiers(), getType().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)), getDeclaredAnnotations());
        }
        public SignatureToken asSignatureToken() {
            return new SignatureToken(getInternalName(), getType().asErasure());
        }
        public int hashCode() {
            return getDeclaringType().hashCode() + 31 * (17 + getName().hashCode());
        }
        public boolean equals(@MaybeNull Object other) {
            if (this == other) {
                return true;
            } else if (!(other instanceof FieldDescription)) {
                return false;
            }
            FieldDescription fieldDescription = (FieldDescription) other;
            return getName().equals(fieldDescription.getName()) && getDeclaringType().equals(fieldDescription.getDeclaringType());
        }
        public String toGenericString() {
            StringBuilder stringBuilder = new StringBuilder();
            if (getModifiers() != EMPTY_MASK) {
                stringBuilder.append(Modifier.toString(getModifiers())).append(' ');
            }
            stringBuilder.append(getType().getActualName()).append(' ');
            stringBuilder.append(getDeclaringType().asErasure().getActualName()).append('.');
            return stringBuilder.append(getName()).toString();
        }
        public String toString() {
            StringBuilder stringBuilder = new StringBuilder();
            if (getModifiers() != EMPTY_MASK) {
                stringBuilder.append(Modifier.toString(getModifiers())).append(' ');
            }
            stringBuilder.append(getType().asErasure().getActualName()).append(' ');
            stringBuilder.append(getDeclaringType().asErasure().getActualName()).append('.');
            return stringBuilder.append(getName()).toString();
        }
    }
    class ForLoadedField extends InDefinedShape.AbstractBase {
        private final Field field;
        public ForLoadedField(Field field) {
            this.field = field;
        }
        public TypeDescription.Generic getType() {
            if (TypeDescription.AbstractBase.RAW_TYPES) {
                return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(field.getType());
            }
            return new TypeDescription.Generic.LazyProjection.ForLoadedFieldType(field);
        }
        public AnnotationList getDeclaredAnnotations() {
            return new AnnotationList.ForLoadedAnnotations(field.getDeclaredAnnotations());
        }
        public String getName() {
            return field.getName();
        }
        public TypeDescription getDeclaringType() {
            return TypeDescription.ForLoadedType.of(field.getDeclaringClass());
        }
        public int getModifiers() {
            return field.getModifiers();
        }
        public boolean isSynthetic() {
            return field.isSynthetic();
        }
    }
    class Latent extends InDefinedShape.AbstractBase {
        private final TypeDescription declaringType;
        private final String name;
        private final int modifiers;
        private final TypeDescription.Generic fieldType;
        private final List<? extends AnnotationDescription> declaredAnnotations;
        public Latent(TypeDescription declaringType, FieldDescription.Token token) {
            this(declaringType, token.getName(), token.getModifiers(), token.getType(), token.getAnnotations());
        }
        public Latent(TypeDescription declaringType, String name, int modifiers, TypeDescription.Generic fieldType, List<? extends AnnotationDescription> declaredAnnotations) {
            this.declaringType = declaringType;
            this.name = name;
            this.modifiers = modifiers;
            this.fieldType = fieldType;
            this.declaredAnnotations = declaredAnnotations;
        }
        public TypeDescription.Generic getType() {
            return fieldType.accept(TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(this));
        }
        public AnnotationList getDeclaredAnnotations() {
            return new AnnotationList.Explicit(declaredAnnotations);
        }
        public String getName() {
            return name;
        }
        public TypeDescription getDeclaringType() {
            return declaringType;
        }
        public int getModifiers() {
            return modifiers;
        }
    }
    class TypeSubstituting extends AbstractBase implements InGenericShape {
        private final TypeDescription.Generic declaringType;
        private final FieldDescription fieldDescription;
        private final TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor;
        public TypeSubstituting(TypeDescription.Generic declaringType, FieldDescription fieldDescription, TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
            this.declaringType = declaringType;
            this.fieldDescription = fieldDescription;
            this.visitor = visitor;
        }
        public TypeDescription.Generic getType() {
            return fieldDescription.getType().accept(visitor);
        }
        public AnnotationList getDeclaredAnnotations() {
            return fieldDescription.getDeclaredAnnotations();
        }
        public TypeDescription.Generic getDeclaringType() {
            return declaringType;
        }
        public int getModifiers() {
            return fieldDescription.getModifiers();
        }
        public String getName() {
            return fieldDescription.getName();
        }
        public InDefinedShape asDefined() {
            return fieldDescription.asDefined();
        }
    }
    class Token implements ByteCodeElement.Token<Token> {
        private final String name;
        private final int modifiers;
        private final TypeDescription.Generic type;
        private final List<? extends AnnotationDescription> annotations;
        public Token(String name, int modifiers, TypeDescription.Generic type) {
            this(name, modifiers, type, Collections.<AnnotationDescription>emptyList());
        }
        public Token(String name, int modifiers, TypeDescription.Generic type, List<? extends AnnotationDescription> annotations) {
            this.name = name;
            this.modifiers = modifiers;
            this.type = type;
            this.annotations = annotations;
        }
        public String getName() {
            return name;
        }
        public TypeDescription.Generic getType() {
            return type;
        }
        public int getModifiers() {
            return modifiers;
        }
        public AnnotationList getAnnotations() {
            return new AnnotationList.Explicit(annotations);
        }
        public Token accept(TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
            return new Token(name, modifiers, type.accept(visitor), annotations);
        }
        public SignatureToken asSignatureToken(TypeDescription declaringType) {
            return new SignatureToken(name, type.accept(new TypeDescription.Generic.Visitor.Reducing(declaringType)));
        }
        public int hashCode() {
            int result = name.hashCode();
            result = 31 * result + modifiers;
            result = 31 * result + type.hashCode();
            result = 31 * result + annotations.hashCode();
            return result;
        }
        public boolean equals(@MaybeNull Object other) {
            if (this == other) {
                return true;
            } else if (other == null || getClass() != other.getClass()) {
                return false;
            }
            Token token = (Token) other;
            return modifiers == token.modifiers && name.equals(token.name) && type.equals(token.type) && annotations.equals(token.annotations);
        }
    }
    class SignatureToken {
        private final String name;
        private final TypeDescription type;
        public SignatureToken(String name, TypeDescription type) {
            this.name = name;
            this.type = type;
        }
        public String getName() {
            return name;
        }
        public TypeDescription getType() {
            return type;
        }
        public int hashCode() {
            int result = name.hashCode();
            result = 31 * result + type.hashCode();
            return result;
        }
        public boolean equals(@MaybeNull Object other) {
            if (this == other) {
                return true;
            } else if (!(other instanceof SignatureToken)) {
                return false;
            }
            SignatureToken signatureToken = (SignatureToken) other;
            return name.equals(signatureToken.name) && type.equals(signatureToken.type);
        }
        public String toString() {
            return type + " " + name;
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```