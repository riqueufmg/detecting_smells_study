##CONTEXT_SIZE=2023
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.dynamic.loading;
public interface ClassLoadingStrategy<T extends ClassLoader> {
    ClassLoader BOOTSTRAP_LOADER = null;
    ProtectionDomain NO_PROTECTION_DOMAIN = null;
    Map<TypeDescription, Class<?>> load(@MaybeNull T classLoader, Map<TypeDescription, byte[]> types);
    enum Default implements Configurable<ClassLoader> {
        WRAPPER(new WrappingDispatcher(ByteArrayClassLoader.PersistenceHandler.LATENT, WrappingDispatcher.PARENT_FIRST)), WRAPPER_PERSISTENT(new WrappingDispatcher(ByteArrayClassLoader.PersistenceHandler.MANIFEST, WrappingDispatcher.PARENT_FIRST)), CHILD_FIRST(new WrappingDispatcher(ByteArrayClassLoader.PersistenceHandler.LATENT, WrappingDispatcher.CHILD_FIRST)), CHILD_FIRST_PERSISTENT(new WrappingDispatcher(ByteArrayClassLoader.PersistenceHandler.MANIFEST, WrappingDispatcher.CHILD_FIRST)), INJECTION(new InjectionDispatcher());
        private static final boolean DEFAULT_FORBID_EXISTING = true;
        private final Configurable<ClassLoader> dispatcher;
        Default(Configurable<ClassLoader> dispatcher) {
            this.dispatcher = dispatcher;
        }
        public Map<TypeDescription, Class<?>> load(@MaybeNull ClassLoader classLoader, Map<TypeDescription, byte[]> types) {
            return dispatcher.load(classLoader, types);
        }
        public Configurable<ClassLoader> with(ProtectionDomain protectionDomain) {
            return dispatcher.with(protectionDomain);
        }
        public Configurable<ClassLoader> with(PackageDefinitionStrategy packageDefinitionStrategy) {
            return dispatcher.with(packageDefinitionStrategy);
        }
        public Configurable<ClassLoader> with(ClassLoaderDecorator.Factory classLoaderDecoratorFactory) {
            return dispatcher.with(classLoaderDecoratorFactory);
        }
        public Configurable<ClassLoader> allowExistingTypes() {
            return dispatcher.allowExistingTypes();
        }
        public Configurable<ClassLoader> opened() {
            return dispatcher.opened();
        }
        protected static class InjectionDispatcher implements ClassLoadingStrategy.Configurable<ClassLoader> {
            private final ProtectionDomain protectionDomain;
            private final PackageDefinitionStrategy packageDefinitionStrategy;
            private final boolean forbidExisting;
            protected InjectionDispatcher() {
                this(NO_PROTECTION_DOMAIN, PackageDefinitionStrategy.NoOp.INSTANCE, DEFAULT_FORBID_EXISTING);
            }
            private InjectionDispatcher(@MaybeNull ProtectionDomain protectionDomain, PackageDefinitionStrategy packageDefinitionStrategy, boolean forbidExisting) {
                this.protectionDomain = protectionDomain;
                this.packageDefinitionStrategy = packageDefinitionStrategy;
                this.forbidExisting = forbidExisting;
            }
            public Map<TypeDescription, Class<?>> load(@MaybeNull ClassLoader classLoader, Map<TypeDescription, byte[]> types) {
                if (classLoader == null) {
                    throw new IllegalArgumentException("Cannot inject classes into the bootstrap class loader");
                }
                return new ClassInjector.UsingReflection(classLoader, protectionDomain, packageDefinitionStrategy, forbidExisting).inject(types);
            }
            public Configurable<ClassLoader> with(ProtectionDomain protectionDomain) {
                return new InjectionDispatcher(protectionDomain, packageDefinitionStrategy, forbidExisting);
            }
            public Configurable<ClassLoader> with(PackageDefinitionStrategy packageDefinitionStrategy) {
                return new InjectionDispatcher(protectionDomain, packageDefinitionStrategy, forbidExisting);
            }
            public Configurable<ClassLoader> with(ClassLoaderDecorator.Factory classLoaderDecoratorFactory) {
                throw new UnsupportedOperationException("Cannot decorate a class loader when using injection");
            }
            public Configurable<ClassLoader> allowExistingTypes() {
                return new InjectionDispatcher(protectionDomain, packageDefinitionStrategy, false);
            }
            public Configurable<ClassLoader> opened() {
                return this;
            }
        }
        protected static class WrappingDispatcher implements ClassLoadingStrategy.Configurable<ClassLoader> {
            private static final boolean CHILD_FIRST = true;
            private static final boolean PARENT_FIRST = false;
            private final ProtectionDomain protectionDomain;
            private final ByteArrayClassLoader.PersistenceHandler persistenceHandler;
            private final PackageDefinitionStrategy packageDefinitionStrategy;
            private final ClassLoaderDecorator.Factory classLoaderDecoratorFactory;
            private final boolean childFirst;
            private final boolean forbidExisting;
            private final boolean sealed;
            protected WrappingDispatcher(ByteArrayClassLoader.PersistenceHandler persistenceHandler, boolean childFirst) {
                this(NO_PROTECTION_DOMAIN, PackageDefinitionStrategy.Trivial.INSTANCE, persistenceHandler, ClassLoaderDecorator.Factory.NoOp.INSTANCE, childFirst, DEFAULT_FORBID_EXISTING, true);
            }
            private WrappingDispatcher(@MaybeNull ProtectionDomain protectionDomain, PackageDefinitionStrategy packageDefinitionStrategy, ByteArrayClassLoader.PersistenceHandler persistenceHandler, ClassLoaderDecorator.Factory classLoaderDecoratorFactory, boolean childFirst, boolean forbidExisting, boolean sealed) {
                this.protectionDomain = protectionDomain;
                this.packageDefinitionStrategy = packageDefinitionStrategy;
                this.persistenceHandler = persistenceHandler;
                this.classLoaderDecoratorFactory = classLoaderDecoratorFactory;
                this.childFirst = childFirst;
                this.forbidExisting = forbidExisting;
                this.sealed = sealed;
            }
            public Map<TypeDescription, Class<?>> load(@MaybeNull ClassLoader classLoader, Map<TypeDescription, byte[]> types) {
                return childFirst ? ByteArrayClassLoader.ChildFirst.load(classLoader, types, protectionDomain, persistenceHandler, packageDefinitionStrategy, classLoaderDecoratorFactory, forbidExisting, sealed) : ByteArrayClassLoader.load(classLoader, types, protectionDomain, persistenceHandler, packageDefinitionStrategy, classLoaderDecoratorFactory, forbidExisting, sealed);
            }
            public Configurable<ClassLoader> with(ProtectionDomain protectionDomain) {
                return new WrappingDispatcher(protectionDomain, packageDefinitionStrategy, persistenceHandler, classLoaderDecoratorFactory, childFirst, forbidExisting, sealed);
            }
            public Configurable<ClassLoader> with(PackageDefinitionStrategy packageDefinitionStrategy) {
                return new WrappingDispatcher(protectionDomain, packageDefinitionStrategy, persistenceHandler, classLoaderDecoratorFactory, childFirst, forbidExisting, sealed);
            }
            public Configurable<ClassLoader> with(ClassLoaderDecorator.Factory classLoaderDecoratorFactory) {
                return new WrappingDispatcher(protectionDomain, packageDefinitionStrategy, persistenceHandler, classLoaderDecoratorFactory, childFirst, forbidExisting, sealed);
            }
            public Configurable<ClassLoader> allowExistingTypes() {
                return new WrappingDispatcher(protectionDomain, packageDefinitionStrategy, persistenceHandler, classLoaderDecoratorFactory, childFirst, false, sealed);
            }
            public Configurable<ClassLoader> opened() {
                return new WrappingDispatcher(protectionDomain, packageDefinitionStrategy, persistenceHandler, classLoaderDecoratorFactory, childFirst, forbidExisting, false);
            }
        }
    }
    interface Configurable<S extends ClassLoader> extends ClassLoadingStrategy<S> {
        Configurable<S> with(ProtectionDomain protectionDomain);
        Configurable<S> with(PackageDefinitionStrategy packageDefinitionStrategy);
        Configurable<S> with(ClassLoaderDecorator.Factory classLoaderDecoratorFactory);
        Configurable<S> allowExistingTypes();
        Configurable<S> opened();
    }
    class UsingLookup implements ClassLoadingStrategy<ClassLoader> {
        private final ClassInjector classInjector;
        protected UsingLookup(ClassInjector classInjector) {
            this.classInjector = classInjector;
        }
        public static ClassLoadingStrategy<ClassLoader> of(Object lookup) {
            return new UsingLookup(ClassInjector.UsingLookup.of(lookup));
        }
        public static ClassLoadingStrategy<ClassLoader> withFallback(Callable<?> lookup) {
            return withFallback(lookup, false);
        }
        public static ClassLoadingStrategy<ClassLoader> withFallback(Callable<?> lookup, boolean wrapper) {
            if (ClassInjector.UsingLookup.isAvailable()) {
                try {
                    return of(lookup.call());
                } catch (Exception exception) {
                    throw new IllegalStateException(exception);
                }
            } else if (ClassInjector.UsingUnsafe.isAvailable()) {
                return new ClassLoadingStrategy.ForUnsafeInjection();
            } else if (wrapper) {
                return Default.WRAPPER;
            } else {
                throw new IllegalStateException("Neither lookup or unsafe class injection is available");
            }
        }
        public Map<TypeDescription, Class<?>> load(@MaybeNull ClassLoader classLoader, Map<TypeDescription, byte[]> types) {
            return classInjector.inject(types);
        }
    }
    class ForBootstrapInjection implements ClassLoadingStrategy<ClassLoader> {
        private final Instrumentation instrumentation;
        private final File folder;
        public ForBootstrapInjection(Instrumentation instrumentation, File folder) {
            this.instrumentation = instrumentation;
            this.folder = folder;
        }
        public Map<TypeDescription, Class<?>> load(@MaybeNull ClassLoader classLoader, Map<TypeDescription, byte[]> types) {
            ClassInjector classInjector = classLoader == null ? ClassInjector.UsingInstrumentation.of(folder, ClassInjector.UsingInstrumentation.Target.BOOTSTRAP, instrumentation) : new ClassInjector.UsingReflection(classLoader);
            return classInjector.inject(types);
        }
    }
    class ForUnsafeInjection implements ClassLoadingStrategy<ClassLoader> {
        private final ProtectionDomain protectionDomain;
        public ForUnsafeInjection() {
            this(NO_PROTECTION_DOMAIN);
        }
        public ForUnsafeInjection(@MaybeNull ProtectionDomain protectionDomain) {
            this.protectionDomain = protectionDomain;
        }
        public Map<TypeDescription, Class<?>> load(@MaybeNull ClassLoader classLoader, Map<TypeDescription, byte[]> types) {
            return new ClassInjector.UsingUnsafe(classLoader, protectionDomain).inject(types);
        }
    }
    class ForJnaInjection implements ClassLoadingStrategy<ClassLoader> {
        private final ProtectionDomain protectionDomain;
        public ForJnaInjection() {
            this(NO_PROTECTION_DOMAIN);
        }
        public ForJnaInjection(@MaybeNull ProtectionDomain protectionDomain) {
            this.protectionDomain = protectionDomain;
        }
        public Map<TypeDescription, Class<?>> load(@MaybeNull ClassLoader classLoader, Map<TypeDescription, byte[]> types) {
            return new ClassInjector.UsingUnsafe(classLoader, protectionDomain).inject(types);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```