##CONTEXT_SIZE=8562
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.implementation;
public interface Implementation extends InstrumentedType.Prepareable {
    ByteCodeAppender appender(Target implementationTarget);
    interface Composable extends Implementation {
        Implementation andThen(Implementation implementation);
        Composable andThen(Composable implementation);
    }
    interface SpecialMethodInvocation extends StackManipulation {
        MethodDescription getMethodDescription();
        TypeDescription getTypeDescription();
        SpecialMethodInvocation withCheckedCompatibilityTo(MethodDescription.TypeToken token);
        JavaConstant.MethodHandle toMethodHandle();
        enum Illegal implements SpecialMethodInvocation {
            INSTANCE;
            public boolean isValid() {
                return false;
            }
            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
                throw new IllegalStateException("Cannot implement an undefined method");
            }
            public MethodDescription getMethodDescription() {
                throw new IllegalStateException("An illegal special method invocation must not be applied");
            }
            public TypeDescription getTypeDescription() {
                throw new IllegalStateException("An illegal special method invocation must not be applied");
            }
            public SpecialMethodInvocation withCheckedCompatibilityTo(MethodDescription.TypeToken token) {
                return this;
            }
            public JavaConstant.MethodHandle toMethodHandle() {
                throw new IllegalStateException("An illegal special method invocation must not be applied");
            }
        }
        abstract class AbstractBase extends StackManipulation.AbstractBase implements SpecialMethodInvocation {
            public int hashCode() {
                return 31 * getMethodDescription().asSignatureToken().hashCode() + getTypeDescription().hashCode();
            }
            public boolean equals(@MaybeNull Object other) {
                if (this == other) {
                    return true;
                } else if (!(other instanceof SpecialMethodInvocation)) {
                    return false;
                }
                SpecialMethodInvocation specialMethodInvocation = (SpecialMethodInvocation) other;
                return getMethodDescription().asSignatureToken().equals(specialMethodInvocation.getMethodDescription().asSignatureToken()) && getTypeDescription().equals(specialMethodInvocation.getTypeDescription());
            }
        }
        class Simple extends SpecialMethodInvocation.AbstractBase {
            private final MethodDescription methodDescription;
            private final TypeDescription typeDescription;
            private final StackManipulation stackManipulation;
            protected Simple(MethodDescription methodDescription, TypeDescription typeDescription, StackManipulation stackManipulation) {
                this.methodDescription = methodDescription;
                this.typeDescription = typeDescription;
                this.stackManipulation = stackManipulation;
            }
            public static SpecialMethodInvocation of(MethodDescription methodDescription, TypeDescription typeDescription) {
                StackManipulation stackManipulation = MethodInvocation.invoke(methodDescription).special(typeDescription);
                return stackManipulation.isValid() ? new SpecialMethodInvocation.Simple(methodDescription, typeDescription, stackManipulation) : SpecialMethodInvocation.Illegal.INSTANCE;
            }
            public MethodDescription getMethodDescription() {
                return methodDescription;
            }
            public TypeDescription getTypeDescription() {
                return typeDescription;
            }
            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
                return stackManipulation.apply(methodVisitor, implementationContext);
            }
            public SpecialMethodInvocation withCheckedCompatibilityTo(MethodDescription.TypeToken token) {
                if (methodDescription.asTypeToken().equals(token)) {
                    return this;
                } else {
                    return SpecialMethodInvocation.Illegal.INSTANCE;
                }
            }
            public JavaConstant.MethodHandle toMethodHandle() {
                return JavaConstant.MethodHandle.ofSpecial(methodDescription.asDefined(), typeDescription);
            }
        }
    }
    interface Target {
        TypeDescription getInstrumentedType();
        TypeDefinition getOriginType();
        SpecialMethodInvocation invokeSuper(MethodDescription.SignatureToken token);
        SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token);
        SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token, TypeDescription targetType);
        SpecialMethodInvocation invokeDominant(MethodDescription.SignatureToken token);
        interface Factory {
            Target make(TypeDescription instrumentedType, MethodGraph.Linked methodGraph, ClassFileVersion classFileVersion);
        }
        abstract class AbstractBase implements Target {
            protected final TypeDescription instrumentedType;
            protected final MethodGraph.Linked methodGraph;
            protected final DefaultMethodInvocation defaultMethodInvocation;
            protected AbstractBase(TypeDescription instrumentedType, MethodGraph.Linked methodGraph, DefaultMethodInvocation defaultMethodInvocation) {
                this.instrumentedType = instrumentedType;
                this.methodGraph = methodGraph;
                this.defaultMethodInvocation = defaultMethodInvocation;
            }
            public TypeDescription getInstrumentedType() {
                return instrumentedType;
            }
            public SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token) {
                SpecialMethodInvocation specialMethodInvocation = SpecialMethodInvocation.Illegal.INSTANCE;
                for (TypeDescription interfaceType : instrumentedType.getInterfaces().asErasures()) {
                    SpecialMethodInvocation invocation = invokeDefault(token, interfaceType).withCheckedCompatibilityTo(token.asTypeToken());
                    if (invocation.isValid()) {
                        if (specialMethodInvocation.isValid()) {
                            return SpecialMethodInvocation.Illegal.INSTANCE;
                        } else {
                            specialMethodInvocation = invocation;
                        }
                    }
                }
                return specialMethodInvocation;
            }
            public SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token, TypeDescription targetType) {
                return defaultMethodInvocation.apply(methodGraph.getInterfaceGraph(targetType).locate(token), targetType);
            }
            public SpecialMethodInvocation invokeDominant(MethodDescription.SignatureToken token) {
                SpecialMethodInvocation specialMethodInvocation = invokeSuper(token);
                return specialMethodInvocation.isValid() ? specialMethodInvocation : invokeDefault(token);
            }
            protected enum DefaultMethodInvocation {
                ENABLED {
                    @Override
                    protected SpecialMethodInvocation apply(MethodGraph.Node node, TypeDescription targetType) {
                        return node.getSort().isUnique() ? SpecialMethodInvocation.Simple.of(node.getRepresentative(), targetType) : SpecialMethodInvocation.Illegal.INSTANCE;
                    }
                }
                , DISABLED {
                    @Override
                    protected SpecialMethodInvocation apply(MethodGraph.Node node, TypeDescription targetType) {
                        return SpecialMethodInvocation.Illegal.INSTANCE;
                    }
                }
                ;
                public static DefaultMethodInvocation of(ClassFileVersion classFileVersion) {
                    return classFileVersion.isAtLeast(ClassFileVersion.JAVA_V8) ? ENABLED : DISABLED;
                }
                protected abstract SpecialMethodInvocation apply(MethodGraph.Node node, TypeDescription targetType);
            }
        }
    }
    interface Context extends MethodAccessorFactory {
        TypeDescription register(AuxiliaryType auxiliaryType);
        FieldDescription.InDefinedShape cache(StackManipulation fieldValue, TypeDescription fieldType);
        TypeDescription getInstrumentedType();
        ClassFileVersion getClassFileVersion();
        FrameGeneration getFrameGeneration();
        enum FrameGeneration {
            GENERATE(true) {
                @Override
                public void generate(MethodVisitor methodVisitor, int type, int stackCount, @MaybeNull Object[] stack, int changedLocalVariableCount, @MaybeNull Object[] changedLocalVariable, int fullLocalVariableCount, @MaybeNull Object[] fullLocalVariable) {
                    methodVisitor.visitFrame(type, changedLocalVariableCount, changedLocalVariable, stackCount, stack);
                }
            }
            , EXPAND(true) {
                @Override
                public void generate(MethodVisitor methodVisitor, int type, int stackCount, @MaybeNull Object[] stack, int changedLocalVariableCount, @MaybeNull Object[] changedLocalVariable, int fullLocalVariableCount, @MaybeNull Object[] fullLocalVariable) {
                    methodVisitor.visitFrame(Opcodes.F_NEW, fullLocalVariableCount, fullLocalVariable, stackCount, stack);
                }
            }
            , DISABLED(false) {
                @Override
                public void generate(MethodVisitor methodVisitor, int type, int stackCount, @MaybeNull Object[] stack, int changedLocalVariableCount, @MaybeNull Object[] changedLocalVariable, int fullLocalVariableCount, @MaybeNull Object[] fullLocalVariable) {
                }
            }
            ;
            private static final Object[] EMPTY = new Object[0];
            private final boolean active;
            FrameGeneration(boolean active) {
                this.active = active;
            }
            public boolean isActive() {
                return active;
            }
            public void same(MethodVisitor methodVisitor, List<? extends TypeDefinition> localVariables) {
                generate(methodVisitor, Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY, localVariables.size(), toStackMapFrames(localVariables));
            }
            public void same1(MethodVisitor methodVisitor, TypeDefinition stackValue, List<? extends TypeDefinition> localVariables) {
                generate(methodVisitor, Opcodes.F_SAME1, 1, new Object[] { toStackMapFrame(stackValue) }, EMPTY.length, EMPTY, localVariables.size(), toStackMapFrames(localVariables));
            }
            public void append(MethodVisitor methodVisitor, List<? extends TypeDefinition> appended, List<? extends TypeDefinition> localVariables) {
                generate(methodVisitor, Opcodes.F_APPEND, EMPTY.length, EMPTY, appended.size(), toStackMapFrames(appended), localVariables.size() + appended.size(), toStackMapFrames(CompoundList.of(localVariables, appended)));
            }
            public void chop(MethodVisitor methodVisitor, int chopped, List<? extends TypeDefinition> localVariables) {
                generate(methodVisitor, Opcodes.F_CHOP, EMPTY.length, EMPTY, chopped, EMPTY, localVariables.size(), toStackMapFrames(localVariables));
            }
            public void full(MethodVisitor methodVisitor, List<? extends TypeDefinition> stackValues, List<? extends TypeDefinition> localVariables) {
                generate(methodVisitor, Opcodes.F_FULL, stackValues.size(), toStackMapFrames(stackValues), localVariables.size(), toStackMapFrames(localVariables), localVariables.size(), toStackMapFrames(localVariables));
            }
            protected abstract void generate(MethodVisitor methodVisitor, int type, int stackCount, @MaybeNull Object[] stack, int changedLocalVariableCount, @MaybeNull Object[] changedLocalVariable, int fullLocalVariableCount, @MaybeNull Object[] fullLocalVariable);
            private static Object[] toStackMapFrames(List<? extends TypeDefinition> typeDefinitions) {
                Object[] value = typeDefinitions.isEmpty() ? EMPTY : new Object[typeDefinitions.size()];
                for (int index = 0; index < typeDefinitions.size(); index++) {
                    value[index] = toStackMapFrame(typeDefinitions.get(index));
                }
                return value;
            }
            private static Object toStackMapFrame(TypeDefinition typeDefinition) {
                if (typeDefinition.represents(boolean.class) || typeDefinition.represents(byte.class) || typeDefinition.represents(short.class) || typeDefinition.represents(char.class) || typeDefinition.represents(int.class)) {
                    return Opcodes.INTEGER;
                } else if (typeDefinition.represents(long.class)) {
                    return Opcodes.LONG;
                } else if (typeDefinition.represents(float.class)) {
                    return Opcodes.FLOAT;
                } else if (typeDefinition.represents(double.class)) {
                    return Opcodes.DOUBLE;
                } else {
                    return typeDefinition.asErasure().getInternalName();
                }
            }
        }
        interface ExtractableView extends Context {
            boolean isEnabled();
            List<DynamicType> getAuxiliaryTypes();
            void drain(TypeInitializer.Drain drain, ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory);
            abstract class AbstractBase implements ExtractableView {
                protected final TypeDescription instrumentedType;
                protected final ClassFileVersion classFileVersion;
                protected final FrameGeneration frameGeneration;
                protected AbstractBase(TypeDescription instrumentedType, ClassFileVersion classFileVersion, FrameGeneration frameGeneration) {
                    this.instrumentedType = instrumentedType;
                    this.classFileVersion = classFileVersion;
                    this.frameGeneration = frameGeneration;
                }
                public TypeDescription getInstrumentedType() {
                    return instrumentedType;
                }
                public ClassFileVersion getClassFileVersion() {
                    return classFileVersion;
                }
                public FrameGeneration getFrameGeneration() {
                    return frameGeneration;
                }
            }
        }
        interface Factory {
            ExtractableView make(TypeDescription instrumentedType, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion classFileVersion, ClassFileVersion auxiliaryClassFileVersion);
            ExtractableView make(TypeDescription instrumentedType, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion classFileVersion, ClassFileVersion auxiliaryClassFileVersion, FrameGeneration frameGeneration);
        }
        class Disabled extends ExtractableView.AbstractBase {
            protected Disabled(TypeDescription instrumentedType, ClassFileVersion classFileVersion, FrameGeneration frameGeneration) {
                super(instrumentedType, classFileVersion, frameGeneration);
            }
            public boolean isEnabled() {
                return false;
            }
            public List<DynamicType> getAuxiliaryTypes() {
                return Collections.emptyList();
            }
            public void drain(TypeInitializer.Drain drain, ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                drain.apply(classVisitor, TypeInitializer.None.INSTANCE, this);
            }
            public TypeDescription register(AuxiliaryType auxiliaryType) {
                throw new IllegalStateException("Registration of auxiliary types was disabled: " + auxiliaryType);
            }
            public MethodDescription.InDefinedShape registerAccessorFor(SpecialMethodInvocation specialMethodInvocation, AccessType accessType) {
                throw new IllegalStateException("Registration of method accessors was disabled: " + specialMethodInvocation.getMethodDescription());
            }
            public MethodDescription.InDefinedShape registerGetterFor(FieldDescription fieldDescription, AccessType accessType) {
                throw new IllegalStateException("Registration of field accessor was disabled: " + fieldDescription);
            }
            public MethodDescription.InDefinedShape registerSetterFor(FieldDescription fieldDescription, AccessType accessType) {
                throw new IllegalStateException("Registration of field accessor was disabled: " + fieldDescription);
            }
            public FieldDescription.InDefinedShape cache(StackManipulation fieldValue, TypeDescription fieldType) {
                throw new IllegalStateException("Field values caching was disabled: " + fieldType);
            }
            public enum Factory implements Context.Factory {
                INSTANCE;
                public ExtractableView make(TypeDescription instrumentedType, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion classFileVersion, ClassFileVersion auxiliaryClassFileVersion) {
                    return make(instrumentedType, auxiliaryTypeNamingStrategy, typeInitializer, classFileVersion, auxiliaryClassFileVersion, classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6) ? FrameGeneration.GENERATE : FrameGeneration.DISABLED);
                }
                public ExtractableView make(TypeDescription instrumentedType, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion classFileVersion, ClassFileVersion auxiliaryClassFileVersion, FrameGeneration frameGeneration) {
                    if (typeInitializer.isDefined()) {
                        throw new IllegalStateException("Cannot define type initializer which was explicitly disabled: " + typeInitializer);
                    }
                    return new Disabled(instrumentedType, classFileVersion, frameGeneration);
                }
            }
        }
        class Default extends ExtractableView.AbstractBase {
            public static final String ACCESSOR_METHOD_SUFFIX = "accessor";
            public static final String FIELD_CACHE_PREFIX = "cachedValue";
            private final AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy;
            private final TypeInitializer typeInitializer;
            private final ClassFileVersion auxiliaryClassFileVersion;
            private final Map<SpecialMethodInvocation, DelegationRecord> registeredAccessorMethods;
            private final Map<FieldDescription, DelegationRecord> registeredGetters;
            private final Map<FieldDescription, DelegationRecord> registeredSetters;
            private final Map<AuxiliaryType, DynamicType> auxiliaryTypes;
            private final Map<FieldCacheEntry, FieldDescription.InDefinedShape> registeredFieldCacheEntries;
            private final Set<FieldDescription.InDefinedShape> registeredFieldCacheFields;
            private final String suffix;
            private boolean fieldCacheCanAppendEntries;
            protected Default(TypeDescription instrumentedType, ClassFileVersion classFileVersion, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion auxiliaryClassFileVersion, FrameGeneration frameGeneration, String suffix) {
                super(instrumentedType, classFileVersion, frameGeneration);
                this.auxiliaryTypeNamingStrategy = auxiliaryTypeNamingStrategy;
                this.typeInitializer = typeInitializer;
                this.auxiliaryClassFileVersion = auxiliaryClassFileVersion;
                this.suffix = suffix;
                registeredAccessorMethods = new HashMap<SpecialMethodInvocation, DelegationRecord>();
                registeredGetters = new HashMap<FieldDescription, DelegationRecord>();
                registeredSetters = new HashMap<FieldDescription, DelegationRecord>();
                auxiliaryTypes = new HashMap<AuxiliaryType, DynamicType>();
                registeredFieldCacheEntries = new HashMap<FieldCacheEntry, FieldDescription.InDefinedShape>();
                registeredFieldCacheFields = new HashSet<FieldDescription.InDefinedShape>();
                fieldCacheCanAppendEntries = true;
            }
            public boolean isEnabled() {
                return true;
            }
            public MethodDescription.InDefinedShape registerAccessorFor(SpecialMethodInvocation specialMethodInvocation, AccessType accessType) {
                DelegationRecord record = registeredAccessorMethods.get(specialMethodInvocation);
                record = record == null ? new AccessorMethodDelegation(instrumentedType, suffix, accessType, specialMethodInvocation) : record.with(accessType);
                registeredAccessorMethods.put(specialMethodInvocation, record);
                return record.getMethod();
            }
            public MethodDescription.InDefinedShape registerGetterFor(FieldDescription fieldDescription, AccessType accessType) {
                DelegationRecord record = registeredGetters.get(fieldDescription);
                record = record == null ? new FieldGetterDelegation(instrumentedType, suffix, accessType, fieldDescription) : record.with(accessType);
                registeredGetters.put(fieldDescription, record);
                return record.getMethod();
            }
            public MethodDescription.InDefinedShape registerSetterFor(FieldDescription fieldDescription, AccessType accessType) {
                DelegationRecord record = registeredSetters.get(fieldDescription);
                record = record == null ? new FieldSetterDelegation(instrumentedType, suffix, accessType, fieldDescription) : record.with(accessType);
                registeredSetters.put(fieldDescription, record);
                return record.getMethod();
            }
            public TypeDescription register(AuxiliaryType auxiliaryType) {
                DynamicType dynamicType = auxiliaryTypes.get(auxiliaryType);
                if (dynamicType == null) {
                    dynamicType = auxiliaryType.make(auxiliaryTypeNamingStrategy.name(instrumentedType, auxiliaryType), auxiliaryClassFileVersion, this);
                    auxiliaryTypes.put(auxiliaryType, dynamicType);
                }
                return dynamicType.getTypeDescription();
            }
            public List<DynamicType> getAuxiliaryTypes() {
                return new ArrayList<DynamicType>(auxiliaryTypes.values());
            }
            public FieldDescription.InDefinedShape cache(StackManipulation fieldValue, TypeDescription fieldType) {
                FieldCacheEntry fieldCacheEntry = new FieldCacheEntry(fieldValue, fieldType);
                FieldDescription.InDefinedShape fieldCache = registeredFieldCacheEntries.get(fieldCacheEntry);
                if (fieldCache != null) {
                    return fieldCache;
                }
                if (!fieldCacheCanAppendEntries) {
                    throw new IllegalStateException("Cached values cannot be registered after defining the type initializer for " + instrumentedType);
                }
                int hashCode = fieldValue.hashCode();
                do {
                    fieldCache = new CacheValueField(instrumentedType, fieldType.asGenericType(), suffix, hashCode++);
                } while (!registeredFieldCacheFields.add(fieldCache));
                registeredFieldCacheEntries.put(fieldCacheEntry, fieldCache);
                return fieldCache;
            }
            public void drain(TypeInitializer.Drain drain, ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                fieldCacheCanAppendEntries = false;
                TypeInitializer typeInitializer = this.typeInitializer;
                for (Map.Entry<FieldCacheEntry, FieldDescription.InDefinedShape> entry : registeredFieldCacheEntries.entrySet()) {
                    FieldVisitor fieldVisitor = classVisitor.visitField(entry.getValue().getModifiers(), entry.getValue().getInternalName(), entry.getValue().getDescriptor(), entry.getValue().getGenericSignature(), FieldDescription.NO_DEFAULT_VALUE);
                    if (fieldVisitor != null) {
                        fieldVisitor.visitEnd();
                        typeInitializer = typeInitializer.expandWith(entry.getKey().storeIn(entry.getValue()));
                    }
                }
                drain.apply(classVisitor, typeInitializer, this);
                for (TypeWriter.MethodPool.Record record : registeredAccessorMethods.values()) {
                    record.apply(classVisitor, this, annotationValueFilterFactory);
                }
                for (TypeWriter.MethodPool.Record record : registeredGetters.values()) {
                    record.apply(classVisitor, this, annotationValueFilterFactory);
                }
                for (TypeWriter.MethodPool.Record record : registeredSetters.values()) {
                    record.apply(classVisitor, this, annotationValueFilterFactory);
                }
            }
            protected static class CacheValueField extends FieldDescription.InDefinedShape.AbstractBase {
                private final TypeDescription instrumentedType;
                private final TypeDescription.Generic fieldType;
                private final String name;
                protected CacheValueField(TypeDescription instrumentedType, TypeDescription.Generic fieldType, String suffix, int hashCode) {
                    this.instrumentedType = instrumentedType;
                    this.fieldType = fieldType;
                    name = FIELD_CACHE_PREFIX + "$" + suffix + "$" + RandomString.hashOf(hashCode);
                }
                public TypeDescription.Generic getType() {
                    return fieldType;
                }
                public AnnotationList getDeclaredAnnotations() {
                    return new AnnotationList.Empty();
                }
                public TypeDescription getDeclaringType() {
                    return instrumentedType;
                }
                public int getModifiers() {
                    return Opcodes.ACC_SYNTHETIC | Opcodes.ACC_FINAL | Opcodes.ACC_STATIC | (instrumentedType.isInterface() ? Opcodes.ACC_PUBLIC : Opcodes.ACC_PRIVATE);
                }
                public String getName() {
                    return name;
                }
            }
            protected static class FieldCacheEntry implements StackManipulation {
                private final StackManipulation fieldValue;
                private final TypeDescription fieldType;
                protected FieldCacheEntry(StackManipulation fieldValue, TypeDescription fieldType) {
                    this.fieldValue = fieldValue;
                    this.fieldType = fieldType;
                }
                protected ByteCodeAppender storeIn(FieldDescription fieldDescription) {
                    return new ByteCodeAppender.Simple(this, FieldAccess.forField(fieldDescription).write());
                }
                protected TypeDescription getFieldType() {
                    return fieldType;
                }
                public boolean isValid() {
                    return fieldValue.isValid();
                }
                public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
                    return fieldValue.apply(methodVisitor, implementationContext);
                }
                public int hashCode() {
                    int result = fieldValue.hashCode();
                    result = 31 * result + fieldType.hashCode();
                    return result;
                }
                public boolean equals(@MaybeNull Object other) {
                    if (this == other) {
                        return true;
                    } else if (other == null || getClass() != other.getClass()) {
                        return false;
                    }
                    FieldCacheEntry fieldCacheEntry = (FieldCacheEntry) other;
                    return fieldValue.equals(fieldCacheEntry.fieldValue) && fieldType.equals(fieldCacheEntry.fieldType);
                }
            }
            protected abstract static class AbstractPropertyAccessorMethod extends MethodDescription.InDefinedShape.AbstractBase {
                public int getModifiers() {
                    return Opcodes.ACC_SYNTHETIC | getBaseModifiers() | (getDeclaringType().isInterface() ? Opcodes.ACC_PUBLIC : Opcodes.ACC_FINAL);
                }
                protected abstract int getBaseModifiers();
            }
            protected static class AccessorMethod extends AbstractPropertyAccessorMethod {
                private final TypeDescription instrumentedType;
                private final MethodDescription methodDescription;
                private final String name;
                protected AccessorMethod(TypeDescription instrumentedType, MethodDescription methodDescription, TypeDescription typeDescription, String suffix) {
                    this.instrumentedType = instrumentedType;
                    this.methodDescription = methodDescription;
                    name = methodDescription.getInternalName() + "$" + ACCESSOR_METHOD_SUFFIX + "$" + suffix + (typeDescription.isInterface() ? "$" + RandomString.hashOf(typeDescription.hashCode()) : "");
                }
                public TypeDescription.Generic getReturnType() {
                    return methodDescription.getReturnType().asRawType();
                }
                public ParameterList<ParameterDescription.InDefinedShape> getParameters() {
                    return new ParameterList.Explicit.ForTypes(this, methodDescription.getParameters().asTypeList().asRawTypes());
                }
                public TypeList.Generic getExceptionTypes() {
                    return methodDescription.getExceptionTypes().asRawTypes();
                }
                public AnnotationValue<?, ?> getDefaultValue() {
                    return AnnotationValue.UNDEFINED;
                }
                public TypeList.Generic getTypeVariables() {
                    return new TypeList.Generic.Empty();
                }
                public AnnotationList getDeclaredAnnotations() {
                    return new AnnotationList.Empty();
                }
                public TypeDescription getDeclaringType() {
                    return instrumentedType;
                }
                protected int getBaseModifiers() {
                    return methodDescription.isStatic() ? Opcodes.ACC_STATIC : EMPTY_MASK;
                }
                public String getInternalName() {
                    return name;
                }
            }
            protected static class FieldGetter extends AbstractPropertyAccessorMethod {
                private final TypeDescription instrumentedType;
                private final FieldDescription fieldDescription;
                private final String name;
                protected FieldGetter(TypeDescription instrumentedType, FieldDescription fieldDescription, String suffix) {
                    this.instrumentedType = instrumentedType;
                    this.fieldDescription = fieldDescription;
                    name = fieldDescription.getName() + "$" + ACCESSOR_METHOD_SUFFIX + "$" + suffix;
                }
                public TypeDescription.Generic getReturnType() {
                    return fieldDescription.getType().asRawType();
                }
                public ParameterList<ParameterDescription.InDefinedShape> getParameters() {
                    return new ParameterList.Empty<ParameterDescription.InDefinedShape>();
                }
                public TypeList.Generic getExceptionTypes() {
                    return new TypeList.Generic.Empty();
                }
                public AnnotationValue<?, ?> getDefaultValue() {
                    return AnnotationValue.UNDEFINED;
                }
                public TypeList.Generic getTypeVariables() {
                    return new TypeList.Generic.Empty();
                }
                public AnnotationList getDeclaredAnnotations() {
                    return new AnnotationList.Empty();
                }
                public TypeDescription getDeclaringType() {
                    return instrumentedType;
                }
                protected int getBaseModifiers() {
                    return fieldDescription.isStatic() ? Opcodes.ACC_STATIC : EMPTY_MASK;
                }
                public String getInternalName() {
                    return name;
                }
            }
            protected static class FieldSetter extends AbstractPropertyAccessorMethod {
                private final TypeDescription instrumentedType;
                private final FieldDescription fieldDescription;
                private final String name;
                protected FieldSetter(TypeDescription instrumentedType, FieldDescription fieldDescription, String suffix) {
                    this.instrumentedType = instrumentedType;
                    this.fieldDescription = fieldDescription;
                    name = fieldDescription.getName() + "$" + ACCESSOR_METHOD_SUFFIX + "$" + suffix;
                }
                public TypeDescription.Generic getReturnType() {
                    return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(void.class);
                }
                public ParameterList<ParameterDescription.InDefinedShape> getParameters() {
                    return new ParameterList.Explicit.ForTypes(this, Collections.singletonList(fieldDescription.getType().asRawType()));
                }
                public TypeList.Generic getExceptionTypes() {
                    return new TypeList.Generic.Empty();
                }
                public AnnotationValue<?, ?> getDefaultValue() {
                    return AnnotationValue.UNDEFINED;
                }
                public TypeList.Generic getTypeVariables() {
                    return new TypeList.Generic.Empty();
                }
                public AnnotationList getDeclaredAnnotations() {
                    return new AnnotationList.Empty();
                }
                public TypeDescription getDeclaringType() {
                    return instrumentedType;
                }
                protected int getBaseModifiers() {
                    return fieldDescription.isStatic() ? Opcodes.ACC_STATIC : EMPTY_MASK;
                }
                public String getInternalName() {
                    return name;
                }
            }
            protected abstract static class DelegationRecord extends TypeWriter.MethodPool.Record.ForDefinedMethod implements ByteCodeAppender {
                protected final MethodDescription.InDefinedShape methodDescription;
                protected final Visibility visibility;
                protected DelegationRecord(MethodDescription.InDefinedShape methodDescription, Visibility visibility) {
                    this.methodDescription = methodDescription;
                    this.visibility = visibility;
                }
                protected abstract DelegationRecord with(AccessType accessType);
                public MethodDescription.InDefinedShape getMethod() {
                    return methodDescription;
                }
                public Sort getSort() {
                    return Sort.IMPLEMENTED;
                }
                public Visibility getVisibility() {
                    return visibility;
                }
                public void applyHead(MethodVisitor methodVisitor) {
                }
                public void applyBody(MethodVisitor methodVisitor, Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                    methodVisitor.visitCode();
                    Size size = applyCode(methodVisitor, implementationContext);
                    methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());
                }
                public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
                }
                public Size applyCode(MethodVisitor methodVisitor, Context implementationContext) {
                    return apply(methodVisitor, implementationContext, getMethod());
                }
                public TypeWriter.MethodPool.Record prepend(ByteCodeAppender byteCodeAppender) {
                    throw new UnsupportedOperationException("Cannot prepend code to a delegation for " + methodDescription);
                }
            }
            protected static class AccessorMethodDelegation extends DelegationRecord {
                private final StackManipulation accessorMethodInvocation;
                protected AccessorMethodDelegation(TypeDescription instrumentedType, String suffix, AccessType accessType, SpecialMethodInvocation specialMethodInvocation) {
                    this(new AccessorMethod(instrumentedType, specialMethodInvocation.getMethodDescription(), specialMethodInvocation.getTypeDescription(), suffix), accessType.getVisibility(), specialMethodInvocation);
                }
                private AccessorMethodDelegation(MethodDescription.InDefinedShape methodDescription, Visibility visibility, StackManipulation accessorMethodInvocation) {
                    super(methodDescription, visibility);
                    this.accessorMethodInvocation = accessorMethodInvocation;
                }
                protected DelegationRecord with(AccessType accessType) {
                    return new AccessorMethodDelegation(methodDescription, visibility.expandTo(accessType.getVisibility()), accessorMethodInvocation);
                }
                public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
                    StackManipulation.Size stackSize = new StackManipulation.Compound(MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(), accessorMethodInvocation, MethodReturn.of(instrumentedMethod.getReturnType())).apply(methodVisitor, implementationContext);
                    return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
                }
            }
            protected static class FieldGetterDelegation extends DelegationRecord {
                private final FieldDescription fieldDescription;
                protected FieldGetterDelegation(TypeDescription instrumentedType, String suffix, AccessType accessType, FieldDescription fieldDescription) {
                    this(new FieldGetter(instrumentedType, fieldDescription, suffix), accessType.getVisibility(), fieldDescription);
                }
                private FieldGetterDelegation(MethodDescription.InDefinedShape methodDescription, Visibility visibility, FieldDescription fieldDescription) {
                    super(methodDescription, visibility);
                    this.fieldDescription = fieldDescription;
                }
                protected DelegationRecord with(AccessType accessType) {
                    return new FieldGetterDelegation(methodDescription, visibility.expandTo(accessType.getVisibility()), fieldDescription);
                }
                public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
                    StackManipulation.Size stackSize = new StackManipulation.Compound(fieldDescription.isStatic() ? StackManipulation.Trivial.INSTANCE : MethodVariableAccess.loadThis(), FieldAccess.forField(fieldDescription).read(), MethodReturn.of(fieldDescription.getType())).apply(methodVisitor, implementationContext);
                    return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
                }
            }
            protected static class FieldSetterDelegation extends DelegationRecord {
                private final FieldDescription fieldDescription;
                protected FieldSetterDelegation(TypeDescription instrumentedType, String suffix, AccessType accessType, FieldDescription fieldDescription) {
                    this(new FieldSetter(instrumentedType, fieldDescription, suffix), accessType.getVisibility(), fieldDescription);
                }
                private FieldSetterDelegation(MethodDescription.InDefinedShape methodDescription, Visibility visibility, FieldDescription fieldDescription) {
                    super(methodDescription, visibility);
                    this.fieldDescription = fieldDescription;
                }
                protected DelegationRecord with(AccessType accessType) {
                    return new FieldSetterDelegation(methodDescription, visibility.expandTo(accessType.getVisibility()), fieldDescription);
                }
                public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
                    StackManipulation.Size stackSize = new StackManipulation.Compound(MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(), FieldAccess.forField(fieldDescription).write(), MethodReturn.VOID).apply(methodVisitor, implementationContext);
                    return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
                }
            }
            public enum Factory implements ExtractableView.Factory {
                INSTANCE;
                public ExtractableView make(TypeDescription instrumentedType, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion classFileVersion, ClassFileVersion auxiliaryClassFileVersion) {
                    return make(instrumentedType, auxiliaryTypeNamingStrategy, typeInitializer, classFileVersion, auxiliaryClassFileVersion, classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6) ? FrameGeneration.GENERATE : FrameGeneration.DISABLED);
                }
                public ExtractableView make(TypeDescription instrumentedType, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion classFileVersion, ClassFileVersion auxiliaryClassFileVersion, FrameGeneration frameGeneration) {
                    return new Default(instrumentedType, classFileVersion, auxiliaryTypeNamingStrategy, typeInitializer, auxiliaryClassFileVersion, frameGeneration, RandomString.make());
                }
                public static class WithFixedSuffix implements ExtractableView.Factory {
                    private final String suffix;
                    public WithFixedSuffix(String suffix) {
                        this.suffix = suffix;
                    }
                    public ExtractableView make(TypeDescription instrumentedType, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion classFileVersion, ClassFileVersion auxiliaryClassFileVersion) {
                        return make(instrumentedType, auxiliaryTypeNamingStrategy, typeInitializer, classFileVersion, auxiliaryClassFileVersion, classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6) ? FrameGeneration.GENERATE : FrameGeneration.DISABLED);
                    }
                    public ExtractableView make(TypeDescription instrumentedType, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion classFileVersion, ClassFileVersion auxiliaryClassFileVersion, FrameGeneration frameGeneration) {
                        return new Default(instrumentedType, classFileVersion, auxiliaryTypeNamingStrategy, typeInitializer, auxiliaryClassFileVersion, frameGeneration, suffix);
                    }
                }
            }
        }
    }
    class Compound implements Implementation {
        private final List<Implementation> implementations;
        public Compound(Implementation... implementation) {
            this(Arrays.asList(implementation));
        }
        public Compound(List<? extends Implementation> implementations) {
            this.implementations = new ArrayList<Implementation>();
            for (Implementation implementation : implementations) {
                if (implementation instanceof Compound.Composable) {
                    this.implementations.addAll(((Compound.Composable) implementation).implementations);
                    this.implementations.add(((Compound.Composable) implementation).composable);
                } else if (implementation instanceof Compound) {
                    this.implementations.addAll(((Compound) implementation).implementations);
                } else {
                    this.implementations.add(implementation);
                }
            }
        }
        public InstrumentedType prepare(InstrumentedType instrumentedType) {
            for (Implementation implementation : implementations) {
                instrumentedType = implementation.prepare(instrumentedType);
            }
            return instrumentedType;
        }
        public ByteCodeAppender appender(Target implementationTarget) {
            ByteCodeAppender[] byteCodeAppender = new ByteCodeAppender[implementations.size()];
            int index = 0;
            for (Implementation implementation : implementations) {
                byteCodeAppender[index++] = implementation.appender(implementationTarget);
            }
            return new ByteCodeAppender.Compound(byteCodeAppender);
        }
        public static class Composable implements Implementation.Composable {
            private final Implementation.Composable composable;
            private final List<Implementation> implementations;
            public Composable(Implementation implementation, Implementation.Composable composable) {
                this(Collections.singletonList(implementation), composable);
            }
            public Composable(List<? extends Implementation> implementations, Implementation.Composable composable) {
                this.implementations = new ArrayList<Implementation>();
                for (Implementation implementation : implementations) {
                    if (implementation instanceof Compound.Composable) {
                        this.implementations.addAll(((Compound.Composable) implementation).implementations);
                        this.implementations.add(((Compound.Composable) implementation).composable);
                    } else if (implementation instanceof Compound) {
                        this.implementations.addAll(((Compound) implementation).implementations);
                    } else {
                        this.implementations.add(implementation);
                    }
                }
                if (composable instanceof Compound.Composable) {
                    this.implementations.addAll(((Compound.Composable) composable).implementations);
                    this.composable = ((Compound.Composable) composable).composable;
                } else {
                    this.composable = composable;
                }
            }
            public InstrumentedType prepare(InstrumentedType instrumentedType) {
                for (Implementation implementation : implementations) {
                    instrumentedType = implementation.prepare(instrumentedType);
                }
                return composable.prepare(instrumentedType);
            }
            public ByteCodeAppender appender(Target implementationTarget) {
                ByteCodeAppender[] byteCodeAppender = new ByteCodeAppender[implementations.size() + 1];
                int index = 0;
                for (Implementation implementation : implementations) {
                    byteCodeAppender[index++] = implementation.appender(implementationTarget);
                }
                byteCodeAppender[index] = composable.appender(implementationTarget);
                return new ByteCodeAppender.Compound(byteCodeAppender);
            }
            public Implementation andThen(Implementation implementation) {
                return new Compound(CompoundList.of(implementations, composable.andThen(implementation)));
            }
            public Implementation.Composable andThen(Implementation.Composable implementation) {
                return new Compound.Composable(implementations, composable.andThen(implementation));
            }
        }
    }
    class Simple implements Implementation {
        private static final int NO_ADDITIONAL_VARIABLES = 0;
        private final ByteCodeAppender byteCodeAppender;
        public Simple(ByteCodeAppender... byteCodeAppender) {
            this.byteCodeAppender = new ByteCodeAppender.Compound(byteCodeAppender);
        }
        public Simple(StackManipulation... stackManipulation) {
            byteCodeAppender = new ByteCodeAppender.Simple(stackManipulation);
        }
        public static Implementation of(Dispatcher dispatcher) {
            return of(dispatcher, NO_ADDITIONAL_VARIABLES);
        }
        public static Implementation of(Dispatcher dispatcher, int additionalVariableLength) {
            return of(dispatcher, NoOp.INSTANCE, additionalVariableLength);
        }
        public static Implementation of(Dispatcher dispatcher, InstrumentedType.Prepareable prepareable) {
            return of(dispatcher, prepareable, NO_ADDITIONAL_VARIABLES);
        }
        public static Implementation of(Dispatcher dispatcher, InstrumentedType.Prepareable prepareable, int additionalVariableLength) {
            if (additionalVariableLength < NO_ADDITIONAL_VARIABLES) {
                throw new IllegalArgumentException("Additional variable length cannot be negative: " + additionalVariableLength);
            }
            return new ForDispatcher(dispatcher, prepareable, additionalVariableLength);
        }
        public InstrumentedType prepare(InstrumentedType instrumentedType) {
            return instrumentedType;
        }
        public ByteCodeAppender appender(Target implementationTarget) {
            return byteCodeAppender;
        }
        public interface Dispatcher {
            StackManipulation apply(Target implementationTarget, MethodDescription instrumentedMethod);
        }
        protected static class ForDispatcher implements Implementation {
            private final Dispatcher dispatcher;
            private final InstrumentedType.Prepareable prepareable;
            private final int additionalVariableLength;
            protected ForDispatcher(Dispatcher dispatcher, InstrumentedType.Prepareable prepareable, int additionalVariableLength) {
                this.dispatcher = dispatcher;
                this.prepareable = prepareable;
                this.additionalVariableLength = additionalVariableLength;
            }
            public InstrumentedType prepare(InstrumentedType instrumentedType) {
                return prepareable.prepare(instrumentedType);
            }
            public ByteCodeAppender appender(Target implementationTarget) {
                return new Appender(implementationTarget);
            }
            protected class Appender implements ByteCodeAppender {
                private final Target implementationTarget;
                protected Appender(Target implementationTarget) {
                    this.implementationTarget = implementationTarget;
                }
                public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
                    return new Size(dispatcher.apply(implementationTarget, instrumentedMethod).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize() + additionalVariableLength);
                }
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```