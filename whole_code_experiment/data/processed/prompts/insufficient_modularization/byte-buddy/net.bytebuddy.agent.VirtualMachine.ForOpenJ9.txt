##CONTEXT_SIZE=12152
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.agent;
public interface VirtualMachine {
    Properties getSystemProperties() throws IOException;
    Properties getAgentProperties() throws IOException;
    void loadAgent(String jarFile) throws IOException;
    void loadAgent(String jarFile, @MaybeNull String argument) throws IOException;
    void loadAgentPath(String path) throws IOException;
    void loadAgentPath(String path, @MaybeNull String argument) throws IOException;
    void loadAgentLibrary(String library) throws IOException;
    void loadAgentLibrary(String library, @MaybeNull String argument) throws IOException;
    void startManagementAgent(Properties properties) throws IOException;
    String startLocalManagementAgent() throws IOException;
    void detach() throws IOException;
    enum Resolver implements PrivilegedAction<Class<? extends VirtualMachine>> {
        INSTANCE;
        public Class<? extends VirtualMachine> run() {
            try {
                Class.forName("com.sun.jna.Platform");
            } catch (ClassNotFoundException exception) {
                throw new IllegalStateException("Optional JNA dependency is not available", exception);
            }
            return System.getProperty("java.vm.name", "").toUpperCase(Locale.US).contains("J9") ? ForOpenJ9.class : ForHotSpot.class;
        }
    }
    abstract class AbstractBase implements VirtualMachine {
        public void loadAgent(String jarFile) throws IOException {
            loadAgent(jarFile, null);
        }
        public void loadAgentPath(String path) throws IOException {
            loadAgentPath(path, null);
        }
        public void loadAgentLibrary(String library) throws IOException {
            loadAgentLibrary(library, null);
        }
    }
    class ForHotSpot extends AbstractBase {
        private static final String PROTOCOL_VERSION = "1";
        private static final String LOAD_COMMAND = "load";
        private static final String INSTRUMENT_COMMAND = "instrument";
        private static final String ARGUMENT_DELIMITER = "=";
        private final Connection connection;
        protected ForHotSpot(Connection connection) {
            this.connection = connection;
        }
        public static VirtualMachine attach(String processId) throws IOException {
            if (Platform.isWindows()) {
                return attach(processId, new Connection.ForJnaWindowsNamedPipe.Factory());
            } else if (Platform.isSolaris()) {
                return attach(processId, new Connection.ForJnaSolarisDoor.Factory(15, 100, TimeUnit.MILLISECONDS));
            } else {
                return attach(processId, Connection.ForJnaPosixSocket.Factory.withDefaultTemporaryFolder(15, 100, TimeUnit.MILLISECONDS));
            }
        }
        public static VirtualMachine attach(String processId, Connection.Factory connectionFactory) throws IOException {
            return new ForHotSpot(connectionFactory.connect(processId));
        }
        private static void checkHeader(Connection.Response response) throws IOException {
            byte[] buffer = new byte[1];
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            int length;
            while ((length = response.read(buffer)) != -1) {
                if (length > 0) {
                    if (buffer[0] == '\n') {
                        break;
                    }
                    outputStream.write(buffer[0]);
                }
            }
            switch(Integer.parseInt(outputStream.toString("UTF-8"))) {
                case 0:
                    return;
                case 101:
                    throw new IOException("Protocol mismatch with target VM");
                default:
                    buffer = new byte[1024];
                    outputStream = new ByteArrayOutputStream();
                    while ((length = response.read(buffer)) != -1) {
                        outputStream.write(buffer, 0, length);
                    }
                    throw new IllegalStateException(outputStream.toString("UTF-8"));
            }
        }
        public Properties getSystemProperties() throws IOException {
            return getProperties("properties");
        }
        public Properties getAgentProperties() throws IOException {
            return getProperties("agentProperties");
        }
        private Properties getProperties(String command) throws IOException {
            Connection.Response response = connection.execute(PROTOCOL_VERSION, command, null, null, null);
            try {
                checkHeader(response);
                byte[] buffer = new byte[1024];
                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                int length;
                while ((length = response.read(buffer)) != -1) {
                    outputStream.write(buffer, 0, length);
                }
                Properties properties = new Properties();
                properties.load(new ByteArrayInputStream(outputStream.toByteArray()));
                return properties;
            } finally {
                response.close();
            }
        }
        public void loadAgent(String jarFile, @MaybeNull String argument) throws IOException {
            load(jarFile, false, argument);
        }
        public void loadAgentPath(String path, @MaybeNull String argument) throws IOException {
            load(path, true, argument);
        }
        public void loadAgentLibrary(String library, @MaybeNull String argument) throws IOException {
            load(library, false, argument);
        }
        protected void load(String file, boolean absolute, @MaybeNull String argument) throws IOException {
            Connection.Response response = connection.execute(PROTOCOL_VERSION, LOAD_COMMAND, INSTRUMENT_COMMAND, Boolean.toString(absolute), (argument == null ? file : file + ARGUMENT_DELIMITER + argument));
            try {
                checkHeader(response);
            } finally {
                response.close();
            }
        }
        public void startManagementAgent(Properties properties) throws IOException {
            StringBuilder stringBuilder = new StringBuilder("ManagementAgent.start ");
            boolean first = true;
            for (Map.Entry<Object, Object> entry : properties.entrySet()) {
                if (!(entry.getKey() instanceof String) || !((String) entry.getKey()).startsWith("com.sun.management.")) {
                    throw new IllegalArgumentException("Illegal property name: " + entry.getKey());
                } else if (first) {
                    first = false;
                } else {
                    stringBuilder.append(' ');
                }
                stringBuilder.append(((String) entry.getKey()).substring("com.sun.management.".length())).append('=');
                String value = entry.getValue().toString();
                if (value.contains(" ")) {
                    stringBuilder.append('\'').append(value).append('\'');
                } else {
                    stringBuilder.append(value);
                }
            }
            Connection.Response response = connection.execute(PROTOCOL_VERSION, "jcmd", stringBuilder.toString(), null, null);
            try {
                checkHeader(response);
            } finally {
                response.close();
            }
        }
        public String startLocalManagementAgent() throws IOException {
            Connection.Response response = connection.execute(PROTOCOL_VERSION, "jcmd", "ManagementAgent.start_local", null, null);
            try {
                checkHeader(response);
                return getAgentProperties().getProperty("com.sun.management.jmxremote.localConnectorAddress");
            } finally {
                response.close();
            }
        }
        public void detach() throws IOException {
            connection.close();
        }
        public interface Connection extends Closeable {
            Response execute(String protocol, String... argument) throws IOException;
            interface Response extends Closeable {
                int read(byte[] buffer) throws IOException;
            }
            interface Factory {
                Connection connect(String processId) throws IOException;
                abstract class ForSocketFile implements Factory {
                    private static final String SOCKET_FILE_PREFIX = ".java_pid";
                    private static final String ATTACH_FILE_PREFIX = ".attach_pid";
                    private final String temporaryDirectory;
                    private final int attempts;
                    private final long pause;
                    private final TimeUnit timeUnit;
                    protected ForSocketFile(String temporaryDirectory, int attempts, long pause, TimeUnit timeUnit) {
                        this.temporaryDirectory = temporaryDirectory;
                        this.attempts = attempts;
                        this.pause = pause;
                        this.timeUnit = timeUnit;
                    }
                    public Connection connect(String processId) throws IOException {
                        File socket = new File(temporaryDirectory, SOCKET_FILE_PREFIX + processId);
                        if (!socket.exists()) {
                            String target = ATTACH_FILE_PREFIX + processId, path = "/proc/" + processId + "/cwd/" + target;
                            File attachFile = new File(path);
                            try {
                                if (!attachFile.createNewFile() && !attachFile.isFile()) {
                                    throw new IllegalStateException("Could not create attach file: " + attachFile);
                                }
                            } catch (IOException ignored) {
                                attachFile = new File(temporaryDirectory, target);
                                if (!attachFile.createNewFile() && !attachFile.isFile()) {
                                    throw new IllegalStateException("Could not create attach file: " + attachFile);
                                }
                            }
                            try {
                                kill(processId, 3);
                                int attempts = this.attempts;
                                while (!socket.exists() && attempts-- > 0) {
                                    timeUnit.sleep(pause);
                                }
                                if (!socket.exists()) {
                                    throw new IllegalStateException("Target VM did not respond: " + processId);
                                }
                            } catch (InterruptedException exception) {
                                Thread.currentThread().interrupt();
                                throw new IllegalStateException(exception);
                            } finally {
                                if (!attachFile.delete()) {
                                    attachFile.deleteOnExit();
                                }
                            }
                        }
                        return doConnect(socket);
                    }
                    protected abstract void kill(String processId, int signal);
                    protected abstract Connection doConnect(File socket) throws IOException;
                }
            }
            abstract class OnPersistentByteChannel<T> implements Connection {
                private static final byte[] BLANK = new byte[] { 0 };
                public Connection.Response execute(String protocol, String... argument) throws IOException {
                    T connection = connect();
                    try {
                        write(connection, protocol.getBytes("UTF-8"));
                        write(connection, BLANK);
                        for (String anArgument : argument) {
                            if (anArgument != null) {
                                write(connection, anArgument.getBytes("UTF-8"));
                            }
                            write(connection, BLANK);
                        }
                        return new Response(connection);
                    } catch (Throwable throwable) {
                        close(connection);
                        if (throwable instanceof RuntimeException) {
                            throw (RuntimeException) throwable;
                        } else if (throwable instanceof IOException) {
                            throw (IOException) throwable;
                        } else {
                            throw new IllegalStateException(throwable);
                        }
                    }
                }
                private class Response implements Connection.Response {
                    private final T connection;
                    private Response(T connection) {
                        this.connection = connection;
                    }
                    public int read(byte[] buffer) throws IOException {
                        return OnPersistentByteChannel.this.read(connection, buffer);
                    }
                    public void close() throws IOException {
                        OnPersistentByteChannel.this.close(connection);
                    }
                }
                protected abstract T connect() throws IOException;
                protected abstract void close(T connection) throws IOException;
                protected abstract void write(T connection, byte[] buffer) throws IOException;
                protected abstract int read(T connection, byte[] buffer) throws IOException;
            }
            class ForJnaPosixSocket extends OnPersistentByteChannel<Integer> {
                private final PosixLibrary library;
                private final File socket;
                protected ForJnaPosixSocket(PosixLibrary library, File socket) {
                    this.library = library;
                    this.socket = socket;
                }
                protected Integer connect() {
                    int handle = library.socket(1, 1, 0);
                    try {
                        PosixLibrary.SocketAddress address = new PosixLibrary.SocketAddress();
                        try {
                            address.setPath(socket.getAbsolutePath());
                            library.connect(handle, address, address.size());
                            return handle;
                        } finally {
                            address = null;
                        }
                    } catch (RuntimeException exception) {
                        library.close(handle);
                        throw exception;
                    }
                }
                protected int read(Integer handle, byte[] buffer) {
                    int read = library.read(handle, ByteBuffer.wrap(buffer), buffer.length);
                    return read == 0 ? -1 : read;
                }
                protected void write(Integer handle, byte[] buffer) {
                    library.write(handle, ByteBuffer.wrap(buffer), buffer.length);
                }
                protected void close(Integer handle) {
                    library.close(handle);
                }
                public void close() {
                }
                protected interface PosixLibrary extends Library {
                    int kill(int processId, int signal) throws LastErrorException;
                    int socket(int domain, int type, int protocol) throws LastErrorException;
                    int connect(int handle, SocketAddress address, int length) throws LastErrorException;
                    int read(int handle, ByteBuffer buffer, int count) throws LastErrorException;
                    int write(int handle, ByteBuffer buffer, int count) throws LastErrorException;
                    int close(int handle) throws LastErrorException;
                    class SocketAddress extends Structure {
                        public short family = 1;
                        public byte[] path = new byte[100];
                        protected void setPath(String path) {
                            try {
                                System.arraycopy(path.getBytes("UTF-8"), 0, this.path, 0, path.length());
                                System.arraycopy(new byte[] { 0 }, 0, this.path, path.length(), 1);
                            } catch (UnsupportedEncodingException exception) {
                                throw new IllegalStateException(exception);
                            }
                        }
                        protected List<String> getFieldOrder() {
                            return Arrays.asList("family", "path");
                        }
                    }
                }
                public static class Factory extends Connection.Factory.ForSocketFile {
                    private final PosixLibrary library;
                    @SuppressWarnings("deprecation")
                    public Factory(String temporaryDirectory, int attempts, long pause, TimeUnit timeUnit) {
                        super(temporaryDirectory, attempts, pause, timeUnit);
                        library = Native.loadLibrary("c", PosixLibrary.class);
                    }
                    public static Connection.Factory withDefaultTemporaryFolder(int attempts, long pause, TimeUnit timeUnit) {
                        String temporaryDirectory;
                        if (Platform.isMac()) {
                            MacLibrary library = Native.loadLibrary("c", MacLibrary.class);
                            Memory memory = new Memory(4096);
                            try {
                                long length = library.confstr(MacLibrary.CS_DARWIN_USER_TEMP_DIR, memory, memory.size());
                                if (length == 0 || length > 4096) {
                                    temporaryDirectory = "/tmp";
                                } else {
                                    temporaryDirectory = memory.getString(0);
                                }
                            } finally {
                                memory = null;
                            }
                        } else {
                            temporaryDirectory = "/tmp";
                        }
                        return new Factory(temporaryDirectory, attempts, pause, timeUnit);
                    }
                    protected void kill(String processId, int signal) {
                        library.kill(Integer.parseInt(processId), signal);
                    }
                    public Connection doConnect(File socket) {
                        return new Connection.ForJnaPosixSocket(library, socket);
                    }
                    public interface MacLibrary extends Library {
                        int CS_DARWIN_USER_TEMP_DIR = 65537;
                        long confstr(int name, Pointer buffer, long length);
                    }
                }
            }
            class ForJnaWindowsNamedPipe implements Connection {
                private static final int MEM_RELEASE = 0x8000;
                private final WindowsLibrary library;
                private final WindowsAttachLibrary attachLibrary;
                private final WinNT.HANDLE process;
                private final WinDef.LPVOID code;
                private final SecureRandom random;
                protected ForJnaWindowsNamedPipe(WindowsLibrary library, WindowsAttachLibrary attachLibrary, WinNT.HANDLE process, WinDef.LPVOID code) {
                    this.library = library;
                    this.attachLibrary = attachLibrary;
                    this.process = process;
                    this.code = code;
                    random = new SecureRandom();
                }
                public Response execute(String protocol, String... argument) {
                    if (!"1".equals(protocol)) {
                        throw new IllegalArgumentException("Unknown protocol version: " + protocol);
                    } else if (argument.length > 4) {
                        throw new IllegalArgumentException("Cannot supply more then four arguments to Windows attach mechanism: " + Arrays.asList(argument));
                    }
                    String name = "\\\\.\\pipe\\javatool" + Math.abs(random.nextInt() + 1);
                    WinBase.SECURITY_ATTRIBUTES sa = createSecurityAttributesToAllowMediumIntegrity();
                    WinNT.HANDLE pipe = Kernel32.INSTANCE.CreateNamedPipe(name, WinBase.PIPE_ACCESS_INBOUND, WinBase.PIPE_TYPE_BYTE | WinBase.PIPE_READMODE_BYTE | WinBase.PIPE_WAIT, 1, 4096, 8192, WinBase.NMPWAIT_USE_DEFAULT_WAIT, sa);
                    if (pipe == null) {
                        throw new Win32Exception(Native.getLastError());
                    }
                    try {
                        WinDef.LPVOID data = attachLibrary.allocate_remote_argument(process, name, argument.length < 1 ? null : argument[0], argument.length < 2 ? null : argument[1], argument.length < 3 ? null : argument[2], argument.length < 4 ? null : argument[3]);
                        if (data == null) {
                            throw new Win32Exception(Native.getLastError());
                        }
                        try {
                            WinNT.HANDLE thread = library.CreateRemoteThread(process, null, 0, code.getPointer(), data.getPointer(), null, null);
                            if (thread == null) {
                                throw new Win32Exception(Native.getLastError());
                            }
                            try {
                                int result = Kernel32.INSTANCE.WaitForSingleObject(thread, WinBase.INFINITE);
                                if (result != 0) {
                                    throw new Win32Exception(result);
                                }
                                IntByReference exitCode = new IntByReference();
                                if (!library.GetExitCodeThread(thread, exitCode)) {
                                    throw new Win32Exception(Native.getLastError());
                                } else if (exitCode.getValue() != 0) {
                                    throw new IllegalStateException("Target VM could not dispatch command successfully: " + exitCode.getValue());
                                }
                                if (!Kernel32.INSTANCE.ConnectNamedPipe(pipe, null)) {
                                    int code = Native.getLastError();
                                    if (code != WinError.ERROR_PIPE_CONNECTED) {
                                        throw new Win32Exception(code);
                                    }
                                }
                                return new NamedPipeResponse(pipe);
                            } finally {
                                if (!Kernel32.INSTANCE.CloseHandle(thread)) {
                                    throw new Win32Exception(Native.getLastError());
                                }
                            }
                        } finally {
                            if (!library.VirtualFreeEx(process, data.getPointer(), 0, MEM_RELEASE)) {
                                throw new Win32Exception(Native.getLastError());
                            }
                        }
                    } catch (Throwable throwable) {
                        if (!Kernel32.INSTANCE.CloseHandle(pipe)) {
                            throw new Win32Exception(Native.getLastError());
                        } else if (throwable instanceof RuntimeException) {
                            throw (RuntimeException) throwable;
                        } else {
                            throw new IllegalStateException(throwable);
                        }
                    }
                }
                private WinBase.SECURITY_ATTRIBUTES createSecurityAttributesToAllowMediumIntegrity() {
                    WinNT.PSID pSidEverybody = new WinNT.PSID(WinNT.SECURITY_MAX_SID_SIZE);
                    if (!Advapi32.INSTANCE.CreateWellKnownSid(WinNT.WELL_KNOWN_SID_TYPE.WinWorldSid, null, pSidEverybody, new IntByReference(WinNT.SECURITY_MAX_SID_SIZE))) {
                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                    }
                    WinNT.PSID pSidSystem = new WinNT.PSID(WinNT.SECURITY_MAX_SID_SIZE);
                    if (!Advapi32.INSTANCE.CreateWellKnownSid(WinNT.WELL_KNOWN_SID_TYPE.WinBuiltinSystemOperatorsSid, null, pSidSystem, new IntByReference(WinNT.SECURITY_MAX_SID_SIZE))) {
                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                    }
                    WinNT.PSID pSidAdmin = new WinNT.PSID(WinNT.SECURITY_MAX_SID_SIZE);
                    if (!Advapi32.INSTANCE.CreateWellKnownSid(WinNT.WELL_KNOWN_SID_TYPE.WinBuiltinAdministratorsSid, null, pSidAdmin, new IntByReference(WinNT.SECURITY_MAX_SID_SIZE))) {
                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                    }
                    int cbAcl = Native.getNativeSize(WinNT.ACL.class, null);
                    cbAcl += Native.getNativeSize(WinNT.ACCESS_ALLOWED_ACE.class, null) * 3;
                    cbAcl += (Advapi32.INSTANCE.GetLengthSid(pSidEverybody) - WinDef.DWORD.SIZE);
                    cbAcl += (Advapi32.INSTANCE.GetLengthSid(pSidSystem) - WinDef.DWORD.SIZE);
                    cbAcl += (Advapi32.INSTANCE.GetLengthSid(pSidAdmin) - WinDef.DWORD.SIZE);
                    cbAcl = Advapi32Util.alignOnDWORD(cbAcl);
                    WinNT.ACL pAcl = new WinNT.ACL(cbAcl);
                    if (!Advapi32.INSTANCE.InitializeAcl(pAcl, cbAcl, WinNT.ACL_REVISION)) {
                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                    }
                    if (!Advapi32.INSTANCE.AddAccessAllowedAce(pAcl, WinNT.ACL_REVISION, WinNT.GENERIC_READ | WinNT.GENERIC_WRITE, pSidEverybody)) {
                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                    }
                    if (!Advapi32.INSTANCE.AddAccessAllowedAce(pAcl, WinNT.ACL_REVISION, WinNT.GENERIC_ALL, pSidSystem)) {
                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                    }
                    if (!Advapi32.INSTANCE.AddAccessAllowedAce(pAcl, WinNT.ACL_REVISION, WinNT.GENERIC_ALL, pSidAdmin)) {
                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                    }
                    WinNT.SECURITY_DESCRIPTOR sd = new WinNT.SECURITY_DESCRIPTOR(64 * 1024);
                    if (!Advapi32.INSTANCE.InitializeSecurityDescriptor(sd, WinNT.SECURITY_DESCRIPTOR_REVISION)) {
                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                    }
                    if (!Advapi32.INSTANCE.SetSecurityDescriptorDacl(sd, true, pAcl, false)) {
                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                    }
                    WinBase.SECURITY_ATTRIBUTES sa = new WinBase.SECURITY_ATTRIBUTES();
                    sa.dwLength = new WinDef.DWORD(sa.size());
                    sa.lpSecurityDescriptor = sd.getPointer();
                    return sa;
                }
                public void close() {
                    try {
                        if (!library.VirtualFreeEx(process, code.getPointer(), 0, MEM_RELEASE)) {
                            throw new Win32Exception(Native.getLastError());
                        }
                    } finally {
                        if (!Kernel32.INSTANCE.CloseHandle(process)) {
                            throw new Win32Exception(Native.getLastError());
                        }
                    }
                }
                protected interface WindowsLibrary extends StdCallLibrary {
                    Pointer VirtualAllocEx(WinNT.HANDLE process, Pointer address, int size, int allocationType, int protect);
                    boolean VirtualFreeEx(WinNT.HANDLE process, Pointer address, int size, int freeType);
                    WinNT.HANDLE CreateRemoteThread(WinNT.HANDLE process, @MaybeNull WinBase.SECURITY_ATTRIBUTES securityAttributes, int stackSize, Pointer code, Pointer argument, @MaybeNull WinDef.DWORD creationFlags, @MaybeNull Pointer threadId);
                    boolean GetExitCodeThread(WinNT.HANDLE thread, IntByReference exitCode);
                }
                protected interface WindowsAttachLibrary extends StdCallLibrary {
                    WinDef.LPVOID allocate_remote_code(WinNT.HANDLE process);
                    WinDef.LPVOID allocate_remote_argument(WinNT.HANDLE process, String pipe, @MaybeNull String argument0, @MaybeNull String argument1, @MaybeNull String argument2, @MaybeNull String argument3);
                }
                protected static class NamedPipeResponse implements Response {
                    private final WinNT.HANDLE pipe;
                    protected NamedPipeResponse(WinNT.HANDLE pipe) {
                        this.pipe = pipe;
                    }
                    public int read(byte[] buffer) {
                        IntByReference read = new IntByReference();
                        if (!Kernel32.INSTANCE.ReadFile(pipe, buffer, buffer.length, read, null)) {
                            int code = Native.getLastError();
                            if (code == WinError.ERROR_BROKEN_PIPE) {
                                return -1;
                            } else {
                                throw new Win32Exception(code);
                            }
                        }
                        return read.getValue();
                    }
                    public void close() {
                        try {
                            if (!Kernel32.INSTANCE.DisconnectNamedPipe(pipe)) {
                                throw new Win32Exception(Native.getLastError());
                            }
                        } finally {
                            if (!Kernel32.INSTANCE.CloseHandle(pipe)) {
                                throw new Win32Exception(Native.getLastError());
                            }
                        }
                    }
                }
                public static class Factory implements Connection.Factory {
                    public static final String LIBRARY_NAME = "net.bytebuddy.library.name";
                    private final WindowsLibrary library;
                    private final WindowsAttachLibrary attachLibrary;
                    @SuppressWarnings("deprecation")
                    public Factory() {
                        library = Native.loadLibrary("kernel32", WindowsLibrary.class, W32APIOptions.DEFAULT_OPTIONS);
                        attachLibrary = Native.loadLibrary(System.getProperty(LIBRARY_NAME, "attach_hotspot_windows"), WindowsAttachLibrary.class);
                    }
                    public Connection connect(String processId) {
                        WinNT.HANDLE process = Kernel32.INSTANCE.OpenProcess(WinNT.PROCESS_ALL_ACCESS, false, Integer.parseInt(processId));
                        if (process == null) {
                            throw new Win32Exception(Native.getLastError());
                        }
                        try {
                            WinDef.LPVOID code = attachLibrary.allocate_remote_code(process);
                            if (code == null) {
                                throw new Win32Exception(Native.getLastError());
                            }
                            return new ForJnaWindowsNamedPipe(library, attachLibrary, process, code);
                        } catch (Throwable throwable) {
                            if (!Kernel32.INSTANCE.CloseHandle(process)) {
                                throw new Win32Exception(Native.getLastError());
                            } else if (throwable instanceof RuntimeException) {
                                throw (RuntimeException) throwable;
                            } else {
                                throw new IllegalStateException(throwable);
                            }
                        }
                    }
                }
            }
            class ForJnaSolarisDoor implements Connection {
                private final SolarisLibrary library;
                private final File socket;
                protected ForJnaSolarisDoor(SolarisLibrary library, File socket) {
                    this.library = library;
                    this.socket = socket;
                }
                public Connection.Response execute(String protocol, String... argument) throws IOException {
                    int handle = library.open(socket.getAbsolutePath(), 2);
                    try {
                        SolarisLibrary.DoorArgument door = new SolarisLibrary.DoorArgument();
                        try {
                            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                            outputStream.write(protocol.getBytes("UTF-8"));
                            outputStream.write(0);
                            for (String anArgument : argument) {
                                if (anArgument != null) {
                                    outputStream.write(anArgument.getBytes("UTF-8"));
                                }
                                outputStream.write(0);
                            }
                            door.dataSize = outputStream.size();
                            Memory dataPointer = new Memory(outputStream.size());
                            try {
                                dataPointer.write(0, outputStream.toByteArray(), 0, outputStream.size());
                                door.dataPointer = dataPointer;
                                Memory result = new Memory(128);
                                try {
                                    door.resultPointer = result;
                                    door.resultSize = (int) result.size();
                                    if (library.door_call(handle, door) != 0) {
                                        throw new IllegalStateException("Door call to target VM failed");
                                    } else if (door.resultSize < 4 || door.resultPointer.getInt(0) != 0) {
                                        throw new IllegalStateException("Target VM could not execute door call");
                                    } else if (door.descriptorCount != 1 || door.descriptorPointer == null) {
                                        throw new IllegalStateException("Did not receive communication descriptor from target VM");
                                    } else {
                                        return new Response(library, door.descriptorPointer.getInt(4));
                                    }
                                } finally {
                                    result = null;
                                }
                            } finally {
                                dataPointer = null;
                            }
                        } finally {
                            door = null;
                        }
                    } finally {
                        library.close(handle);
                    }
                }
                public void close() {
                }
                protected interface SolarisLibrary extends Library {
                    int kill(int processId, int signal) throws LastErrorException;
                    int open(String file, int flags) throws LastErrorException;
                    int read(int handle, ByteBuffer buffer, int length) throws LastErrorException;
                    int close(int descriptor) throws LastErrorException;
                    int door_call(int descriptor, DoorArgument argument) throws LastErrorException;
                    class DoorArgument extends Structure {
                        public Pointer dataPointer;
                        public int dataSize;
                        public Pointer descriptorPointer;
                        public int descriptorCount;
                        public Pointer resultPointer;
                        public int resultSize;
                        protected List<String> getFieldOrder() {
                            return Arrays.asList("dataPointer", "dataSize", "descriptorPointer", "descriptorCount", "resultPointer", "resultSize");
                        }
                    }
                }
                protected static class Response implements Connection.Response {
                    private final SolarisLibrary library;
                    private final int handle;
                    protected Response(SolarisLibrary library, int handle) {
                        this.library = library;
                        this.handle = handle;
                    }
                    public int read(byte[] buffer) {
                        int read = library.read(handle, ByteBuffer.wrap(buffer), buffer.length);
                        return read == 0 ? -1 : read;
                    }
                    public void close() {
                        library.close(handle);
                    }
                }
                public static class Factory extends Connection.Factory.ForSocketFile {
                    private final SolarisLibrary library;
                    @SuppressWarnings("deprecation")
                    public Factory(int attempts, long pause, TimeUnit timeUnit) {
                        super("/tmp", attempts, pause, timeUnit);
                        library = Native.loadLibrary("c", SolarisLibrary.class);
                    }
                    protected void kill(String processId, int signal) {
                        library.kill(Integer.parseInt(processId), signal);
                    }
                    protected Connection doConnect(File socket) {
                        return new ForJnaSolarisDoor(library, socket);
                    }
                }
            }
        }
    }
    class ForOpenJ9 extends AbstractBase {
        private static final String IBM_TEMPORARY_FOLDER = "com.ibm.tools.attach.directory";
        private static final SecureRandom SECURE_RANDOM = new SecureRandom();
        private final Socket socket;
        protected ForOpenJ9(Socket socket) {
            this.socket = socket;
        }
        public static VirtualMachine attach(String processId) throws IOException {
            return attach(processId, 5000, Platform.isWindows() ? new Dispatcher.ForJnaWindowsEnvironment() : new Dispatcher.ForJnaPosixEnvironment(15, 100, TimeUnit.MILLISECONDS));
        }
        public static VirtualMachine attach(String processId, int timeout, Dispatcher dispatcher) throws IOException {
            String temporary = System.getProperty(IBM_TEMPORARY_FOLDER);
            File directory = temporary == null ? new File(dispatcher.getTemporaryFolder(processId), ".com_ibm_tools_attach") : new File(temporary);
            long userId = dispatcher.userId();
            RandomAccessFile attachLock = new RandomAccessFile(new File(directory, "_attachlock"), "rw");
            try {
                FileLock attachLockLock = attachLock.getChannel().lock();
                try {
                    List<Properties> virtualMachines;
                    RandomAccessFile master = new RandomAccessFile(new File(directory, "_master"), "rw");
                    try {
                        FileLock masterLock = master.getChannel().lock();
                        try {
                            File[] vmFolder = directory.listFiles();
                            if (vmFolder == null) {
                                throw new IllegalStateException("No descriptor files found in " + directory);
                            }
                            virtualMachines = new ArrayList<Properties>();
                            for (File aVmFolder : vmFolder) {
                                if (aVmFolder.isDirectory() && (userId == 0L || dispatcher.getOwnerIdOf(aVmFolder) == userId)) {
                                    File attachInfo = new File(aVmFolder, "attachInfo");
                                    if (attachInfo.isFile()) {
                                        Properties virtualMachine = new Properties();
                                        FileInputStream inputStream = new FileInputStream(attachInfo);
                                        try {
                                            virtualMachine.load(inputStream);
                                        } finally {
                                            inputStream.close();
                                        }
                                        int targetProcessId = Integer.parseInt(virtualMachine.getProperty("processId"));
                                        long targetUserId;
                                        try {
                                            targetUserId = Long.parseLong(virtualMachine.getProperty("userUid"));
                                        } catch (NumberFormatException ignored) {
                                            targetUserId = 0L;
                                        }
                                        if (userId != 0L && targetUserId == 0L) {
                                            targetUserId = dispatcher.getOwnerIdOf(attachInfo);
                                        }
                                        if (targetProcessId == 0L || dispatcher.isExistingProcess(targetProcessId)) {
                                            virtualMachines.add(virtualMachine);
                                        } else if (userId == 0L || targetUserId == userId) {
                                            File[] vmFile = aVmFolder.listFiles();
                                            if (vmFile != null) {
                                                for (File aVmFile : vmFile) {
                                                    if (!aVmFile.delete()) {
                                                        aVmFile.deleteOnExit();
                                                    }
                                                }
                                            }
                                            if (!aVmFolder.delete()) {
                                                aVmFolder.deleteOnExit();
                                            }
                                        }
                                    }
                                }
                            }
                        } finally {
                            masterLock.release();
                        }
                    } finally {
                        master.close();
                    }
                    Properties target = null;
                    for (Properties virtualMachine : virtualMachines) {
                        if (virtualMachine.getProperty("processId").equalsIgnoreCase(processId)) {
                            target = virtualMachine;
                            break;
                        }
                    }
                    if (target == null) {
                        throw new IllegalStateException("Could not locate target process info in " + directory);
                    }
                    ServerSocket serverSocket = new ServerSocket(0);
                    try {
                        serverSocket.setSoTimeout(timeout);
                        File receiver = new File(directory, target.getProperty("vmId"));
                        String key;
                        synchronized (SECURE_RANDOM) {
                            key = Long.toHexString(SECURE_RANDOM.nextLong());
                        }
                        File reply = new File(receiver, "replyInfo");
                        long targetUserId;
                        try {
                            targetUserId = Long.parseLong(target.getProperty("userUid"));
                        } catch (NumberFormatException ignored) {
                            targetUserId = 0L;
                        }
                        try {
                            if (reply.createNewFile()) {
                                dispatcher.setPermissions(reply, 0600);
                            }
                            if (userId == 0L && targetUserId != 0L) {
                                dispatcher.chownFileToUser(reply, targetUserId);
                            }
                            FileOutputStream outputStream = new FileOutputStream(reply);
                            try {
                                outputStream.write(key.getBytes("UTF-8"));
                                outputStream.write("\n".getBytes("UTF-8"));
                                outputStream.write(Long.toString(serverSocket.getLocalPort()).getBytes("UTF-8"));
                                outputStream.write("\n".getBytes("UTF-8"));
                            } finally {
                                outputStream.close();
                            }
                            Map<RandomAccessFile, FileLock> locks = new HashMap<RandomAccessFile, FileLock>();
                            try {
                                String pid = Long.toString(dispatcher.pid());
                                for (Properties virtualMachine : virtualMachines) {
                                    if (!virtualMachine.getProperty("processId").equalsIgnoreCase(pid)) {
                                        String attachNotificationSync = virtualMachine.getProperty("attachNotificationSync");
                                        RandomAccessFile syncFile = new RandomAccessFile(attachNotificationSync == null ? new File(directory, "attachNotificationSync") : new File(attachNotificationSync), "rw");
                                        try {
                                            locks.put(syncFile, syncFile.getChannel().lock());
                                        } catch (IOException ignored) {
                                            syncFile.close();
                                        }
                                    }
                                }
                                int notifications = 0;
                                File[] item = directory.listFiles();
                                if (item != null) {
                                    for (File anItem : item) {
                                        String name = anItem.getName();
                                        if (!name.startsWith(".trash_") && !name.equalsIgnoreCase("_attachlock") && !name.equalsIgnoreCase("_master") && !name.equalsIgnoreCase("_notifier")) {
                                            notifications += 1;
                                        }
                                    }
                                }
                                boolean global = Boolean.parseBoolean(target.getProperty("globalSemaphore"));
                                dispatcher.incrementSemaphore(directory, "_notifier", global, notifications);
                                try {
                                    Socket socket = serverSocket.accept();
                                    String answer = new String(read(socket), "UTF-8");
                                    if (answer.contains(' ' + key + ' ')) {
                                        return new ForOpenJ9(socket);
                                    } else {
                                        socket.close();
                                        throw new IllegalStateException("Unexpected answered to attachment: " + answer);
                                    }
                                } finally {
                                    dispatcher.decrementSemaphore(directory, "_notifier", global, notifications);
                                }
                            } finally {
                                for (Map.Entry<RandomAccessFile, FileLock> entry : locks.entrySet()) {
                                    try {
                                        try {
                                            entry.getValue().release();
                                        } finally {
                                            entry.getKey().close();
                                        }
                                    } catch (Throwable ignored) {
                                    }
                                }
                            }
                        } finally {
                            if (!reply.delete()) {
                                reply.deleteOnExit();
                            }
                        }
                    } finally {
                        serverSocket.close();
                    }
                } finally {
                    attachLockLock.release();
                }
            } finally {
                attachLock.close();
            }
        }
        public Properties getSystemProperties() throws IOException {
            write(socket, "ATTACH_GETSYSTEMPROPERTIES".getBytes("UTF-8"));
            Properties properties = new Properties();
            properties.load(new ByteArrayInputStream(read(socket)));
            return properties;
        }
        public Properties getAgentProperties() throws IOException {
            write(socket, "ATTACH_GETAGENTPROPERTIES".getBytes("UTF-8"));
            Properties properties = new Properties();
            properties.load(new ByteArrayInputStream(read(socket)));
            return properties;
        }
        public void loadAgent(String jarFile, @MaybeNull String argument) throws IOException {
            write(socket, ("ATTACH_LOADAGENT(instrument," + jarFile + '=' + (argument == null ? "" : argument) + ')').getBytes("UTF-8"));
            String answer = new String(read(socket), "UTF-8");
            if (answer.startsWith("ATTACH_ERR")) {
                throw new IllegalStateException("Target VM failed loading agent: " + answer);
            } else if (!answer.startsWith("ATTACH_ACK") && !answer.startsWith("ATTACH_RESULT=")) {
                throw new IllegalStateException("Unexpected response: " + answer);
            }
        }
        public void loadAgentPath(String path, @MaybeNull String argument) throws IOException {
            write(socket, ("ATTACH_LOADAGENTPATH(" + path + (argument == null ? "" : (',' + argument)) + ')').getBytes("UTF-8"));
            String answer = new String(read(socket), "UTF-8");
            if (answer.startsWith("ATTACH_ERR")) {
                throw new IllegalStateException("Target VM failed loading native agent: " + answer);
            } else if (!answer.startsWith("ATTACH_ACK") && !answer.startsWith("ATTACH_RESULT=")) {
                throw new IllegalStateException("Unexpected response: " + answer);
            }
        }
        public void loadAgentLibrary(String library, @MaybeNull String argument) throws IOException {
            write(socket, ("ATTACH_LOADAGENTLIBRARY(" + library + (argument == null ? "" : (',' + argument)) + ')').getBytes("UTF-8"));
            String answer = new String(read(socket), "UTF-8");
            if (answer.startsWith("ATTACH_ERR")) {
                throw new IllegalStateException("Target VM failed loading native library: " + answer);
            } else if (!answer.startsWith("ATTACH_ACK") && !answer.startsWith("ATTACH_RESULT=")) {
                throw new IllegalStateException("Unexpected response: " + answer);
            }
        }
        public void startManagementAgent(Properties properties) throws IOException {
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            properties.store(outputStream, null);
            write(socket, "ATTACH_START_MANAGEMENT_AGENT".getBytes("UTF-8"));
            write(socket, outputStream.toByteArray());
            String answer = new String(read(socket), "UTF-8");
            if (answer.startsWith("ATTACH_ERR")) {
                throw new IllegalStateException("Target VM could not start management agent: " + answer);
            } else if (!answer.startsWith("ATTACH_ACK") && !answer.startsWith("ATTACH_RESULT=")) {
                throw new IllegalStateException("Unexpected response: " + answer);
            }
        }
        public String startLocalManagementAgent() throws IOException {
            write(socket, "ATTACH_START_LOCAL_MANAGEMENT_AGENT".getBytes("UTF-8"));
            String answer = new String(read(socket), "UTF-8");
            if (answer.startsWith("ATTACH_ERR")) {
                throw new IllegalStateException("Target VM could not start management agent: " + answer);
            } else if (answer.startsWith("ATTACH_ACK")) {
                return answer.substring("ATTACH_ACK".length());
            } else if (answer.startsWith("ATTACH_RESULT=")) {
                return answer.substring("ATTACH_RESULT=".length());
            } else {
                throw new IllegalStateException("Unexpected response: " + answer);
            }
        }
        public void detach() throws IOException {
            try {
                write(socket, "ATTACH_DETACH".getBytes("UTF-8"));
                read(socket);
            } finally {
                socket.close();
            }
        }
        private static void write(Socket socket, byte[] value) throws IOException {
            socket.getOutputStream().write(value);
            socket.getOutputStream().write(0);
            socket.getOutputStream().flush();
        }
        private static byte[] read(Socket socket) throws IOException {
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            byte[] buffer = new byte[1024];
            int length;
            while ((length = socket.getInputStream().read(buffer)) != -1) {
                if (length > 0 && buffer[length - 1] == 0) {
                    outputStream.write(buffer, 0, length - 1);
                    break;
                } else {
                    outputStream.write(buffer, 0, length);
                }
            }
            return outputStream.toByteArray();
        }
        public interface Dispatcher {
            String getTemporaryFolder(String processId);
            int pid();
            int userId();
            boolean isExistingProcess(int processId);
            int getOwnerIdOf(File file);
            void setPermissions(File file, int permissions);
            void incrementSemaphore(File directory, String name, boolean global, int count);
            void decrementSemaphore(File directory, String name, boolean global, int count);
            void chownFileToUser(File file, long userId);
            class ForJnaPosixEnvironment implements Dispatcher {
                private final PosixLibrary library;
                private final PosixOwnerProvider provider;
                @SuppressWarnings("deprecation")
                public ForJnaPosixEnvironment(int attempts, long pause, TimeUnit timeUnit) {
                    provider = Platform.isAIX() ? new PosixOwnerProvider.UsingIStat(attempts, pause, timeUnit) : new PosixOwnerProvider.UsingStat(attempts, pause, timeUnit);
                    library = Native.loadLibrary("c", PosixLibrary.class);
                }
                public String getTemporaryFolder(String processId) {
                    if (Platform.isLinux()) {
                        File file = new File("/proc/" + processId + "/root/tmp");
                        if (file.isDirectory() && file.canRead()) {
                            return file.getAbsolutePath();
                        }
                    }
                    String temporaryFolder = System.getenv("TMPDIR");
                    return temporaryFolder == null ? "/tmp" : temporaryFolder;
                }
                public int pid() {
                    return library.getpid();
                }
                public int userId() {
                    return library.getuid();
                }
                public boolean isExistingProcess(int processId) {
                    return library.kill(processId, PosixLibrary.NULL_SIGNAL) != PosixLibrary.ESRCH;
                }
                public int getOwnerIdOf(File file) {
                    return provider.getOwnerIdOf(file);
                }
                public void setPermissions(File file, int permissions) {
                    library.chmod(file.getAbsolutePath(), permissions);
                }
                public void incrementSemaphore(File directory, String name, boolean global, int count) {
                    notifySemaphore(directory, name, count, (short) 1, (short) 0, false);
                }
                public void decrementSemaphore(File directory, String name, boolean global, int count) {
                    notifySemaphore(directory, name, count, (short) -1, (short) (PosixLibrary.SEM_UNDO | PosixLibrary.IPC_NOWAIT), true);
                }
                public void chownFileToUser(File file, long userId) {
                    library.chown(file.getAbsolutePath(), userId);
                }
                private void notifySemaphore(File directory, String name, int count, short operation, short flags, boolean acceptUnavailable) {
                    int semaphore = library.semget(library.ftok(new File(directory, name).getAbsolutePath(), 0xA1), 2, 0666);
                    PosixLibrary.SemaphoreOperation target = new PosixLibrary.SemaphoreOperation();
                    target.operation = operation;
                    target.flags = flags;
                    while (count-- > 0) {
                        try {
                            library.semop(semaphore, target, 1);
                        } catch (LastErrorException exception) {
                            if (acceptUnavailable && (Native.getLastError() == PosixLibrary.EAGAIN || Native.getLastError() == PosixLibrary.EDEADLK)) {
                                break;
                            } else {
                                throw exception;
                            }
                        }
                    }
                }
                protected interface PosixLibrary extends Library {
                    int NULL_SIGNAL = 0;
                    int ESRCH = 3;
                    int EAGAIN = 11;
                    int EDEADLK = 35;
                    short SEM_UNDO = 0x1000;
                    short IPC_NOWAIT = 04000;
                    int getpid() throws LastErrorException;
                    int getuid() throws LastErrorException;
                    int kill(int processId, int signal) throws LastErrorException;
                    int chmod(String path, int mode) throws LastErrorException;
                    int chown(String path, long userId) throws LastErrorException;
                    int ftok(String path, int id) throws LastErrorException;
                    int semget(int key, int count, int flags) throws LastErrorException;
                    int semop(int id, SemaphoreOperation operation, int flags) throws LastErrorException;
                    class SemaphoreOperation extends Structure {
                        public short number;
                        public short operation;
                        public short flags;
                        protected List<String> getFieldOrder() {
                            return Arrays.asList("number", "operation", "flags");
                        }
                    }
                }
                protected interface PosixOwnerProvider {
                    int getOwnerIdOf(File file);
                    class UsingStat implements PosixOwnerProvider {
                        private final int attempts;
                        private final long pause;
                        private final TimeUnit timeUnit;
                        public UsingStat(int attempts, long pause, TimeUnit timeUnit) {
                            this.attempts = attempts;
                            this.pause = pause;
                            this.timeUnit = timeUnit;
                        }
                        public int getOwnerIdOf(File file) {
                            try {
                                Process process = Runtime.getRuntime().exec(new String[] { "stat", Platform.isMac() ? "-f" : "-c", "%u", file.getAbsolutePath() });
                                int attempts = this.attempts;
                                String line = null;
                                do {
                                    try {
                                        if (process.exitValue() != 0) {
                                            throw new IllegalStateException("Error while executing stat");
                                        }
                                        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream(), "UTF-8"));
                                        try {
                                            line = reader.readLine();
                                        } finally {
                                            reader.close();
                                        }
                                        break;
                                    } catch (IllegalThreadStateException ignored) {
                                        try {
                                            Thread.sleep(timeUnit.toMillis(pause));
                                        } catch (InterruptedException exception) {
                                            Thread.currentThread().interrupt();
                                            throw new IllegalStateException(exception);
                                        }
                                    }
                                } while (--attempts > 0);
                                if (line == null) {
                                    process.destroy();
                                    throw new IllegalStateException("Command for stat did not exit in time");
                                }
                                return Integer.parseInt(line);
                            } catch (IOException exception) {
                                throw new IllegalStateException("Unable to execute stat command", exception);
                            }
                        }
                    }
                    class UsingIStat implements PosixOwnerProvider {
                        private static final Pattern AIX_OWNER_PATTERN = Pattern.compile("Owner: (\\d+)\\(");
                        private final int attempts;
                        private final long pause;
                        private final TimeUnit timeUnit;
                        public UsingIStat(int attempts, long pause, TimeUnit timeUnit) {
                            this.attempts = attempts;
                            this.pause = pause;
                            this.timeUnit = timeUnit;
                        }
                        public int getOwnerIdOf(File file) {
                            try {
                                Process process = Runtime.getRuntime().exec(new String[] { "istat", file.getAbsolutePath() });
                                int attempts = this.attempts;
                                String lines = null;
                                do {
                                    try {
                                        if (process.exitValue() != 0) {
                                            throw new IllegalStateException("Error while executing istat");
                                        }
                                        StringBuilder output = new StringBuilder();
                                        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream(), "UTF-8"));
                                        try {
                                            String line;
                                            while ((line = reader.readLine()) != null) {
                                                output.append(line).append("\n");
                                            }
                                        } finally {
                                            reader.close();
                                        }
                                        lines = output.toString();
                                        break;
                                    } catch (IllegalThreadStateException ignored) {
                                        try {
                                            Thread.sleep(timeUnit.toMillis(pause));
                                        } catch (InterruptedException exception) {
                                            Thread.currentThread().interrupt();
                                            throw new IllegalStateException(exception);
                                        }
                                    }
                                } while (--attempts > 0);
                                if (lines == null) {
                                    process.destroy();
                                    throw new IllegalStateException("Command for istat did not exit in time");
                                }
                                Matcher matcher = AIX_OWNER_PATTERN.matcher(lines);
                                if (matcher.find()) {
                                    return Integer.parseInt(matcher.group(1));
                                } else {
                                    throw new IllegalStateException("Unable to parse response from istat command: " + lines);
                                }
                            } catch (IOException exception) {
                                throw new IllegalStateException("Unable to execute istat command", exception);
                            }
                        }
                    }
                }
            }
            class ForJnaWindowsEnvironment implements Dispatcher {
                private static final int NO_USER_ID = 0;
                private static final String CREATION_MUTEX_NAME = "j9shsemcreationMutex";
                private final WindowsLibrary library;
                @SuppressWarnings("deprecation")
                public ForJnaWindowsEnvironment() {
                    library = Native.loadLibrary("kernel32", WindowsLibrary.class, W32APIOptions.DEFAULT_OPTIONS);
                }
                public String getTemporaryFolder(String processId) {
                    WinDef.DWORD length = new WinDef.DWORD(WinDef.MAX_PATH);
                    char[] path = new char[length.intValue()];
                    if (Kernel32.INSTANCE.GetTempPath(length, path).intValue() == 0) {
                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                    }
                    return Native.toString(path);
                }
                public int pid() {
                    return Kernel32.INSTANCE.GetCurrentProcessId();
                }
                public int userId() {
                    return NO_USER_ID;
                }
                public boolean isExistingProcess(int processId) {
                    WinNT.HANDLE handle = Kernel32.INSTANCE.OpenProcess(WinNT.PROCESS_QUERY_INFORMATION, false, processId);
                    if (handle == null) {
                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                    }
                    IntByReference exists = new IntByReference();
                    if (!Kernel32.INSTANCE.GetExitCodeProcess(handle, exists)) {
                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                    }
                    return exists.getValue() == WinBase.STILL_ACTIVE;
                }
                public int getOwnerIdOf(File file) {
                    return NO_USER_ID;
                }
                public void setPermissions(File file, int permissions) {
                }
                public void incrementSemaphore(File directory, String name, boolean global, int count) {
                    AttachmentHandle handle = openSemaphore(directory, name, global);
                    try {
                        while (count-- > 0) {
                            if (!library.ReleaseSemaphore(handle.getHandle(), 1, null)) {
                                throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                            }
                        }
                    } finally {
                        handle.close();
                    }
                }
                public void decrementSemaphore(File directory, String name, boolean global, int count) {
                    AttachmentHandle handle = openSemaphore(directory, name, global);
                    try {
                        while (count-- > 0) {
                            int result = Kernel32.INSTANCE.WaitForSingleObject(handle.getHandle(), 0);
                            switch(result) {
                                case WinBase.WAIT_ABANDONED:
                                case WinBase.WAIT_OBJECT_0:
                                    break;
                                case WinError.WAIT_TIMEOUT:
                                    return;
                                default:
                                    throw new Win32Exception(result);
                            }
                        }
                    } finally {
                        handle.close();
                    }
                }
                public void chownFileToUser(File file, long userId) {
                }
                private AttachmentHandle openSemaphore(File directory, String name, boolean global) {
                    WinNT.SECURITY_DESCRIPTOR securityDescriptor = new WinNT.SECURITY_DESCRIPTOR(64 * 1024);
                    try {
                        if (!Advapi32.INSTANCE.InitializeSecurityDescriptor(securityDescriptor, WinNT.SECURITY_DESCRIPTOR_REVISION)) {
                            throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                        }
                        if (!Advapi32.INSTANCE.SetSecurityDescriptorDacl(securityDescriptor, true, null, true)) {
                            throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                        }
                        WindowsLibrary.SecurityAttributes securityAttributes = new WindowsLibrary.SecurityAttributes();
                        try {
                            securityAttributes.length = new WinDef.DWORD(securityAttributes.size());
                            securityAttributes.securityDescriptor = securityDescriptor.getPointer();
                            WinNT.HANDLE mutex = library.CreateMutex(securityAttributes, false, CREATION_MUTEX_NAME);
                            if (mutex == null) {
                                int lastError = Kernel32.INSTANCE.GetLastError();
                                if (lastError == WinError.ERROR_ALREADY_EXISTS) {
                                    mutex = library.OpenMutex(WinNT.STANDARD_RIGHTS_REQUIRED | WinNT.SYNCHRONIZE | 0x0001, false, CREATION_MUTEX_NAME);
                                    if (mutex == null) {
                                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                                    }
                                } else {
                                    throw new Win32Exception(lastError);
                                }
                            }
                            int result = Kernel32.INSTANCE.WaitForSingleObject(mutex, 2000);
                            switch(result) {
                                case WinBase.WAIT_FAILED:
                                case WinError.WAIT_TIMEOUT:
                                    throw new Win32Exception(result);
                                default:
                                    try {
                                        String target = (global ? "Global\\" : "") + (directory.getAbsolutePath() + '_' + name).replaceAll("[^a-zA-Z0-9_]", "") + "_semaphore";
                                        WinNT.HANDLE parent = library.OpenSemaphoreW(WindowsLibrary.SEMAPHORE_ALL_ACCESS, false, target);
                                        if (parent == null) {
                                            parent = library.CreateSemaphoreW(null, 0, Integer.MAX_VALUE, target);
                                            if (parent == null) {
                                                throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                                            }
                                            WinNT.HANDLE child = library.CreateSemaphoreW(null, 0, Integer.MAX_VALUE, target + "_set0");
                                            if (child == null) {
                                                throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                                            }
                                            return new AttachmentHandle(parent, child);
                                        } else {
                                            WinNT.HANDLE child = library.OpenSemaphoreW(WindowsLibrary.SEMAPHORE_ALL_ACCESS, false, target + "_set0");
                                            if (child == null) {
                                                throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                                            }
                                            return new AttachmentHandle(parent, child);
                                        }
                                    } finally {
                                        if (!library.ReleaseMutex(mutex)) {
                                            throw new Win32Exception(Native.getLastError());
                                        }
                                    }
                            }
                        } finally {
                            securityAttributes = null;
                        }
                    } finally {
                        securityDescriptor = null;
                    }
                }
                protected interface WindowsLibrary extends StdCallLibrary {
                    int SEMAPHORE_ALL_ACCESS = 0x1F0003;
                    WinNT.HANDLE OpenSemaphoreW(int access, boolean inheritHandle, String name);
                    WinNT.HANDLE CreateSemaphoreW(@MaybeNull WinBase.SECURITY_ATTRIBUTES securityAttributes, long count, long maximumCount, String name);
                    boolean ReleaseSemaphore(WinNT.HANDLE handle, long count, @MaybeNull Long previousCount);
                    WinNT.HANDLE CreateMutex(SecurityAttributes attributes, boolean owner, String name);
                    WinNT.HANDLE OpenMutex(int access, boolean inherit, String name);
                    boolean ReleaseMutex(WinNT.HANDLE handle);
                    class SecurityAttributes extends Structure {
                        public WinDef.DWORD length;
                        public Pointer securityDescriptor;
                        public boolean inherit;
                        protected List<String> getFieldOrder() {
                            return Arrays.asList("length", "securityDescriptor", "inherit");
                        }
                    }
                }
                protected static class AttachmentHandle implements Closeable {
                    private final WinNT.HANDLE parent;
                    private final WinNT.HANDLE child;
                    protected AttachmentHandle(WinNT.HANDLE parent, WinNT.HANDLE child) {
                        this.parent = parent;
                        this.child = child;
                    }
                    protected WinNT.HANDLE getHandle() {
                        return child;
                    }
                    public void close() {
                        boolean closed;
                        try {
                            if (!Kernel32.INSTANCE.CloseHandle(child)) {
                                throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                            }
                        } finally {
                            closed = Kernel32.INSTANCE.CloseHandle(parent);
                        }
                        if (!closed) {
                            throw new Win32Exception(Kernel32.INSTANCE.GetLastError());
                        }
                    }
                }
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```