##CONTEXT_SIZE=3303
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.android;
public abstract class AndroidClassLoadingStrategy implements ClassLoadingStrategy<ClassLoader> {
    private static final String DEX_CLASS_FILE = "classes.dex";
    private static final String JAR_FILE_EXTENSION = ".jar";
    private static final String EMPTY_LIBRARY_PATH = null;
    private static final FileProcessor FILE_PROCESSOR;
    static {
        FileProcessor fileProcessor;
        try {
            fileProcessor = new FileProcessor.ForReadOnlyClassFile(Class.forName("java.nio.file.Files").getMethod("setPosixFilePermissions", Class.forName("java.nio.file.Path"), Set.class), File.class.getMethod("toPath"), Collections.singleton(Class.forName("java.nio.file.attribute.PosixFilePermission").getMethod("valueOf", String.class).invoke(null, "OWNER_READ")));
        } catch (Throwable ignored) {
            fileProcessor = FileProcessor.Disabled.INSTANCE;
        }
        FILE_PROCESSOR = fileProcessor;
    }
    private final DexProcessor dexProcessor;
    protected final File privateDirectory;
    protected final RandomString randomString;
    protected AndroidClassLoadingStrategy(File privateDirectory, DexProcessor dexProcessor) {
        if (!privateDirectory.isDirectory()) {
            throw new IllegalArgumentException("Not a directory " + privateDirectory);
        }
        this.privateDirectory = privateDirectory;
        this.dexProcessor = dexProcessor;
        randomString = new RandomString();
    }
    public Map<TypeDescription, Class<?>> load(@MaybeNull ClassLoader classLoader, Map<TypeDescription, byte[]> types) {
        DexProcessor.Conversion conversion = dexProcessor.create();
        for (Map.Entry<TypeDescription, byte[]> entry : types.entrySet()) {
            conversion.register(entry.getKey().getName(), entry.getValue());
        }
        File jar = new File(privateDirectory, randomString.nextString() + JAR_FILE_EXTENSION);
        try {
            if (!jar.createNewFile()) {
                throw new IllegalStateException("Cannot create " + jar);
            }
            OutputStream outputStream = new FileOutputStream(jar);
            try {
                JarOutputStream jarOutputStream = new JarOutputStream(outputStream);
                jarOutputStream.putNextEntry(new JarEntry(DEX_CLASS_FILE));
                conversion.drainTo(jarOutputStream);
                jarOutputStream.closeEntry();
                jarOutputStream.close();
            } finally {
                outputStream.close();
            }
            FILE_PROCESSOR.accept(jar);
            return doLoad(classLoader, types.keySet(), jar);
        } catch (IOException exception) {
            throw new IllegalStateException("Cannot write to zip file " + jar, exception);
        } finally {
            if (!jar.delete()) {
                Logger.getLogger("net.bytebuddy").warning("Could not delete " + jar);
            }
        }
    }
    protected abstract Map<TypeDescription, Class<?>> doLoad(@MaybeNull ClassLoader classLoader, Set<TypeDescription> typeDescriptions, File jar) throws IOException;
    protected interface FileProcessor {
        void accept(File file);
        enum Disabled implements FileProcessor {
            INSTANCE;
            public void accept(File file) {
            }
        }
        class ForReadOnlyClassFile implements FileProcessor {
            private final Method setPosixFilePermissions;
            private final Method toPath;
            private final Set<?> permissions;
            protected ForReadOnlyClassFile(Method setPosixFilePermissions, Method toPath, Set<?> permissions) {
                this.setPosixFilePermissions = setPosixFilePermissions;
                this.toPath = toPath;
                this.permissions = permissions;
            }
            public void accept(File file) {
                try {
                    setPosixFilePermissions.invoke(null, toPath.invoke(file), permissions);
                } catch (IllegalAccessException exception) {
                    throw new IllegalStateException("Cannot access file system permissions", exception);
                } catch (InvocationTargetException exception) {
                    if (!(exception.getTargetException() instanceof UnsupportedOperationException)) {
                        throw new IllegalStateException("Cannot invoke file system permissions method", exception.getTargetException());
                    }
                }
            }
        }
    }
    public interface DexProcessor {
        Conversion create();
        interface Conversion {
            void register(String name, byte[] binaryRepresentation);
            void drainTo(OutputStream outputStream) throws IOException;
        }
        class ForSdkCompiler implements DexProcessor {
            private static final int DEX_COMPATIBLE_API_VERSION = 13;
            private static final Dispatcher DISPATCHER;
            static {
                Dispatcher dispatcher;
                try {
                    Class<?> dxContextType = Class.forName("com.android.dx.command.dexer.DxContext");
                    dispatcher = new Dispatcher.ForApi26LevelCompatibleVm(CfTranslator.class.getMethod("translate", dxContextType, DirectClassFile.class, byte[].class, CfOptions.class, DexOptions.class, DexFile.class), dxContextType.getConstructor());
                } catch (Throwable ignored) {
                    try {
                        dispatcher = new Dispatcher.ForLegacyVm(CfTranslator.class.getMethod("translate", DirectClassFile.class, byte[].class, CfOptions.class, DexOptions.class, DexFile.class), DexOptions.class.getField("minSdkVersion"));
                    } catch (Throwable suppressed) {
                        try {
                            dispatcher = new Dispatcher.ForLegacyVm(CfTranslator.class.getMethod("translate", DirectClassFile.class, byte[].class, CfOptions.class, DexOptions.class, DexFile.class), DexOptions.class.getField("targetApiLevel"));
                        } catch (Throwable throwable) {
                            dispatcher = new Dispatcher.Unavailable(throwable.getMessage());
                        }
                    }
                }
                DISPATCHER = dispatcher;
            }
            protected static DexProcessor makeDefault() {
                DexOptions dexOptions = new DexOptions();
                DISPATCHER.setTargetApi(dexOptions, DEX_COMPATIBLE_API_VERSION);
                return new ForSdkCompiler(dexOptions, new CfOptions());
            }
            private static final String CLASS_FILE_EXTENSION = ".class";
            private static final Writer NO_PRINT_OUTPUT = null;
            private static final boolean NOT_VERBOSE = false;
            private final DexOptions dexFileOptions;
            private final CfOptions dexCompilerOptions;
            public ForSdkCompiler(DexOptions dexFileOptions, CfOptions dexCompilerOptions) {
                this.dexFileOptions = dexFileOptions;
                this.dexCompilerOptions = dexCompilerOptions;
            }
            public DexProcessor.Conversion create() {
                return new Conversion(new DexFile(dexFileOptions));
            }
            protected class Conversion implements DexProcessor.Conversion {
                private static final boolean NON_STRICT = false;
                private final DexFile dexFile;
                protected Conversion(DexFile dexFile) {
                    this.dexFile = dexFile;
                }
                public void register(String name, byte[] binaryRepresentation) {
                    DirectClassFile directClassFile = new DirectClassFile(binaryRepresentation, name.replace('.', '/') + CLASS_FILE_EXTENSION, NON_STRICT);
                    directClassFile.setAttributeFactory(new StdAttributeFactory());
                    dexFile.add(DISPATCHER.translate(directClassFile, binaryRepresentation, dexCompilerOptions, dexFileOptions, new DexFile(dexFileOptions)));
                }
                public void drainTo(OutputStream outputStream) throws IOException {
                    dexFile.writeTo(outputStream, NO_PRINT_OUTPUT, NOT_VERBOSE);
                }
            }
            protected interface Dispatcher {
                ClassDefItem translate(DirectClassFile directClassFile, byte[] binaryRepresentation, CfOptions dexCompilerOptions, DexOptions dexFileOptions, DexFile dexFile);
                void setTargetApi(DexOptions dexOptions, int targetApiLevel);
                class Unavailable implements Dispatcher {
                    private final String message;
                    protected Unavailable(String message) {
                        this.message = message;
                    }
                    public ClassDefItem translate(DirectClassFile directClassFile, byte[] binaryRepresentation, CfOptions dexCompilerOptions, DexOptions dexFileOptions, DexFile dexFile) {
                        throw new IllegalStateException("Could not resolve dispatcher: " + message);
                    }
                    public void setTargetApi(DexOptions dexOptions, int targetApiLevel) {
                        throw new IllegalStateException("Could not resolve dispatcher: " + message);
                    }
                }
                class ForLegacyVm implements Dispatcher {
                    private final Method translate;
                    private final Field targetApi;
                    protected ForLegacyVm(Method translate, Field targetApi) {
                        this.translate = translate;
                        this.targetApi = targetApi;
                    }
                    public ClassDefItem translate(DirectClassFile directClassFile, byte[] binaryRepresentation, CfOptions dexCompilerOptions, DexOptions dexFileOptions, DexFile dexFile) {
                        try {
                            return (ClassDefItem) translate.invoke(null, directClassFile, binaryRepresentation, dexCompilerOptions, dexFileOptions, dexFile);
                        } catch (IllegalAccessException exception) {
                            throw new IllegalStateException("Cannot access an Android dex file translation method", exception);
                        } catch (InvocationTargetException exception) {
                            throw new IllegalStateException("Cannot invoke Android dex file translation method", exception.getTargetException());
                        }
                    }
                    public void setTargetApi(DexOptions dexOptions, int targetApiLevel) {
                        try {
                            targetApi.set(dexOptions, targetApiLevel);
                        } catch (IllegalAccessException exception) {
                            throw new IllegalStateException("Cannot access an Android dex file translation method", exception);
                        }
                    }
                }
                class ForApi26LevelCompatibleVm implements Dispatcher {
                    private final Method translate;
                    private final Constructor<?> dxContext;
                    protected ForApi26LevelCompatibleVm(Method translate, Constructor<?> dxContext) {
                        this.translate = translate;
                        this.dxContext = dxContext;
                    }
                    public ClassDefItem translate(DirectClassFile directClassFile, byte[] binaryRepresentation, CfOptions dexCompilerOptions, DexOptions dexFileOptions, DexFile dexFile) {
                        try {
                            return (ClassDefItem) translate.invoke(null, dxContext.newInstance(), directClassFile, binaryRepresentation, dexCompilerOptions, dexFileOptions, dexFile);
                        } catch (IllegalAccessException exception) {
                            throw new IllegalStateException("Cannot access an Android dex file translation method", exception);
                        } catch (InstantiationException exception) {
                            throw new IllegalStateException("Cannot instantiate dex context", exception);
                        } catch (InvocationTargetException exception) {
                            throw new IllegalStateException("Cannot invoke Android dex file translation method", exception.getTargetException());
                        }
                    }
                    public void setTargetApi(DexOptions dexOptions, int targetApiLevel) {
                    }
                }
            }
        }
    }
    public static class Wrapping extends AndroidClassLoadingStrategy {
        public Wrapping(File privateDirectory) {
            this(privateDirectory, DexProcessor.ForSdkCompiler.makeDefault());
        }
        public Wrapping(File privateDirectory, DexProcessor dexProcessor) {
            super(privateDirectory, dexProcessor);
        }
        protected Map<TypeDescription, Class<?>> doLoad(@MaybeNull ClassLoader classLoader, Set<TypeDescription> typeDescriptions, File jar) {
            ClassLoader dexClassLoader = new DexClassLoader(jar.getAbsolutePath(), privateDirectory.getAbsolutePath(), EMPTY_LIBRARY_PATH, classLoader);
            Map<TypeDescription, Class<?>> loadedTypes = new HashMap<TypeDescription, Class<?>>();
            for (TypeDescription typeDescription : typeDescriptions) {
                try {
                    loadedTypes.put(typeDescription, Class.forName(typeDescription.getName(), false, dexClassLoader));
                } catch (ClassNotFoundException exception) {
                    throw new IllegalStateException("Cannot load " + typeDescription, exception);
                }
            }
            return loadedTypes;
        }
    }
    public static class Injecting extends AndroidClassLoadingStrategy {
        private static final Dispatcher DISPATCHER;
        static {
            Dispatcher dispatcher;
            try {
                dispatcher = new Dispatcher.ForAndroidPVm(BaseDexClassLoader.class.getMethod("addDexPath", String.class, boolean.class));
            } catch (Throwable ignored) {
                dispatcher = Dispatcher.ForLegacyVm.INSTANCE;
            }
            DISPATCHER = dispatcher;
        }
        public Injecting(File privateDirectory) {
            this(privateDirectory, DexProcessor.ForSdkCompiler.makeDefault());
        }
        public Injecting(File privateDirectory, DexProcessor dexProcessor) {
            super(privateDirectory, dexProcessor);
        }
        public Map<TypeDescription, Class<?>> load(@MaybeNull ClassLoader classLoader, Map<TypeDescription, byte[]> types) {
            if (classLoader == null) {
                throw new IllegalArgumentException("Cannot inject classes into the bootstrap class loader on Android");
            }
            return super.load(classLoader, types);
        }
        protected Map<TypeDescription, Class<?>> doLoad(@MaybeNull ClassLoader classLoader, Set<TypeDescription> typeDescriptions, File jar) throws IOException {
            dalvik.system.DexFile dexFile = DISPATCHER.loadDex(privateDirectory, jar, classLoader, randomString);
            try {
                Map<TypeDescription, Class<?>> loadedTypes = new HashMap<TypeDescription, Class<?>>();
                for (TypeDescription typeDescription : typeDescriptions) {
                    synchronized (classLoader) {
                        Class<?> type = DISPATCHER.loadClass(dexFile, classLoader, typeDescription);
                        if (type == null) {
                            throw new IllegalStateException("Could not load " + typeDescription);
                        }
                        loadedTypes.put(typeDescription, type);
                    }
                }
                return loadedTypes;
            } finally {
                if (dexFile != null) {
                    dexFile.close();
                }
            }
        }
        protected interface Dispatcher {
            dalvik.system.DexFile loadDex(File privateDirectory, File jar, @MaybeNull ClassLoader classLoader, RandomString randomString) throws IOException;
            Class<?> loadClass(dalvik.system.DexFile dexFile, @MaybeNull ClassLoader classLoader, TypeDescription typeDescription);
            enum ForLegacyVm implements Dispatcher {
                INSTANCE;
                private static final int NO_FLAGS = 0;
                private static final String EXTENSION = ".data";
                public dalvik.system.DexFile loadDex(File privateDirectory, File jar, @MaybeNull ClassLoader classLoader, RandomString randomString) throws IOException {
                    return dalvik.system.DexFile.loadDex(jar.getAbsolutePath(), new File(privateDirectory.getAbsolutePath(), randomString.nextString() + EXTENSION).getAbsolutePath(), NO_FLAGS);
                }
                public Class<?> loadClass(dalvik.system.DexFile dexFile, @MaybeNull ClassLoader classLoader, TypeDescription typeDescription) {
                    return dexFile.loadClass(typeDescription.getName(), classLoader);
                }
            }
            class ForAndroidPVm implements Dispatcher {
                private static final dalvik.system.DexFile NO_RETURN_VALUE = null;
                private final Method addDexPath;
                protected ForAndroidPVm(Method addDexPath) {
                    this.addDexPath = addDexPath;
                }
                public dalvik.system.DexFile loadDex(File privateDirectory, File jar, @MaybeNull ClassLoader classLoader, RandomString randomString) throws IOException {
                    if (!(classLoader instanceof BaseDexClassLoader)) {
                        throw new IllegalArgumentException("On Android P, a class injection can only be applied to BaseDexClassLoader: " + classLoader);
                    }
                    try {
                        addDexPath.invoke(classLoader, jar.getAbsolutePath(), false);
                        return NO_RETURN_VALUE;
                    } catch (IllegalAccessException exception) {
                        throw new IllegalStateException("Cannot access BaseDexClassLoader#addDexPath(String, boolean)", exception);
                    } catch (InvocationTargetException exception) {
                        Throwable cause = exception.getTargetException();
                        if (cause instanceof IOException) {
                            throw (IOException) cause;
                        } else {
                            throw new IllegalStateException("Cannot invoke BaseDexClassLoader#addDexPath(String, boolean)", cause);
                        }
                    }
                }
                public Class<?> loadClass(@MaybeNull dalvik.system.DexFile dexFile, @MaybeNull ClassLoader classLoader, TypeDescription typeDescription) {
                    try {
                        return Class.forName(typeDescription.getName(), false, classLoader);
                    } catch (ClassNotFoundException exception) {
                        throw new IllegalStateException("Could not locate " + typeDescription, exception);
                    }
                }
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```