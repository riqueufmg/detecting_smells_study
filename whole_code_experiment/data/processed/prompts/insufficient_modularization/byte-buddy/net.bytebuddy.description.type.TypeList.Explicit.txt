##CONTEXT_SIZE=3286
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.description.type;
public interface TypeList extends FilterableList<TypeDescription, TypeList> {
    TypeList UNDEFINED = null;
    String[] NO_INTERFACES = null;
    String[] toInternalNames();
    int getStackSize();
    TypeList.Generic asGenericTypes();
    abstract class AbstractBase extends FilterableList.AbstractBase<TypeDescription, TypeList> implements TypeList {
        protected TypeList wrap(List<TypeDescription> values) {
            return new Explicit(values);
        }
        public int getStackSize() {
            return StackSize.of(this);
        }
        public String[] toInternalNames() {
            String[] internalNames = new String[size()];
            int i = 0;
            for (TypeDescription typeDescription : this) {
                internalNames[i++] = typeDescription.getInternalName();
            }
            return internalNames.length == 0 ? NO_INTERFACES : internalNames;
        }
        public Generic asGenericTypes() {
            return new Generic.Explicit(this);
        }
    }
    class ForLoadedTypes extends AbstractBase {
        private final List<? extends Class<?>> types;
        public ForLoadedTypes(Class<?>... type) {
            this(Arrays.asList(type));
        }
        public ForLoadedTypes(List<? extends Class<?>> types) {
            this.types = types;
        }
        public TypeDescription get(int index) {
            return TypeDescription.ForLoadedType.of(types.get(index));
        }
        public int size() {
            return types.size();
        }
        public String[] toInternalNames() {
            String[] internalNames = new String[types.size()];
            int i = 0;
            for (Class<?> type : types) {
                internalNames[i++] = Type.getInternalName(type);
            }
            return internalNames.length == 0 ? NO_INTERFACES : internalNames;
        }
    }
    class Explicit extends AbstractBase {
        private final List<? extends TypeDescription> typeDescriptions;
        public Explicit(TypeDescription... typeDescription) {
            this(Arrays.asList(typeDescription));
        }
        public Explicit(List<? extends TypeDescription> typeDescriptions) {
            this.typeDescriptions = typeDescriptions;
        }
        public static TypeList of(List<? extends JavaConstant> constants) {
            List<TypeDescription> typeDescriptions = new ArrayList<TypeDescription>(constants.size());
            for (JavaConstant constant : constants) {
                typeDescriptions.add(constant.getTypeDescription());
            }
            return new Explicit(typeDescriptions);
        }
        public TypeDescription get(int index) {
            return typeDescriptions.get(index);
        }
        public int size() {
            return typeDescriptions.size();
        }
    }
    class Empty extends FilterableList.Empty<TypeDescription, TypeList> implements TypeList {
        public String[] toInternalNames() {
            return NO_INTERFACES;
        }
        public int getStackSize() {
            return 0;
        }
        public Generic asGenericTypes() {
            return new Generic.Empty();
        }
    }
    interface Generic extends FilterableList<TypeDescription.Generic, Generic> {
        TypeList asErasures();
        Generic asRawTypes();
        ByteCodeElement.Token.TokenList<TypeVariableToken> asTokenList(ElementMatcher<? super TypeDescription> visitor);
        Generic accept(TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor);
        int getStackSize();
        abstract class AbstractBase extends FilterableList.AbstractBase<TypeDescription.Generic, Generic> implements Generic {
            protected Generic wrap(List<TypeDescription.Generic> values) {
                return new Explicit(values);
            }
            public Generic accept(TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
                List<TypeDescription.Generic> visited = new ArrayList<TypeDescription.Generic>(size());
                for (TypeDescription.Generic typeDescription : this) {
                    visited.add(typeDescription.accept(visitor));
                }
                return new Explicit(visited);
            }
            public ByteCodeElement.Token.TokenList<TypeVariableToken> asTokenList(ElementMatcher<? super TypeDescription> matcher) {
                List<TypeVariableToken> tokens = new ArrayList<TypeVariableToken>(size());
                for (TypeDescription.Generic typeVariable : this) {
                    tokens.add(TypeVariableToken.of(typeVariable, matcher));
                }
                return new ByteCodeElement.Token.TokenList<TypeVariableToken>(tokens);
            }
            public int getStackSize() {
                int stackSize = 0;
                for (TypeDescription.Generic typeDescription : this) {
                    stackSize += typeDescription.getStackSize().getSize();
                }
                return stackSize;
            }
            public TypeList asErasures() {
                List<TypeDescription> typeDescriptions = new ArrayList<TypeDescription>(size());
                for (TypeDescription.Generic typeDescription : this) {
                    typeDescriptions.add(typeDescription.asErasure());
                }
                return new TypeList.Explicit(typeDescriptions);
            }
            public Generic asRawTypes() {
                List<TypeDescription.Generic> typeDescriptions = new ArrayList<TypeDescription.Generic>(size());
                for (TypeDescription.Generic typeDescription : this) {
                    typeDescriptions.add(typeDescription.asRawType());
                }
                return new Explicit(typeDescriptions);
            }
        }
        class Explicit extends AbstractBase {
            private final List<? extends TypeDefinition> typeDefinitions;
            public Explicit(TypeDefinition... typeDefinition) {
                this(Arrays.asList(typeDefinition));
            }
            public Explicit(List<? extends TypeDefinition> typeDefinitions) {
                this.typeDefinitions = typeDefinitions;
            }
            public TypeDescription.Generic get(int index) {
                return typeDefinitions.get(index).asGenericType();
            }
            public int size() {
                return typeDefinitions.size();
            }
        }
        class ForLoadedTypes extends AbstractBase {
            private final List<? extends java.lang.reflect.Type> types;
            public ForLoadedTypes(java.lang.reflect.Type... type) {
                this(Arrays.asList(type));
            }
            public ForLoadedTypes(List<? extends java.lang.reflect.Type> types) {
                this.types = types;
            }
            public TypeDescription.Generic get(int index) {
                return TypeDefinition.Sort.describe(types.get(index));
            }
            public int size() {
                return types.size();
            }
            public static class OfTypeVariables extends Generic.AbstractBase {
                private final List<TypeVariable<?>> typeVariables;
                protected OfTypeVariables(TypeVariable<?>... typeVariable) {
                    this(Arrays.asList(typeVariable));
                }
                protected OfTypeVariables(List<TypeVariable<?>> typeVariables) {
                    this.typeVariables = typeVariables;
                }
                public static Generic of(GenericDeclaration genericDeclaration) {
                    return new OfTypeVariables(genericDeclaration.getTypeParameters());
                }
                public TypeDescription.Generic get(int index) {
                    TypeVariable<?> typeVariable = typeVariables.get(index);
                    return TypeDefinition.Sort.describe(typeVariable, new TypeDescription.Generic.AnnotationReader.Delegator.ForLoadedTypeVariable(typeVariable));
                }
                public int size() {
                    return typeVariables.size();
                }
            }
        }
        class ForDetachedTypes extends AbstractBase {
            private final List<? extends TypeDescription.Generic> detachedTypes;
            private final TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor;
            public ForDetachedTypes(List<? extends TypeDescription.Generic> detachedTypes, TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
                this.detachedTypes = detachedTypes;
                this.visitor = visitor;
            }
            public static Generic attachVariables(TypeDescription typeDescription, List<? extends TypeVariableToken> detachedTypeVariables) {
                return new OfTypeVariables(typeDescription, detachedTypeVariables, TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(typeDescription));
            }
            public static Generic attach(FieldDescription fieldDescription, List<? extends TypeDescription.Generic> detachedTypes) {
                return new ForDetachedTypes(detachedTypes, TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(fieldDescription));
            }
            public static Generic attach(MethodDescription methodDescription, List<? extends TypeDescription.Generic> detachedTypes) {
                return new ForDetachedTypes(detachedTypes, TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(methodDescription));
            }
            public static Generic attachVariables(MethodDescription methodDescription, List<? extends TypeVariableToken> detachedTypeVariables) {
                return new OfTypeVariables(methodDescription, detachedTypeVariables, TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(methodDescription));
            }
            public static Generic attach(ParameterDescription parameterDescription, List<? extends TypeDescription.Generic> detachedTypes) {
                return new ForDetachedTypes(detachedTypes, TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(parameterDescription));
            }
            public TypeDescription.Generic get(int index) {
                return detachedTypes.get(index).accept(visitor);
            }
            public int size() {
                return detachedTypes.size();
            }
            public static class WithResolvedErasure extends Generic.AbstractBase {
                private final List<? extends TypeDescription.Generic> detachedTypes;
                private final TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor;
                public WithResolvedErasure(List<? extends TypeDescription.Generic> detachedTypes, TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
                    this.detachedTypes = detachedTypes;
                    this.visitor = visitor;
                }
                public TypeDescription.Generic get(int index) {
                    return new TypeDescription.Generic.LazyProjection.WithResolvedErasure(detachedTypes.get(index), visitor);
                }
                public int size() {
                    return detachedTypes.size();
                }
            }
            public static class OfTypeVariables extends Generic.AbstractBase {
                private final TypeVariableSource typeVariableSource;
                private final List<? extends TypeVariableToken> detachedTypeVariables;
                private final TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor;
                public OfTypeVariables(TypeVariableSource typeVariableSource, List<? extends TypeVariableToken> detachedTypeVariables, TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
                    this.typeVariableSource = typeVariableSource;
                    this.detachedTypeVariables = detachedTypeVariables;
                    this.visitor = visitor;
                }
                public TypeDescription.Generic get(int index) {
                    return new AttachedTypeVariable(typeVariableSource, detachedTypeVariables.get(index), visitor);
                }
                public int size() {
                    return detachedTypeVariables.size();
                }
                protected static class AttachedTypeVariable extends TypeDescription.Generic.OfTypeVariable {
                    private final TypeVariableSource typeVariableSource;
                    private final TypeVariableToken typeVariableToken;
                    private final TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor;
                    protected AttachedTypeVariable(TypeVariableSource typeVariableSource, TypeVariableToken typeVariableToken, TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
                        this.typeVariableSource = typeVariableSource;
                        this.typeVariableToken = typeVariableToken;
                        this.visitor = visitor;
                    }
                    public Generic getUpperBounds() {
                        return typeVariableToken.getBounds().accept(visitor);
                    }
                    public TypeVariableSource getTypeVariableSource() {
                        return typeVariableSource;
                    }
                    public String getSymbol() {
                        return typeVariableToken.getSymbol();
                    }
                    public AnnotationList getDeclaredAnnotations() {
                        return typeVariableToken.getAnnotations();
                    }
                }
            }
        }
        class OfLoadedInterfaceTypes extends AbstractBase {
            private final Class<?> type;
            public OfLoadedInterfaceTypes(Class<?> type) {
                this.type = type;
            }
            public TypeDescription.Generic get(int index) {
                return new OfLoadedInterfaceTypes.TypeProjection(type, index, type.getInterfaces());
            }
            public int size() {
                return type.getInterfaces().length;
            }
            public TypeList asErasures() {
                return new TypeList.ForLoadedTypes(type.getInterfaces());
            }
            private static class TypeProjection extends TypeDescription.Generic.LazyProjection.WithLazyNavigation.OfAnnotatedElement {
                private final Class<?> type;
                private final int index;
                private final Class<?>[] erasure;
                private TypeProjection(Class<?> type, int index, Class<?>[] erasure) {
                    this.type = type;
                    this.index = index;
                    this.erasure = erasure;
                }
                protected TypeDescription.Generic resolve() {
                    java.lang.reflect.Type[] type = this.type.getGenericInterfaces();
                    return erasure.length == type.length ? Sort.describeOrNull(type[index], getAnnotationReader()) : asRawType();
                }
                public TypeDescription asErasure() {
                    return TypeDescription.ForLoadedType.of(erasure[index]);
                }
                protected AnnotationReader getAnnotationReader() {
                    return new AnnotationReader.Delegator.ForLoadedInterface(type, index);
                }
            }
        }
        class OfConstructorExceptionTypes extends AbstractBase {
            private final Constructor<?> constructor;
            public OfConstructorExceptionTypes(Constructor<?> constructor) {
                this.constructor = constructor;
            }
            public TypeDescription.Generic get(int index) {
                return new OfConstructorExceptionTypes.TypeProjection(constructor, index, constructor.getExceptionTypes());
            }
            public int size() {
                return constructor.getExceptionTypes().length;
            }
            public TypeList asErasures() {
                return new TypeList.ForLoadedTypes(constructor.getExceptionTypes());
            }
            private static class TypeProjection extends TypeDescription.Generic.LazyProjection.WithEagerNavigation.OfAnnotatedElement {
                private final Constructor<?> constructor;
                private final int index;
                private final Class<?>[] erasure;
                private TypeProjection(Constructor<?> constructor, int index, Class<?>[] erasure) {
                    this.constructor = constructor;
                    this.index = index;
                    this.erasure = erasure;
                }
                protected TypeDescription.Generic resolve() {
                    java.lang.reflect.Type[] type = constructor.getGenericExceptionTypes();
                    return erasure.length == type.length ? Sort.describeOrNull(type[index], getAnnotationReader()) : asRawType();
                }
                public TypeDescription asErasure() {
                    return TypeDescription.ForLoadedType.of(erasure[index]);
                }
                protected AnnotationReader getAnnotationReader() {
                    return new AnnotationReader.Delegator.ForLoadedExecutableExceptionType(constructor, index);
                }
            }
        }
        class OfMethodExceptionTypes extends AbstractBase {
            private final Method method;
            public OfMethodExceptionTypes(Method method) {
                this.method = method;
            }
            public TypeDescription.Generic get(int index) {
                return new OfMethodExceptionTypes.TypeProjection(method, index, method.getExceptionTypes());
            }
            public int size() {
                return method.getExceptionTypes().length;
            }
            public TypeList asErasures() {
                return new TypeList.ForLoadedTypes(method.getExceptionTypes());
            }
            private static class TypeProjection extends TypeDescription.Generic.LazyProjection.WithEagerNavigation.OfAnnotatedElement {
                private final Method method;
                private final int index;
                private final Class<?>[] erasure;
                public TypeProjection(Method method, int index, Class<?>[] erasure) {
                    this.method = method;
                    this.index = index;
                    this.erasure = erasure;
                }
                protected TypeDescription.Generic resolve() {
                    java.lang.reflect.Type[] type = method.getGenericExceptionTypes();
                    return erasure.length == type.length ? Sort.describeOrNull(type[index], getAnnotationReader()) : asRawType();
                }
                public TypeDescription asErasure() {
                    return TypeDescription.ForLoadedType.of(erasure[index]);
                }
                protected AnnotationReader getAnnotationReader() {
                    return new AnnotationReader.Delegator.ForLoadedExecutableExceptionType(method, index);
                }
            }
        }
        class Empty extends FilterableList.Empty<TypeDescription.Generic, Generic> implements Generic {
            public TypeList asErasures() {
                return new TypeList.Empty();
            }
            public Generic asRawTypes() {
                return this;
            }
            public Generic accept(TypeDescription.Generic.Visitor<? extends TypeDescription.Generic> visitor) {
                return new Generic.Empty();
            }
            public ByteCodeElement.Token.TokenList<TypeVariableToken> asTokenList(ElementMatcher<? super TypeDescription> matcher) {
                return new ByteCodeElement.Token.TokenList<TypeVariableToken>();
            }
            public int getStackSize() {
                return 0;
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```