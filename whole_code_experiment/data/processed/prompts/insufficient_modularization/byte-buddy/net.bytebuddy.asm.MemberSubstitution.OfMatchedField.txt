##CONTEXT_SIZE=36631
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.asm;
public class MemberSubstitution implements AsmVisitorWrapper.ForDeclaredMethods.MethodVisitorWrapper {
    protected static final int THIS_REFERENCE = 0;
    private final MethodGraph.Compiler methodGraphCompiler;
    private final TypePoolResolver typePoolResolver;
    private final boolean strict;
    private final boolean failIfNoMatch;
    private final Replacement.Factory replacementFactory;
    protected MemberSubstitution(boolean strict) {
        this(MethodGraph.Compiler.DEFAULT, TypePoolResolver.OfImplicitPool.INSTANCE, strict, false, Replacement.NoOp.INSTANCE);
    }
    protected MemberSubstitution(MethodGraph.Compiler methodGraphCompiler, TypePoolResolver typePoolResolver, boolean strict, boolean failIfNoMatch, Replacement.Factory replacementFactory) {
        this.methodGraphCompiler = methodGraphCompiler;
        this.typePoolResolver = typePoolResolver;
        this.failIfNoMatch = failIfNoMatch;
        this.strict = strict;
        this.replacementFactory = replacementFactory;
    }
    public static MemberSubstitution strict() {
        return new MemberSubstitution(true);
    }
    public static MemberSubstitution relaxed() {
        return new MemberSubstitution(false);
    }
    public WithoutSpecification<Target.ForMember> element(ElementMatcher<? super ByteCodeElement.Member> matcher) {
        return new WithoutSpecification.ForMatchedByteCodeElement(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher);
    }
    public WithoutSpecification.ForMatchedField field(ElementMatcher<? super FieldDescription> matcher) {
        return new WithoutSpecification.ForMatchedField(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher);
    }
    public WithoutSpecification.ForMatchedMethod method(ElementMatcher<? super MethodDescription> matcher) {
        return new WithoutSpecification.ForMatchedMethod(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher);
    }
    public WithoutSpecification<Target.ForMember> constructor(ElementMatcher<? super MethodDescription> matcher) {
        return invokable(isConstructor().and(matcher));
    }
    public WithoutSpecification<Target.ForMember> invokable(ElementMatcher<? super MethodDescription> matcher) {
        return new WithoutSpecification.ForMatchedMethod(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher);
    }
    public WithoutSpecification.ForMatchedDynamicInvocation lambdaExpression() {
        return dynamic(new LambdaMetaFactoryMatcher());
    }
    public WithoutSpecification.ForMatchedDynamicInvocation dynamic(ElementMatcher<? super JavaConstant.MethodHandle> matcher) {
        return new WithoutSpecification.ForMatchedDynamicInvocation(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher, ElementMatchers.<String>any(), ElementMatchers.<JavaConstant.MethodType>any(), ElementMatchers.<List<? extends JavaConstant>>any());
    }
    public MemberSubstitution with(MethodGraph.Compiler methodGraphCompiler) {
        return new MemberSubstitution(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory);
    }
    public MemberSubstitution with(TypePoolResolver typePoolResolver) {
        return new MemberSubstitution(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory);
    }
    public MemberSubstitution failIfNoMatch(boolean failIfNoMatch) {
        return new MemberSubstitution(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory);
    }
    public AsmVisitorWrapper.ForDeclaredMethods on(ElementMatcher<? super MethodDescription> matcher) {
        return new AsmVisitorWrapper.ForDeclaredMethods().invokable(matcher, this);
    }
    public MethodVisitor wrap(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, TypePool typePool, int writerFlags, int readerFlags) {
        typePool = typePoolResolver.resolve(instrumentedType, instrumentedMethod, typePool);
        return new SubstitutingMethodVisitor(methodVisitor, instrumentedType, instrumentedMethod, methodGraphCompiler, strict, failIfNoMatch, replacementFactory.make(instrumentedType, instrumentedMethod, typePool), implementationContext, typePool, implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V11));
    }
    public abstract static class WithoutSpecification<T extends Target> {
        protected final MethodGraph.Compiler methodGraphCompiler;
        protected final TypePoolResolver typePoolResolver;
        protected final boolean strict;
        protected final boolean failIfNoMatch;
        protected final Replacement.Factory replacementFactory;
        protected WithoutSpecification(MethodGraph.Compiler methodGraphCompiler, TypePoolResolver typePoolResolver, boolean strict, boolean failIfNoMatch, Replacement.Factory replacementFactory) {
            this.methodGraphCompiler = methodGraphCompiler;
            this.typePoolResolver = typePoolResolver;
            this.strict = strict;
            this.failIfNoMatch = failIfNoMatch;
            this.replacementFactory = replacementFactory;
        }
        public MemberSubstitution stub() {
            return replaceWith(Substitution.Stubbing.INSTANCE);
        }
        public MemberSubstitution replaceWithConstant(Object value) {
            ConstantValue constant = ConstantValue.Simple.wrap(value);
            return replaceWith(new Substitution.ForValue(constant.toStackManipulation(), constant.getTypeDescription().asGenericType()));
        }
        public MemberSubstitution replaceWith(Field field) {
            return replaceWith(new FieldDescription.ForLoadedField(field));
        }
        public MemberSubstitution replaceWith(FieldDescription fieldDescription) {
            return replaceWith(new Substitution.ForFieldAccess.OfGivenField(fieldDescription));
        }
        public MemberSubstitution replaceWithField(ElementMatcher<? super FieldDescription> matcher) {
            return replaceWith(new Substitution.ForFieldAccess.OfMatchedField(matcher));
        }
        public MemberSubstitution replaceWith(Method method) {
            return replaceWith(new MethodDescription.ForLoadedMethod(method));
        }
        public MemberSubstitution replaceWith(MethodDescription methodDescription) {
            if (!methodDescription.isMethod()) {
                throw new IllegalArgumentException("Cannot use " + methodDescription + " as a replacement");
            }
            return replaceWith(new Substitution.ForMethodInvocation.OfGivenMethod(methodDescription));
        }
        public MemberSubstitution replaceWithMethod(ElementMatcher<? super MethodDescription> matcher) {
            return replaceWithMethod(matcher, methodGraphCompiler);
        }
        public MemberSubstitution replaceWithMethod(ElementMatcher<? super MethodDescription> matcher, MethodGraph.Compiler methodGraphCompiler) {
            return replaceWith(new Substitution.ForMethodInvocation.OfMatchedMethod(matcher, methodGraphCompiler));
        }
        public MemberSubstitution replaceWithInstrumentedMethod() {
            return replaceWith(Substitution.ForMethodInvocation.OfInstrumentedMethod.INSTANCE);
        }
        public final MemberSubstitution replaceWithChain(Substitution.Chain.Step.Factory<? super T>... step) {
            return replaceWithChain(Arrays.asList(step));
        }
        public MemberSubstitution replaceWithChain(List<? extends Substitution.Chain.Step.Factory<? super T>> steps) {
            return replaceWith(Substitution.Chain.<T>withDefaultAssigner().executing(steps));
        }
        public abstract MemberSubstitution replaceWith(Substitution.Factory<? super T> factory);
        public static class ForMatchedDynamicInvocation extends WithoutSpecification<Target.ForDynamicInvocation> {
            private final ElementMatcher<? super JavaConstant.MethodHandle> handleMatcher;
            private final ElementMatcher.Junction<? super String> nameMatcher;
            private final ElementMatcher.Junction<? super JavaConstant.MethodType> typeMatcher;
            private final ElementMatcher.Junction<? super List<? extends JavaConstant>> argumentsMatcher;
            protected ForMatchedDynamicInvocation(MethodGraph.Compiler methodGraphCompiler, TypePoolResolver typePoolResolver, boolean strict, boolean failIfNoMatch, Replacement.Factory replacementFactory, ElementMatcher<? super JavaConstant.MethodHandle> handleMatcher, ElementMatcher.Junction<? super String> nameMatcher, ElementMatcher.Junction<? super JavaConstant.MethodType> typeMatcher, ElementMatcher.Junction<? super List<? extends JavaConstant>> argumentsMatcher) {
                super(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory);
                this.handleMatcher = handleMatcher;
                this.nameMatcher = nameMatcher;
                this.typeMatcher = typeMatcher;
                this.argumentsMatcher = argumentsMatcher;
            }
            public ForMatchedDynamicInvocation withName(ElementMatcher<? super String> nameMatcher) {
                return new ForMatchedDynamicInvocation(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, handleMatcher, this.nameMatcher.<String>and(nameMatcher), typeMatcher, argumentsMatcher);
            }
            public ForMatchedDynamicInvocation withType(ElementMatcher<? super JavaConstant.MethodType> typeMatcher) {
                return new ForMatchedDynamicInvocation(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, handleMatcher, nameMatcher, this.typeMatcher.<JavaConstant.MethodType>and(typeMatcher), argumentsMatcher);
            }
            public ForMatchedDynamicInvocation withArguments(ElementMatcher<? super List<? extends JavaConstant>> argumentsMatcher) {
                return new ForMatchedDynamicInvocation(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, handleMatcher, nameMatcher, typeMatcher, this.argumentsMatcher.<List<? extends JavaConstant>>and(argumentsMatcher));
            }
            public MemberSubstitution replaceWith(Substitution.Factory<? super Target.ForDynamicInvocation> substitutionFactory) {
                return new MemberSubstitution(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, new Replacement.Factory.Compound(this.replacementFactory, new Replacement.ForDynamicInvocation.Factory(handleMatcher, nameMatcher, typeMatcher, argumentsMatcher, substitutionFactory)));
            }
        }
        protected static class ForMatchedByteCodeElement extends WithoutSpecification<Target.ForMember> {
            private final ElementMatcher<? super ByteCodeElement.Member> matcher;
            protected ForMatchedByteCodeElement(MethodGraph.Compiler methodGraphCompiler, TypePoolResolver typePoolResolver, boolean strict, boolean failIfNoMatch, Replacement.Factory replacementFactory, ElementMatcher<? super ByteCodeElement.Member> matcher) {
                super(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory);
                this.matcher = matcher;
            }
            public MemberSubstitution replaceWith(Substitution.Factory<? super Target.ForMember> substitutionFactory) {
                return new MemberSubstitution(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, new Replacement.Factory.Compound(this.replacementFactory, Replacement.ForElementMatchers.Factory.of(matcher, substitutionFactory)));
            }
        }
        public static class ForMatchedField extends WithoutSpecification<Target.ForMember> {
            private final ElementMatcher<? super FieldDescription> matcher;
            private final boolean matchRead;
            private final boolean matchWrite;
            protected ForMatchedField(MethodGraph.Compiler methodGraphCompiler, TypePoolResolver typePoolResolver, boolean strict, boolean failIfNoMatch, Replacement.Factory replacementFactory, ElementMatcher<? super FieldDescription> matcher) {
                this(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher, true, true);
            }
            protected ForMatchedField(MethodGraph.Compiler methodGraphCompiler, TypePoolResolver typePoolResolver, boolean strict, boolean failIfNoMatch, Replacement.Factory replacementFactory, ElementMatcher<? super FieldDescription> matcher, boolean matchRead, boolean matchWrite) {
                super(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory);
                this.matcher = matcher;
                this.matchRead = matchRead;
                this.matchWrite = matchWrite;
            }
            public WithoutSpecification<Target.ForMember> onRead() {
                return new ForMatchedField(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher, true, false);
            }
            public WithoutSpecification<Target.ForMember> onWrite() {
                return new ForMatchedField(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher, false, true);
            }
            public MemberSubstitution replaceWith(Substitution.Factory<? super Target.ForMember> substitutionFactory) {
                return new MemberSubstitution(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, new Replacement.Factory.Compound(this.replacementFactory, Replacement.ForElementMatchers.Factory.ofField(matcher, matchRead, matchWrite, substitutionFactory)));
            }
        }
        public static class ForMatchedMethod extends WithoutSpecification<Target.ForMember> {
            private final ElementMatcher<? super MethodDescription> matcher;
            private final boolean includeVirtualCalls;
            private final boolean includeSuperCalls;
            protected ForMatchedMethod(MethodGraph.Compiler methodGraphCompiler, TypePoolResolver typePoolResolver, boolean strict, boolean failIfNoMatch, Replacement.Factory replacementFactory, ElementMatcher<? super MethodDescription> matcher) {
                this(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher, true, true);
            }
            protected ForMatchedMethod(MethodGraph.Compiler methodGraphCompiler, TypePoolResolver typePoolResolver, boolean strict, boolean failIfNoMatch, Replacement.Factory replacementFactory, ElementMatcher<? super MethodDescription> matcher, boolean includeVirtualCalls, boolean includeSuperCalls) {
                super(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory);
                this.matcher = matcher;
                this.includeVirtualCalls = includeVirtualCalls;
                this.includeSuperCalls = includeSuperCalls;
            }
            public WithoutSpecification<Target.ForMember> onVirtualCall() {
                return new ForMatchedMethod(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, isVirtual().and(matcher), true, false);
            }
            public WithoutSpecification<Target.ForMember> onSuperCall() {
                return new ForMatchedMethod(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, isVirtual().and(matcher), false, true);
            }
            public MemberSubstitution replaceWith(Substitution.Factory<? super Target.ForMember> substitutionFactory) {
                return new MemberSubstitution(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, new Replacement.Factory.Compound(this.replacementFactory, Replacement.ForElementMatchers.Factory.ofMethod(matcher, includeVirtualCalls, includeSuperCalls, substitutionFactory)));
            }
        }
    }
    public interface TypePoolResolver {
        TypePool resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool);
        enum OfImplicitPool implements TypePoolResolver {
            INSTANCE;
            public TypePool resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
                return typePool;
            }
        }
        class ForExplicitPool implements TypePoolResolver {
            private final TypePool typePool;
            public ForExplicitPool(TypePool typePool) {
                this.typePool = typePool;
            }
            public TypePool resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
                return this.typePool;
            }
        }
        class ForClassFileLocator implements TypePoolResolver {
            private final ClassFileLocator classFileLocator;
            private final TypePool.Default.ReaderMode readerMode;
            public ForClassFileLocator(ClassFileLocator classFileLocator) {
                this(classFileLocator, TypePool.Default.ReaderMode.FAST);
            }
            public ForClassFileLocator(ClassFileLocator classFileLocator, TypePool.Default.ReaderMode readerMode) {
                this.classFileLocator = classFileLocator;
                this.readerMode = readerMode;
            }
            public static TypePoolResolver of(@MaybeNull ClassLoader classLoader) {
                return new ForClassFileLocator(ClassFileLocator.ForClassLoader.of(classLoader));
            }
            public TypePool resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
                return new TypePool.Default(new TypePool.CacheProvider.Simple(), classFileLocator, readerMode, typePool);
            }
        }
    }
    public interface Target {
        String getName();
        boolean isStaticDispatch();
        class ForMember implements Target {
            private final TypeDescription receiverType;
            private final ByteCodeElement.Member member;
            protected ForMember(TypeDescription receiverType, ByteCodeElement.Member member) {
                this.receiverType = receiverType;
                this.member = member;
            }
            public String getName() {
                return member.getInternalName();
            }
            public boolean isStaticDispatch() {
                return member.isStatic() || member instanceof MethodDescription && ((MethodDescription) member).isConstructor();
            }
            public TypeDescription getReceiverType() {
                return receiverType;
            }
            public ByteCodeElement.Member getMember() {
                return member;
            }
        }
        class ForDynamicInvocation implements Target {
            private final JavaConstant.MethodType methodType;
            private final String name;
            private final List<? extends JavaConstant> arguments;
            protected ForDynamicInvocation(JavaConstant.MethodType methodType, String name, List<? extends JavaConstant> arguments) {
                this.methodType = methodType;
                this.name = name;
                this.arguments = arguments;
            }
            public boolean isStaticDispatch() {
                return true;
            }
            public JavaConstant.MethodType getMethodType() {
                return methodType;
            }
            public String getName() {
                return name;
            }
            public List<? extends JavaConstant> getArguments() {
                return arguments;
            }
        }
    }
    public interface Substitution<T extends Target> {
        StackManipulation resolve(T target, TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, int freeOffset);
        interface Factory<S extends Target> {
            Substitution<? super S> make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool);
        }
        enum Stubbing implements Substitution<Target>, Factory<Target> {
            INSTANCE;
            public Substitution<Target> make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
                return this;
            }
            public StackManipulation resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, int freeOffset) {
                List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(parameters.size());
                for (int index = parameters.size() - 1; index >= 0; index--) {
                    stackManipulations.add(Removal.of(parameters.get(index)));
                }
                return new StackManipulation.Compound(CompoundList.of(stackManipulations, DefaultValue.of(result.asErasure())));
            }
        }
        class ForValue implements Substitution<Target>, Factory<Target> {
            private final StackManipulation stackManipulation;
            private final TypeDescription.Generic typeDescription;
            public ForValue(StackManipulation stackManipulation, TypeDescription.Generic typeDescription) {
                this.stackManipulation = stackManipulation;
                this.typeDescription = typeDescription;
            }
            public Substitution<Target> make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
                return this;
            }
            public StackManipulation resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, int freeOffset) {
                List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(parameters.size());
                for (int index = parameters.size() - 1; index >= 0; index--) {
                    stackManipulations.add(Removal.of(parameters.get(index)));
                }
                if (!typeDescription.asErasure().isAssignableTo(result.asErasure())) {
                    throw new IllegalStateException("Cannot assign " + typeDescription + " to " + result);
                }
                return new StackManipulation.Compound(CompoundList.of(stackManipulations, this.stackManipulation));
            }
        }
        class ForFieldAccess implements Substitution<Target> {
            private final TypeDescription instrumentedType;
            private final FieldResolver fieldResolver;
            public ForFieldAccess(TypeDescription instrumentedType, FieldResolver fieldResolver) {
                this.instrumentedType = instrumentedType;
                this.fieldResolver = fieldResolver;
            }
            public StackManipulation resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, int freeOffset) {
                FieldDescription fieldDescription = fieldResolver.resolve(target, parameters, result);
                if (!fieldDescription.isAccessibleTo(instrumentedType)) {
                    throw new IllegalStateException(instrumentedType + " cannot access " + fieldDescription);
                } else if (result.represents(void.class)) {
                    if (parameters.size() != (fieldDescription.isStatic() ? 1 : 2)) {
                        throw new IllegalStateException("Cannot set " + fieldDescription + " with " + parameters);
                    } else if (!fieldDescription.isStatic() && !parameters.get(0).asErasure().isAssignableTo(fieldDescription.getDeclaringType().asErasure())) {
                        throw new IllegalStateException("Cannot set " + fieldDescription + " on " + parameters.get(0));
                    } else if (!parameters.get(fieldDescription.isStatic() ? 0 : 1).asErasure().isAssignableTo(fieldDescription.getType().asErasure())) {
                        throw new IllegalStateException("Cannot set " + fieldDescription + " to " + parameters.get(fieldDescription.isStatic() ? 0 : 1));
                    }
                    return FieldAccess.forField(fieldDescription).write();
                } else {
                    if (parameters.size() != (fieldDescription.isStatic() ? 0 : 1)) {
                        throw new IllegalStateException("Cannot set " + fieldDescription + " with " + parameters);
                    } else if (!fieldDescription.isStatic() && !parameters.get(0).asErasure().isAssignableTo(fieldDescription.getDeclaringType().asErasure())) {
                        throw new IllegalStateException("Cannot get " + fieldDescription + " on " + parameters.get(0));
                    } else if (!fieldDescription.getType().asErasure().isAssignableTo(result.asErasure())) {
                        throw new IllegalStateException("Cannot get " + fieldDescription + " as " + result);
                    }
                    return FieldAccess.forField(fieldDescription).read();
                }
            }
            public interface FieldResolver {
                FieldDescription resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result);
                class Simple implements FieldResolver {
                    private final FieldDescription fieldDescription;
                    public Simple(FieldDescription fieldDescription) {
                        this.fieldDescription = fieldDescription;
                    }
                    public FieldDescription resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result) {
                        return fieldDescription;
                    }
                }
                class ForElementMatcher implements FieldResolver {
                    private final TypeDescription instrumentedType;
                    private final ElementMatcher<? super FieldDescription> matcher;
                    protected ForElementMatcher(TypeDescription instrumentedType, ElementMatcher<? super FieldDescription> matcher) {
                        this.instrumentedType = instrumentedType;
                        this.matcher = matcher;
                    }
                    public FieldDescription resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result) {
                        if (parameters.isEmpty()) {
                            throw new IllegalStateException("Cannot substitute parameterless instruction with " + parameters);
                        } else if (parameters.get(0).isPrimitive() || parameters.get(0).isArray()) {
                            throw new IllegalStateException("Cannot access field on primitive or array type for " + parameters.get(0));
                        }
                        TypeDefinition current = parameters.get(0).accept(new TypeDescription.Generic.Visitor.Substitutor.ForReplacement(instrumentedType));
                        do {
                            FieldList<?> fields = current.getDeclaredFields().filter(not(isStatic()).<FieldDescription>and(isVisibleTo(instrumentedType)).and(matcher));
                            if (fields.size() == 1) {
                                return fields.getOnly();
                            } else if (fields.size() > 1) {
                                throw new IllegalStateException("Ambiguous field location of " + fields);
                            }
                            current = current.getSuperClass();
                        } while (current != null);
                        throw new IllegalStateException("Cannot locate field matching " + matcher + " on " + target);
                    }
                }
            }
            public static class OfGivenField implements Factory<Target> {
                private final FieldDescription fieldDescription;
                public OfGivenField(FieldDescription fieldDescription) {
                    this.fieldDescription = fieldDescription;
                }
                public Substitution<Target> make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
                    return new ForFieldAccess(instrumentedType, new FieldResolver.Simple(fieldDescription));
                }
            }
            public static class OfMatchedField implements Factory<Target> {
                private final ElementMatcher<? super FieldDescription> matcher;
                public OfMatchedField(ElementMatcher<? super FieldDescription> matcher) {
                    this.matcher = matcher;
                }
                public Substitution<Target> make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
                    return new ForFieldAccess(instrumentedType, new FieldResolver.ForElementMatcher(instrumentedType, matcher));
                }
            }
        }
        class ForMethodInvocation implements Substitution<Target> {
            private final TypeDescription instrumentedType;
            private final MethodResolver methodResolver;
            public ForMethodInvocation(TypeDescription instrumentedType, MethodResolver methodResolver) {
                this.instrumentedType = instrumentedType;
                this.methodResolver = methodResolver;
            }
            public StackManipulation resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, int freeOffset) {
                MethodDescription methodDescription = methodResolver.resolve(target, parameters, result);
                if (!methodDescription.isAccessibleTo(instrumentedType)) {
                    throw new IllegalStateException(instrumentedType + " cannot access " + methodDescription);
                }
                TypeList.Generic mapped = methodDescription.isStatic() ? methodDescription.getParameters().asTypeList() : new TypeList.Generic.Explicit(CompoundList.of(methodDescription.getDeclaringType(), methodDescription.getParameters().asTypeList()));
                if (!methodDescription.getReturnType().asErasure().isAssignableTo(result.asErasure())) {
                    throw new IllegalStateException("Cannot assign return value of " + methodDescription + " to " + result);
                } else if (mapped.size() != parameters.size()) {
                    throw new IllegalStateException("Cannot invoke " + methodDescription + " on " + parameters.size() + " parameters");
                }
                for (int index = 0; index < mapped.size(); index++) {
                    if (!parameters.get(index).asErasure().isAssignableTo(mapped.get(index).asErasure())) {
                        throw new IllegalStateException("Cannot invoke " + methodDescription + " on parameter " + index + " of type " + parameters.get(index));
                    }
                }
                return methodDescription.isVirtual() ? MethodInvocation.invoke(methodDescription).virtual(mapped.get(THIS_REFERENCE).asErasure()) : MethodInvocation.invoke(methodDescription);
            }
            public interface MethodResolver {
                MethodDescription resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result);
                class Simple implements MethodResolver {
                    private final MethodDescription methodDescription;
                    public Simple(MethodDescription methodDescription) {
                        this.methodDescription = methodDescription;
                    }
                    public MethodDescription resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result) {
                        return methodDescription;
                    }
                }
                class Matching implements MethodResolver {
                    private final TypeDescription instrumentedType;
                    private final MethodGraph.Compiler methodGraphCompiler;
                    private final ElementMatcher<? super MethodDescription> matcher;
                    public Matching(TypeDescription instrumentedType, MethodGraph.Compiler methodGraphCompiler, ElementMatcher<? super MethodDescription> matcher) {
                        this.instrumentedType = instrumentedType;
                        this.methodGraphCompiler = methodGraphCompiler;
                        this.matcher = matcher;
                    }
                    public MethodDescription resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result) {
                        if (parameters.isEmpty()) {
                            throw new IllegalStateException("Cannot substitute parameterless instruction with " + parameters);
                        } else if (parameters.get(0).isPrimitive() || parameters.get(0).isArray()) {
                            throw new IllegalStateException("Cannot invoke method on primitive or array type for " + parameters.get(0));
                        }
                        TypeDefinition typeDefinition = parameters.get(0).accept(new TypeDescription.Generic.Visitor.Substitutor.ForReplacement(instrumentedType));
                        List<MethodDescription> candidates = CompoundList.<MethodDescription>of(methodGraphCompiler.compile(typeDefinition, instrumentedType).listNodes().asMethodList().filter(matcher), typeDefinition.getDeclaredMethods().filter(isPrivate().<MethodDescription>and(isVisibleTo(instrumentedType)).and(matcher)));
                        if (candidates.size() == 1) {
                            return candidates.get(0);
                        } else {
                            throw new IllegalStateException("Not exactly one method that matches " + matcher + ": " + candidates);
                        }
                    }
                }
            }
            enum OfInstrumentedMethod implements Factory<Target> {
                INSTANCE;
                public Substitution<Target> make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
                    return new ForMethodInvocation(instrumentedType, new MethodResolver.Simple(instrumentedMethod));
                }
            }
            public static class OfGivenMethod implements Factory<Target> {
                private final MethodDescription methodDescription;
                public OfGivenMethod(MethodDescription methodDescription) {
                    this.methodDescription = methodDescription;
                }
                public Substitution<Target> make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
                    return new ForMethodInvocation(instrumentedType, new MethodResolver.Simple(methodDescription));
                }
            }
            public static class OfMatchedMethod implements Factory<Target> {
                private final ElementMatcher<? super MethodDescription> matcher;
                private final MethodGraph.Compiler methodGraphCompiler;
                public OfMatchedMethod(ElementMatcher<? super MethodDescription> matcher, MethodGraph.Compiler methodGraphCompiler) {
                    this.matcher = matcher;
                    this.methodGraphCompiler = methodGraphCompiler;
                }
                public Substitution<Target> make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
                    return new ForMethodInvocation(instrumentedType, new MethodResolver.Matching(instrumentedType, methodGraphCompiler, matcher));
                }
            }
        }
        class Chain<S extends Target> implements Substitution<S> {
            private final Assigner assigner;
            private final Assigner.Typing typing;
            private final List<Step<? super S>> steps;
            protected Chain(Assigner assigner, Assigner.Typing typing, List<Step<? super S>> steps) {
                this.assigner = assigner;
                this.typing = typing;
                this.steps = steps;
            }
            public static <U extends Target> Chain.Factory<U> withDefaultAssigner() {
                return with(Assigner.DEFAULT, Assigner.Typing.STATIC);
            }
            public static <U extends Target> Chain.Factory<U> with(Assigner assigner, Assigner.Typing typing) {
                return new Chain.Factory<U>(assigner, typing, Collections.<Step.Factory<? super U>>emptyList());
            }
            public StackManipulation resolve(S target, TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, int freeOffset) {
                List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(1 + parameters.size() + steps.size() * 2 + (result.represents(void.class) ? 0 : 2));
                Map<Integer, Integer> offsets = new HashMap<Integer, Integer>();
                for (int index = parameters.size() - 1; index >= 0; index--) {
                    stackManipulations.add(MethodVariableAccess.of(parameters.get(index)).storeAt(freeOffset));
                    offsets.put(index, freeOffset);
                    freeOffset += parameters.get(index).getStackSize().getSize();
                }
                stackManipulations.add(DefaultValue.of(result));
                TypeDescription.Generic current = result;
                for (Step<? super S> step : steps) {
                    Step.Resolution resolution = step.resolve(target, parameters, result, methodHandle, stackManipulation, current, offsets, freeOffset);
                    stackManipulations.add(resolution.getStackManipulation());
                    current = resolution.getResultType();
                }
                StackManipulation assignment = assigner.assign(current, result, typing);
                if (!assignment.isValid()) {
                    throw new IllegalStateException("Failed to assign " + current + " to " + result);
                }
                stackManipulations.add(assignment);
                return new StackManipulation.Compound(stackManipulations);
            }
            public interface Step<U extends Target> {
                Resolution resolve(U target, TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, TypeDescription.Generic current, Map<Integer, Integer> offsets, int freeOffset);
                interface Resolution {
                    StackManipulation getStackManipulation();
                    TypeDescription.Generic getResultType();
                }
                interface Factory<V extends Target> {
                    Step<V> make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod);
                }
                enum OfOriginalExpression implements Step<Target>, Factory<Target> {
                    INSTANCE;
                    public Resolution resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, TypeDescription.Generic current, Map<Integer, Integer> offsets, int freeOffset) {
                        List<StackManipulation> stackManipulations;
                        if (target instanceof Target.ForMember) {
                            ByteCodeElement.Member member = ((Target.ForMember) target).getMember();
                            if (member instanceof MethodDescription && ((MethodDescription) member).isConstructor()) {
                                stackManipulations = new ArrayList<StackManipulation>(parameters.size() + 4);
                                stackManipulations.add(Removal.of(current));
                                stackManipulations.add(TypeCreation.of(member.getDeclaringType().asErasure()));
                                stackManipulations.add(Duplication.SINGLE);
                            } else {
                                stackManipulations = new ArrayList<StackManipulation>(parameters.size() + 4);
                                stackManipulations.add(Removal.of(current));
                            }
                            for (int index = 0; index < parameters.size(); index++) {
                                stackManipulations.add(MethodVariableAccess.of(parameters.get(index)).loadFrom(offsets.get(index)));
                            }
                            if (member instanceof MethodDescription) {
                                stackManipulations.add(stackManipulation);
                                return new Simple(new StackManipulation.Compound(stackManipulations), ((MethodDescription) member).isConstructor() ? member.getDeclaringType().asGenericType() : ((MethodDescription) member).getReturnType());
                            } else if (member instanceof FieldDescription) {
                                if (member.isStatic()) {
                                    if (parameters.isEmpty()) {
                                        stackManipulations.add(stackManipulation);
                                        return new Simple(new StackManipulation.Compound(stackManipulations), ((FieldDescription) member).getType());
                                    } else {
                                        stackManipulations.add(stackManipulation);
                                        return new Simple(new StackManipulation.Compound(stackManipulations), TypeDefinition.Sort.describe(void.class));
                                    }
                                } else {
                                    if (parameters.size() == 1) {
                                        stackManipulations.add(FieldAccess.forField((FieldDescription) member).read());
                                        return new Simple(new StackManipulation.Compound(stackManipulations), ((FieldDescription) member).getType());
                                    } else {
                                        stackManipulations.add(FieldAccess.forField((FieldDescription) member).write());
                                        return new Simple(new StackManipulation.Compound(stackManipulations), TypeDefinition.Sort.describe(void.class));
                                    }
                                }
                            } else {
                                throw new IllegalStateException("Unexpected member: " + member);
                            }
                        } else if (target instanceof Target.ForDynamicInvocation) {
                            stackManipulations = new ArrayList<StackManipulation>(parameters.size() + 4);
                            stackManipulations.add(Removal.of(current));
                            for (int index = 0; index < parameters.size(); index++) {
                                stackManipulations.add(MethodVariableAccess.of(parameters.get(index)).loadFrom(offsets.get(index)));
                            }
                            stackManipulations.add(stackManipulation);
                            return new Simple(new StackManipulation.Compound(stackManipulations), ((Target.ForDynamicInvocation) target).getMethodType().getReturnType().asGenericType());
                        } else {
                            throw new IllegalStateException("Unexpected target: " + target);
                        }
                    }
                    public Step<Target> make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                        return this;
                    }
                }
                class Simple implements Step<Target>, Factory<Target>, Resolution {
                    private final StackManipulation stackManipulation;
                    private final TypeDescription.Generic resultType;
                    public Simple(StackManipulation stackManipulation, Type resultType) {
                        this(stackManipulation, TypeDefinition.Sort.describe(resultType));
                    }
                    public Simple(StackManipulation stackManipulation, TypeDescription.Generic resultType) {
                        this.stackManipulation = stackManipulation;
                        this.resultType = resultType;
                    }
                    public static Step.Factory<Target> of(Object value) {
                        ConstantValue constant = ConstantValue.Simple.wrap(value);
                        return new Simple(constant.toStackManipulation(), constant.getTypeDescription().asGenericType());
                    }
                    public Step<Target> make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                        return this;
                    }
                    public Resolution resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, TypeDescription.Generic current, Map<Integer, Integer> offsets, int freeOffset) {
                        return current.represents(void.class) ? this : new Simple(new StackManipulation.Compound(Removal.of(current), this.stackManipulation), resultType);
                    }
                    public StackManipulation getStackManipulation() {
                        return stackManipulation;
                    }
                    public TypeDescription.Generic getResultType() {
                        return resultType;
                    }
                }
                class ForAssignment implements Step<Target> {
                    private final TypeDescription.Generic result;
                    private final Assigner assigner;
                    protected ForAssignment(@MaybeNull TypeDescription.Generic result, Assigner assigner) {
                        this.result = result;
                        this.assigner = assigner;
                    }
                    public static Step.Factory<Target> castTo(Type type) {
                        return new Factory(TypeDefinition.Sort.describe(type));
                    }
                    public static Step.Factory<Target> castTo(TypeDescription.Generic typeDescription) {
                        return new Factory(typeDescription);
                    }
                    public static Step.Factory<Target> castToSubstitutionResult() {
                        return new Factory(null);
                    }
                    public Resolution resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, TypeDescription.Generic current, Map<Integer, Integer> offsets, int freeOffset) {
                        StackManipulation assignment = assigner.assign(current, this.result == null ? result : this.result, Assigner.Typing.DYNAMIC);
                        if (!assignment.isValid()) {
                            throw new IllegalStateException("Failed to assign " + current + " to " + (this.result == null ? result : this.result));
                        }
                        return new Simple(assignment, this.result == null ? result : this.result);
                    }
                    protected static class Factory implements Step.Factory<Target> {
                        private final TypeDescription.Generic result;
                        protected Factory(@MaybeNull TypeDescription.Generic result) {
                            this.result = result;
                        }
                        public Step<Target> make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                            return new ForAssignment(result, assigner);
                        }
                    }
                }
                class ForArgumentSubstitution implements Step<Target> {
                    private final StackManipulation substitution;
                    private final TypeDescription.Generic typeDescription;
                    private final int index;
                    private final Assigner assigner;
                    private final Assigner.Typing typing;
                    protected ForArgumentSubstitution(StackManipulation substitution, TypeDescription.Generic typeDescription, int index, Assigner assigner, Assigner.Typing typing) {
                        this.substitution = substitution;
                        this.typeDescription = typeDescription;
                        this.index = index;
                        this.assigner = assigner;
                        this.typing = typing;
                    }
                    public static Step.Factory<Target> of(Object value, int index) {
                        if (index < 0) {
                            throw new IllegalArgumentException("Index cannot be negative: " + index);
                        }
                        ConstantValue constant = ConstantValue.Simple.wrap(value);
                        return new Factory(constant.toStackManipulation(), constant.getTypeDescription().asGenericType(), index);
                    }
                    public Resolution resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, TypeDescription.Generic current, Map<Integer, Integer> offsets, int freeOffset) {
                        if (index >= parameters.size()) {
                            throw new IllegalStateException(target + " has not " + index + " arguments");
                        }
                        StackManipulation assignment = assigner.assign(typeDescription, parameters.get(index), typing);
                        if (!assignment.isValid()) {
                            throw new IllegalStateException("Cannot assign " + typeDescription + " to " + parameters.get(index));
                        }
                        return new Simple(new StackManipulation.Compound(substitution, assignment, MethodVariableAccess.of(parameters.get(index)).storeAt(offsets.get(index))), current);
                    }
                    public static class Factory implements Step.Factory<Target> {
                        private final StackManipulation stackManipulation;
                        private final TypeDescription.Generic typeDescription;
                        private final int index;
                        public Factory(StackManipulation stackManipulation, Type type, int index) {
                            this(stackManipulation, TypeDefinition.Sort.describe(type), index);
                        }
                        public Factory(StackManipulation stackManipulation, TypeDescription.Generic typeDescription, int index) {
                            this.stackManipulation = stackManipulation;
                            this.typeDescription = typeDescription;
                            this.index = index;
                        }
                        public Step<Target> make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                            return new ForArgumentSubstitution(stackManipulation, typeDescription, index, assigner, typing);
                        }
                    }
                }
                class ForArgumentLoading implements Step<Target>, Factory<Target> {
                    private final int index;
                    protected ForArgumentLoading(int index) {
                        this.index = index;
                    }
                    public static Factory<Target> ofTarget(int index) {
                        if (index < 0) {
                            throw new IllegalArgumentException("Argument index cannot be negative: " + index);
                        }
                        return new ForArgumentLoading(index);
                    }
                    public static Factory<Target> ofInstrumentedMethod(int index) {
                        if (index < 0) {
                            throw new IllegalArgumentException("Argument index cannot be negative: " + index);
                        }
                        return new OfInstrumentedMethod(index);
                    }
                    public static Factory<Target> ofThis() {
                        return OfInstrumentedMethodThis.INSTANCE;
                    }
                    public Step<Target> make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                        return this;
                    }
                    public Resolution resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, TypeDescription.Generic current, Map<Integer, Integer> offsets, int freeOffset) {
                        if (index >= parameters.size()) {
                            throw new IllegalStateException(target + " has not " + index + " arguments");
                        }
                        return new Simple(new StackManipulation.Compound(Removal.of(current), MethodVariableAccess.of(parameters.get(index)).loadFrom(offsets.get(index))), parameters.get(index));
                    }
                    protected enum OfInstrumentedMethodThis implements Factory<Target> {
                        INSTANCE;
                        public Step<Target> make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                            if (instrumentedMethod.isStatic()) {
                                throw new IllegalStateException(instrumentedMethod + " is static and does not define a this reference");
                            }
                            return new Simple(MethodVariableAccess.loadThis(), instrumentedType.asGenericType());
                        }
                    }
                    protected static class OfInstrumentedMethod implements Factory<Target> {
                        private final int index;
                        protected OfInstrumentedMethod(int index) {
                            this.index = index;
                        }
                        public Step<Target> make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                            if (instrumentedMethod.getParameters().size() < index) {
                                throw new IllegalStateException(instrumentedMethod + " does not declare " + index + " parameters");
                            }
                            ParameterDescription parameterDescription = instrumentedMethod.getParameters().get(index);
                            return new Simple(MethodVariableAccess.load(parameterDescription), parameterDescription.getType());
                        }
                    }
                }
                abstract class ForField implements Step<Target> {
                    protected final FieldDescription fieldDescription;
                    protected final Assigner assigner;
                    protected final Assigner.Typing typing;
                    protected ForField(FieldDescription fieldDescription, Assigner assigner, Assigner.Typing typing) {
                        this.fieldDescription = fieldDescription;
                        this.assigner = assigner;
                        this.typing = typing;
                    }
                    public Resolution resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, TypeDescription.Generic current, Map<Integer, Integer> offsets, int freeOffset) {
                        List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(2);
                        if (fieldDescription.isStatic()) {
                            stackManipulations.add(Removal.of(current));
                        } else {
                            StackManipulation assignment = assigner.assign(current, fieldDescription.getDeclaringType().asGenericType(), typing);
                            if (!assignment.isValid()) {
                                throw new IllegalStateException("Cannot assign " + current + " to " + fieldDescription.getDeclaringType());
                            }
                            stackManipulations.add(assignment);
                        }
                        return doResolve(target, parameters, offsets, new StackManipulation.Compound(stackManipulations));
                    }
                    protected abstract Resolution doResolve(Target target, TypeList.Generic parameters, Map<Integer, Integer> offsets, StackManipulation stackManipulation);
                    public static class Read extends ForField {
                        protected Read(FieldDescription fieldDescription, Assigner assigner, Assigner.Typing typing) {
                            super(fieldDescription, assigner, typing);
                        }
                        protected Resolution doResolve(Target target, TypeList.Generic parameters, Map<Integer, Integer> offsets, StackManipulation stackManipulation) {
                            return new Simple(new StackManipulation.Compound(stackManipulation, FieldAccess.forField(fieldDescription).read()), fieldDescription.getType());
                        }
                        public static class Factory implements Step.Factory<Target> {
                            private final FieldDescription fieldDescription;
                            public Factory(Field field) {
                                this(new FieldDescription.ForLoadedField(field));
                            }
                            public Factory(FieldDescription fieldDescription) {
                                this.fieldDescription = fieldDescription;
                            }
                            public Step<Target> make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                return new Read(fieldDescription, assigner, typing);
                            }
                        }
                    }
                    public static class Write extends ForField {
                        private final int index;
                        protected Write(FieldDescription fieldDescription, Assigner assigner, Assigner.Typing typing, int index) {
                            super(fieldDescription, assigner, typing);
                            this.index = index;
                        }
                        protected Resolution doResolve(Target target, TypeList.Generic parameters, Map<Integer, Integer> offsets, StackManipulation stackManipulation) {
                            int index = target.isStaticDispatch() ? this.index : this.index + 1;
                            if (index >= parameters.size()) {
                                throw new IllegalStateException("Target does not define an argument with index " + index);
                            }
                            StackManipulation assignment = assigner.assign(parameters.get(index), fieldDescription.getType(), typing);
                            if (!assignment.isValid()) {
                                throw new IllegalStateException("Cannot write " + parameters.get(index) + " to " + fieldDescription);
                            }
                            return new Simple(new StackManipulation.Compound(stackManipulation, MethodVariableAccess.of(parameters.get(index)).loadFrom(offsets.get(index)), assignment, FieldAccess.forField(fieldDescription).write()), TypeDefinition.Sort.describe(void.class));
                        }
                        public static class Factory implements Step.Factory<Target> {
                            private final FieldDescription fieldDescription;
                            private final int index;
                            public Factory(Field field, int index) {
                                this(new FieldDescription.ForLoadedField(field), index);
                            }
                            public Factory(FieldDescription fieldDescription, int index) {
                                this.fieldDescription = fieldDescription;
                                this.index = index;
                            }
                            public Step<Target> make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                return new Write(fieldDescription, assigner, typing, index);
                            }
                        }
                    }
                }
                class ForInvocation implements Step<Target> {
                    private final MethodDescription methodDescription;
                    private final Map<Integer, Integer> substitutions;
                    private final Assigner assigner;
                    private final Assigner.Typing typing;
                    protected ForInvocation(MethodDescription methodDescription, Map<Integer, Integer> substitutions, Assigner assigner, Assigner.Typing typing) {
                        this.methodDescription = methodDescription;
                        this.substitutions = substitutions;
                        this.assigner = assigner;
                        this.typing = typing;
                    }
                    public Resolution resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, TypeDescription.Generic current, Map<Integer, Integer> offsets, int freeOffset) {
                        List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(3 + parameters.size() * 2);
                        if (methodDescription.isStatic()) {
                            stackManipulations.add(Removal.of(current));
                        } else if (methodDescription.isConstructor()) {
                            stackManipulations.add(Removal.of(current));
                            stackManipulations.add(TypeCreation.of(methodDescription.getDeclaringType().asErasure()));
                        } else {
                            StackManipulation assignment = assigner.assign(current, methodDescription.getDeclaringType().asGenericType(), typing);
                            if (!assignment.isValid()) {
                                throw new IllegalStateException("Cannot assign " + current + " to " + methodDescription.getDeclaringType());
                            }
                            stackManipulations.add(assignment);
                        }
                        boolean shift = !target.isStaticDispatch();
                        for (int index = 0; index < methodDescription.getParameters().size(); index++) {
                            int substitution = substitutions.containsKey(index + (shift ? 1 : 0)) ? substitutions.get(index + (shift ? 1 : 0)) : index + (shift ? 1 : 0);
                            if (substitution >= parameters.size()) {
                                throw new IllegalStateException(target + " does not support an index " + substitution);
                            }
                            stackManipulations.add(MethodVariableAccess.of(parameters.get(substitution)).loadFrom(offsets.get(substitution)));
                            StackManipulation assignment = assigner.assign(parameters.get(substitution), methodDescription.getParameters().get(index).getType(), typing);
                            if (!assignment.isValid()) {
                                throw new IllegalStateException("Cannot assign parameter with " + index + " of type " + parameters.get(substitution) + " to " + methodDescription);
                            }
                            stackManipulations.add(assignment);
                        }
                        stackManipulations.add(MethodInvocation.invoke(methodDescription));
                        return new Simple(new StackManipulation.Compound(stackManipulations), methodDescription.getReturnType());
                    }
                    public static class Factory implements Step.Factory<Target> {
                        private final MethodDescription methodDescription;
                        private final Map<Integer, Integer> substitutions;
                        public Factory(Method method) {
                            this(new MethodDescription.ForLoadedMethod(method));
                        }
                        public Factory(Method method, Map<Integer, Integer> substitutions) {
                            this(new MethodDescription.ForLoadedMethod(method), substitutions);
                        }
                        public Factory(Constructor<?> constructor) {
                            this(new MethodDescription.ForLoadedConstructor(constructor));
                        }
                        public Factory(Constructor<?> constructor, Map<Integer, Integer> substitutions) {
                            this(new MethodDescription.ForLoadedConstructor(constructor), substitutions);
                        }
                        public Factory(MethodDescription methodDescription) {
                            this(methodDescription, Collections.<Integer, Integer>emptyMap());
                        }
                        public Factory(MethodDescription methodDescription, Map<Integer, Integer> substitutions) {
                            this.methodDescription = methodDescription;
                            this.substitutions = substitutions;
                        }
                        public Step<Target> make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                            return new ForInvocation(methodDescription, substitutions, assigner, typing);
                        }
                    }
                }
                class ForDelegation implements Step<Target> {
                    private final TypeDescription.Generic returned;
                    private final Dispatcher.Resolved dispatcher;
                    private final List<OffsetMapping.Resolved> offsetMappings;
                    protected ForDelegation(TypeDescription.Generic returned, Dispatcher.Resolved dispatcher, List<OffsetMapping.Resolved> offsetMappings) {
                        this.returned = returned;
                        this.dispatcher = dispatcher;
                        this.offsetMappings = offsetMappings;
                    }
                    public static Step.Factory<Target> to(Method method) {
                        return to(new MethodDescription.ForLoadedMethod(method));
                    }
                    public static Step.Factory<Target> to(Constructor<?> constructor) {
                        return to(new MethodDescription.ForLoadedConstructor(constructor));
                    }
                    public static Step.Factory<Target> to(MethodDescription.InDefinedShape methodDescription) {
                        if (methodDescription.isTypeInitializer()) {
                            throw new IllegalArgumentException("Cannot delegate to a type initializer: " + methodDescription);
                        }
                        return to(methodDescription, Dispatcher.ForRegularInvocation.Factory.INSTANCE, Collections.<OffsetMapping.Factory<?>>emptyList());
                    }
                    private static Step.Factory<Target> to(MethodDescription.InDefinedShape delegate, Dispatcher.Factory dispatcherFactory, List<? extends OffsetMapping.Factory<?>> userFactories) {
                        if (delegate.isTypeInitializer()) {
                            throw new IllegalArgumentException("Cannot delegate to type initializer: " + delegate);
                        }
                        return new Factory(delegate, dispatcherFactory.make(delegate), CompoundList.of(Arrays.<OffsetMapping.Factory<?>>asList(OffsetMapping.ForArgument.Factory.INSTANCE, OffsetMapping.ForThisReference.Factory.INSTANCE, OffsetMapping.ForAllArguments.Factory.INSTANCE, OffsetMapping.ForSelfCallHandle.Factory.INSTANCE, OffsetMapping.ForHandle.Factory.INSTANCE, OffsetMapping.ForDynamicConstant.Factory.INSTANCE, OffsetMapping.ForField.Unresolved.Factory.INSTANCE, OffsetMapping.ForFieldHandle.Unresolved.GetterFactory.INSTANCE, OffsetMapping.ForFieldHandle.Unresolved.SetterFactory.INSTANCE, OffsetMapping.ForOrigin.Factory.INSTANCE, OffsetMapping.ForStubValue.Factory.INSTANCE, new OffsetMapping.ForStackManipulation.OfDefaultValue<Unused>(Unused.class), OffsetMapping.ForCurrent.Factory.INSTANCE), userFactories));
                    }
                    public static WithCustomMapping withCustomMapping() {
                        return new WithCustomMapping(Dispatcher.ForRegularInvocation.Factory.INSTANCE, Collections.<Class<? extends Annotation>, OffsetMapping.Factory<?>>emptyMap());
                    }
                    public Resolution resolve(Target target, TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, TypeDescription.Generic current, Map<Integer, Integer> offsets, int freeOffset) {
                        List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(offsetMappings.size() + 3);
                        stackManipulations.add(current.represents(void.class) ? StackManipulation.Trivial.INSTANCE : MethodVariableAccess.of(current).storeAt(freeOffset));
                        stackManipulations.add(dispatcher.initialize());
                        for (OffsetMapping.Resolved offsetMapping : offsetMappings) {
                            stackManipulations.add(offsetMapping.apply(target, parameters, result, current, methodHandle, offsets, freeOffset));
                        }
                        stackManipulations.add(dispatcher.apply(target, methodHandle));
                        return new Simple(new StackManipulation.Compound(stackManipulations), returned);
                    }
                    protected static class Factory implements Step.Factory<Target> {
                        private final MethodDescription.InDefinedShape delegate;
                        private final Dispatcher dispatcher;
                        private final List<OffsetMapping> offsetMappings;
                        protected Factory(MethodDescription.InDefinedShape delegate, Dispatcher dispatcher, List<? extends OffsetMapping.Factory<?>> factories) {
                            Map<TypeDescription, OffsetMapping.Factory<?>> offsetMappings = new HashMap<TypeDescription, OffsetMapping.Factory<?>>();
                            for (OffsetMapping.Factory<?> factory : factories) {
                                offsetMappings.put(net.bytebuddy.description.type.TypeDescription.ForLoadedType.of(factory.getAnnotationType()), factory);
                            }
                            this.offsetMappings = new ArrayList<OffsetMapping>(factories.size());
                            if (delegate.isMethod() && !delegate.isStatic()) {
                                OffsetMapping offsetMapping = null;
                                for (AnnotationDescription annotationDescription : delegate.getDeclaredAnnotations()) {
                                    OffsetMapping.Factory<?> factory = offsetMappings.get(annotationDescription.getAnnotationType());
                                    if (factory != null) {
                                        @SuppressWarnings("unchecked")
                                        OffsetMapping current = factory.make(delegate, (AnnotationDescription.Loadable) annotationDescription.prepare(factory.getAnnotationType()));
                                        if (offsetMapping == null) {
                                            offsetMapping = current;
                                        } else {
                                            throw new IllegalStateException(delegate + " is bound to both " + current + " and " + offsetMapping);
                                        }
                                    }
                                }
                                this.offsetMappings.add(offsetMapping == null ? new OffsetMapping.ForThisReference(delegate.getDeclaringType().asGenericType(), null, Source.SUBSTITUTED_ELEMENT, false) : offsetMapping);
                            }
                            for (int index = 0; index < delegate.getParameters().size(); index++) {
                                ParameterDescription.InDefinedShape parameterDescription = delegate.getParameters().get(index);
                                OffsetMapping offsetMapping = null;
                                for (AnnotationDescription annotationDescription : parameterDescription.getDeclaredAnnotations()) {
                                    OffsetMapping.Factory<?> factory = offsetMappings.get(annotationDescription.getAnnotationType());
                                    if (factory != null) {
                                        @SuppressWarnings("unchecked")
                                        OffsetMapping current = factory.make(parameterDescription, (AnnotationDescription.Loadable) annotationDescription.prepare(factory.getAnnotationType()));
                                        if (offsetMapping == null) {
                                            offsetMapping = current;
                                        } else {
                                            throw new IllegalStateException(parameterDescription + " is bound to both " + current + " and " + offsetMapping);
                                        }
                                    }
                                }
                                this.offsetMappings.add(offsetMapping == null ? new OffsetMapping.ForArgument(parameterDescription.getType(), index, null, Source.SUBSTITUTED_ELEMENT, false) : offsetMapping);
                            }
                            this.delegate = delegate;
                            this.dispatcher = dispatcher;
                        }
                        public Step<Target> make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                            List<OffsetMapping.Resolved> targets = new ArrayList<OffsetMapping.Resolved>(offsetMappings.size());
                            for (OffsetMapping offsetMapping : offsetMappings) {
                                targets.add(offsetMapping.resolve(assigner, typing, instrumentedType, instrumentedMethod));
                            }
                            return new ForDelegation(delegate.getReturnType(), dispatcher.resolve(instrumentedType, instrumentedMethod), targets);
                        }
                    }
                    public interface OffsetMapping {
                        OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod);
                        interface Resolved {
                            StackManipulation apply(Target target, TypeList.Generic parameters, TypeDescription.Generic result, TypeDescription.Generic current, JavaConstant.MethodHandle methodHandle, Map<Integer, Integer> offsets, int offset);
                            class ForStackManipulation implements OffsetMapping.Resolved {
                                private final StackManipulation stackManipulation;
                                public ForStackManipulation(StackManipulation stackManipulation) {
                                    this.stackManipulation = stackManipulation;
                                }
                                public StackManipulation apply(Target target, TypeList.Generic parameters, TypeDescription.Generic result, TypeDescription.Generic current, JavaConstant.MethodHandle methodHandle, Map<Integer, Integer> offsets, int offset) {
                                    return stackManipulation;
                                }
                            }
                        }
                        interface Factory<T extends Annotation> {
                            Class<T> getAnnotationType();
                            OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation);
                            OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation);
                            abstract class AbstractBase<S extends Annotation> implements OffsetMapping.Factory<S> {
                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<S> annotation) {
                                    return make(target.getDeclaringType().asGenericType(), annotation);
                                }
                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<S> annotation) {
                                    return make(target.getType(), annotation);
                                }
                                protected abstract OffsetMapping make(TypeDescription.Generic target, AnnotationDescription.Loadable<S> annotation);
                            }
                            abstract class WithParameterSupportOnly<S extends Annotation> implements OffsetMapping.Factory<S> {
                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<S> annotation) {
                                    throw new UnsupportedOperationException("This factory does not support binding a method receiver");
                                }
                            }
                            class Simple<S extends Annotation> extends OffsetMapping.Factory.AbstractBase<S> {
                                private final Class<S> annotationType;
                                private final OffsetMapping offsetMapping;
                                public Simple(Class<S> annotationType, OffsetMapping offsetMapping) {
                                    this.annotationType = annotationType;
                                    this.offsetMapping = offsetMapping;
                                }
                                public Class<S> getAnnotationType() {
                                    return annotationType;
                                }
                                protected OffsetMapping make(TypeDescription.Generic target, AnnotationDescription.Loadable<S> annotation) {
                                    return offsetMapping;
                                }
                            }
                        }
                        class ForStackManipulation implements OffsetMapping {
                            private final StackManipulation stackManipulation;
                            private final TypeDescription.Generic typeDescription;
                            private final TypeDescription.Generic targetType;
                            public ForStackManipulation(StackManipulation stackManipulation, TypeDescription.Generic typeDescription, TypeDescription.Generic targetType) {
                                this.targetType = targetType;
                                this.stackManipulation = stackManipulation;
                                this.typeDescription = typeDescription;
                            }
                            public static <S extends Annotation> OffsetMapping.Factory<S> of(Class<S> annotationType, @MaybeNull Object value) {
                                return value == null ? new OffsetMapping.ForStackManipulation.OfDefaultValue<S>(annotationType) : new OffsetMapping.ForStackManipulation.Factory<S>(annotationType, ConstantValue.Simple.wrap(value));
                            }
                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                return new ForStackManipulation.Resolved(assigner, typing, stackManipulation, typeDescription, targetType);
                            }
                            protected static class Resolved implements OffsetMapping.Resolved {
                                private final Assigner assigner;
                                private final Assigner.Typing typing;
                                private final StackManipulation stackManipulation;
                                private final TypeDescription.Generic typeDescription;
                                private final TypeDescription.Generic targetType;
                                protected Resolved(Assigner assigner, Assigner.Typing typing, StackManipulation stackManipulation, TypeDescription.Generic typeDescription, TypeDescription.Generic targetType) {
                                    this.assigner = assigner;
                                    this.typing = typing;
                                    this.stackManipulation = stackManipulation;
                                    this.typeDescription = typeDescription;
                                    this.targetType = targetType;
                                }
                                public StackManipulation apply(Target target, TypeList.Generic parameters, TypeDescription.Generic result, TypeDescription.Generic current, JavaConstant.MethodHandle methodHandle, Map<Integer, Integer> offsets, int offset) {
                                    StackManipulation assignment = assigner.assign(typeDescription, targetType, typing);
                                    if (!assignment.isValid()) {
                                        throw new IllegalStateException("Cannot assign " + typeDescription + " to " + targetType);
                                    }
                                    return new StackManipulation.Compound(stackManipulation, assignment);
                                }
                            }
                            public static class OfDefaultValue<T extends Annotation> implements OffsetMapping.Factory<T> {
                                private final Class<T> annotationType;
                                public OfDefaultValue(Class<T> annotationType) {
                                    this.annotationType = annotationType;
                                }
                                public Class<T> getAnnotationType() {
                                    return annotationType;
                                }
                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation) {
                                    throw new UnsupportedOperationException("This factory does not support binding a method receiver");
                                }
                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation) {
                                    return new ForStackManipulation(DefaultValue.of(target.getType()), target.getType(), target.getType());
                                }
                            }
                            public static class OfAnnotationProperty<T extends Annotation> extends OffsetMapping.Factory.WithParameterSupportOnly<T> {
                                private final Class<T> annotationType;
                                private final MethodDescription.InDefinedShape property;
                                protected OfAnnotationProperty(Class<T> annotationType, MethodDescription.InDefinedShape property) {
                                    this.annotationType = annotationType;
                                    this.property = property;
                                }
                                public static <S extends Annotation> OffsetMapping.Factory<S> of(Class<S> annotationType, String property) {
                                    if (!annotationType.isAnnotation()) {
                                        throw new IllegalArgumentException("Not an annotation type: " + annotationType);
                                    }
                                    try {
                                        return new ForStackManipulation.OfAnnotationProperty<S>(annotationType, new MethodDescription.ForLoadedMethod(annotationType.getMethod(property)));
                                    } catch (NoSuchMethodException exception) {
                                        throw new IllegalArgumentException("Cannot find a property " + property + " on " + annotationType, exception);
                                    }
                                }
                                public Class<T> getAnnotationType() {
                                    return annotationType;
                                }
                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation) {
                                    ConstantValue value = ConstantValue.Simple.wrapOrNull(annotation.getValue(property).resolve());
                                    if (value == null) {
                                        throw new IllegalStateException("Not a constant value property: " + property);
                                    }
                                    return new ForStackManipulation(value.toStackManipulation(), value.getTypeDescription().asGenericType(), target.getType());
                                }
                            }
                            public static class OfSerializedConstant<T extends Annotation> extends OffsetMapping.Factory.AbstractBase<T> {
                                private final Class<T> annotationType;
                                private final StackManipulation deserialization;
                                private final TypeDescription.Generic typeDescription;
                                protected OfSerializedConstant(Class<T> annotationType, StackManipulation deserialization, TypeDescription.Generic typeDescription) {
                                    this.annotationType = annotationType;
                                    this.deserialization = deserialization;
                                    this.typeDescription = typeDescription;
                                }
                                public static <S extends Annotation, U extends Serializable> OffsetMapping.Factory<S> of(Class<S> type, U value, Class<? super U> targetType) {
                                    if (!targetType.isInstance(value)) {
                                        throw new IllegalArgumentException(value + " is no instance of " + targetType);
                                    }
                                    return new ForStackManipulation.OfSerializedConstant<S>(type, SerializedConstant.of(value), net.bytebuddy.description.type.TypeDescription.ForLoadedType.of(targetType).asGenericType());
                                }
                                public Class<T> getAnnotationType() {
                                    return annotationType;
                                }
                                protected OffsetMapping make(TypeDescription.Generic target, AnnotationDescription.Loadable<T> annotation) {
                                    return new ForStackManipulation(deserialization, typeDescription, target);
                                }
                            }
                            public static class OfDynamicInvocation<T extends Annotation> extends OffsetMapping.Factory.AbstractBase<T> {
                                private final Class<T> annotationType;
                                private final MethodDescription.InDefinedShape bootstrapMethod;
                                private final List<? extends JavaConstant> arguments;
                                public OfDynamicInvocation(Class<T> annotationType, MethodDescription.InDefinedShape bootstrapMethod, List<? extends JavaConstant> arguments) {
                                    this.annotationType = annotationType;
                                    this.bootstrapMethod = bootstrapMethod;
                                    this.arguments = arguments;
                                }
                                public Class<T> getAnnotationType() {
                                    return annotationType;
                                }
                                protected OffsetMapping make(TypeDescription.Generic target, AnnotationDescription.Loadable<T> annotation) {
                                    if (!target.isInterface()) {
                                        throw new IllegalArgumentException(target + " is not an interface");
                                    } else if (!target.getInterfaces().isEmpty()) {
                                        throw new IllegalArgumentException(target + " must not extend other interfaces");
                                    } else if (!target.isPublic()) {
                                        throw new IllegalArgumentException(target + " is mot public");
                                    }
                                    MethodList<?> methodCandidates = target.getDeclaredMethods().filter(isAbstract());
                                    if (methodCandidates.size() != 1) {
                                        throw new IllegalArgumentException(target + " must declare exactly one abstract method");
                                    }
                                    return new OffsetMapping.ForStackManipulation(MethodInvocation.invoke(bootstrapMethod).dynamic(methodCandidates.getOnly().getInternalName(), target.asErasure(), Collections.<TypeDescription>emptyList(), arguments), target, target);
                                }
                            }
                            public static class Factory<T extends Annotation> extends OffsetMapping.Factory.AbstractBase<T> {
                                private final Class<T> annotationType;
                                private final StackManipulation stackManipulation;
                                private final TypeDescription.Generic typeDescription;
                                public Factory(Class<T> annotationType, ConstantValue value) {
                                    this(annotationType, value.toStackManipulation(), value.getTypeDescription().asGenericType());
                                }
                                public Factory(Class<T> annotationType, StackManipulation stackManipulation, TypeDescription.Generic typeDescription) {
                                    this.annotationType = annotationType;
                                    this.stackManipulation = stackManipulation;
                                    this.typeDescription = typeDescription;
                                }
                                public Class<T> getAnnotationType() {
                                    return annotationType;
                                }
                                protected OffsetMapping make(TypeDescription.Generic target, AnnotationDescription.Loadable<T> annotation) {
                                    return new ForStackManipulation(stackManipulation, typeDescription, target);
                                }
                            }
                        }
                        class ForArgument implements OffsetMapping {
                            private final TypeDescription.Generic targetType;
                            private final int index;
                            private final Assigner.Typing typing;
                            private final Source source;
                            private final boolean optional;
                            public ForArgument(TypeDescription.Generic targetType, int index, @MaybeNull Assigner.Typing typing, Source source, boolean optional) {
                                this.targetType = targetType;
                                this.index = index;
                                this.typing = typing;
                                this.source = source;
                                this.optional = optional;
                            }
                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                return new ForArgument.Resolved(targetType, index, this.typing == null ? typing : this.typing, source, optional, assigner, instrumentedMethod);
                            }
                            protected enum Factory implements OffsetMapping.Factory<Argument> {
                                INSTANCE;
                                private static final MethodDescription.InDefinedShape ARGUMENT_VALUE;
                                private static final MethodDescription.InDefinedShape ARGUMENT_TYPING;
                                private static final MethodDescription.InDefinedShape ARGUMENT_SOURCE;
                                private static final MethodDescription.InDefinedShape ARGUMENT_OPTIONAL;
                                static {
                                    MethodList<MethodDescription.InDefinedShape> methods = net.bytebuddy.description.type.TypeDescription.ForLoadedType.of(Argument.class).getDeclaredMethods();
                                    ARGUMENT_VALUE = methods.filter(named("value")).getOnly();
                                    ARGUMENT_TYPING = methods.filter(named("typing")).getOnly();
                                    ARGUMENT_SOURCE = methods.filter(named("source")).getOnly();
                                    ARGUMENT_OPTIONAL = methods.filter(named("optional")).getOnly();
                                }
                                public Class<Argument> getAnnotationType() {
                                    return Argument.class;
                                }
                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<Argument> annotation) {
                                    return new ForArgument(target.getDeclaringType().asGenericType(), annotation.getValue(ARGUMENT_VALUE).resolve(Integer.class), annotation.getValue(ARGUMENT_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class), annotation.getValue(ARGUMENT_SOURCE).resolve(EnumerationDescription.class).load(Source.class), annotation.getValue(ARGUMENT_OPTIONAL).resolve(Boolean.class));
                                }
                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<Argument> annotation) {
                                    int index = annotation.getValue(ARGUMENT_VALUE).resolve(Integer.class);
                                    if (index < 0) {
                                        throw new IllegalStateException("Cannot assign negative parameter index " + index + " for " + target);
                                    }
                                    return new ForArgument(target.getType(), index, annotation.getValue(ARGUMENT_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class), annotation.getValue(ARGUMENT_SOURCE).resolve(EnumerationDescription.class).load(Source.class), annotation.getValue(ARGUMENT_OPTIONAL).resolve(Boolean.class));
                                }
                            }
                            protected static class Resolved implements OffsetMapping.Resolved {
                                private final TypeDescription.Generic targetType;
                                private final int index;
                                private final Assigner.Typing typing;
                                private final Source source;
                                private final boolean optional;
                                private final Assigner assigner;
                                private final MethodDescription instrumentedMethod;
                                protected Resolved(TypeDescription.Generic targetType, int index, Assigner.Typing typing, Source source, boolean optional, Assigner assigner, MethodDescription instrumentedMethod) {
                                    this.targetType = targetType;
                                    this.index = index;
                                    this.typing = typing;
                                    this.source = source;
                                    this.optional = optional;
                                    this.assigner = assigner;
                                    this.instrumentedMethod = instrumentedMethod;
                                }
                                public StackManipulation apply(Target target, TypeList.Generic parameters, TypeDescription.Generic result, TypeDescription.Generic current, JavaConstant.MethodHandle methodHandle, Map<Integer, Integer> offsets, int offset) {
                                    Source.Value value = source.argument(index, parameters, offsets, target, instrumentedMethod);
                                    if (value != null) {
                                        StackManipulation assignment = assigner.assign(value.getTypeDescription(), targetType, typing);
                                        if (!assignment.isValid()) {
                                            throw new IllegalStateException("Cannot assign " + value.getTypeDescription() + " to " + targetType);
                                        }
                                        return new StackManipulation.Compound(MethodVariableAccess.of(value.getTypeDescription()).loadFrom(value.getOffset()), assignment);
                                    } else if (optional) {
                                        return DefaultValue.of(targetType);
                                    } else {
                                        throw new IllegalStateException("No argument with index " + index + " available for " + target);
                                    }
                                }
                            }
                        }
                        class ForThisReference implements OffsetMapping {
                            private final TypeDescription.Generic targetType;
                            private final Assigner.Typing typing;
                            private final Source source;
                            private final boolean optional;
                            public ForThisReference(TypeDescription.Generic targetType, @MaybeNull Assigner.Typing typing, Source source, boolean optional) {
                                this.targetType = targetType;
                                this.typing = typing;
                                this.source = source;
                                this.optional = optional;
                            }
                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                return new ForThisReference.Resolved(targetType, this.typing == null ? typing : this.typing, source, optional, assigner, instrumentedMethod);
                            }
                            protected static class Resolved implements OffsetMapping.Resolved {
                                private final TypeDescription.Generic targetType;
                                private final Assigner.Typing typing;
                                private final Source source;
                                private final boolean optional;
                                private final Assigner assigner;
                                private final MethodDescription instrumentedMethod;
                                protected Resolved(TypeDescription.Generic targetType, Assigner.Typing typing, Source source, boolean optional, Assigner assigner, MethodDescription instrumentedMethod) {
                                    this.targetType = targetType;
                                    this.typing = typing;
                                    this.source = source;
                                    this.optional = optional;
                                    this.assigner = assigner;
                                    this.instrumentedMethod = instrumentedMethod;
                                }
                                public StackManipulation apply(Target target, TypeList.Generic parameters, TypeDescription.Generic result, TypeDescription.Generic current, JavaConstant.MethodHandle methodHandle, Map<Integer, Integer> offsets, int offset) {
                                    Source.Value value = source.self(parameters, offsets, target, instrumentedMethod);
                                    if (value != null) {
                                        StackManipulation assignment = assigner.assign(value.getTypeDescription(), targetType, typing);
                                        if (!assignment.isValid()) {
                                            throw new IllegalStateException("Cannot assign " + value.getTypeDescription() + " to " + targetType);
                                        }
                                        return new StackManipulation.Compound(MethodVariableAccess.of(value.getTypeDescription()).loadFrom(value.getOffset()), assignment);
                                    } else if (optional) {
                                        return DefaultValue.of(targetType);
                                    } else {
                                        throw new IllegalStateException("No this reference available for " + target);
                                    }
                                }
                            }
                            protected enum Factory implements OffsetMapping.Factory<This> {
                                INSTANCE;
                                private static final MethodDescription.InDefinedShape THIS_TYPING;
                                private static final MethodDescription.InDefinedShape THIS_SOURCE;
                                private static final MethodDescription.InDefinedShape THIS_OPTIONAL;
                                static {
                                    MethodList<MethodDescription.InDefinedShape> methods = net.bytebuddy.description.type.TypeDescription.ForLoadedType.of(This.class).getDeclaredMethods();
                                    THIS_TYPING = methods.filter(named("typing")).getOnly();
                                    THIS_SOURCE = methods.filter(named("source")).getOnly();
                                    THIS_OPTIONAL = methods.filter(named("optional")).getOnly();
                                }
                                public Class<This> getAnnotationType() {
                                    return This.class;
                                }
                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<This> annotation) {
                                    return new ForThisReference(target.getDeclaringType().asGenericType(), annotation.getValue(THIS_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class), annotation.getValue(THIS_SOURCE).resolve(EnumerationDescription.class).load(Source.class), annotation.getValue(THIS_OPTIONAL).resolve(Boolean.class));
                                }
                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<This> annotation) {
                                    return new ForThisReference(target.getType(), annotation.getValue(THIS_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class), annotation.getValue(THIS_SOURCE).resolve(EnumerationDescription.class).load(Source.class), annotation.getValue(THIS_OPTIONAL).resolve(Boolean.class));
                                }
                            }
                        }
                        class ForAllArguments implements OffsetMapping {
                            private final TypeDescription.Generic targetComponentType;
                            private final Assigner.Typing typing;
                            private final Source source;
                            private final boolean includeSelf;
                            private final boolean nullIfEmpty;
                            public ForAllArguments(TypeDescription.Generic targetComponentType, @MaybeNull Assigner.Typing typing, Source source, boolean includeSelf, boolean nullIfEmpty) {
                                this.targetComponentType = targetComponentType;
                                this.typing = typing;
                                this.source = source;
                                this.includeSelf = includeSelf;
                                this.nullIfEmpty = nullIfEmpty;
                            }
                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                return new ForAllArguments.Resolved(targetComponentType, this.typing == null ? typing : this.typing, source, includeSelf, nullIfEmpty, assigner, instrumentedMethod);
                            }
                            protected enum Factory implements OffsetMapping.Factory<AllArguments> {
                                INSTANCE;
                                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_TYPING;
                                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_SOURCE;
                                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_INCLUDE_SELF;
                                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_NULL_IF_EMPTY;
                                static {
                                    MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(AllArguments.class).getDeclaredMethods();
                                    ALL_ARGUMENTS_TYPING = methods.filter(named("typing")).getOnly();
                                    ALL_ARGUMENTS_SOURCE = methods.filter(named("source")).getOnly();
                                    ALL_ARGUMENTS_INCLUDE_SELF = methods.filter(named("includeSelf")).getOnly();
                                    ALL_ARGUMENTS_NULL_IF_EMPTY = methods.filter(named("nullIfEmpty")).getOnly();
                                }
                                public Class<AllArguments> getAnnotationType() {
                                    return AllArguments.class;
                                }
                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<AllArguments> annotation) {
                                    throw new UnsupportedOperationException("This factory does not support binding a method receiver");
                                }
                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<AllArguments> annotation) {
                                    if (!target.getType().isArray()) {
                                        throw new IllegalStateException("Expected array as parameter type for " + target);
                                    }
                                    return new ForAllArguments(target.getType().getComponentType(), annotation.getValue(ALL_ARGUMENTS_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class), annotation.getValue(ALL_ARGUMENTS_SOURCE).resolve(EnumerationDescription.class).load(Source.class), annotation.getValue(ALL_ARGUMENTS_INCLUDE_SELF).resolve(Boolean.class), annotation.getValue(ALL_ARGUMENTS_NULL_IF_EMPTY).resolve(Boolean.class));
                                }
                            }
                            protected static class Resolved implements OffsetMapping.Resolved {
                                private final TypeDescription.Generic targetComponentType;
                                private final Assigner.Typing typing;
                                private final Source source;
                                private final boolean includeSelf;
                                private final boolean nullIfEmpty;
                                private final Assigner assigner;
                                private final MethodDescription instrumentedMethod;
                                protected Resolved(TypeDescription.Generic targetComponentType, Assigner.Typing typing, Source source, boolean includeSelf, boolean nullIfEmpty, Assigner assigner, MethodDescription instrumentedMethod) {
                                    this.targetComponentType = targetComponentType;
                                    this.typing = typing;
                                    this.source = source;
                                    this.includeSelf = includeSelf;
                                    this.nullIfEmpty = nullIfEmpty;
                                    this.assigner = assigner;
                                    this.instrumentedMethod = instrumentedMethod;
                                }
                                public StackManipulation apply(Target target, TypeList.Generic parameters, TypeDescription.Generic result, TypeDescription.Generic current, JavaConstant.MethodHandle methodHandle, Map<Integer, Integer> offsets, int offset) {
                                    List<Source.Value> values = source.arguments(includeSelf, parameters, offsets, target, instrumentedMethod);
                                    if (nullIfEmpty && values.isEmpty()) {
                                        return NullConstant.INSTANCE;
                                    } else {
                                        List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>();
                                        for (Source.Value value : values) {
                                            StackManipulation assignment = assigner.assign(value.getTypeDescription(), targetComponentType, typing);
                                            if (!assignment.isValid()) {
                                                throw new IllegalStateException("Cannot assign " + value.getTypeDescription() + " to " + targetComponentType);
                                            }
                                            stackManipulations.add(new StackManipulation.Compound(MethodVariableAccess.of(value.getTypeDescription()).loadFrom(value.getOffset()), assignment));
                                        }
                                        return ArrayFactory.forType(targetComponentType).withValues(stackManipulations);
                                    }
                                }
                            }
                        }
                        class ForSelfCallHandle implements OffsetMapping {
                            private final Source source;
                            private final boolean bound;
                            public ForSelfCallHandle(Source source, boolean bound) {
                                this.source = source;
                                this.bound = bound;
                            }
                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                return bound ? new ForSelfCallHandle.Bound(source, instrumentedMethod) : new ForSelfCallHandle.Unbound(source, instrumentedMethod);
                            }
                            protected enum Factory implements OffsetMapping.Factory<SelfCallHandle> {
                                INSTANCE;
                                private static final MethodDescription.InDefinedShape SELF_CALL_HANDLE_SOURCE;
                                private static final MethodDescription.InDefinedShape SELF_CALL_HANDLE_BOUND;
                                static {
                                    MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(SelfCallHandle.class).getDeclaredMethods();
                                    SELF_CALL_HANDLE_SOURCE = methods.filter(named("source")).getOnly();
                                    SELF_CALL_HANDLE_BOUND = methods.filter(named("bound")).getOnly();
                                }
                                public Class<SelfCallHandle> getAnnotationType() {
                                    return SelfCallHandle.class;
                                }
                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<SelfCallHandle> annotation) {
                                    throw new UnsupportedOperationException("This factory does not support binding a method receiver");
                                }
                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<SelfCallHandle> annotation) {
                                    if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {
                                        throw new IllegalStateException("Cannot assign method handle to " + target);
                                    }
                                    return new ForSelfCallHandle(annotation.getValue(SELF_CALL_HANDLE_SOURCE).resolve(EnumerationDescription.class).load(Source.class), annotation.getValue(SELF_CALL_HANDLE_BOUND).resolve(Boolean.class));
                                }
                            }
                            protected static class Bound implements OffsetMapping.Resolved {
                                private final Source source;
                                private final MethodDescription instrumentedMethod;
                                protected Bound(Source source, MethodDescription instrumentedMethod) {
                                    this.source = source;
                                    this.instrumentedMethod = instrumentedMethod;
                                }
                                public StackManipulation apply(Target target, TypeList.Generic parameters, TypeDescription.Generic result, TypeDescription.Generic current, JavaConstant.MethodHandle methodHandle, Map<Integer, Integer> offsets, int offset) {
                                    Source.Value dispatched = source.self(parameters, offsets, target, instrumentedMethod);
                                    List<Source.Value> values = source.arguments(false, parameters, offsets, target, instrumentedMethod);
                                    List<StackManipulation> stackManipulations = new ArrayList<StackManipulation>(1 + (values.size() + (dispatched == null ? 0 : 2)) + (values.isEmpty() ? 0 : 1));
                                    stackManipulations.add(source.handle(methodHandle, instrumentedMethod).toStackManipulation());
                                    if (dispatched != null) {
                                        stackManipulations.add(MethodVariableAccess.of(dispatched.getTypeDescription()).loadFrom(dispatched.getOffset()));
                                        stackManipulations.add(MethodInvocation.invoke(new MethodDescription.Latent(JavaType.METHOD_HANDLE.getTypeStub(), new MethodDescription.Token("bindTo", Opcodes.ACC_PUBLIC, JavaType.METHOD_HANDLE.getTypeStub().asGenericType(), new TypeList.Generic.Explicit(TypeDefinition.Sort.describe(Object.class))))));
                                    }
                                    if (!values.isEmpty()) {
                                        for (Source.Value value : values) {
                                            stackManipulations.add(MethodVariableAccess.of(value.getTypeDescription()).loadFrom(value.getOffset()));
                                        }
                                        stackManipulations.add(MethodInvocation.invoke(new MethodDescription.Latent(JavaType.METHOD_HANDLES.getTypeStub(), new MethodDescription.Token("insertArguments", Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, JavaType.METHOD_HANDLE.getTypeStub().asGenericType(), new TypeList.Generic.Explicit(JavaType.METHOD_HANDLE.getTypeStub(), TypeDefinition.Sort.describe(int.class), TypeDefinition.Sort.describe(Object[].class))))));
                                    }
                                    return new StackManipulation.Compound(stackManipulations);
                                }
                            }
                            protected static class Unbound implements OffsetMapping.Resolved {
                                private final Source source;
                                private final MethodDescription instrumentedMethod;
                                protected Unbound(Source source, MethodDescription instrumentedMethod) {
                                    this.source = source;
                                    this.instrumentedMethod = instrumentedMethod;
                                }
                                public StackManipulation apply(Target target, TypeList.Generic parameters, TypeDescription.Generic result, TypeDescription.Generic current, JavaConstant.MethodHandle methodHandle, Map<Integer, Integer> offsets, int offset) {
                                    return source.handle(methodHandle, instrumentedMethod).toStackManipulation();
                                }
                            }
                        }
                        class ForHandle implements OffsetMapping {
                            private final JavaConstant.MethodHandle.HandleType type;
                            private final TypeDescription owner;
                            private final String name;
                            private final TypeDescription returnType;
                            private final List<? extends TypeDescription> parameterTypes;
                            protected ForHandle(JavaConstant.MethodHandle.HandleType type, TypeDescription owner, String name, TypeDescription returnType, List<? extends TypeDescription> parameterTypes) {
                                this.type = type;
                                this.owner = owner;
                                this.name = name;
                                this.returnType = returnType;
                                this.parameterTypes = parameterTypes;
                            }
                            public Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                return new Resolved.ForStackManipulation(new JavaConstantValue(new JavaConstant.MethodHandle(type, owner.represents(void.class) ? instrumentedType : owner, name, returnType, parameterTypes)));
                            }
                            protected enum Factory implements OffsetMapping.Factory<Handle> {
                                INSTANCE;
                                private static final MethodDescription.InDefinedShape HANDLE_TYPE;
                                private static final MethodDescription.InDefinedShape HANDLE_OWNER;
                                private static final MethodDescription.InDefinedShape HANDLE_NAME;
                                private static final MethodDescription.InDefinedShape HANDLE_RETURN_TYPE;
                                private static final MethodDescription.InDefinedShape HANDLE_PARAMETER_TYPES;
                                static {
                                    MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(Handle.class).getDeclaredMethods();
                                    HANDLE_TYPE = methods.filter(named("type")).getOnly();
                                    HANDLE_OWNER = methods.filter(named("owner")).getOnly();
                                    HANDLE_NAME = methods.filter(named("name")).getOnly();
                                    HANDLE_RETURN_TYPE = methods.filter(named("returnType")).getOnly();
                                    HANDLE_PARAMETER_TYPES = methods.filter(named("parameterTypes")).getOnly();
                                }
                                public Class<Handle> getAnnotationType() {
                                    return Handle.class;
                                }
                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<Handle> annotation) {
                                    throw new UnsupportedOperationException("This factory does not support binding a method receiver");
                                }
                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<Handle> annotation) {
                                    if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {
                                        throw new IllegalStateException("Cannot assign method handle to " + target);
                                    }
                                    return new ForHandle(annotation.getValue(HANDLE_TYPE).resolve(EnumerationDescription.class).load(JavaConstant.MethodHandle.HandleType.class), annotation.getValue(HANDLE_OWNER).resolve(TypeDescription.class), annotation.getValue(HANDLE_NAME).resolve(String.class), annotation.getValue(HANDLE_RETURN_TYPE).resolve(TypeDescription.class), Arrays.asList(annotation.getValue(HANDLE_PARAMETER_TYPES).resolve(TypeDescription[].class)));
                                }
                            }
                        }
                        class ForDynamicConstant implements OffsetMapping {
                            private final String name;
                            private final TypeDescription typeDescription;
                            private final JavaConstant.MethodHandle.HandleType bootstrapType;
                            private final TypeDescription bootstrapOwner;
                            private final String bootstrapName;
                            private final TypeDescription bootstrapReturnType;
                            private final List<? extends TypeDescription> bootstrapParameterTypes;
                            private final List<JavaConstant> arguments;
                            private final boolean invokedynamic;
                            public ForDynamicConstant(String name, TypeDescription typeDescription, JavaConstant.MethodHandle.HandleType bootstrapType, TypeDescription bootstrapOwner, String bootstrapName, TypeDescription bootstrapReturnType, List<? extends TypeDescription> bootstrapParameterTypes, List<JavaConstant> arguments, boolean invokedynamic) {
                                this.name = name;
                                this.typeDescription = typeDescription;
                                this.bootstrapType = bootstrapType;
                                this.bootstrapOwner = bootstrapOwner;
                                this.bootstrapName = bootstrapName;
                                this.bootstrapReturnType = bootstrapReturnType;
                                this.bootstrapParameterTypes = bootstrapParameterTypes;
                                this.arguments = arguments;
                                this.invokedynamic = invokedynamic;
                            }
                            public Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                if (invokedynamic) {
                                    return new Resolved.ForStackManipulation(new Invokedynamic(name, JavaConstant.MethodType.of(typeDescription), new JavaConstant.MethodHandle(bootstrapType, bootstrapOwner.represents(void.class) ? instrumentedType : bootstrapOwner, bootstrapName, bootstrapReturnType, bootstrapParameterTypes), arguments));
                                } else {
                                    return new Resolved.ForStackManipulation(new JavaConstantValue(new JavaConstant.Dynamic(name, typeDescription, new JavaConstant.MethodHandle(bootstrapType, bootstrapOwner.represents(void.class) ? instrumentedType : bootstrapOwner, bootstrapName, bootstrapReturnType, bootstrapParameterTypes), arguments)));
                                }
                            }
                            protected enum Factory implements OffsetMapping.Factory<DynamicConstant> {
                                INSTANCE;
                                private static final MethodDescription.InDefinedShape NAME;
                                private static final MethodDescription.InDefinedShape BOOTSTRAP_TYPE;
                                private static final MethodDescription.InDefinedShape BOOTSTRAP_OWNER;
                                private static final MethodDescription.InDefinedShape BOOTSTRAP_NAME;
                                private static final MethodDescription.InDefinedShape BOOTSTRAP_RETURN_TYPE;
                                private static final MethodDescription.InDefinedShape BOOTSTRAP_PARAMETER_TYPES;
                                private static final MethodDescription.InDefinedShape INVOKEDYNAMIC;
                                static {
                                    MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(DynamicConstant.class).getDeclaredMethods();
                                    NAME = methods.filter(named("name")).getOnly();
                                    BOOTSTRAP_TYPE = methods.filter(named("bootstrapType")).getOnly();
                                    BOOTSTRAP_OWNER = methods.filter(named("bootstrapOwner")).getOnly();
                                    BOOTSTRAP_NAME = methods.filter(named("bootstrapName")).getOnly();
                                    BOOTSTRAP_RETURN_TYPE = methods.filter(named("bootstrapReturnType")).getOnly();
                                    BOOTSTRAP_PARAMETER_TYPES = methods.filter(named("bootstrapParameterTypes")).getOnly();
                                    INVOKEDYNAMIC = methods.filter(named("invokedynamic")).getOnly();
                                }
                                public Class<DynamicConstant> getAnnotationType() {
                                    return DynamicConstant.class;
                                }
                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<DynamicConstant> annotation) {
                                    throw new UnsupportedOperationException("This factory does not support binding a method receiver");
                                }
                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<DynamicConstant> annotation) {
                                    return new ForDynamicConstant(annotation.getValue(NAME).resolve(String.class), target.getType().asErasure(), annotation.getValue(BOOTSTRAP_TYPE).resolve(EnumerationDescription.class).load(JavaConstant.MethodHandle.HandleType.class), annotation.getValue(BOOTSTRAP_OWNER).resolve(TypeDescription.class), annotation.getValue(BOOTSTRAP_NAME).resolve(String.class), annotation.getValue(BOOTSTRAP_RETURN_TYPE).resolve(TypeDescription.class), Arrays.asList(annotation.getValue(BOOTSTRAP_PARAMETER_TYPES).resolve(TypeDescription[].class)), Collections.<JavaConstant>emptyList(), annotation.getValue(INVOKEDYNAMIC).resolve(Boolean.class));
                                }
                            }
                        }
                        abstract class ForField implements OffsetMapping {
                            private static final MethodDescription.InDefinedShape FIELD_VALUE_VALUE;
                            private static final MethodDescription.InDefinedShape FIELD_VALUE_DECLARING_TYPE;
                            private static final MethodDescription.InDefinedShape FIELD_VALUE_TYPING;
                            static {
                                MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(FieldValue.class).getDeclaredMethods();
                                FIELD_VALUE_VALUE = methods.filter(named("value")).getOnly();
                                FIELD_VALUE_DECLARING_TYPE = methods.filter(named("declaringType")).getOnly();
                                FIELD_VALUE_TYPING = methods.filter(named("typing")).getOnly();
                            }
                            private final TypeDescription.Generic target;
                            private final Assigner.Typing typing;
                            protected ForField(TypeDescription.Generic target, @MaybeNull Assigner.Typing typing) {
                                this.target = target;
                                this.typing = typing;
                            }
                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                FieldDescription fieldDescription = resolve(instrumentedType, instrumentedMethod);
                                if (!fieldDescription.isStatic() && instrumentedMethod.isStatic()) {
                                    throw new IllegalStateException("Cannot access non-static field " + fieldDescription + " from static method " + instrumentedMethod);
                                }
                                StackManipulation assignment = assigner.assign(fieldDescription.getType(), target, this.typing == null ? typing : this.typing);
                                if (!assignment.isValid()) {
                                    throw new IllegalStateException("Cannot assign " + fieldDescription + " to " + target);
                                }
                                return new OffsetMapping.Resolved.ForStackManipulation(new StackManipulation.Compound(fieldDescription.isStatic() ? StackManipulation.Trivial.INSTANCE : MethodVariableAccess.loadThis(), FieldAccess.forField(fieldDescription).read(), assignment));
                            }
                            protected abstract FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
                            public abstract static class Unresolved extends ForField {
                                protected static final String BEAN_PROPERTY = "";
                                private final String name;
                                protected Unresolved(TypeDescription.Generic target, Assigner.Typing typing, String name) {
                                    super(target, typing);
                                    this.name = name;
                                }
                                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                    FieldLocator locator = fieldLocator(instrumentedType);
                                    FieldLocator.Resolution resolution = name.equals(BEAN_PROPERTY) ? FieldLocator.Resolution.Simple.ofBeanAccessor(locator, instrumentedMethod) : locator.locate(name);
                                    if (!resolution.isResolved()) {
                                        throw new IllegalStateException("Cannot locate field named " + name + " for " + instrumentedType);
                                    } else {
                                        return resolution.getField();
                                    }
                                }
                                protected abstract FieldLocator fieldLocator(TypeDescription instrumentedType);
                                public static class WithImplicitType extends Unresolved {
                                    protected WithImplicitType(TypeDescription.Generic target, AnnotationDescription.Loadable<FieldValue> annotation) {
                                        this(target, annotation.getValue(FIELD_VALUE_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class), annotation.getValue(FIELD_VALUE_VALUE).resolve(String.class));
                                    }
                                    public WithImplicitType(TypeDescription.Generic target, Assigner.Typing typing, String name) {
                                        super(target, typing, name);
                                    }
                                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
                                        return new FieldLocator.ForClassHierarchy(instrumentedType);
                                    }
                                }
                                public static class WithExplicitType extends Unresolved {
                                    private final TypeDescription declaringType;
                                    protected WithExplicitType(TypeDescription.Generic target, AnnotationDescription.Loadable<FieldValue> annotation, TypeDescription declaringType) {
                                        this(target, annotation.getValue(FIELD_VALUE_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class), annotation.getValue(FIELD_VALUE_VALUE).resolve(String.class), declaringType);
                                    }
                                    public WithExplicitType(TypeDescription.Generic target, Assigner.Typing typing, String name, TypeDescription declaringType) {
                                        super(target, typing, name);
                                        this.declaringType = declaringType;
                                    }
                                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
                                        if (!declaringType.represents(TargetType.class) && !instrumentedType.isAssignableTo(declaringType)) {
                                            throw new IllegalStateException(declaringType + " is no super type of " + instrumentedType);
                                        }
                                        return new FieldLocator.ForExactType(TargetType.resolve(declaringType, instrumentedType));
                                    }
                                }
                                protected enum Factory implements OffsetMapping.Factory<FieldValue> {
                                    INSTANCE;
                                    public Class<FieldValue> getAnnotationType() {
                                        return FieldValue.class;
                                    }
                                    public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<FieldValue> annotation) {
                                        TypeDescription declaringType = annotation.getValue(FIELD_VALUE_DECLARING_TYPE).resolve(TypeDescription.class);
                                        return declaringType.represents(void.class) ? new Unresolved.WithImplicitType(target.getDeclaringType().asGenericType(), annotation) : new Unresolved.WithExplicitType(target.getDeclaringType().asGenericType(), annotation, declaringType);
                                    }
                                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<FieldValue> annotation) {
                                        TypeDescription declaringType = annotation.getValue(FIELD_VALUE_DECLARING_TYPE).resolve(TypeDescription.class);
                                        return declaringType.represents(void.class) ? new Unresolved.WithImplicitType(target.getType(), annotation) : new Unresolved.WithExplicitType(target.getType(), annotation, declaringType);
                                    }
                                }
                            }
                            public static class Resolved extends ForField {
                                private final FieldDescription fieldDescription;
                                public Resolved(TypeDescription.Generic target, Assigner.Typing typing, FieldDescription fieldDescription) {
                                    super(target, typing);
                                    this.fieldDescription = fieldDescription;
                                }
                                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                    if (!fieldDescription.isStatic() && !fieldDescription.getDeclaringType().asErasure().isAssignableFrom(instrumentedType)) {
                                        throw new IllegalStateException(fieldDescription + " is no member of " + instrumentedType);
                                    } else if (!fieldDescription.isVisibleTo(instrumentedType)) {
                                        throw new IllegalStateException("Cannot access " + fieldDescription + " from " + instrumentedType);
                                    }
                                    return fieldDescription;
                                }
                                public static class Factory<T extends Annotation> extends OffsetMapping.Factory.AbstractBase<T> {
                                    private final Class<T> annotationType;
                                    private final FieldDescription fieldDescription;
                                    private final Assigner.Typing typing;
                                    public Factory(Class<T> annotationType, FieldDescription fieldDescription) {
                                        this(annotationType, fieldDescription, Assigner.Typing.STATIC);
                                    }
                                    public Factory(Class<T> annotationType, FieldDescription fieldDescription, Assigner.Typing typing) {
                                        this.annotationType = annotationType;
                                        this.fieldDescription = fieldDescription;
                                        this.typing = typing;
                                    }
                                    public Class<T> getAnnotationType() {
                                        return annotationType;
                                    }
                                    protected OffsetMapping make(TypeDescription.Generic target, AnnotationDescription.Loadable<T> annotation) {
                                        return new ForField.Resolved(target, typing, fieldDescription);
                                    }
                                }
                            }
                        }
                        abstract class ForFieldHandle implements OffsetMapping {
                            private final Access access;
                            protected ForFieldHandle(Access access) {
                                this.access = access;
                            }
                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                FieldDescription fieldDescription = resolve(instrumentedType, instrumentedMethod);
                                if (!fieldDescription.isStatic() && instrumentedMethod.isStatic()) {
                                    throw new IllegalStateException("Cannot access non-static field " + fieldDescription + " from static method " + instrumentedMethod);
                                }
                                if (fieldDescription.isStatic()) {
                                    return new OffsetMapping.Resolved.ForStackManipulation(access.resolve(fieldDescription.asDefined()).toStackManipulation());
                                } else {
                                    return new OffsetMapping.Resolved.ForStackManipulation(new StackManipulation.Compound(access.resolve(fieldDescription.asDefined()).toStackManipulation(), MethodVariableAccess.REFERENCE.loadFrom(THIS_REFERENCE), MethodInvocation.invoke(new MethodDescription.Latent(JavaType.METHOD_HANDLE.getTypeStub(), new MethodDescription.Token("bindTo", Opcodes.ACC_PUBLIC, JavaType.METHOD_HANDLE.getTypeStub().asGenericType(), new TypeList.Generic.Explicit(TypeDefinition.Sort.describe(Object.class)))))));
                                }
                            }
                            protected abstract FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
                            public enum Access {
                                GETTER {
                                    @Override
                                    protected JavaConstant.MethodHandle resolve(FieldDescription.InDefinedShape fieldDescription) {
                                        return JavaConstant.MethodHandle.ofGetter(fieldDescription);
                                    }
                                }
                                , SETTER {
                                    @Override
                                    protected JavaConstant.MethodHandle resolve(FieldDescription.InDefinedShape fieldDescription) {
                                        return JavaConstant.MethodHandle.ofSetter(fieldDescription);
                                    }
                                }
                                ;
                                protected abstract JavaConstant.MethodHandle resolve(FieldDescription.InDefinedShape fieldDescription);
                            }
                            public abstract static class Unresolved extends ForFieldHandle {
                                protected static final String BEAN_PROPERTY = "";
                                private final String name;
                                public Unresolved(Access access, String name) {
                                    super(access);
                                    this.name = name;
                                }
                                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                    FieldLocator locator = fieldLocator(instrumentedType);
                                    FieldLocator.Resolution resolution = name.equals(BEAN_PROPERTY) ? FieldLocator.Resolution.Simple.ofBeanAccessor(locator, instrumentedMethod) : locator.locate(name);
                                    if (!resolution.isResolved()) {
                                        throw new IllegalStateException("Cannot locate field named " + name + " for " + instrumentedType);
                                    } else {
                                        return resolution.getField();
                                    }
                                }
                                protected abstract FieldLocator fieldLocator(TypeDescription instrumentedType);
                                public static class WithImplicitType extends Unresolved {
                                    public WithImplicitType(Access access, String name) {
                                        super(access, name);
                                    }
                                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
                                        return new FieldLocator.ForClassHierarchy(instrumentedType);
                                    }
                                }
                                public static class WithExplicitType extends Unresolved {
                                    private final TypeDescription declaringType;
                                    public WithExplicitType(Access access, String name, TypeDescription declaringType) {
                                        super(access, name);
                                        this.declaringType = declaringType;
                                    }
                                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
                                        if (!declaringType.represents(TargetType.class) && !instrumentedType.isAssignableTo(declaringType)) {
                                            throw new IllegalStateException(declaringType + " is no super type of " + instrumentedType);
                                        }
                                        return new FieldLocator.ForExactType(TargetType.resolve(declaringType, instrumentedType));
                                    }
                                }
                                protected enum GetterFactory implements OffsetMapping.Factory<FieldGetterHandle> {
                                    INSTANCE;
                                    private static final MethodDescription.InDefinedShape FIELD_GETTER_HANDLE_VALUE;
                                    private static final MethodDescription.InDefinedShape FIELD_GETTER_HANDLE_DECLARING_TYPE;
                                    static {
                                        MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(FieldGetterHandle.class).getDeclaredMethods();
                                        FIELD_GETTER_HANDLE_VALUE = methods.filter(named("value")).getOnly();
                                        FIELD_GETTER_HANDLE_DECLARING_TYPE = methods.filter(named("declaringType")).getOnly();
                                    }
                                    public Class<FieldGetterHandle> getAnnotationType() {
                                        return FieldGetterHandle.class;
                                    }
                                    public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<FieldGetterHandle> annotation) {
                                        throw new UnsupportedOperationException("This factory does not support binding a method receiver");
                                    }
                                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<FieldGetterHandle> annotation) {
                                        if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {
                                            throw new IllegalStateException("Cannot assign method handle to " + target);
                                        }
                                        TypeDescription declaringType = annotation.getValue(FIELD_GETTER_HANDLE_DECLARING_TYPE).resolve(TypeDescription.class);
                                        return declaringType.represents(void.class) ? new ForFieldHandle.Unresolved.WithImplicitType(Access.GETTER, annotation.getValue(FIELD_GETTER_HANDLE_VALUE).resolve(String.class)) : new ForFieldHandle.Unresolved.WithExplicitType(Access.GETTER, annotation.getValue(FIELD_GETTER_HANDLE_VALUE).resolve(String.class), declaringType);
                                    }
                                }
                                protected enum SetterFactory implements OffsetMapping.Factory<FieldSetterHandle> {
                                    INSTANCE;
                                    private static final MethodDescription.InDefinedShape FIELD_SETTER_HANDLE_VALUE;
                                    private static final MethodDescription.InDefinedShape FIELD_SETTER_HANDLE_DECLARING_TYPE;
                                    static {
                                        MethodList<MethodDescription.InDefinedShape> methods = TypeDescription.ForLoadedType.of(FieldSetterHandle.class).getDeclaredMethods();
                                        FIELD_SETTER_HANDLE_VALUE = methods.filter(named("value")).getOnly();
                                        FIELD_SETTER_HANDLE_DECLARING_TYPE = methods.filter(named("declaringType")).getOnly();
                                    }
                                    public Class<FieldSetterHandle> getAnnotationType() {
                                        return FieldSetterHandle.class;
                                    }
                                    public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<FieldSetterHandle> annotation) {
                                        throw new UnsupportedOperationException("This factory does not support binding a method receiver");
                                    }
                                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<FieldSetterHandle> annotation) {
                                        if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {
                                            throw new IllegalStateException("Cannot assign method handle to " + target);
                                        }
                                        TypeDescription declaringType = annotation.getValue(FIELD_SETTER_HANDLE_DECLARING_TYPE).resolve(TypeDescription.class);
                                        return declaringType.represents(void.class) ? new ForFieldHandle.Unresolved.WithImplicitType(Access.SETTER, annotation.getValue(FIELD_SETTER_HANDLE_VALUE).resolve(String.class)) : new ForFieldHandle.Unresolved.WithExplicitType(Access.SETTER, annotation.getValue(FIELD_SETTER_HANDLE_VALUE).resolve(String.class), declaringType);
                                    }
                                }
                            }
                            public static class Resolved extends OffsetMapping.ForFieldHandle {
                                private final FieldDescription fieldDescription;
                                public Resolved(Access access, FieldDescription fieldDescription) {
                                    super(access);
                                    this.fieldDescription = fieldDescription;
                                }
                                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                    if (!fieldDescription.isStatic() && !fieldDescription.getDeclaringType().asErasure().isAssignableFrom(instrumentedType)) {
                                        throw new IllegalStateException(fieldDescription + " is no member of " + instrumentedType);
                                    } else if (!fieldDescription.isVisibleTo(instrumentedType)) {
                                        throw new IllegalStateException("Cannot access " + fieldDescription + " from " + instrumentedType);
                                    }
                                    return fieldDescription;
                                }
                                public static class Factory<T extends Annotation> implements OffsetMapping.Factory<T> {
                                    private final Class<T> annotationType;
                                    private final FieldDescription fieldDescription;
                                    private final Access access;
                                    public Factory(Class<T> annotationType, FieldDescription fieldDescription, Access access) {
                                        this.annotationType = annotationType;
                                        this.fieldDescription = fieldDescription;
                                        this.access = access;
                                    }
                                    public Class<T> getAnnotationType() {
                                        return annotationType;
                                    }
                                    public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation) {
                                        throw new UnsupportedOperationException("This factory does not support binding a method receiver");
                                    }
                                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<T> annotation) {
                                        if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {
                                            throw new IllegalStateException("Cannot assign method handle to " + target);
                                        }
                                        return new ForFieldHandle.Resolved(access, fieldDescription);
                                    }
                                }
                            }
                        }
                        class ForOrigin implements OffsetMapping {
                            private final Sort sort;
                            private final Source source;
                            protected ForOrigin(Sort sort, Source source) {
                                this.sort = sort;
                                this.source = source;
                            }
                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                return new ForOrigin.Resolved(sort, source, instrumentedMethod);
                            }
                            protected enum Sort {
                                METHOD {
                                    @Override
                                    protected boolean isRepresentable(ByteCodeElement.Member member) {
                                        return member instanceof MethodDescription && ((MethodDescription) member).isMethod();
                                    }
                                    @Override
                                    protected StackManipulation resolve(ByteCodeElement.Member member, List<TypeDescription> parameterTypes, TypeDescription returnType) {
                                        return MethodConstant.of(((MethodDescription) member).asDefined());
                                    }
                                }
                                ,
                                CONSTRUCTOR {
                                    @Override
                                    protected boolean isRepresentable(ByteCodeElement.Member member) {
                                        return member instanceof MethodDescription && ((MethodDescription) member).isConstructor();
                                    }
                                    @Override
                                    protected StackManipulation resolve(ByteCodeElement.Member member, List<TypeDescription> parameterTypes, TypeDescription returnType) {
                                        return MethodConstant.of(((MethodDescription) member).asDefined());
                                    }
                                }
                                ,
                                FIELD {
                                    @Override
                                    protected boolean isRepresentable(ByteCodeElement.Member member) {
                                        return member instanceof FieldDescription;
                                    }
                                    @Override
                                    protected StackManipulation resolve(ByteCodeElement.Member member, List<TypeDescription> parameterTypes, TypeDescription returnType) {
                                        return new FieldConstant(((FieldDescription) member).asDefined());
                                    }
                                }
                                ,
                                MODIFIERS {
                                    @Override
                                    protected boolean isRepresentable(ByteCodeElement.Member member) {
                                        return true;
                                    }
                                    @Override
                                    protected StackManipulation resolve(ByteCodeElement.Member member, List<TypeDescription> parameterTypes, TypeDescription returnType) {
                                        return IntegerConstant.forValue(member.getModifiers());
                                    }
                                }
                                ,
                                EXECUTABLE {
                                    @Override
                                    protected boolean isRepresentable(ByteCodeElement.Member member) {
                                        return member instanceof MethodDescription;
                                    }
                                    @Override
                                    protected StackManipulation resolve(ByteCodeElement.Member member, List<TypeDescription> parameterTypes, TypeDescription returnType) {
                                        return MethodConstant.of(((MethodDescription) member).asDefined());
                                    }
                                }
                                ,
                                TYPE {
                                    @Override
                                    protected boolean isRepresentable(ByteCodeElement.Member member) {
                                        return true;
                                    }
                                    @Override
                                    protected StackManipulation resolve(ByteCodeElement.Member member, List<TypeDescription> parameterTypes, TypeDescription returnType) {
                                        return ClassConstant.of(member.getDeclaringType().asErasure());
                                    }
                                }
                                ,
                                LOOKUP {
                                    @Override
                                    protected boolean isRepresentable(ByteCodeElement.Member member) {
                                        return true;
                                    }
                                    @Override
                                    protected StackManipulation resolve(ByteCodeElement.Member member, List<TypeDescription> parameterTypes, TypeDescription returnType) {
                                        return MethodInvocation.lookup();
                                    }
                                }
                                ,
                                METHOD_HANDLE {
                                    @Override
                                    protected boolean isRepresentable(ByteCodeElement.Member member) {
                                        return true;
                                    }
                                    @Override
                                    protected StackManipulation resolve(ByteCodeElement.Member member, List<TypeDescription> parameterTypes, TypeDescription returnType) {
                                        JavaConstant.MethodHandle handle;
                                        if (member instanceof MethodDescription) {
                                            handle = JavaConstant.MethodHandle.of(((MethodDescription) member).asDefined());
                                        } else if (member instanceof FieldDescription) {
                                            handle = returnType.represents(void.class) ? JavaConstant.MethodHandle.ofSetter(((FieldDescription) member).asDefined()) : JavaConstant.MethodHandle.ofGetter(((FieldDescription) member).asDefined());
                                        } else {
                                            throw new IllegalStateException("Unexpected byte code element: " + member);
                                        }
                                        return handle.toStackManipulation();
                                    }
                                }
                                ,
                                METHOD_TYPE {
                                    @Override
                                    protected boolean isRepresentable(ByteCodeElement.Member member) {
                                        return true;
                                    }
                                    @Override
                                    protected StackManipulation resolve(ByteCodeElement.Member member, List<TypeDescription> parameterTypes, TypeDescription returnType) {
                                        return JavaConstant.MethodType.of(returnType, parameterTypes).toStackManipulation();
                                    }
                                }
                                ,
                                STRING {
                                    @Override
                                    protected boolean isRepresentable(ByteCodeElement.Member member) {
                                        return true;
                                    }
                                    @Override
                                    protected StackManipulation resolve(ByteCodeElement.Member member, List<TypeDescription> parameterTypes, TypeDescription returnType) {
                                        return new TextConstant(member.toString());
                                    }
                                }
                                ;
                                protected abstract boolean isRepresentable(ByteCodeElement.Member member);
                                protected abstract StackManipulation resolve(ByteCodeElement.Member member, List<TypeDescription> parameterTypes, TypeDescription returnType);
                            }
                            protected enum Factory implements OffsetMapping.Factory<Origin> {
                                INSTANCE;
                                private static final MethodDescription.InDefinedShape ORIGIN_TYPE = TypeDescription.ForLoadedType.of(Origin.class).getDeclaredMethods().filter(named("source")).getOnly();
                                public Class<Origin> getAnnotationType() {
                                    return Origin.class;
                                }
                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<Origin> annotation) {
                                    throw new UnsupportedOperationException("This factory does not support binding a method receiver");
                                }
                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<Origin> annotation) {
                                    Sort sort;
                                    if (target.getType().asErasure().represents(Class.class)) {
                                        sort = Sort.TYPE;
                                    } else if (target.getType().asErasure().represents(Method.class)) {
                                        sort = Sort.METHOD;
                                    } else if (target.getType().asErasure().represents(Constructor.class)) {
                                        sort = Sort.CONSTRUCTOR;
                                    } else if (target.getType().asErasure().represents(Field.class)) {
                                        sort = Sort.FIELD;
                                    } else if (target.getType().asErasure().represents(int.class)) {
                                        sort = Sort.MODIFIERS;
                                    } else if (JavaType.EXECUTABLE.getTypeStub().equals(target.getType().asErasure())) {
                                        sort = Sort.EXECUTABLE;
                                    } else if (JavaType.METHOD_HANDLE.getTypeStub().equals(target.getType().asErasure())) {
                                        sort = Sort.METHOD_HANDLE;
                                    } else if (JavaType.METHOD_TYPE.getTypeStub().equals(target.getType().asErasure())) {
                                        sort = Sort.METHOD_TYPE;
                                    } else if (JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().equals(target.getType().asErasure())) {
                                        sort = Sort.LOOKUP;
                                    } else if (target.getType().asErasure().isAssignableFrom(String.class)) {
                                        sort = Sort.STRING;
                                    } else {
                                        throw new IllegalStateException("Non-supported type " + target.getType() + " for @Origin annotation");
                                    }
                                    return new ForOrigin(sort, annotation.getValue(ORIGIN_TYPE).resolve(EnumerationDescription.class).load(Source.class));
                                }
                            }
                            protected static class Resolved implements OffsetMapping.Resolved {
                                private final Sort sort;
                                private final Source source;
                                private final MethodDescription instrumentedMethod;
                                protected Resolved(Sort sort, Source source, MethodDescription instrumentedMethod) {
                                    this.sort = sort;
                                    this.source = source;
                                    this.instrumentedMethod = instrumentedMethod;
                                }
                                public StackManipulation apply(Target target, TypeList.Generic parameters, TypeDescription.Generic result, TypeDescription.Generic current, JavaConstant.MethodHandle methodHandle, Map<Integer, Integer> offsets, int offset) {
                                    if (!source.isRepresentable(sort, target, instrumentedMethod)) {
                                        throw new IllegalStateException("Cannot represent " + sort + " for " + source + " in " + instrumentedMethod);
                                    }
                                    return source.resolve(sort, target, parameters, result, instrumentedMethod);
                                }
                            }
                        }
                        class ForStubValue implements OffsetMapping {
                            private final Source source;
                            protected ForStubValue(Source source) {
                                this.source = source;
                            }
                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                return new Resolved(source, instrumentedMethod);
                            }
                            protected static class Resolved implements OffsetMapping.Resolved {
                                private final Source source;
                                private final MethodDescription instrumentedMethod;
                                protected Resolved(Source source, MethodDescription instrumentedMethod) {
                                    this.source = source;
                                    this.instrumentedMethod = instrumentedMethod;
                                }
                                public StackManipulation apply(Target target, TypeList.Generic parameters, TypeDescription.Generic result, TypeDescription.Generic current, JavaConstant.MethodHandle methodHandle, Map<Integer, Integer> offsets, int offset) {
                                    return DefaultValue.of(source.handle(methodHandle, instrumentedMethod).getReturnType());
                                }
                            }
                            protected enum Factory implements OffsetMapping.Factory<StubValue> {
                                INSTANCE;
                                private static final MethodDescription.InDefinedShape STUB_VALUE_SOURCE = TypeDescription.ForLoadedType.of(StubValue.class).getDeclaredMethods().filter(named("source")).getOnly();
                                public Class<StubValue> getAnnotationType() {
                                    return StubValue.class;
                                }
                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<StubValue> annotation) {
                                    throw new UnsupportedOperationException("This factory does not support binding a method receiver");
                                }
                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<StubValue> annotation) {
                                    if (!target.getType().represents(Object.class)) {
                                        throw new IllegalStateException("Expected " + target + " to declare an Object type");
                                    }
                                    return new ForStubValue(annotation.getValue(STUB_VALUE_SOURCE).resolve(EnumerationDescription.class).load(Source.class));
                                }
                            }
                        }
                        class ForCurrent implements OffsetMapping {
                            private final TypeDescription.Generic targetType;
                            private final Assigner.Typing typing;
                            public ForCurrent(TypeDescription.Generic targetType, @MaybeNull Assigner.Typing typing) {
                                this.targetType = targetType;
                                this.typing = typing;
                            }
                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                return new ForCurrent.Resolved(targetType, assigner, this.typing == null ? typing : this.typing);
                            }
                            protected enum Factory implements OffsetMapping.Factory<Current> {
                                INSTANCE;
                                private static final MethodDescription.InDefinedShape CURRENT_TYPING = TypeDescription.ForLoadedType.of(Current.class).getDeclaredMethods().filter(named("typing")).getOnly();
                                public Class<Current> getAnnotationType() {
                                    return Current.class;
                                }
                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable<Current> annotation) {
                                    return new ForCurrent(target.getDeclaringType().asGenericType(), annotation.getValue(CURRENT_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class));
                                }
                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable<Current> annotation) {
                                    return new ForCurrent(target.getType(), annotation.getValue(CURRENT_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class));
                                }
                            }
                            protected static class Resolved implements OffsetMapping.Resolved {
                                private final TypeDescription.Generic targetType;
                                private final Assigner assigner;
                                private final Assigner.Typing typing;
                                public Resolved(TypeDescription.Generic targetType, Assigner assigner, Assigner.Typing typing) {
                                    this.targetType = targetType;
                                    this.assigner = assigner;
                                    this.typing = typing;
                                }
                                public StackManipulation apply(Target target, TypeList.Generic parameters, TypeDescription.Generic result, TypeDescription.Generic current, JavaConstant.MethodHandle methodHandle, Map<Integer, Integer> offsets, int offset) {
                                    StackManipulation assignment = assigner.assign(current, targetType, typing);
                                    if (!assignment.isValid()) {
                                        throw new IllegalStateException("Cannot assign " + current + " to " + targetType);
                                    }
                                    return new StackManipulation.Compound(MethodVariableAccess.of(current).loadFrom(offset), assignment);
                                }
                            }
                        }
                    }
                    protected interface Dispatcher {
                        Dispatcher.Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
                        interface Resolved {
                            StackManipulation initialize();
                            StackManipulation apply(Target target, JavaConstant.MethodHandle methodHandle);
                        }
                        interface Factory {
                            Dispatcher make(MethodDescription.InDefinedShape delegate);
                        }
                        class ForRegularInvocation implements Dispatcher, Dispatcher.Resolved {
                            private final MethodDescription delegate;
                            protected ForRegularInvocation(MethodDescription delegate) {
                                this.delegate = delegate;
                            }
                            public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                return this;
                            }
                            public StackManipulation initialize() {
                                return delegate.isConstructor() ? new StackManipulation.Compound(TypeCreation.of(delegate.getDeclaringType().asErasure()), Duplication.SINGLE) : StackManipulation.Trivial.INSTANCE;
                            }
                            public StackManipulation apply(Target target, JavaConstant.MethodHandle methodHandle) {
                                return MethodInvocation.invoke(delegate);
                            }
                            protected enum Factory implements Dispatcher.Factory {
                                INSTANCE;
                                public Dispatcher make(MethodDescription.InDefinedShape delegate) {
                                    return new ForRegularInvocation(delegate);
                                }
                            }
                        }
                        class ForDynamicInvocation implements Dispatcher {
                            private final MethodDescription.InDefinedShape bootstrapMethod;
                            private final MethodDescription.InDefinedShape delegate;
                            private final BootstrapArgumentResolver resolver;
                            protected ForDynamicInvocation(MethodDescription.InDefinedShape bootstrapMethod, MethodDescription.InDefinedShape delegate, BootstrapArgumentResolver resolver) {
                                this.bootstrapMethod = bootstrapMethod;
                                this.delegate = delegate;
                                this.resolver = resolver;
                            }
                            protected static Dispatcher.Factory of(MethodDescription.InDefinedShape bootstrapMethod, BootstrapArgumentResolver.Factory resolverFactory) {
                                if (!bootstrapMethod.isInvokeBootstrap()) {
                                    throw new IllegalStateException("Not a bootstrap method: " + bootstrapMethod);
                                }
                                return new ForDynamicInvocation.Factory(bootstrapMethod, resolverFactory);
                            }
                            public Dispatcher.Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                return new ForDynamicInvocation.Resolved(bootstrapMethod, delegate, resolver.resolve(instrumentedType, instrumentedMethod));
                            }
                            protected static class Resolved implements Dispatcher.Resolved {
                                private final MethodDescription.InDefinedShape bootstrapMethod;
                                private final MethodDescription.InDefinedShape delegate;
                                private final BootstrapArgumentResolver.Resolved resolver;
                                protected Resolved(MethodDescription.InDefinedShape bootstrapMethod, MethodDescription.InDefinedShape delegate, BootstrapArgumentResolver.Resolved resolver) {
                                    this.bootstrapMethod = bootstrapMethod;
                                    this.delegate = delegate;
                                    this.resolver = resolver;
                                }
                                public StackManipulation initialize() {
                                    return StackManipulation.Trivial.INSTANCE;
                                }
                                public StackManipulation apply(Target target, JavaConstant.MethodHandle methodHandle) {
                                    List<JavaConstant> constants = resolver.make(target, methodHandle);
                                    if (!bootstrapMethod.isInvokeBootstrap(TypeList.Explicit.of(constants))) {
                                        throw new IllegalArgumentException(bootstrapMethod + " is not accepting advice bootstrap arguments: " + constants);
                                    }
                                    return MethodInvocation.invoke(bootstrapMethod).dynamic(delegate.getInternalName(), delegate.getReturnType().asErasure(), delegate.getParameters().asTypeList().asErasures(), constants);
                                }
                            }
                            protected static class Factory implements Dispatcher.Factory {
                                private final MethodDescription.InDefinedShape bootstrapMethod;
                                private final BootstrapArgumentResolver.Factory resolverFactory;
                                protected Factory(MethodDescription.InDefinedShape bootstrapMethod, BootstrapArgumentResolver.Factory resolverFactory) {
                                    this.bootstrapMethod = bootstrapMethod;
                                    this.resolverFactory = resolverFactory;
                                }
                                public Dispatcher make(MethodDescription.InDefinedShape delegate) {
                                    return new ForDynamicInvocation(bootstrapMethod, delegate, resolverFactory.make(delegate));
                                }
                            }
                        }
                    }
                    public interface BootstrapArgumentResolver {
                        BootstrapArgumentResolver.Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
                        interface Resolved {
                            List<JavaConstant> make(Target target, JavaConstant.MethodHandle methodHandle);
                        }
                        interface Factory {
                            BootstrapArgumentResolver make(MethodDescription.InDefinedShape delegate);
                        }
                        class ForDefaultValues implements BootstrapArgumentResolver {
                            private final MethodDescription.InDefinedShape delegate;
                            protected ForDefaultValues(MethodDescription.InDefinedShape delegate) {
                                this.delegate = delegate;
                            }
                            public BootstrapArgumentResolver.Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                return new Resolved(delegate, instrumentedType, instrumentedMethod);
                            }
                            protected static class Resolved implements BootstrapArgumentResolver.Resolved {
                                private final MethodDescription.InDefinedShape delegate;
                                private final TypeDescription instrumentedType;
                                private final MethodDescription instrumentedMethod;
                                protected Resolved(MethodDescription.InDefinedShape delegate, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
                                    this.delegate = delegate;
                                    this.instrumentedType = instrumentedType;
                                    this.instrumentedMethod = instrumentedMethod;
                                }
                                public List<JavaConstant> make(Target target, JavaConstant.MethodHandle methodHandle) {
                                    if (instrumentedMethod.isTypeInitializer()) {
                                        return Arrays.asList(JavaConstant.Simple.ofLoaded(delegate.getDeclaringType().getName()), JavaConstant.Simple.of(target instanceof Target.ForMember ? ((Target.ForMember) target).getReceiverType() : TypeDescription.ForLoadedType.of(void.class)), JavaConstant.Simple.ofLoaded(target.getName()), methodHandle, JavaConstant.Simple.of(instrumentedType), JavaConstant.Simple.ofLoaded(instrumentedMethod.getInternalName()));
                                    } else {
                                        return Arrays.asList(JavaConstant.Simple.ofLoaded(delegate.getDeclaringType().getName()), JavaConstant.Simple.of(target instanceof Target.ForMember ? ((Target.ForMember) target).getReceiverType() : TypeDescription.ForLoadedType.of(void.class)), JavaConstant.Simple.ofLoaded(target.getName()), methodHandle, JavaConstant.Simple.of(instrumentedType), JavaConstant.Simple.ofLoaded(instrumentedMethod.getInternalName()), JavaConstant.MethodHandle.of(instrumentedMethod.asDefined()));
                                    }
                                }
                            }
                            public enum Factory implements BootstrapArgumentResolver.Factory {
                                INSTANCE;
                                public BootstrapArgumentResolver make(MethodDescription.InDefinedShape delegate) {
                                    return new ForDefaultValues(delegate);
                                }
                            }
                        }
                    }
                    public static class WithCustomMapping {
                        private final Dispatcher.Factory dispatcherFactory;
                        private final Map<Class<? extends Annotation>, OffsetMapping.Factory<?>> offsetMappings;
                        protected WithCustomMapping(Dispatcher.Factory dispatcherFactory, Map<Class<? extends Annotation>, OffsetMapping.Factory<?>> offsetMappings) {
                            this.dispatcherFactory = dispatcherFactory;
                            this.offsetMappings = offsetMappings;
                        }
                        public <T extends Annotation> WithCustomMapping bind(Class<T> type, @MaybeNull Object value) {
                            return bind(OffsetMapping.ForStackManipulation.of(type, value));
                        }
                        public <T extends Annotation> WithCustomMapping bind(Class<T> type, Field field) {
                            return bind(type, new FieldDescription.ForLoadedField(field));
                        }
                        public <T extends Annotation> WithCustomMapping bind(Class<T> type, FieldDescription fieldDescription) {
                            return bind(new OffsetMapping.ForField.Resolved.Factory<T>(type, fieldDescription));
                        }
                        public <T extends Annotation> WithCustomMapping bind(Class<T> type, Class<?> value) {
                            return bind(type, TypeDescription.ForLoadedType.of(value));
                        }
                        public <T extends Annotation> WithCustomMapping bind(Class<T> type, TypeDescription value) {
                            return bind(new OffsetMapping.ForStackManipulation.Factory<T>(type, ConstantValue.Simple.wrap(value)));
                        }
                        public <T extends Annotation> WithCustomMapping bind(Class<T> type, Enum<?> value) {
                            return bind(type, new EnumerationDescription.ForLoadedEnumeration(value));
                        }
                        public <T extends Annotation> WithCustomMapping bind(Class<T> type, EnumerationDescription value) {
                            return bind(new OffsetMapping.ForStackManipulation.Factory<T>(type, ConstantValue.Simple.wrap(value)));
                        }
                        public <T extends Annotation> WithCustomMapping bindSerialized(Class<T> type, Serializable value) {
                            return bindSerialized(type, value, (Class<Serializable>) value.getClass());
                        }
                        public <T extends Annotation, S extends Serializable> WithCustomMapping bindSerialized(Class<T> type, S value, Class<? super S> targetType) {
                            return bind(OffsetMapping.ForStackManipulation.OfSerializedConstant.of(type, value, targetType));
                        }
                        public <T extends Annotation> WithCustomMapping bindProperty(Class<T> type, String property) {
                            return bind(OffsetMapping.ForStackManipulation.OfAnnotationProperty.of(type, property));
                        }
                        public <T extends Annotation> WithCustomMapping bind(Class<T> type, ConstantValue constant) {
                            return bind(new OffsetMapping.ForStackManipulation.Factory<T>(type, constant.toStackManipulation(), constant.getTypeDescription().asGenericType()));
                        }
                        public <T extends Annotation> WithCustomMapping bind(Class<T> type, StackManipulation stackManipulation, java.lang.reflect.Type targetType) {
                            return bind(type, stackManipulation, TypeDefinition.Sort.describe(targetType));
                        }
                        public <T extends Annotation> WithCustomMapping bind(Class<T> type, StackManipulation stackManipulation, TypeDescription.Generic targetType) {
                            return bind(new OffsetMapping.ForStackManipulation.Factory<T>(type, stackManipulation, targetType));
                        }
                        public <T extends Annotation> WithCustomMapping bindLambda(Class<T> type, Constructor<?> constructor, Class<?> functionalInterface) {
                            return bindLambda(type, new MethodDescription.ForLoadedConstructor(constructor), TypeDescription.ForLoadedType.of(functionalInterface));
                        }
                        public <T extends Annotation> WithCustomMapping bindLambda(Class<T> type, Constructor<?> constructor, Class<?> functionalInterface, MethodGraph.Compiler methodGraphCompiler) {
                            return bindLambda(type, new MethodDescription.ForLoadedConstructor(constructor), TypeDescription.ForLoadedType.of(functionalInterface), methodGraphCompiler);
                        }
                        public <T extends Annotation> WithCustomMapping bindLambda(Class<T> type, Method method, Class<?> functionalInterface) {
                            return bindLambda(type, new MethodDescription.ForLoadedMethod(method), TypeDescription.ForLoadedType.of(functionalInterface));
                        }
                        public <T extends Annotation> WithCustomMapping bindLambda(Class<T> type, Method method, Class<?> functionalInterface, MethodGraph.Compiler methodGraphCompiler) {
                            return bindLambda(type, new MethodDescription.ForLoadedMethod(method), TypeDescription.ForLoadedType.of(functionalInterface), methodGraphCompiler);
                        }
                        public <T extends Annotation> WithCustomMapping bindLambda(Class<T> type, MethodDescription.InDefinedShape methodDescription, TypeDescription functionalInterface) {
                            return bindLambda(type, methodDescription, functionalInterface, MethodGraph.Compiler.DEFAULT);
                        }
                        public <T extends Annotation> WithCustomMapping bindLambda(Class<T> type, MethodDescription.InDefinedShape methodDescription, TypeDescription functionalInterface, MethodGraph.Compiler methodGraphCompiler) {
                            if (!functionalInterface.isInterface()) {
                                throw new IllegalArgumentException(functionalInterface + " is not an interface type");
                            }
                            MethodList<?> methods = methodGraphCompiler.compile((TypeDefinition) functionalInterface).listNodes().asMethodList().filter(isAbstract());
                            if (methods.size() != 1) {
                                throw new IllegalArgumentException(functionalInterface + " does not define exactly one abstract method: " + methods);
                            }
                            return bindDynamic(type, new MethodDescription.Latent(new TypeDescription.Latent("java.lang.invoke.LambdaMetafactory", Opcodes.ACC_PUBLIC, TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class)), "metafactory", Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, Collections.<TypeVariableToken>emptyList(), JavaType.CALL_SITE.getTypeStub().asGenericType(), Arrays.asList(new ParameterDescription.Token(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().asGenericType()), new ParameterDescription.Token(TypeDescription.ForLoadedType.of(String.class).asGenericType()), new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType()), new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType()), new ParameterDescription.Token(JavaType.METHOD_HANDLE.getTypeStub().asGenericType()), new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType())), Collections.<TypeDescription.Generic>emptyList(), Collections.<AnnotationDescription>emptyList(), AnnotationValue.UNDEFINED, TypeDescription.Generic.UNDEFINED), JavaConstant.MethodType.ofSignature(methods.asDefined().getOnly()), JavaConstant.MethodHandle.of(methodDescription), JavaConstant.MethodType.ofSignature(methods.asDefined().getOnly()));
                        }
                        public <T extends Annotation> WithCustomMapping bindDynamic(Class<T> type, Method bootstrapMethod, Object... constant) {
                            return bindDynamic(type, bootstrapMethod, Arrays.asList(constant));
                        }
                        public <T extends Annotation> WithCustomMapping bindDynamic(Class<T> type, Method bootstrapMethod, List<?> constants) {
                            return bindDynamic(type, new MethodDescription.ForLoadedMethod(bootstrapMethod), constants);
                        }
                        public <T extends Annotation> WithCustomMapping bindDynamic(Class<T> type, Constructor<?> bootstrapMethod, Object... constant) {
                            return bindDynamic(type, bootstrapMethod, Arrays.asList(constant));
                        }
                        public <T extends Annotation> WithCustomMapping bindDynamic(Class<T> type, Constructor<?> bootstrapMethod, List<?> constants) {
                            return bindDynamic(type, new MethodDescription.ForLoadedConstructor(bootstrapMethod), constants);
                        }
                        public <T extends Annotation> WithCustomMapping bindDynamic(Class<T> type, MethodDescription.InDefinedShape bootstrapMethod, Object... constant) {
                            return bindDynamic(type, bootstrapMethod, Arrays.asList(constant));
                        }
                        public <T extends Annotation> WithCustomMapping bindDynamic(Class<T> type, MethodDescription.InDefinedShape bootstrapMethod, List<?> constants) {
                            List<JavaConstant> arguments = JavaConstant.Simple.wrap(constants);
                            if (!bootstrapMethod.isInvokeBootstrap(TypeList.Explicit.of(arguments))) {
                                throw new IllegalArgumentException("Not a valid bootstrap method " + bootstrapMethod + " for " + arguments);
                            }
                            return bind(new OffsetMapping.ForStackManipulation.OfDynamicInvocation<T>(type, bootstrapMethod, arguments));
                        }
                        public <T extends Annotation> WithCustomMapping bind(Class<T> type, OffsetMapping offsetMapping) {
                            return bind(new OffsetMapping.Factory.Simple<T>(type, offsetMapping));
                        }
                        public WithCustomMapping bind(OffsetMapping.Factory<?> offsetMapping) {
                            Map<Class<? extends Annotation>, OffsetMapping.Factory<?>> offsetMappings = new LinkedHashMap<Class<? extends Annotation>, OffsetMapping.Factory<?>>(this.offsetMappings);
                            if (!offsetMapping.getAnnotationType().isAnnotation()) {
                                throw new IllegalArgumentException("Not an annotation type: " + offsetMapping.getAnnotationType());
                            } else if (offsetMappings.put(offsetMapping.getAnnotationType(), offsetMapping) != null) {
                                throw new IllegalArgumentException("Annotation type already mapped: " + offsetMapping.getAnnotationType());
                            }
                            return new WithCustomMapping(dispatcherFactory, offsetMappings);
                        }
                        public WithCustomMapping bootstrap(Constructor<?> constructor) {
                            return bootstrap(new MethodDescription.ForLoadedConstructor(constructor));
                        }
                        public WithCustomMapping bootstrap(Constructor<?> constructor, BootstrapArgumentResolver.Factory resolverFactory) {
                            return bootstrap(new MethodDescription.ForLoadedConstructor(constructor), resolverFactory);
                        }
                        public WithCustomMapping bootstrap(Method method) {
                            return bootstrap(new MethodDescription.ForLoadedMethod(method));
                        }
                        public WithCustomMapping bootstrap(Method method, BootstrapArgumentResolver.Factory resolverFactory) {
                            return bootstrap(new MethodDescription.ForLoadedMethod(method), resolverFactory);
                        }
                        public WithCustomMapping bootstrap(MethodDescription.InDefinedShape bootstrap) {
                            return bootstrap(bootstrap, BootstrapArgumentResolver.ForDefaultValues.Factory.INSTANCE);
                        }
                        public WithCustomMapping bootstrap(MethodDescription.InDefinedShape bootstrap, BootstrapArgumentResolver.Factory resolverFactory) {
                            return new WithCustomMapping(Dispatcher.ForDynamicInvocation.of(bootstrap, resolverFactory), offsetMappings);
                        }
                        public Step.Factory<Target> to(Method method) {
                            return to(new MethodDescription.ForLoadedMethod(method));
                        }
                        public Step.Factory<Target> to(Constructor<?> constructor) {
                            return to(new MethodDescription.ForLoadedConstructor(constructor));
                        }
                        public Step.Factory<Target> to(MethodDescription.InDefinedShape methodDescription) {
                            return ForDelegation.to(methodDescription, dispatcherFactory, new ArrayList<OffsetMapping.Factory<?>>(offsetMappings.values()));
                        }
                    }
                }
            }
            public static class Factory<U extends Target> implements Substitution.Factory<U> {
                private final Assigner assigner;
                private final Assigner.Typing typing;
                private final List<Step.Factory<? super U>> steps;
                protected Factory(Assigner assigner, Assigner.Typing typing, List<Step.Factory<? super U>> steps) {
                    this.assigner = assigner;
                    this.typing = typing;
                    this.steps = steps;
                }
                public Substitution<? super U> make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
                    if (steps.isEmpty()) {
                        return Stubbing.INSTANCE;
                    }
                    List<Step<? super U>> steps = new ArrayList<Step<? super U>>(this.steps.size());
                    for (Step.Factory<? super U> step : this.steps) {
                        steps.add(step.make(assigner, typing, instrumentedType, instrumentedMethod));
                    }
                    return new Chain<U>(assigner, typing, steps);
                }
                public final Factory<U> executing(Step.Factory<? super U>... step) {
                    return executing(Arrays.asList(step));
                }
                public Factory<U> executing(List<? extends Step.Factory<? super U>> steps) {
                    return new Factory<U>(assigner, typing, CompoundList.of(this.steps, steps));
                }
            }
        }
    }
    protected interface Replacement {
        Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypeDescription typeDescription, FieldDescription fieldDescription, boolean writeAccess);
        Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypeDescription typeDescription, MethodDescription methodDescription, InvocationType invocationType);
        Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, JavaConstant.MethodHandle methodHandle, JavaConstant.MethodType methodType, String name, List<JavaConstant> constants);
        interface Binding {
            boolean isBound();
            StackManipulation make(TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, int freeOffset);
            enum Unresolved implements Binding {
                INSTANCE;
                public boolean isBound() {
                    return false;
                }
                public StackManipulation make(TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, int freeOffset) {
                    throw new IllegalStateException("Cannot resolve unresolved binding");
                }
            }
            class ForMember implements Binding {
                private final TypeDescription receiver;
                private final ByteCodeElement.Member member;
                private final Substitution<? super Target.ForMember> substitution;
                protected ForMember(TypeDescription receiver, ByteCodeElement.Member member, Substitution<? super Target.ForMember> substitution) {
                    this.receiver = receiver;
                    this.member = member;
                    this.substitution = substitution;
                }
                public boolean isBound() {
                    return true;
                }
                public StackManipulation make(TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, int freeOffset) {
                    return substitution.resolve(new Target.ForMember(receiver, member), parameters, result, methodHandle, stackManipulation, freeOffset);
                }
            }
            class ForDynamicInvocation implements Binding {
                private final JavaConstant.MethodType methodType;
                private final String name;
                private final List<JavaConstant> arguments;
                private final Substitution<? super Target.ForDynamicInvocation> substitution;
                protected ForDynamicInvocation(JavaConstant.MethodType methodType, String name, List<JavaConstant> arguments, Substitution<? super Target.ForDynamicInvocation> substitution) {
                    this.methodType = methodType;
                    this.name = name;
                    this.arguments = arguments;
                    this.substitution = substitution;
                }
                public boolean isBound() {
                    return true;
                }
                public StackManipulation make(TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, int freeOffset) {
                    return substitution.resolve(new Target.ForDynamicInvocation(methodType, name, arguments), parameters, result, methodHandle, stackManipulation, freeOffset);
                }
            }
        }
        interface Factory {
            Replacement make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool);
            class Compound implements Factory {
                private final List<Factory> factories;
                protected Compound(Factory... factory) {
                    this(Arrays.asList(factory));
                }
                protected Compound(List<? extends Factory> factories) {
                    this.factories = new ArrayList<Factory>();
                    for (Factory factory : factories) {
                        if (factory instanceof Compound) {
                            this.factories.addAll(((Compound) factory).factories);
                        } else if (!(factory instanceof NoOp)) {
                            this.factories.add(factory);
                        }
                    }
                }
                public Replacement make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
                    List<Replacement> replacements = new ArrayList<Replacement>();
                    for (Factory factory : factories) {
                        replacements.add(factory.make(instrumentedType, instrumentedMethod, typePool));
                    }
                    return new ForFirstBinding(replacements);
                }
            }
        }
        enum InvocationType {
            VIRTUAL, SUPER, OTHER;
            protected static InvocationType of(int opcode, MethodDescription methodDescription) {
                switch(opcode) {
                    case Opcodes.INVOKEVIRTUAL:
                    case Opcodes.INVOKEINTERFACE:
                        return InvocationType.VIRTUAL;
                    case Opcodes.INVOKESPECIAL:
                        return methodDescription.isVirtual() ? SUPER : OTHER;
                    default:
                        return OTHER;
                }
            }
            protected boolean matches(boolean includeVirtualCalls, boolean includeSuperCalls) {
                switch(this) {
                    case VIRTUAL:
                        return includeVirtualCalls;
                    case SUPER:
                        return includeSuperCalls;
                    default:
                        return true;
                }
            }
        }
        enum NoOp implements Replacement, Factory {
            INSTANCE;
            public Replacement make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
                return this;
            }
            public Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypeDescription typeDescription, FieldDescription fieldDescription, boolean writeAccess) {
                return Binding.Unresolved.INSTANCE;
            }
            public Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypeDescription typeDescription, MethodDescription methodDescription, InvocationType invocationType) {
                return Binding.Unresolved.INSTANCE;
            }
            public Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, JavaConstant.MethodHandle methodHandle, JavaConstant.MethodType methodType, String name, List<JavaConstant> constants) {
                return Binding.Unresolved.INSTANCE;
            }
        }
        class ForElementMatchers implements Replacement {
            private final ElementMatcher<? super FieldDescription> fieldMatcher;
            private final ElementMatcher<? super MethodDescription> methodMatcher;
            private final boolean matchFieldRead;
            private final boolean matchFieldWrite;
            private final boolean includeVirtualCalls;
            private final boolean includeSuperCalls;
            private final Substitution<? super Target.ForMember> substitution;
            protected ForElementMatchers(ElementMatcher<? super FieldDescription> fieldMatcher, ElementMatcher<? super MethodDescription> methodMatcher, boolean matchFieldRead, boolean matchFieldWrite, boolean includeVirtualCalls, boolean includeSuperCalls, Substitution<? super Target.ForMember> substitution) {
                this.fieldMatcher = fieldMatcher;
                this.methodMatcher = methodMatcher;
                this.matchFieldRead = matchFieldRead;
                this.matchFieldWrite = matchFieldWrite;
                this.includeVirtualCalls = includeVirtualCalls;
                this.includeSuperCalls = includeSuperCalls;
                this.substitution = substitution;
            }
            public Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypeDescription typeDescription, FieldDescription fieldDescription, boolean writeAccess) {
                return (writeAccess ? matchFieldWrite : matchFieldRead) && fieldMatcher.matches(fieldDescription) ? new Binding.ForMember(typeDescription, fieldDescription, substitution) : Binding.Unresolved.INSTANCE;
            }
            public Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypeDescription typeDescription, MethodDescription methodDescription, InvocationType invocationType) {
                return invocationType.matches(includeVirtualCalls, includeSuperCalls) && methodMatcher.matches(methodDescription) ? new Binding.ForMember(typeDescription, methodDescription, substitution) : Binding.Unresolved.INSTANCE;
            }
            public Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, JavaConstant.MethodHandle methodHandle, JavaConstant.MethodType methodType, String name, List<JavaConstant> constants) {
                return Binding.Unresolved.INSTANCE;
            }
            protected static class Factory implements Replacement.Factory {
                private final ElementMatcher<? super FieldDescription> fieldMatcher;
                private final ElementMatcher<? super MethodDescription> methodMatcher;
                private final boolean matchFieldRead;
                private final boolean matchFieldWrite;
                private final boolean includeVirtualCalls;
                private final boolean includeSuperCalls;
                private final Substitution.Factory<? super Target.ForMember> substitutionFactory;
                protected Factory(ElementMatcher<? super FieldDescription> fieldMatcher, ElementMatcher<? super MethodDescription> methodMatcher, boolean matchFieldRead, boolean matchFieldWrite, boolean includeVirtualCalls, boolean includeSuperCalls, Substitution.Factory<? super Target.ForMember> substitutionFactory) {
                    this.fieldMatcher = fieldMatcher;
                    this.methodMatcher = methodMatcher;
                    this.matchFieldRead = matchFieldRead;
                    this.matchFieldWrite = matchFieldWrite;
                    this.includeVirtualCalls = includeVirtualCalls;
                    this.includeSuperCalls = includeSuperCalls;
                    this.substitutionFactory = substitutionFactory;
                }
                protected static Replacement.Factory of(ElementMatcher<? super ByteCodeElement.Member> matcher, Substitution.Factory<? super Target.ForMember> factory) {
                    return new Factory(matcher, matcher, true, true, true, true, factory);
                }
                protected static Replacement.Factory ofField(ElementMatcher<? super FieldDescription> matcher, boolean matchFieldRead, boolean matchFieldWrite, Substitution.Factory<? super Target.ForMember> factory) {
                    return new Factory(matcher, none(), matchFieldRead, matchFieldWrite, false, false, factory);
                }
                protected static Replacement.Factory ofMethod(ElementMatcher<? super MethodDescription> matcher, boolean includeVirtualCalls, boolean includeSuperCalls, Substitution.Factory<? super Target.ForMember> factory) {
                    return new Factory(none(), matcher, false, false, includeVirtualCalls, includeSuperCalls, factory);
                }
                public Replacement make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
                    return new ForElementMatchers(fieldMatcher, methodMatcher, matchFieldRead, matchFieldWrite, includeVirtualCalls, includeSuperCalls, substitutionFactory.make(instrumentedType, instrumentedMethod, typePool));
                }
            }
        }
        class ForDynamicInvocation implements Replacement {
            private final ElementMatcher<? super JavaConstant.MethodHandle> handleMatcher;
            private final ElementMatcher.Junction<? super String> nameMatcher;
            private final ElementMatcher.Junction<? super JavaConstant.MethodType> typeMatcher;
            private final ElementMatcher.Junction<? super List<JavaConstant>> argumentsMatcher;
            private final Substitution<? super Target.ForDynamicInvocation> substitution;
            protected ForDynamicInvocation(ElementMatcher<? super JavaConstant.MethodHandle> handleMatcher, ElementMatcher.Junction<? super String> nameMatcher, ElementMatcher.Junction<? super JavaConstant.MethodType> typeMatcher, ElementMatcher.Junction<? super List<JavaConstant>> argumentsMatcher, Substitution<? super Target.ForDynamicInvocation> substitution) {
                this.handleMatcher = handleMatcher;
                this.nameMatcher = nameMatcher;
                this.typeMatcher = typeMatcher;
                this.argumentsMatcher = argumentsMatcher;
                this.substitution = substitution;
            }
            public Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypeDescription typeDescription, FieldDescription fieldDescription, boolean writeAccess) {
                return Binding.Unresolved.INSTANCE;
            }
            public Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypeDescription typeDescription, MethodDescription methodDescription, InvocationType invocationType) {
                return Binding.Unresolved.INSTANCE;
            }
            public Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, JavaConstant.MethodHandle methodHandle, JavaConstant.MethodType methodType, String name, List<JavaConstant> constants) {
                if (handleMatcher.matches(methodHandle) && nameMatcher.matches(name) && typeMatcher.matches(methodType) && argumentsMatcher.matches(constants)) {
                    return new Binding.ForDynamicInvocation(methodType, name, constants, substitution);
                }
                return Binding.Unresolved.INSTANCE;
            }
            protected static class Factory implements Replacement.Factory {
                private final ElementMatcher<? super JavaConstant.MethodHandle> handleMatcher;
                private final ElementMatcher.Junction<? super String> nameMatcher;
                private final ElementMatcher.Junction<? super JavaConstant.MethodType> typeMatcher;
                private final ElementMatcher.Junction<? super List<JavaConstant>> argumentsMatcher;
                private final Substitution.Factory<? super Target.ForDynamicInvocation> substitutionFactory;
                protected Factory(ElementMatcher<? super JavaConstant.MethodHandle> handleMatcher, ElementMatcher.Junction<? super String> nameMatcher, ElementMatcher.Junction<? super JavaConstant.MethodType> typeMatcher, ElementMatcher.Junction<? super List<JavaConstant>> argumentsMatcher, Substitution.Factory<? super Target.ForDynamicInvocation> substitutionFactory) {
                    this.handleMatcher = handleMatcher;
                    this.nameMatcher = nameMatcher;
                    this.typeMatcher = typeMatcher;
                    this.argumentsMatcher = argumentsMatcher;
                    this.substitutionFactory = substitutionFactory;
                }
                public Replacement make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
                    return new ForDynamicInvocation(handleMatcher, nameMatcher, typeMatcher, argumentsMatcher, substitutionFactory.make(instrumentedType, instrumentedMethod, typePool));
                }
            }
        }
        class ForFirstBinding implements Replacement {
            private final List<? extends Replacement> replacements;
            protected ForFirstBinding(List<? extends Replacement> replacements) {
                this.replacements = replacements;
            }
            public Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypeDescription typeDescription, FieldDescription fieldDescription, boolean writeAccess) {
                for (Replacement replacement : replacements) {
                    Binding binding = replacement.bind(instrumentedType, instrumentedMethod, typeDescription, fieldDescription, writeAccess);
                    if (binding.isBound()) {
                        return binding;
                    }
                }
                return Binding.Unresolved.INSTANCE;
            }
            public Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypeDescription typeDescription, MethodDescription methodDescription, InvocationType invocationType) {
                for (Replacement replacement : replacements) {
                    Binding binding = replacement.bind(instrumentedType, instrumentedMethod, typeDescription, methodDescription, invocationType);
                    if (binding.isBound()) {
                        return binding;
                    }
                }
                return Binding.Unresolved.INSTANCE;
            }
            public Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, JavaConstant.MethodHandle methodHandle, JavaConstant.MethodType methodType, String name, List<JavaConstant> constants) {
                for (Replacement replacement : replacements) {
                    Binding binding = replacement.bind(instrumentedType, instrumentedMethod, methodHandle, methodType, name, constants);
                    if (binding.isBound()) {
                        return binding;
                    }
                }
                return Binding.Unresolved.INSTANCE;
            }
        }
    }
    protected static class SubstitutingMethodVisitor extends LocalVariableAwareMethodVisitor {
        private final TypeDescription instrumentedType;
        private final MethodDescription instrumentedMethod;
        private final MethodGraph.Compiler methodGraphCompiler;
        private final boolean strict;
        private final boolean failIfNoMatch;
        private final Replacement replacement;
        private final Implementation.Context implementationContext;
        private final TypePool typePool;
        private final boolean virtualPrivateCalls;
        private int stackSizeBuffer;
        private int localVariableExtension;
        private boolean matched;
        protected SubstitutingMethodVisitor(MethodVisitor methodVisitor, TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodGraph.Compiler methodGraphCompiler, boolean strict, boolean failIfNoMatch, Replacement replacement, Implementation.Context implementationContext, TypePool typePool, boolean virtualPrivateCalls) {
            super(methodVisitor, instrumentedMethod);
            this.instrumentedType = instrumentedType;
            this.instrumentedMethod = instrumentedMethod;
            this.methodGraphCompiler = methodGraphCompiler;
            this.strict = strict;
            this.failIfNoMatch = failIfNoMatch;
            this.replacement = replacement;
            this.implementationContext = implementationContext;
            this.typePool = typePool;
            this.virtualPrivateCalls = virtualPrivateCalls;
            stackSizeBuffer = 0;
            localVariableExtension = 0;
        }
        public void visitFieldInsn(int opcode, String owner, String internalName, String descriptor) {
            TypePool.Resolution resolution = typePool.describe(owner.replace('/', '.'));
            if (resolution.isResolved()) {
                FieldList<?> candidates;
                Iterator<TypeDefinition> iterator = resolution.resolve().iterator();
                do {
                    candidates = iterator.next().getDeclaredFields().filter(strict ? ElementMatchers.<FieldDescription>named(internalName).and(hasDescriptor(descriptor)) : ElementMatchers.<FieldDescription>failSafe(named(internalName).and(hasDescriptor(descriptor))));
                } while (iterator.hasNext() && candidates.isEmpty());
                if (!candidates.isEmpty()) {
                    Replacement.Binding binding = replacement.bind(instrumentedType, instrumentedMethod, resolution.resolve(), candidates.getOnly(), opcode == Opcodes.PUTFIELD || opcode == Opcodes.PUTSTATIC);
                    if (binding.isBound()) {
                        TypeList.Generic parameters;
                        TypeDescription.Generic result;
                        boolean read;
                        switch(opcode) {
                            case Opcodes.PUTFIELD:
                                parameters = new TypeList.Generic.Explicit(candidates.getOnly().getDeclaringType(), candidates.getOnly().getType());
                                result = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(void.class);
                                read = false;
                                break;
                            case Opcodes.PUTSTATIC:
                                parameters = new TypeList.Generic.Explicit(candidates.getOnly().getType());
                                result = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(void.class);
                                read = false;
                                break;
                            case Opcodes.GETFIELD:
                                parameters = new TypeList.Generic.Explicit(candidates.getOnly().getDeclaringType());
                                result = candidates.getOnly().getType();
                                read = true;
                                break;
                            case Opcodes.GETSTATIC:
                                parameters = new TypeList.Generic.Empty();
                                result = candidates.getOnly().getType();
                                read = true;
                                break;
                            default:
                                throw new IllegalStateException("Unexpected opcode: " + opcode);
                        }
                        stackSizeBuffer = Math.max(stackSizeBuffer, binding.make(parameters, result, read ? JavaConstant.MethodHandle.ofGetter(candidates.getOnly().asDefined()) : JavaConstant.MethodHandle.ofSetter(candidates.getOnly().asDefined()), read ? FieldAccess.forField(candidates.getOnly()).read() : FieldAccess.forField(candidates.getOnly()).write(), getFreeOffset()).apply(new LocalVariableTracingMethodVisitor(mv), implementationContext).getMaximalSize());
                        matched = true;
                        return;
                    }
                } else if (strict) {
                    throw new IllegalStateException("Could not resolve " + owner.replace('/', '.') + "." + internalName + descriptor + " using " + typePool);
                }
            } else if (strict) {
                throw new IllegalStateException("Could not resolve " + owner.replace('/', '.') + " using " + typePool);
            }
            super.visitFieldInsn(opcode, owner, internalName, descriptor);
        }
        public void visitMethodInsn(int opcode, String owner, String internalName, String descriptor, boolean isInterface) {
            TypePool.Resolution resolution = typePool.describe(owner.replace('/', '.'));
            if (resolution.isResolved()) {
                MethodList<?> candidates;
                if (opcode == Opcodes.INVOKESPECIAL && internalName.equals(MethodDescription.CONSTRUCTOR_INTERNAL_NAME)) {
                    candidates = resolution.resolve().getDeclaredMethods().filter(strict ? ElementMatchers.<MethodDescription>isConstructor().and(hasDescriptor(descriptor)) : ElementMatchers.<MethodDescription>failSafe(isConstructor().and(hasDescriptor(descriptor))));
                } else if (opcode == Opcodes.INVOKESTATIC) {
                    Iterator<TypeDefinition> iterator = resolution.resolve().iterator();
                    do {
                        candidates = iterator.next().getDeclaredMethods().filter(strict ? ElementMatchers.<MethodDescription>named(internalName).and(hasDescriptor(descriptor)) : ElementMatchers.<MethodDescription>failSafe(named(internalName).and(hasDescriptor(descriptor))));
                    } while (iterator.hasNext() && candidates.isEmpty());
                } else if (opcode == Opcodes.INVOKESPECIAL) {
                    candidates = resolution.resolve().getDeclaredMethods().filter(strict ? ElementMatchers.<MethodDescription>named(internalName).and(hasDescriptor(descriptor)) : ElementMatchers.<MethodDescription>failSafe(named(internalName).and(hasDescriptor(descriptor))));
                } else if (virtualPrivateCalls) {
                    candidates = resolution.resolve().getDeclaredMethods().filter(strict ? ElementMatchers.<MethodDescription>isPrivate().and(not(isStatic())).and(named(internalName).and(hasDescriptor(descriptor))) : ElementMatchers.<MethodDescription>failSafe(isPrivate().<MethodDescription>and(not(isStatic())).and(named(internalName).and(hasDescriptor(descriptor)))));
                    if (candidates.isEmpty()) {
                        candidates = methodGraphCompiler.compile((TypeDefinition) resolution.resolve(), instrumentedType).listNodes().asMethodList().filter(strict ? ElementMatchers.<MethodDescription>named(internalName).and(hasDescriptor(descriptor)) : ElementMatchers.<MethodDescription>failSafe(named(internalName).and(hasDescriptor(descriptor))));
                    }
                } else {
                    candidates = methodGraphCompiler.compile((TypeDefinition) resolution.resolve(), instrumentedType).listNodes().asMethodList().filter(strict ? ElementMatchers.<MethodDescription>named(internalName).and(hasDescriptor(descriptor)) : ElementMatchers.<MethodDescription>failSafe(named(internalName).and(hasDescriptor(descriptor))));
                }
                if (!candidates.isEmpty()) {
                    Replacement.Binding binding = replacement.bind(instrumentedType, instrumentedMethod, resolution.resolve(), candidates.getOnly(), Replacement.InvocationType.of(opcode, candidates.getOnly()));
                    if (binding.isBound()) {
                        StackManipulation.Size size = binding.make(candidates.getOnly().isStatic() || candidates.getOnly().isConstructor() ? candidates.getOnly().getParameters().asTypeList() : new TypeList.Generic.Explicit(CompoundList.of(resolution.resolve(), candidates.getOnly().getParameters().asTypeList())), candidates.getOnly().isConstructor() ? candidates.getOnly().getDeclaringType().asGenericType() : candidates.getOnly().getReturnType(), opcode == Opcodes.INVOKESPECIAL && candidates.getOnly().isMethod() && !candidates.getOnly().isPrivate() ? JavaConstant.MethodHandle.ofSpecial(candidates.getOnly().asDefined(), resolution.resolve()) : JavaConstant.MethodHandle.of(candidates.getOnly().asDefined()), opcode == Opcodes.INVOKESPECIAL && candidates.getOnly().isMethod() && !candidates.getOnly().isPrivate() ? MethodInvocation.invoke(candidates.getOnly()).special(resolution.resolve()) : MethodInvocation.invoke(candidates.getOnly()), getFreeOffset()).apply(new LocalVariableTracingMethodVisitor(mv), implementationContext);
                        if (candidates.getOnly().isConstructor()) {
                            stackSizeBuffer = Math.max(stackSizeBuffer, size.getMaximalSize() + 2);
                            stackSizeBuffer = Math.max(stackSizeBuffer, new StackManipulation.Compound(Duplication.SINGLE.flipOver(TypeDescription.ForLoadedType.of(Object.class)), Removal.SINGLE, Removal.SINGLE, Duplication.SINGLE.flipOver(TypeDescription.ForLoadedType.of(Object.class)), Removal.SINGLE, Removal.SINGLE).apply(mv, implementationContext).getMaximalSize() + StackSize.SINGLE.getSize());
                        } else {
                            stackSizeBuffer = Math.max(stackSizeBuffer, size.getMaximalSize());
                        }
                        matched = true;
                        return;
                    }
                } else if (strict) {
                    throw new IllegalStateException("Could not resolve " + owner.replace('/', '.') + "." + internalName + descriptor + " using " + typePool);
                }
            } else if (strict) {
                throw new IllegalStateException("Could not resolve " + owner.replace('/', '.') + " using " + typePool);
            }
            super.visitMethodInsn(opcode, owner, internalName, descriptor, isInterface);
        }
        public void visitInvokeDynamicInsn(String name, String descriptor, org.objectweb.asm.Handle handle, Object... argument) {
            JavaConstant.MethodHandle methodHandle;
            JavaConstant.MethodType methodType;
            List<JavaConstant> constants = new ArrayList<JavaConstant>(argument.length);
            try {
                methodHandle = JavaConstant.MethodHandle.ofAsm(typePool, handle);
                methodType = JavaConstant.MethodType.ofAsm(typePool, org.objectweb.asm.Type.getMethodType(descriptor));
                for (Object anArgument : argument) {
                    constants.add(JavaConstant.Simple.ofAsm(typePool, anArgument));
                }
            } catch (TypePool.Resolution.NoSuchTypeException exception) {
                if (strict) {
                    throw new IllegalStateException("Could not resolve " + exception.getName() + " using " + typePool);
                }
                methodHandle = null;
                methodType = null;
            }
            if (methodHandle != null && methodType != null && constants.size() == argument.length) {
                Replacement.Binding binding = replacement.bind(instrumentedType, instrumentedMethod, methodHandle, methodType, name, constants);
                if (binding.isBound()) {
                    StackManipulation.Size size = binding.make(methodType.getParameterTypes().asGenericTypes(), methodType.getReturnType().asGenericType(), methodHandle, new Invokedynamic(name, methodType, methodHandle, constants), getFreeOffset()).apply(new LocalVariableTracingMethodVisitor(mv), implementationContext);
                    stackSizeBuffer = Math.max(stackSizeBuffer, size.getMaximalSize());
                    matched = true;
                    return;
                }
            }
            super.visitInvokeDynamicInsn(name, descriptor, handle, argument);
        }
        public void visitMaxs(int stackSize, int localVariableLength) {
            if (failIfNoMatch && !matched) {
                throw new IllegalStateException("No substitution found within " + instrumentedMethod + " of " + instrumentedType);
            }
            super.visitMaxs(stackSize + stackSizeBuffer, Math.max(localVariableExtension, localVariableLength));
        }
        private class LocalVariableTracingMethodVisitor extends MethodVisitor {
            private LocalVariableTracingMethodVisitor(MethodVisitor methodVisitor) {
                super(OpenedClassReader.ASM_API, methodVisitor);
            }
            public void visitVarInsn(int opcode, int offset) {
                switch(opcode) {
                    case Opcodes.ISTORE:
                    case Opcodes.FSTORE:
                    case Opcodes.ASTORE:
                        localVariableExtension = Math.max(localVariableExtension, offset + 1);
                        break;
                    case Opcodes.LSTORE:
                    case Opcodes.DSTORE:
                        localVariableExtension = Math.max(localVariableExtension, offset + 2);
                        break;
                }
                super.visitVarInsn(opcode, offset);
            }
        }
    }
    public @interface This {
        Assigner.Typing typing() default Assigner.Typing.STATIC;
        Source source() default Source.SUBSTITUTED_ELEMENT;
        boolean optional() default false;
    }
    public @interface Argument {
        int value();
        Assigner.Typing typing() default Assigner.Typing.STATIC;
        Source source() default Source.SUBSTITUTED_ELEMENT;
        boolean optional() default false;
    }
    public @interface AllArguments {
        Assigner.Typing typing() default Assigner.Typing.STATIC;
        Source source() default Source.SUBSTITUTED_ELEMENT;
        boolean includeSelf() default false;
        boolean nullIfEmpty() default false;
    }
    public @interface SelfCallHandle {
        Source source() default Source.SUBSTITUTED_ELEMENT;
        boolean bound() default true;
    }
    public @interface Handle {
        JavaConstant.MethodHandle.HandleType type();
        Class<?> owner() default void.class;
        String name();
        Class<?> returnType();
        Class<?>[] parameterTypes();
    }
    public @interface DynamicConstant {
        String name() default JavaConstant.Dynamic.DEFAULT_NAME;
        JavaConstant.MethodHandle.HandleType bootstrapType();
        Class<?> bootstrapOwner() default void.class;
        String bootstrapName();
        Class<?> bootstrapReturnType();
        Class<?>[] bootstrapParameterTypes();
        boolean invokedynamic() default false;
    }
    public @interface FieldValue {
        String value() default Substitution.Chain.Step.ForDelegation.OffsetMapping.ForField.Unresolved.BEAN_PROPERTY;
        Class<?> declaringType() default void.class;
        Assigner.Typing typing() default Assigner.Typing.STATIC;
    }
    public @interface FieldGetterHandle {
        String value() default Substitution.Chain.Step.ForDelegation.OffsetMapping.ForFieldHandle.Unresolved.BEAN_PROPERTY;
        Class<?> declaringType() default void.class;
    }
    public @interface FieldSetterHandle {
        String value() default Substitution.Chain.Step.ForDelegation.OffsetMapping.ForFieldHandle.Unresolved.BEAN_PROPERTY;
        Class<?> declaringType() default void.class;
    }
    public @interface Origin {
        Source source() default Source.SUBSTITUTED_ELEMENT;
    }
    public @interface Unused {
    }
    public @interface StubValue {
        Source source() default Source.SUBSTITUTED_ELEMENT;
    }
    public @interface Current {
        Assigner.Typing typing() default Assigner.Typing.STATIC;
    }
    public enum Source {
        SUBSTITUTED_ELEMENT {
            @Override
            @MaybeNull
            protected Source.Value self(TypeList.Generic parameters, Map<Integer, Integer> offsets, Target target, MethodDescription instrumentedMethod) {
                return target.isStaticDispatch() ? null : new Source.Value(parameters.get(THIS_REFERENCE), offsets.get(THIS_REFERENCE));
            }
            @Override
            @MaybeNull
            protected Source.Value argument(int index, TypeList.Generic parameters, Map<Integer, Integer> offsets, Target target, MethodDescription instrumentedMethod) {
                return index < parameters.size() - (target.isStaticDispatch() ? 0 : 1) ? new Source.Value(parameters.get(index + (target.isStaticDispatch() ? 0 : 1)), offsets.get(index + (target.isStaticDispatch() ? 0 : 1))) : null;
            }
            @Override
            protected List<Source.Value> arguments(boolean includesSelf, TypeList.Generic parameters, Map<Integer, Integer> offsets, Target target, MethodDescription instrumentedMethod) {
                List<Source.Value> values = new ArrayList<Source.Value>(parameters.size() - (!includesSelf && target.isStaticDispatch() ? 1 : 0));
                for (int index = target.isStaticDispatch() || includesSelf ? 0 : 1; index < parameters.size(); index++) {
                    values.add(new Source.Value(parameters.get(index), offsets.get(index)));
                }
                return values;
            }
            @Override
            protected JavaConstant.MethodHandle handle(JavaConstant.MethodHandle methodHandle, MethodDescription instrumentedMethod) {
                return methodHandle;
            }
            @Override
            protected boolean isRepresentable(Substitution.Chain.Step.ForDelegation.OffsetMapping.ForOrigin.Sort sort, Target target, MethodDescription instrumentedMethod) {
                return target instanceof Target.ForMember && sort.isRepresentable(((Target.ForMember) target).getMember());
            }
            @Override
            protected StackManipulation resolve(Substitution.Chain.Step.ForDelegation.OffsetMapping.ForOrigin.Sort sort, Target target, TypeList.Generic parameters, TypeDescription.Generic result, MethodDescription instrumentedMethod) {
                ByteCodeElement.Member member = ((Target.ForMember) target).getMember();
                return sort.resolve(member, parameters.asErasures(), result.asErasure());
            }
        }
        , ENCLOSING_METHOD {
            @Override
            @MaybeNull
            protected Source.Value self(TypeList.Generic parameters, Map<Integer, Integer> offsets, Target target, MethodDescription instrumentedMethod) {
                return instrumentedMethod.isStatic() ? null : new Source.Value(instrumentedMethod.getDeclaringType().asGenericType(), THIS_REFERENCE);
            }
            @Override
            @MaybeNull
            protected Source.Value argument(int index, TypeList.Generic parameters, Map<Integer, Integer> offsets, Target target, MethodDescription instrumentedMethod) {
                if (index < instrumentedMethod.getParameters().size()) {
                    ParameterDescription parameterDescription = instrumentedMethod.getParameters().get(index);
                    return new Source.Value(parameterDescription.getType(), parameterDescription.getOffset());
                } else {
                    return null;
                }
            }
            @Override
            protected List<Source.Value> arguments(boolean includesSelf, TypeList.Generic parameters, Map<Integer, Integer> offsets, Target target, MethodDescription instrumentedMethod) {
                List<Source.Value> values;
                if (includesSelf && !instrumentedMethod.isStatic()) {
                    values = new ArrayList<Source.Value>(instrumentedMethod.getParameters().size() + 1);
                    values.add(new Source.Value(instrumentedMethod.getDeclaringType().asGenericType(), THIS_REFERENCE));
                } else {
                    values = new ArrayList<Source.Value>(instrumentedMethod.getParameters().size());
                }
                for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {
                    values.add(new Source.Value(parameterDescription.getType(), parameterDescription.getOffset()));
                }
                return values;
            }
            @Override
            protected JavaConstant.MethodHandle handle(JavaConstant.MethodHandle methodHandle, MethodDescription instrumentedMethod) {
                return JavaConstant.MethodHandle.of(instrumentedMethod.asDefined());
            }
            @Override
            protected boolean isRepresentable(Substitution.Chain.Step.ForDelegation.OffsetMapping.ForOrigin.Sort sort, Target target, MethodDescription instrumentedMethod) {
                return sort.isRepresentable(instrumentedMethod);
            }
            @Override
            protected StackManipulation resolve(Substitution.Chain.Step.ForDelegation.OffsetMapping.ForOrigin.Sort sort, Target target, TypeList.Generic parameters, TypeDescription.Generic result, MethodDescription instrumentedMethod) {
                return sort.resolve(instrumentedMethod, instrumentedMethod.isStatic() || instrumentedMethod.isConstructor() ? instrumentedMethod.getParameters().asTypeList().asErasures() : CompoundList.of(instrumentedMethod.getDeclaringType().asErasure(), instrumentedMethod.getParameters().asTypeList().asErasures()), instrumentedMethod.isConstructor() ? instrumentedMethod.getDeclaringType().asErasure() : instrumentedMethod.getReturnType().asErasure());
            }
        }
        ;
        protected abstract Source.Value self(TypeList.Generic parameters, Map<Integer, Integer> offsets, Target target, MethodDescription instrumentedMethod);
        protected abstract Source.Value argument(int index, TypeList.Generic parameters, Map<Integer, Integer> offsets, Target target, MethodDescription instrumentedMethod);
        protected abstract List<Source.Value> arguments(boolean includesSelf, TypeList.Generic parameters, Map<Integer, Integer> offsets, Target target, MethodDescription instrumentedMethod);
        protected abstract JavaConstant.MethodHandle handle(JavaConstant.MethodHandle methodHandle, MethodDescription instrumentedMethod);
        protected abstract boolean isRepresentable(Substitution.Chain.Step.ForDelegation.OffsetMapping.ForOrigin.Sort sort, Target target, MethodDescription instrumentedMethod);
        protected abstract StackManipulation resolve(Substitution.Chain.Step.ForDelegation.OffsetMapping.ForOrigin.Sort sort, Target target, TypeList.Generic parameters, TypeDescription.Generic result, MethodDescription instrumentedMethod);
        protected static class Value {
            private final TypeDescription.Generic typeDescription;
            private final int offset;
            protected Value(TypeDescription.Generic typeDescription, int offset) {
                this.typeDescription = typeDescription;
                this.offset = offset;
            }
            protected TypeDescription.Generic getTypeDescription() {
                return typeDescription;
            }
            protected int getOffset() {
                return offset;
            }
        }
    }
    protected static class LambdaMetaFactoryMatcher implements ElementMatcher<JavaConstant.MethodHandle> {
        public boolean matches(@MaybeNull JavaConstant.MethodHandle target) {
            return target != null && target.getOwnerType().getName().equals("java.lang.invoke.LambdaMetafactory");
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```