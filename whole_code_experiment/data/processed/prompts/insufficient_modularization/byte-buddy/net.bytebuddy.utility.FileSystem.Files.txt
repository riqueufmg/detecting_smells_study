##CONTEXT_SIZE=862
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.utility;
public abstract class FileSystem {
    public static FileSystem getInstance() {
        try {
            Class.forName("java.nio.file.Files", false, ClassLoadingStrategy.BOOTSTRAP_LOADER);
            return new ForNio2CapableVm();
        } catch (ClassNotFoundException ignored) {
            return new ForLegacyVm();
        }
    }
    private static <T> T doPrivileged(PrivilegedAction<T> action) {
        return action.run();
    }
    public abstract void copy(File source, File target) throws IOException;
    public void link(File source, File target) throws IOException {
        copy(source, target);
    }
    public abstract void move(File source, File target) throws IOException;
    protected static class ForLegacyVm extends FileSystem {
        public void copy(File source, File target) throws IOException {
            InputStream inputStream = new FileInputStream(source);
            try {
                OutputStream outputStream = new FileOutputStream(target);
                try {
                    byte[] buffer = new byte[1024];
                    int length;
                    while ((length = inputStream.read(buffer)) != -1) {
                        outputStream.write(buffer, 0, length);
                    }
                } finally {
                    outputStream.close();
                }
            } finally {
                inputStream.close();
            }
        }
        public void move(File source, File target) throws IOException {
            InputStream inputStream = new FileInputStream(source);
            try {
                OutputStream outputStream = new FileOutputStream(target);
                try {
                    byte[] buffer = new byte[1024];
                    int length;
                    while ((length = inputStream.read(buffer)) != -1) {
                        outputStream.write(buffer, 0, length);
                    }
                } finally {
                    outputStream.close();
                }
            } finally {
                inputStream.close();
            }
            if (!source.delete()) {
                source.deleteOnExit();
            }
        }
    }
    protected static class ForNio2CapableVm extends FileSystem {
        private static final Dispatcher DISPATCHER = doPrivileged(JavaDispatcher.of(Dispatcher.class));
        private static final Files FILES = doPrivileged(JavaDispatcher.of(Files.class));
        private static final StandardCopyOption STANDARD_COPY_OPTION = doPrivileged(JavaDispatcher.of(StandardCopyOption.class));
        public void copy(File source, File target) throws IOException {
            Object[] option = STANDARD_COPY_OPTION.toArray(1);
            option[0] = STANDARD_COPY_OPTION.valueOf("REPLACE_EXISTING");
            FILES.copy(DISPATCHER.toPath(source), DISPATCHER.toPath(target), option);
        }
        public void link(File source, File target) throws IOException {
            FILES.createLink(FILES.deleteIfExists(DISPATCHER.toPath(target)), DISPATCHER.toPath(source));
        }
        public void move(File source, File target) throws IOException {
            Object[] option = STANDARD_COPY_OPTION.toArray(1);
            option[0] = STANDARD_COPY_OPTION.valueOf("REPLACE_EXISTING");
            FILES.move(DISPATCHER.toPath(source), DISPATCHER.toPath(target), option);
        }
        protected interface Dispatcher {
            Object toPath(File value) throws IOException;
        }
        protected interface Files {
            Object copy(@JavaDispatcher.Proxied("java.nio.file.Path") Object source, @JavaDispatcher.Proxied("java.nio.file.Path") Object target, @JavaDispatcher.Proxied("java.nio.file.CopyOption") Object[] option) throws IOException;
            Object createLink(@JavaDispatcher.Proxied("java.nio.file.Path") Object source, @JavaDispatcher.Proxied("java.nio.file.Path") Object target) throws IOException;
            Object move(@JavaDispatcher.Proxied("java.nio.file.Path") Object source, @JavaDispatcher.Proxied("java.nio.file.Path") Object target, @JavaDispatcher.Proxied("java.nio.file.CopyOption") Object[] option) throws IOException;
            Object deleteIfExists(@JavaDispatcher.Proxied("java.nio.file.Path") Object file) throws IOException;
        }
        protected interface StandardCopyOption {
            Object[] toArray(int size);
            Object valueOf(String name);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```