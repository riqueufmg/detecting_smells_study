##CONTEXT_SIZE=2173
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.utility;
public interface AsmClassWriter {
    ClassVisitor getVisitor();
    byte[] getBinaryRepresentation();
    interface Factory {
        AsmClassWriter make(int flags);
        AsmClassWriter make(int flags, AsmClassReader classReader);
        AsmClassWriter make(int flags, TypePool typePool);
        AsmClassWriter make(int flags, AsmClassReader classReader, TypePool typePool);
        enum Default implements Factory {
            IMPLICIT {
                public AsmClassWriter make(int flags, AsmClassReader classReader, TypePool typePool) {
                    return (FACTORY == IMPLICIT ? ASM_FIRST : FACTORY).make(flags, classReader, typePool);
                }
            }
            , ASM_FIRST {
                public AsmClassWriter make(int flags, AsmClassReader classReader, TypePool typePool) {
                    return AsmClassWriter.class.getClassLoader() != null && ClassFileVersion.ofThisVm().isGreaterThan(ClassFileVersion.latest()) ? CLASS_FILE_API_ONLY.make(flags, classReader, typePool) : ASM_ONLY.make(flags, classReader, typePool);
                }
            }
            , CLASS_FILE_API_FIRST {
                public AsmClassWriter make(int flags, AsmClassReader classReader, TypePool typePool) {
                    return ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V24) ? CLASS_FILE_API_ONLY.make(flags, classReader, typePool) : ASM_ONLY.make(flags, classReader, typePool);
                }
            }
            , ASM_ONLY {
                public AsmClassWriter make(int flags, AsmClassReader classReader, TypePool typePool) {
                    ClassReader unwrapped = classReader.unwrap(ClassReader.class);
                    return new ForAsm(unwrapped == null ? new FrameComputingClassWriter(flags, typePool) : new FrameComputingClassWriter(unwrapped, flags, typePool));
                }
            }
            , CLASS_FILE_API_ONLY {
                @SuppressFBWarnings(value = "NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE", justification = "False positive in FindBugs.")
                public AsmClassWriter make(int flags, AsmClassReader classReader, TypePool typePool) {
                    Object jdkClassReader = JDK_CLASS_READER == null ? null : classReader.unwrap(JDK_CLASS_READER);
                    if (jdkClassReader == null) {
                        return new ForClassFileApi(ForClassFileApi.DISPATCHER.make(flags, SuperClassResolvingJdkClassWriter.GET_SUPER_CLASS, new SuperClassResolvingJdkClassWriter(typePool)));
                    } else {
                        return new ForClassFileApi(ForClassFileApi.DISPATCHER.make(jdkClassReader, flags, SuperClassResolvingJdkClassWriter.GET_SUPER_CLASS, new SuperClassResolvingJdkClassWriter(typePool)));
                    }
                }
            }
            ;
            private static final Class<?> JDK_CLASS_READER;
            private static final Factory FACTORY;
            static {
                String processor;
                try {
                    processor = doPrivileged(new GetSystemPropertyAction(OpenedClassReader.PROCESSOR_PROPERTY));
                } catch (Throwable ignored) {
                    processor = null;
                }
                FACTORY = processor == null ? Default.ASM_FIRST : Default.valueOf(processor);
                Class<?> type;
                try {
                    type = ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V24) ? Class.forName("codes.rafael.asmjdkbridge.JdkClassReader") : null;
                } catch (ClassNotFoundException ignored) {
                    type = null;
                }
                JDK_CLASS_READER = type;
            }
            private static <T> T doPrivileged(PrivilegedAction<T> action) {
                return action.run();
            }
            public AsmClassWriter make(int flags) {
                return make(flags, TypePool.Empty.INSTANCE);
            }
            public AsmClassWriter make(int flags, AsmClassReader classReader) {
                return make(flags, classReader, TypePool.Empty.INSTANCE);
            }
            public AsmClassWriter make(int flags, TypePool typePool) {
                return make(flags, EmptyAsmClassReader.INSTANCE, typePool);
            }
            protected enum EmptyAsmClassReader implements AsmClassReader {
                INSTANCE;
                public AsmClassWriter toWriter(int flags, TypePool typePool) {
                    return null;
                }
                public <T> T unwrap(Class<T> type) {
                    return null;
                }
                public int getModifiers() {
                    throw new UnsupportedOperationException();
                }
                public String getInternalName() {
                    throw new UnsupportedOperationException();
                }
                public String getSuperClassInternalName() {
                    throw new UnsupportedOperationException();
                }
                public List<String> getInterfaceInternalNames() {
                    throw new UnsupportedOperationException();
                }
                public void accept(ClassVisitor classVisitor, int flags) {
                    throw new UnsupportedOperationException();
                }
            }
            public static class NonRetainingAsmClassReader implements AsmClassReader {
                private final AsmClassReader delegate;
                public NonRetainingAsmClassReader(AsmClassReader delegate) {
                    this.delegate = delegate;
                }
                public <T> T unwrap(Class<T> type) {
                    return delegate.unwrap(type);
                }
                public AsmClassWriter toWriter(int flags, TypePool typePool) {
                    return null;
                }
                public int getModifiers() {
                    return delegate.getModifiers();
                }
                public String getInternalName() {
                    return delegate.getInternalName();
                }
                public String getSuperClassInternalName() {
                    return delegate.getSuperClassInternalName();
                }
                public List<String> getInterfaceInternalNames() {
                    return delegate.getInterfaceInternalNames();
                }
                public void accept(ClassVisitor classVisitor, int flags) {
                    delegate.accept(classVisitor, flags);
                }
            }
        }
        class Suppressing implements Factory {
            private final Factory delegate;
            public Suppressing(Factory delegate) {
                this.delegate = delegate;
            }
            public AsmClassWriter make(int flags) {
                return delegate.make(flags);
            }
            public AsmClassWriter make(int flags, AsmClassReader classReader) {
                return delegate.make(flags);
            }
            public AsmClassWriter make(int flags, TypePool typePool) {
                return delegate.make(flags, typePool);
            }
            public AsmClassWriter make(int flags, AsmClassReader classReader, TypePool typePool) {
                return delegate.make(flags, typePool);
            }
        }
    }
    class ForAsm implements AsmClassWriter {
        private final ClassWriter classWriter;
        public ForAsm(ClassWriter classWriter) {
            this.classWriter = classWriter;
        }
        public ClassVisitor getVisitor() {
            return classWriter;
        }
        public byte[] getBinaryRepresentation() {
            return classWriter.toByteArray();
        }
    }
    class ForClassFileApi implements AsmClassWriter {
        private static final JdkClassWriter DISPATCHER = doPrivileged(JavaDispatcher.of(JdkClassWriter.class, ForClassFileApi.class.getClassLoader()));
        private final ClassVisitor classWriter;
        public ForClassFileApi(ClassVisitor classWriter) {
            if (!DISPATCHER.isInstance(classWriter)) {
                throw new IllegalArgumentException("Not a JDK class writer: " + classWriter);
            }
            this.classWriter = classWriter;
        }
        private static <T> T doPrivileged(PrivilegedAction<T> action) {
            return action.run();
        }
        public ClassVisitor getVisitor() {
            return classWriter;
        }
        public byte[] getBinaryRepresentation() {
            return DISPATCHER.toByteArray(classWriter);
        }
        protected interface JdkClassWriter {
            boolean isInstance(ClassVisitor value);
            ClassVisitor make(int flags, Method getSuperClass, Object target);
            ClassVisitor make(@JavaDispatcher.Proxied("codes.rafael.asmjdkbridge.JdkClassReader") Object classReader, int flags, Method getSuperClass, Object target);
            byte[] toByteArray(ClassVisitor value);
        }
    }
    class FrameComputingClassWriter extends ClassWriter {
        private final TypePool typePool;
        public FrameComputingClassWriter(int flags, TypePool typePool) {
            super(flags);
            this.typePool = typePool;
        }
        public FrameComputingClassWriter(ClassReader classReader, int flags, TypePool typePool) {
            super(classReader, flags);
            this.typePool = typePool;
        }
        protected String getCommonSuperClass(String leftTypeName, String rightTypeName) {
            TypeDescription leftType = typePool.describe(leftTypeName.replace('/', '.')).resolve();
            TypeDescription rightType = typePool.describe(rightTypeName.replace('/', '.')).resolve();
            if (leftType.isAssignableFrom(rightType)) {
                return leftType.getInternalName();
            } else if (leftType.isAssignableTo(rightType)) {
                return rightType.getInternalName();
            } else if (leftType.isInterface() || rightType.isInterface()) {
                return TypeDescription.ForLoadedType.of(Object.class).getInternalName();
            } else {
                do {
                    TypeDescription.Generic superClass = leftType.getSuperClass();
                    if (superClass == null) {
                        return TypeDescription.ForLoadedType.of(Object.class).getInternalName();
                    }
                    leftType = superClass.asErasure();
                } while (!leftType.isAssignableFrom(rightType));
                return leftType.getInternalName();
            }
        }
    }
    class SuperClassResolvingJdkClassWriter {
        protected static final Method GET_SUPER_CLASS;
        static {
            Method getSuperClass;
            try {
                getSuperClass = SuperClassResolvingJdkClassWriter.class.getMethod("getSuperClass", String.class);
            } catch (NoSuchMethodException e) {
                throw new IllegalStateException("Failed to resolve own method", e);
            }
            GET_SUPER_CLASS = getSuperClass;
        }
        private final TypePool typePool;
        public SuperClassResolvingJdkClassWriter(TypePool typePool) {
            this.typePool = typePool;
        }
        public String getSuperClass(String internalName) {
            TypeDescription typeDescription = typePool.describe(internalName.replace('/', '.')).resolve();
            return typeDescription.isInterface() ? null : typeDescription.getSuperClass().asErasure().getInternalName();
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```