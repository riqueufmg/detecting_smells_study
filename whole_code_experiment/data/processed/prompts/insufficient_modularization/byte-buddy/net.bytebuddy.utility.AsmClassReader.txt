##CONTEXT_SIZE=1133
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.utility;
public interface AsmClassReader {
    Attribute[] NO_ATTRIBUTES = new Attribute[0];
    <T> T unwrap(Class<T> type);
    int getModifiers();
    String getInternalName();
    String getSuperClassInternalName();
    List<String> getInterfaceInternalNames();
    void accept(ClassVisitor classVisitor, int flags);
    interface Factory {
        AsmClassReader make(byte[] binaryRepresentation);
        AsmClassReader make(byte[] binaryRepresentation, boolean experimental);
        enum Default implements Factory {
            IMPLICIT {
                public AsmClassReader make(byte[] binaryRepresentation, boolean experimental) {
                    return (FACTORY == IMPLICIT ? ASM_FIRST : FACTORY).make(binaryRepresentation, experimental);
                }
            }
            , ASM_FIRST {
                public AsmClassReader make(byte[] binaryRepresentation, boolean experimental) {
                    return AsmClassReader.class.getClassLoader() != null && ClassFileVersion.ofThisVm().isGreaterThan(ClassFileVersion.latest()) ? CLASS_FILE_API_ONLY.make(binaryRepresentation, experimental) : ASM_ONLY.make(binaryRepresentation, experimental);
                }
            }
            , CLASS_FILE_API_FIRST {
                public AsmClassReader make(byte[] binaryRepresentation, boolean experimental) {
                    return ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V24) ? CLASS_FILE_API_ONLY.make(binaryRepresentation, experimental) : ASM_ONLY.make(binaryRepresentation, experimental);
                }
            }
            , ASM_ONLY {
                public AsmClassReader make(byte[] binaryRepresentation, boolean experimental) {
                    return new ForAsm(OpenedClassReader.of(binaryRepresentation, experimental));
                }
            }
            , CLASS_FILE_API_ONLY {
                public AsmClassReader make(byte[] binaryRepresentation, boolean experimental) {
                    return new AsmClassReader.ForClassFileApi(ForClassFileApi.DISPATCHER.make(binaryRepresentation, NO_ATTRIBUTES));
                }
            }
            ;
            private static final Factory FACTORY;
            static {
                String processor;
                try {
                    processor = doPrivileged(new GetSystemPropertyAction(OpenedClassReader.PROCESSOR_PROPERTY));
                } catch (Throwable ignored) {
                    processor = null;
                }
                FACTORY = processor == null ? Default.ASM_FIRST : Default.valueOf(processor);
            }
            private static <T> T doPrivileged(PrivilegedAction<T> action) {
                return action.run();
            }
            public AsmClassReader make(byte[] binaryRepresentation) {
                return make(binaryRepresentation, OpenedClassReader.EXPERIMENTAL);
            }
        }
    }
    class ForAsm implements AsmClassReader {
        private final ClassReader classReader;
        public ForAsm(ClassReader classReader) {
            this.classReader = classReader;
        }
        public <T> T unwrap(Class<T> type) {
            return type.isInstance(classReader) ? type.cast(classReader) : null;
        }
        public int getModifiers() {
            return classReader.getAccess();
        }
        public String getInternalName() {
            return classReader.getClassName();
        }
        public String getSuperClassInternalName() {
            return classReader.getSuperName();
        }
        public List<String> getInterfaceInternalNames() {
            String[] value = classReader.getInterfaces();
            return value == null ? Collections.<String>emptyList() : Arrays.asList(value);
        }
        public void accept(ClassVisitor classVisitor, int flags) {
            classReader.accept(classVisitor, NO_ATTRIBUTES, flags);
        }
    }
    class ForClassFileApi implements AsmClassReader {
        protected static final JdkClassReader DISPATCHER = doPrivileged(JavaDispatcher.of(JdkClassReader.class, ForClassFileApi.class.getClassLoader()));
        private final Object classReader;
        public ForClassFileApi(Object classReader) {
            if (!DISPATCHER.isInstance(classReader)) {
                throw new IllegalArgumentException();
            }
            this.classReader = classReader;
        }
        private static <T> T doPrivileged(PrivilegedAction<T> action) {
            return action.run();
        }
        public <T> T unwrap(Class<T> type) {
            return type.isInstance(classReader) ? type.cast(classReader) : null;
        }
        public int getModifiers() {
            return DISPATCHER.getAccess(classReader);
        }
        public String getInternalName() {
            return DISPATCHER.getClassName(classReader);
        }
        public String getSuperClassInternalName() {
            return DISPATCHER.getSuperName(classReader);
        }
        public List<String> getInterfaceInternalNames() {
            String[] value = DISPATCHER.getInterfaces(classReader);
            return value == null ? Collections.<String>emptyList() : Arrays.asList(value);
        }
        public String getSuperClassName() {
            return DISPATCHER.getSuperName(classReader);
        }
        public String[] getInterfaceTypeName() {
            return DISPATCHER.getInterfaces(classReader);
        }
        public void accept(ClassVisitor classVisitor, int flags) {
            DISPATCHER.accept(classReader, classVisitor, flags);
        }
        protected interface JdkClassReader {
            boolean isInstance(Object value);
            Object make(byte[] binaryRepresentation, Attribute[] attribute);
            int getAccess(Object classReader);
            String getClassName(Object classReader);
            String getSuperName(Object classReader);
            String[] getInterfaces(Object classReader);
            void accept(Object classReader, ClassVisitor classVisitor, int flags);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```