##CONTEXT_SIZE=1787
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.build.gradle.android;
public abstract class ByteBuddyLocalClassesEnhancerTask extends DefaultTask {
    public abstract ListProperty<Transformation> getTransformations();
    public abstract ConfigurableFileCollection getAndroidBootClasspath();
    public abstract ConfigurableFileCollection getByteBuddyClasspath();
    public abstract Property<JavaVersion> getJavaTargetCompatibilityVersion();
    public abstract Property<Discovery> getDiscovery();
    public abstract Property<EntryPoint> getEntryPoint();
    public abstract ListProperty<RegularFile> getInputJars();
    public abstract ListProperty<Directory> getLocalClassesDirs();
    public abstract RegularFileProperty getOutputFile();
    public abstract Property<Boolean> getWarnOnEmptyTypeSet();
    public abstract Property<Boolean> getFailFast();
    public abstract Property<Boolean> getFailOnLiveInitializer();
    public abstract Property<Integer> getThreads();
    public abstract Property<String> getSuffix();
    public abstract Property<Boolean> getExtendedParsing();
    public abstract ConfigurableFileCollection getDiscoverySet();
    private static URL[] toUrls(Collection<File> files) {
        URL[] url = new URL[files.size()];
        int index = 0;
        for (File file : files) {
            try {
                url[index++] = file.toURI().toURL();
            } catch (MalformedURLException exception) {
                throw new IllegalStateException("Failed to convert file " + file.getAbsolutePath(), exception);
            }
        }
        return url;
    }
    public void execute() throws IOException {
        List<Object> transformations = new ArrayList<Object>(getTransformations().get().size());
        for (Transformation transformation : getTransformations().get()) {
            transformations.add(transformation.resolve());
        }
        Set<Plugin.Engine.Source> sources = new LinkedHashSet<Plugin.Engine.Source>();
        Set<File> localClasspath = new HashSet<>();
        for (Directory directory : getLocalClassesDirs().get()) {
            File file = directory.getAsFile();
            localClasspath.add(file);
            sources.add(new Plugin.Engine.Source.ForFolder(file));
        }
        for (RegularFile jarFile : getInputJars().get()) {
            sources.add(new Plugin.Engine.Source.ForJarFile(jarFile.getAsFile()));
        }
        ClassFileVersion classFileVersion = ClassFileVersion.ofJavaVersionString(getJavaTargetCompatibilityVersion().get().toString());
        AndroidDescriptor androidDescriptor = DefaultAndroidDescriptor.ofClassPath(localClasspath);
        ClassLoader classLoader = new URLClassLoader(toUrls(getByteBuddyClasspath().getFiles()), new URLClassLoader(toUrls(getAndroidBootClasspath().getFiles()), ByteBuddy.class.getClassLoader()));
        try {
            Class<?> discovery = Class.forName("net.bytebuddy.build.gradle.Discovery");
            Class.forName("net.bytebuddy.build.gradle.AbstractByteBuddyTask").getMethod("apply", Logger.class, ClassLoader.class, List.class, discovery, ClassFileLocator.class, Iterable.class, Iterable.class, EntryPoint.class, ClassFileVersion.class, ClassFileVersion.class, Plugin.Factory.UsingReflection.ArgumentResolver.class, String.class, int.class, boolean.class, boolean.class, boolean.class, boolean.class, Plugin.Engine.Source.class, Plugin.Engine.Target.class).invoke(null, getLogger(), classLoader, transformations, discovery.getMethod("valueOf", String.class).invoke(null, getDiscovery().get().name()), ClassFileLocator.ForClassLoader.of(ByteBuddy.class.getClassLoader()), getAndroidBootClasspath().plus(getByteBuddyClasspath()).getFiles(), getDiscoverySet().getFiles(), getEntryPoint().get(), classFileVersion, classFileVersion, Plugin.Factory.UsingReflection.ArgumentResolver.ForType.of(AndroidDescriptor.class, androidDescriptor), getSuffix().get(), getThreads().get(), getExtendedParsing().get(), getFailFast().get(), getFailOnLiveInitializer().get(), getWarnOnEmptyTypeSet().get(), new Plugin.Engine.Source.Compound(sources), new TargetForAndroidAppJarFile(getOutputFile().get().getAsFile()));
        } catch (InvocationTargetException exception) {
            Throwable cause = exception.getCause();
            if (cause instanceof IOException) {
                throw (IOException) cause;
            } else if (cause instanceof RuntimeException) {
                throw (RuntimeException) cause;
            } else {
                throw new GradleException("Unexpected transformation error", cause);
            }
        } catch (Throwable throwable) {
            throw new GradleException("Unexpected transformation error", throwable);
        } finally {
            if (classLoader instanceof Closeable) {
                ((Closeable) classLoader).close();
            }
        }
    }
    public static class ConfigurationAction implements Action<ByteBuddyLocalClassesEnhancerTask> {
        private final FileCollection byteBuddyConfiguration;
        private final BaseExtension androidExtension;
        private final ByteBuddyAndroidTaskExtension byteBuddyExtension;
        public ConfigurationAction(FileCollection byteBuddyConfiguration, BaseExtension androidExtension, ByteBuddyAndroidTaskExtension byteBuddyExtension) {
            this.byteBuddyConfiguration = byteBuddyConfiguration;
            this.androidExtension = androidExtension;
            this.byteBuddyExtension = byteBuddyExtension;
        }
        public void execute(ByteBuddyLocalClassesEnhancerTask task) {
            task.getByteBuddyClasspath().from(byteBuddyConfiguration);
            task.getAndroidBootClasspath().from(androidExtension.getBootClasspath());
            task.getJavaTargetCompatibilityVersion().set(androidExtension.getCompileOptions().getTargetCompatibility());
            byteBuddyExtension.configure(task);
        }
    }
    protected static class DefaultAndroidDescriptor implements AndroidDescriptor {
        private final Set<String> names;
        protected DefaultAndroidDescriptor(Set<String> names) {
            this.names = names;
        }
        protected static AndroidDescriptor ofClassPath(Set<File> roots) {
            Set<String> names = new HashSet<String>();
            for (File root : roots) {
                Queue<File> queue = QueueFactory.make(Collections.singleton(root));
                while (!queue.isEmpty()) {
                    File file = queue.remove();
                    if (file.isDirectory()) {
                        File[] value = file.listFiles();
                        if (value != null) {
                            queue.addAll(Arrays.asList(value));
                        }
                    } else if (file.getName().endsWith(ClassFileLocator.CLASS_FILE_EXTENSION)) {
                        String path = root.getAbsoluteFile().toURI().relativize(file.getAbsoluteFile().toURI()).getPath();
                        names.add(path.substring(0, path.length() - ClassFileLocator.CLASS_FILE_EXTENSION.length()).replace('/', '.'));
                    }
                }
            }
            return new DefaultAndroidDescriptor(names);
        }
        public TypeScope getTypeScope(TypeDescription typeDescription) {
            return names.contains(typeDescription.getName()) ? TypeScope.LOCAL : TypeScope.EXTERNAL;
        }
    }
    protected static class TargetForAndroidAppJarFile extends Plugin.Engine.Target.ForJarFile {
        private final File file;
        protected TargetForAndroidAppJarFile(File file) {
            super(file);
            this.file = file;
        }
        public Sink write(@MaybeNull Manifest manifest) throws IOException {
            OutputStream outputStream = new FileOutputStream(file);
            try {
                return manifest == null ? new ForAndroidAppOutputStream(new JarOutputStream(outputStream)) : new ForAndroidAppOutputStream(new JarOutputStream(outputStream, manifest));
            } catch (IOException exception) {
                outputStream.close();
                throw exception;
            } catch (RuntimeException exception) {
                outputStream.close();
                throw exception;
            } catch (Error error) {
                outputStream.close();
                throw error;
            }
        }
        protected static class ForAndroidAppOutputStream extends Sink.ForJarOutputStream {
            private final JarOutputStream outputStream;
            protected ForAndroidAppOutputStream(JarOutputStream outputStream) {
                super(outputStream);
                this.outputStream = outputStream;
            }
            public void retain(Plugin.Engine.Source.Element element) throws IOException {
                JarEntry entry = element.resolveAs(JarEntry.class);
                if (entry != null && entry.isDirectory()) {
                    return;
                }
                String name = element.getName();
                try {
                    outputStream.putNextEntry(new JarEntry(name));
                    if (!name.endsWith("/")) {
                        InputStream inputStream = element.getInputStream();
                        try {
                            byte[] buffer = new byte[1024];
                            int length;
                            while ((length = inputStream.read(buffer)) != -1) {
                                outputStream.write(buffer, 0, length);
                            }
                        } finally {
                            inputStream.close();
                        }
                    }
                    outputStream.closeEntry();
                } catch (ZipException exception) {
                    if (!name.startsWith("META-INF") && !name.endsWith("-info.class") && name.endsWith(".class")) {
                        throw exception;
                    }
                }
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```