##CONTEXT_SIZE=735
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.build.gradle.android;
public class ByteBuddyAndroidTaskExtension {
    private final Project project;
    private final List<Transformation> transformations;
    private EntryPoint entryPoint;
    private String suffix;
    private boolean failOnLiveInitializer;
    private boolean warnOnEmptyTypeSet;
    private boolean failFast;
    private boolean extendedParsing;
    private Discovery discovery;
    private int threads;
    private FileCollection discoverySet;
    public ByteBuddyAndroidTaskExtension(Project project) {
        this.project = project;
        transformations = new ArrayList<Transformation>();
        entryPoint = new EntryPoint.Unvalidated(EntryPoint.Default.DECORATE);
        suffix = "";
        failOnLiveInitializer = true;
        warnOnEmptyTypeSet = true;
        failFast = true;
        discovery = Discovery.EMPTY;
    }
    public List<Transformation> getTransformations() {
        return transformations;
    }
    public void transformation(Closure<Transformation> closure) {
        transformations.add((Transformation) project.configure(new Transformation(project), closure));
    }
    public void transformation(Action<Transformation> action) {
        Transformation transformation = new Transformation(project);
        action.execute(transformation);
        transformations.add(transformation);
    }
    public EntryPoint getEntryPoint() {
        return entryPoint;
    }
    public void setEntryPoint(EntryPoint entryPoint) {
        this.entryPoint = entryPoint;
    }
    public String getSuffix() {
        return suffix;
    }
    public void setSuffix(String suffix) {
        this.suffix = suffix;
    }
    public boolean isFailOnLiveInitializer() {
        return failOnLiveInitializer;
    }
    public void setFailOnLiveInitializer(boolean failOnLiveInitializer) {
        this.failOnLiveInitializer = failOnLiveInitializer;
    }
    public boolean isWarnOnEmptyTypeSet() {
        return warnOnEmptyTypeSet;
    }
    public void setWarnOnEmptyTypeSet(boolean warnOnEmptyTypeSet) {
        this.warnOnEmptyTypeSet = warnOnEmptyTypeSet;
    }
    public boolean isFailFast() {
        return failFast;
    }
    public void setFailFast(boolean failFast) {
        this.failFast = failFast;
    }
    public boolean isExtendedParsing() {
        return extendedParsing;
    }
    public void setExtendedParsing(boolean extendedParsing) {
        this.extendedParsing = extendedParsing;
    }
    public Discovery getDiscovery() {
        return discovery;
    }
    public void setDiscovery(Discovery discovery) {
        this.discovery = discovery;
    }
    public int getThreads() {
        return threads;
    }
    public void setThreads(int threads) {
        this.threads = threads;
    }
    public FileCollection getDiscoverySet() {
        return discoverySet;
    }
    public void setDiscoverySet(@MaybeNull FileCollection discoverySet) {
        this.discoverySet = discoverySet;
    }
    protected void configure(ByteBuddyLocalClassesEnhancerTask task) {
        task.getTransformations().convention(getTransformations());
        task.getEntryPoint().convention(getEntryPoint());
        task.getSuffix().convention(getSuffix());
        task.getFailOnLiveInitializer().convention(isFailOnLiveInitializer());
        task.getWarnOnEmptyTypeSet().convention(isWarnOnEmptyTypeSet());
        task.getFailFast().convention(isFailFast());
        task.getExtendedParsing().convention(isExtendedParsing());
        task.getDiscovery().convention(getDiscovery());
        task.getThreads().convention(getThreads());
        task.getDiscoverySet().setFrom(getDiscoverySet());
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```