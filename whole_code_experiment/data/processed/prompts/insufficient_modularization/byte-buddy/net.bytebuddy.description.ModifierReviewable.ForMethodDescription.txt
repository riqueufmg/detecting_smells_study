##CONTEXT_SIZE=1875
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.description;
public interface ModifierReviewable {
    int EMPTY_MASK = 0;
    int getModifiers();
    boolean isFinal();
    boolean isSynthetic();
    SyntheticState getSyntheticState();
    interface OfByteCodeElement extends ModifierReviewable {
        boolean isPublic();
        boolean isProtected();
        boolean isPackagePrivate();
        boolean isPrivate();
        boolean isStatic();
        boolean isDeprecated();
        Ownership getOwnership();
        Visibility getVisibility();
    }
    interface OfAbstraction extends OfByteCodeElement {
        boolean isAbstract();
    }
    interface OfEnumeration extends OfByteCodeElement {
        boolean isEnum();
        EnumerationState getEnumerationState();
    }
    interface OfMandatable extends ModifierReviewable {
        boolean isMandated();
        Mandate getMandate();
    }
    interface ForTypeDefinition extends OfAbstraction, OfEnumeration {
        boolean isInterface();
        boolean isAnnotation();
        TypeManifestation getTypeManifestation();
    }
    interface ForFieldDescription extends OfEnumeration {
        boolean isVolatile();
        boolean isTransient();
        FieldManifestation getFieldManifestation();
        FieldPersistence getFieldPersistence();
    }
    interface ForMethodDescription extends OfAbstraction {
        boolean isSynchronized();
        boolean isVarArgs();
        boolean isNative();
        boolean isBridge();
        boolean isStrict();
        SynchronizationState getSynchronizationState();
        MethodStrictness getMethodStrictness();
        MethodManifestation getMethodManifestation();
    }
    interface ForParameterDescription extends OfMandatable {
        ParameterManifestation getParameterManifestation();
        ProvisioningState getProvisioningState();
    }
    interface ForModuleDescription extends ModifierReviewable {
        boolean isOpen();
        Openness getOpenness();
    }
    interface ForModuleRequirement extends OfMandatable {
        boolean isTransitive();
        boolean isStaticPhase();
        Transitivity getTransitivity();
        RequiredPhase getRequiredPhase();
    }
    abstract class AbstractBase implements ForTypeDefinition, ForFieldDescription, ForMethodDescription, ForParameterDescription, ForModuleDescription, ForModuleRequirement {
        public boolean isAbstract() {
            return matchesMask(Opcodes.ACC_ABSTRACT);
        }
        public boolean isFinal() {
            return matchesMask(Opcodes.ACC_FINAL);
        }
        public boolean isStatic() {
            return matchesMask(Opcodes.ACC_STATIC);
        }
        public boolean isPublic() {
            return matchesMask(Opcodes.ACC_PUBLIC);
        }
        public boolean isProtected() {
            return matchesMask(Opcodes.ACC_PROTECTED);
        }
        public boolean isPackagePrivate() {
            return !isPublic() && !isProtected() && !isPrivate();
        }
        public boolean isPrivate() {
            return matchesMask(Opcodes.ACC_PRIVATE);
        }
        public boolean isNative() {
            return matchesMask(Opcodes.ACC_NATIVE);
        }
        public boolean isSynchronized() {
            return matchesMask(Opcodes.ACC_SYNCHRONIZED);
        }
        public boolean isStrict() {
            return matchesMask(Opcodes.ACC_STRICT);
        }
        public boolean isMandated() {
            return matchesMask(Opcodes.ACC_MANDATED);
        }
        public boolean isSynthetic() {
            return matchesMask(Opcodes.ACC_SYNTHETIC);
        }
        public boolean isBridge() {
            return matchesMask(Opcodes.ACC_BRIDGE);
        }
        public boolean isDeprecated() {
            return matchesMask(Opcodes.ACC_DEPRECATED);
        }
        public boolean isAnnotation() {
            return matchesMask(Opcodes.ACC_ANNOTATION);
        }
        public boolean isEnum() {
            return matchesMask(Opcodes.ACC_ENUM);
        }
        public boolean isInterface() {
            return matchesMask(Opcodes.ACC_INTERFACE);
        }
        public boolean isTransient() {
            return matchesMask(Opcodes.ACC_TRANSIENT);
        }
        public boolean isVolatile() {
            return matchesMask(Opcodes.ACC_VOLATILE);
        }
        public boolean isVarArgs() {
            return matchesMask(Opcodes.ACC_VARARGS);
        }
        public boolean isOpen() {
            return matchesMask(Opcodes.ACC_OPEN);
        }
        public boolean isStaticPhase() {
            return matchesMask(Opcodes.ACC_STATIC_PHASE);
        }
        public boolean isTransitive() {
            return matchesMask(Opcodes.ACC_TRANSITIVE);
        }
        public SyntheticState getSyntheticState() {
            return isSynthetic() ? SyntheticState.SYNTHETIC : SyntheticState.PLAIN;
        }
        public Mandate getMandate() {
            return isMandated() ? Mandate.MANDATED : Mandate.PLAIN;
        }
        public Visibility getVisibility() {
            int modifiers = getModifiers();
            switch(modifiers & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED | Opcodes.ACC_PRIVATE)) {
                case Opcodes.ACC_PUBLIC:
                    return Visibility.PUBLIC;
                case Opcodes.ACC_PROTECTED:
                    return Visibility.PROTECTED;
                case EMPTY_MASK:
                    return Visibility.PACKAGE_PRIVATE;
                case Opcodes.ACC_PRIVATE:
                    return Visibility.PRIVATE;
                default:
                    throw new IllegalStateException("Unexpected modifiers: " + modifiers);
            }
        }
        public Ownership getOwnership() {
            return isStatic() ? Ownership.STATIC : Ownership.MEMBER;
        }
        public EnumerationState getEnumerationState() {
            return isEnum() ? EnumerationState.ENUMERATION : EnumerationState.PLAIN;
        }
        public TypeManifestation getTypeManifestation() {
            int modifiers = getModifiers();
            switch(modifiers & (Opcodes.ACC_ANNOTATION | Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT | Opcodes.ACC_FINAL)) {
                case Opcodes.ACC_FINAL:
                    return TypeManifestation.FINAL;
                case Opcodes.ACC_ABSTRACT:
                    return TypeManifestation.ABSTRACT;
                case Opcodes.ACC_ABSTRACT | Opcodes.ACC_INTERFACE:
                    return TypeManifestation.INTERFACE;
                case Opcodes.ACC_ABSTRACT | Opcodes.ACC_INTERFACE | Opcodes.ACC_ANNOTATION:
                    return TypeManifestation.ANNOTATION;
                case EMPTY_MASK:
                    return TypeManifestation.PLAIN;
                default:
                    throw new IllegalStateException("Unexpected modifiers: " + modifiers);
            }
        }
        public FieldManifestation getFieldManifestation() {
            int modifiers = getModifiers();
            switch(modifiers & (Opcodes.ACC_VOLATILE | Opcodes.ACC_FINAL)) {
                case Opcodes.ACC_FINAL:
                    return FieldManifestation.FINAL;
                case Opcodes.ACC_VOLATILE:
                    return FieldManifestation.VOLATILE;
                case EMPTY_MASK:
                    return FieldManifestation.PLAIN;
                default:
                    throw new IllegalStateException("Unexpected modifiers: " + modifiers);
            }
        }
        public FieldPersistence getFieldPersistence() {
            int modifiers = getModifiers();
            switch(modifiers & Opcodes.ACC_TRANSIENT) {
                case Opcodes.ACC_TRANSIENT:
                    return FieldPersistence.TRANSIENT;
                case EMPTY_MASK:
                    return FieldPersistence.PLAIN;
                default:
                    throw new IllegalStateException("Unexpected modifiers: " + modifiers);
            }
        }
        public SynchronizationState getSynchronizationState() {
            return isSynchronized() ? SynchronizationState.SYNCHRONIZED : SynchronizationState.PLAIN;
        }
        public MethodManifestation getMethodManifestation() {
            int modifiers = getModifiers();
            switch(modifiers & (Opcodes.ACC_NATIVE | Opcodes.ACC_ABSTRACT | Opcodes.ACC_FINAL | Opcodes.ACC_BRIDGE)) {
                case Opcodes.ACC_NATIVE | Opcodes.ACC_FINAL:
                    return MethodManifestation.FINAL_NATIVE;
                case Opcodes.ACC_NATIVE:
                    return MethodManifestation.NATIVE;
                case Opcodes.ACC_FINAL:
                    return MethodManifestation.FINAL;
                case Opcodes.ACC_BRIDGE:
                    return MethodManifestation.BRIDGE;
                case Opcodes.ACC_BRIDGE | Opcodes.ACC_FINAL:
                    return MethodManifestation.FINAL_BRIDGE;
                case Opcodes.ACC_ABSTRACT:
                    return MethodManifestation.ABSTRACT;
                case EMPTY_MASK:
                    return MethodManifestation.PLAIN;
                default:
                    throw new IllegalStateException("Unexpected modifiers: " + modifiers);
            }
        }
        public MethodStrictness getMethodStrictness() {
            return isStrict() ? MethodStrictness.STRICT : MethodStrictness.PLAIN;
        }
        public ParameterManifestation getParameterManifestation() {
            return isFinal() ? ParameterManifestation.FINAL : ParameterManifestation.PLAIN;
        }
        public ProvisioningState getProvisioningState() {
            return isMandated() ? ProvisioningState.MANDATED : ProvisioningState.PLAIN;
        }
        public Openness getOpenness() {
            return isOpen() ? Openness.OPEN : Openness.CLOSED;
        }
        public Transitivity getTransitivity() {
            return isTransitive() ? Transitivity.TRANSITIVE : Transitivity.NONE;
        }
        public RequiredPhase getRequiredPhase() {
            return isStaticPhase() ? RequiredPhase.STATIC : RequiredPhase.ALWAYS;
        }
        private boolean matchesMask(int mask) {
            return (getModifiers() & mask) == mask;
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```