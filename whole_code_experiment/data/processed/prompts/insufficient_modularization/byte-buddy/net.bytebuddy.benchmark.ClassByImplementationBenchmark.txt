##CONTEXT_SIZE=1629
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.benchmark;
public class ClassByImplementationBenchmark {
    public static final Class<? extends ExampleInterface> BASE_CLASS = ExampleInterface.class;
    public static final String DEFAULT_REFERENCE_VALUE = null;
    public static final boolean DEFAULT_BOOLEAN_VALUE = false;
    public static final byte DEFAULT_BYTE_VALUE = 0;
    public static final short DEFAULT_SHORT_VALUE = 0;
    public static final char DEFAULT_CHAR_VALUE = 0;
    public static final int DEFAULT_INT_VALUE = 0;
    public static final long DEFAULT_LONG_VALUE = 0L;
    public static final float DEFAULT_FLOAT_VALUE = 0f;
    public static final double DEFAULT_DOUBLE_VALUE = 0d;
    private Class<? extends ExampleInterface> baseClass = BASE_CLASS;
    private String defaultReferenceValue = DEFAULT_REFERENCE_VALUE;
    private boolean defaultBooleanValue = DEFAULT_BOOLEAN_VALUE;
    private byte defaultByteValue = DEFAULT_BYTE_VALUE;
    private short defaultShortValue = DEFAULT_SHORT_VALUE;
    private char defaultCharValue = DEFAULT_CHAR_VALUE;
    private int defaultIntValue = DEFAULT_INT_VALUE;
    private long defaultLongValue = DEFAULT_LONG_VALUE;
    private float defaultFloatValue = DEFAULT_FLOAT_VALUE;
    private double defaultDoubleValue = DEFAULT_DOUBLE_VALUE;
    private int urlLength = 0;
    private ClassLoader newClassLoader() {
        return new URLClassLoader(new URL[urlLength]);
    }
    private TypeDescription baseClassDescription;
    public void setup() {
        baseClassDescription = TypePool.Default.ofSystemLoader().describe(baseClass.getName()).resolve();
    }
    public ExampleInterface baseline() {
        return new ExampleInterface() {
            public boolean method(boolean arg) {
                return false;
            }
            public byte method(byte arg) {
                return 0;
            }
            public short method(short arg) {
                return 0;
            }
            public int method(int arg) {
                return 0;
            }
            public char method(char arg) {
                return 0;
            }
            public long method(long arg) {
                return 0;
            }
            public float method(float arg) {
                return 0;
            }
            public double method(double arg) {
                return 0;
            }
            @AlwaysNull
            public Object method(Object arg) {
                return null;
            }
            @AlwaysNull
            public boolean[] method(boolean arg1, boolean arg2, boolean arg3) {
                return null;
            }
            @AlwaysNull
            public byte[] method(byte arg1, byte arg2, byte arg3) {
                return null;
            }
            @AlwaysNull
            public short[] method(short arg1, short arg2, short arg3) {
                return null;
            }
            @AlwaysNull
            public int[] method(int arg1, int arg2, int arg3) {
                return null;
            }
            @AlwaysNull
            public char[] method(char arg1, char arg2, char arg3) {
                return null;
            }
            @AlwaysNull
            public long[] method(long arg1, long arg2, long arg3) {
                return null;
            }
            @AlwaysNull
            public float[] method(float arg1, float arg2, float arg3) {
                return null;
            }
            @AlwaysNull
            public double[] method(double arg1, double arg2, double arg3) {
                return null;
            }
            @AlwaysNull
            public Object[] method(Object arg1, Object arg2, Object arg3) {
                return null;
            }
        };
    }
    public ExampleInterface benchmarkByteBuddy() throws Exception {
        return new ByteBuddy().with(TypeValidation.DISABLED).ignore(none()).subclass(baseClass).method(isDeclaredBy(baseClass)).intercept(StubMethod.INSTANCE).make().load(newClassLoader(), ClassLoadingStrategy.Default.INJECTION).getLoaded().getDeclaredConstructor().newInstance();
    }
    public ExampleInterface benchmarkByteBuddyWithTypePool() throws Exception {
        return (ExampleInterface) new ByteBuddy().with(TypeValidation.DISABLED).ignore(none()).subclass(baseClassDescription).method(isDeclaredBy(baseClassDescription)).intercept(StubMethod.INSTANCE).make().load(newClassLoader(), ClassLoadingStrategy.Default.INJECTION).getLoaded().getDeclaredConstructor().newInstance();
    }
    public ExampleInterface benchmarkCglib() {
        Enhancer enhancer = new Enhancer();
        enhancer.setUseCache(false);
        enhancer.setClassLoader(newClassLoader());
        enhancer.setSuperclass(baseClass);
        CallbackHelper callbackHelper = new CallbackHelper(Object.class, new Class<?>[] { baseClass }) {
            protected Object getCallback(Method method) {
                if (method.getDeclaringClass() == baseClass) {
                    return new FixedValue() {
                        public Object loadObject() {
                            return null;
                        }
                    };
                } else {
                    return NoOp.INSTANCE;
                }
            }
        };
        enhancer.setCallbackFilter(callbackHelper);
        enhancer.setCallbacks(callbackHelper.getCallbacks());
        return (ExampleInterface) enhancer.create();
    }
    public ExampleInterface benchmarkJavassist() throws Exception {
        ProxyFactory proxyFactory = new ProxyFactory() {
            protected ClassLoader getClassLoader() {
                return newClassLoader();
            }
        };
        proxyFactory.setUseCache(false);
        proxyFactory.setUseWriteReplace(false);
        proxyFactory.setSuperclass(Object.class);
        proxyFactory.setInterfaces(new Class<?>[] { baseClass });
        proxyFactory.setFilter(new MethodFilter() {
            public boolean isHandled(Method method) {
                return true;
            }
        });
        @SuppressWarnings("unchecked")
        Object instance = proxyFactory.createClass().getDeclaredConstructor().newInstance();
        ((javassist.util.proxy.Proxy) instance).setHandler(new MethodHandler() {
            public Object invoke(Object self, Method thisMethod, Method proceed, Object[] args) throws Throwable {
                Class<?> returnType = thisMethod.getReturnType();
                if (returnType.isPrimitive()) {
                    if (returnType == boolean.class) {
                        return defaultBooleanValue;
                    } else if (returnType == byte.class) {
                        return defaultByteValue;
                    } else if (returnType == short.class) {
                        return defaultShortValue;
                    } else if (returnType == char.class) {
                        return defaultCharValue;
                    } else if (returnType == int.class) {
                        return defaultIntValue;
                    } else if (returnType == long.class) {
                        return defaultLongValue;
                    } else if (returnType == float.class) {
                        return defaultFloatValue;
                    } else {
                        return defaultDoubleValue;
                    }
                } else {
                    return defaultReferenceValue;
                }
            }
        });
        return (ExampleInterface) instance;
    }
    public ExampleInterface benchmarkJdkProxy() throws Exception {
        return (ExampleInterface) Proxy.newProxyInstance(newClassLoader(), new Class<?>[] { baseClass }, new InvocationHandler() {
            @MaybeNull
            public Object invoke(Object proxy, Method method, @MaybeNull Object[] argument) {
                Class<?> returnType = method.getReturnType();
                if (returnType.isPrimitive()) {
                    if (returnType == boolean.class) {
                        return defaultBooleanValue;
                    } else if (returnType == byte.class) {
                        return defaultByteValue;
                    } else if (returnType == short.class) {
                        return defaultShortValue;
                    } else if (returnType == char.class) {
                        return defaultCharValue;
                    } else if (returnType == int.class) {
                        return defaultIntValue;
                    } else if (returnType == long.class) {
                        return defaultLongValue;
                    } else if (returnType == float.class) {
                        return defaultFloatValue;
                    } else {
                        return defaultDoubleValue;
                    }
                } else {
                    return defaultReferenceValue;
                }
            }
        });
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```