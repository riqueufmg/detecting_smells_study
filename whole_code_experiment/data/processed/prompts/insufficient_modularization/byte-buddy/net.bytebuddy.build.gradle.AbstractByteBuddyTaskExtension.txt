##CONTEXT_SIZE=1161
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package net.bytebuddy.build.gradle;
public abstract class AbstractByteBuddyTaskExtension<T extends AbstractByteBuddyTask> {
    private final Project project;
    private final List<Transformation> transformations;
    private EntryPoint entryPoint;
    private String suffix;
    private boolean failOnLiveInitializer;
    private boolean warnOnEmptyTypeSet;
    private boolean failFast;
    private boolean extendedParsing;
    private Discovery discovery;
    private Adjustment adjustment;
    private Adjustment.ErrorHandler adjustmentErrorHandler;
    private Action<Task> adjustmentPostProcessor;
    private int threads;
    private boolean lazy;
    private ClassFileVersion classFileVersion;
    private ClassFileVersion multiReleaseClassFileVersion;
    protected AbstractByteBuddyTaskExtension(@UnknownNull Project project) {
        this.project = project;
        transformations = new ArrayList<Transformation>();
        entryPoint = EntryPoint.Default.REBASE;
        suffix = "";
        failOnLiveInitializer = true;
        warnOnEmptyTypeSet = true;
        failFast = true;
        discovery = Discovery.EMPTY;
        adjustment = Adjustment.FULL;
        adjustmentErrorHandler = Adjustment.ErrorHandler.WARN;
        adjustmentPostProcessor = Adjustment.NoOpPostProcessor.INSTANCE;
    }
    public List<Transformation> getTransformations() {
        return transformations;
    }
    public void transformation(Closure<Transformation> closure) {
        Transformation transformation = ObjectFactory.newInstance(project, Transformation.class, project);
        if (transformation == null) {
            transformation = new Transformation(project);
        }
        transformations.add((Transformation) project.configure(transformation, closure));
    }
    public void transformation(Action<Transformation> action) {
        Transformation transformation = ObjectFactory.newInstance(project, Transformation.class, project);
        if (transformation == null) {
            transformation = new Transformation(project);
        }
        action.execute(transformation);
        transformations.add(transformation);
    }
    public EntryPoint getEntryPoint() {
        return entryPoint;
    }
    public void setEntryPoint(EntryPoint entryPoint) {
        this.entryPoint = entryPoint;
    }
    public String getSuffix() {
        return suffix;
    }
    public void setSuffix(String suffix) {
        this.suffix = suffix;
    }
    public boolean isFailOnLiveInitializer() {
        return failOnLiveInitializer;
    }
    public void setFailOnLiveInitializer(boolean failOnLiveInitializer) {
        this.failOnLiveInitializer = failOnLiveInitializer;
    }
    public boolean isWarnOnEmptyTypeSet() {
        return warnOnEmptyTypeSet;
    }
    public void setWarnOnEmptyTypeSet(boolean warnOnEmptyTypeSet) {
        this.warnOnEmptyTypeSet = warnOnEmptyTypeSet;
    }
    public boolean isFailFast() {
        return failFast;
    }
    public void setFailFast(boolean failFast) {
        this.failFast = failFast;
    }
    public boolean isExtendedParsing() {
        return extendedParsing;
    }
    public void setExtendedParsing(boolean extendedParsing) {
        this.extendedParsing = extendedParsing;
    }
    public Discovery getDiscovery() {
        return discovery;
    }
    public void setDiscovery(Discovery discovery) {
        this.discovery = discovery;
    }
    public Adjustment getAdjustment() {
        return adjustment;
    }
    public void setAdjustment(Adjustment adjustment) {
        this.adjustment = adjustment;
    }
    public Adjustment.ErrorHandler getAdjustmentErrorHandler() {
        return adjustmentErrorHandler;
    }
    public void setAdjustmentErrorHandler(Adjustment.ErrorHandler adjustmentErrorHandler) {
        this.adjustmentErrorHandler = adjustmentErrorHandler;
    }
    public Action<Task> getAdjustmentPostProcessor() {
        return adjustmentPostProcessor;
    }
    public void setAdjustmentPostProcessor(Action<Task> adjustmentPostProcessor) {
        this.adjustmentPostProcessor = adjustmentPostProcessor;
    }
    public int getThreads() {
        return threads;
    }
    public void setThreads(int threads) {
        this.threads = threads;
    }
    public boolean isLazy() {
        return lazy;
    }
    public void setLazy(boolean lazy) {
        this.lazy = lazy;
    }
    public ClassFileVersion getClassFileVersion() {
        return classFileVersion;
    }
    public void setClassFileVersion(@MaybeNull ClassFileVersion classFileVersion) {
        this.classFileVersion = classFileVersion;
    }
    public ClassFileVersion getMultiReleaseClassFileVersion() {
        return multiReleaseClassFileVersion;
    }
    public void setMultiReleaseClassFileVersion(@MaybeNull ClassFileVersion multiReleaseClassFileVersion) {
        this.multiReleaseClassFileVersion = multiReleaseClassFileVersion;
    }
    protected void resolve(JavaVersion version) {
        if (classFileVersion == null) {
            classFileVersion = ClassFileVersion.ofJavaVersion(Integer.parseInt(version.getMajorVersion()));
        }
    }
    protected abstract boolean isEmptyDiscovery();
    protected abstract void doConfigure(T task);
    protected void configure(T task) {
        task.getTransformations().addAll(getTransformations());
        task.setEntryPoint(getEntryPoint());
        task.setSuffix(getSuffix());
        task.setFailOnLiveInitializer(isFailOnLiveInitializer());
        task.setWarnOnEmptyTypeSet(isWarnOnEmptyTypeSet());
        task.setFailFast(isFailFast());
        task.setExtendedParsing(isExtendedParsing());
        task.setDiscovery(getDiscovery());
        task.setThreads(getThreads());
        task.setClassFileVersion(getClassFileVersion());
        task.setMultiReleaseClassFileVersion(getMultiReleaseClassFileVersion());
        doConfigure(task);
    }
    protected abstract void discoverySet(FileCollection fileCollection);
    protected abstract Class<? extends T> toType();
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```