##CONTEXT_SIZE=940
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.common.jimfs;
final class JimfsFileStore extends FileStore {
    private final FileTree tree;
    private final HeapDisk disk;
    private final AttributeService attributes;
    private final FileFactory factory;
    private final ImmutableSet<Feature> supportedFeatures;
    private final FileSystemState state;
    private final Lock readLock;
    private final Lock writeLock;
    public JimfsFileStore(FileTree tree, FileFactory factory, HeapDisk disk, AttributeService attributes, ImmutableSet<Feature> supportedFeatures, FileSystemState state) {
        this.tree = checkNotNull(tree);
        this.factory = checkNotNull(factory);
        this.disk = checkNotNull(disk);
        this.attributes = checkNotNull(attributes);
        this.supportedFeatures = checkNotNull(supportedFeatures);
        this.state = checkNotNull(state);
        ReadWriteLock lock = new ReentrantReadWriteLock();
        this.readLock = lock.readLock();
        this.writeLock = lock.writeLock();
    }
    FileSystemState state() {
        return state;
    }
    Lock readLock() {
        return readLock;
    }
    Lock writeLock() {
        return writeLock;
    }
    ImmutableSortedSet<Name> getRootDirectoryNames() {
        state.checkOpen();
        return tree.getRootDirectoryNames();
    }
    Directory getRoot(Name name) {
        DirectoryEntry entry = tree.getRoot(name);
        return entry == null ? null : (Directory) entry.file();
    }
    boolean supportsFeature(Feature feature) {
        return supportedFeatures.contains(feature);
    }
    DirectoryEntry lookUp(File workingDirectory, JimfsPath path, Set<? super LinkOption> options) throws IOException {
        state.checkOpen();
        return tree.lookUp(workingDirectory, path, options);
    }
    Supplier<RegularFile> regularFileCreator() {
        state.checkOpen();
        return factory.regularFileCreator();
    }
    Supplier<Directory> directoryCreator() {
        state.checkOpen();
        return factory.directoryCreator();
    }
    Supplier<SymbolicLink> symbolicLinkCreator(JimfsPath target) {
        state.checkOpen();
        return factory.symbolicLinkCreator(target);
    }
    File copyWithoutContent(File file, AttributeCopyOption attributeCopyOption) throws IOException {
        File copy = factory.copyWithoutContent(file);
        setInitialAttributes(copy);
        attributes.copyAttributes(file, copy, attributeCopyOption);
        return copy;
    }
    void setInitialAttributes(File file, FileAttribute<?>... attrs) {
        state.checkOpen();
        attributes.setInitialAttributes(file, attrs);
    }
    <V extends FileAttributeView> V getFileAttributeView(FileLookup lookup, Class<V> type) {
        state.checkOpen();
        return attributes.getFileAttributeView(lookup, type);
    }
    ImmutableMap<String, Object> readAttributes(File file, String attributes) {
        state.checkOpen();
        return this.attributes.readAttributes(file, attributes);
    }
    <A extends BasicFileAttributes> A readAttributes(File file, Class<A> type) {
        state.checkOpen();
        return attributes.readAttributes(file, type);
    }
    void setAttribute(File file, String attribute, Object value) {
        state.checkOpen();
        attributes.setAttribute(file, attribute, value, false);
    }
    ImmutableSet<String> supportedFileAttributeViews() {
        state.checkOpen();
        return attributes.supportedFileAttributeViews();
    }
    public String name() {
        return "jimfs";
    }
    public String type() {
        return "jimfs";
    }
    public boolean isReadOnly() {
        return false;
    }
    public long getTotalSpace() throws IOException {
        state.checkOpen();
        return disk.getTotalSpace();
    }
    public long getUsableSpace() throws IOException {
        state.checkOpen();
        return getUnallocatedSpace();
    }
    public long getUnallocatedSpace() throws IOException {
        state.checkOpen();
        return disk.getUnallocatedSpace();
    }
    public boolean supportsFileAttributeView(Class<? extends FileAttributeView> type) {
        state.checkOpen();
        return attributes.supportsFileAttributeView(type);
    }
    public boolean supportsFileAttributeView(String name) {
        state.checkOpen();
        return attributes.supportedFileAttributeViews().contains(name);
    }
    public <V extends FileStoreAttributeView> V getFileStoreAttributeView(Class<V> type) {
        state.checkOpen();
        return null;
    }
    public Object getAttribute(String attribute) throws IOException {
        throw new UnsupportedOperationException();
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```