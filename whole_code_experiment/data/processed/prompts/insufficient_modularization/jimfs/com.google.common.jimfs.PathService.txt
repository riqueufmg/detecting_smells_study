##CONTEXT_SIZE=1385
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.common.jimfs;
final class PathService implements Comparator<JimfsPath> {
    private static final Comparator<Name> DISPLAY_ROOT_COMPARATOR = nullsLast(Name.displayComparator());
    private static final Comparator<Iterable<Name>> DISPLAY_NAMES_COMPARATOR = Comparators.lexicographical(Name.displayComparator());
    private static final Comparator<Name> CANONICAL_ROOT_COMPARATOR = nullsLast(Name.canonicalComparator());
    private static final Comparator<Iterable<Name>> CANONICAL_NAMES_COMPARATOR = Comparators.lexicographical(Name.canonicalComparator());
    private final PathType type;
    private final ImmutableSet<PathNormalization> displayNormalizations;
    private final ImmutableSet<PathNormalization> canonicalNormalizations;
    private final boolean equalityUsesCanonicalForm;
    private final Comparator<Name> rootComparator;
    private final Comparator<Iterable<Name>> namesComparator;
    private volatile FileSystem fileSystem;
    private volatile JimfsPath emptyPath;
    PathService(Configuration config) {
        this(config.pathType, config.nameDisplayNormalization, config.nameCanonicalNormalization, config.pathEqualityUsesCanonicalForm);
    }
    PathService(PathType type, Iterable<PathNormalization> displayNormalizations, Iterable<PathNormalization> canonicalNormalizations, boolean equalityUsesCanonicalForm) {
        this.type = checkNotNull(type);
        this.displayNormalizations = ImmutableSet.copyOf(displayNormalizations);
        this.canonicalNormalizations = ImmutableSet.copyOf(canonicalNormalizations);
        this.equalityUsesCanonicalForm = equalityUsesCanonicalForm;
        this.rootComparator = equalityUsesCanonicalForm ? CANONICAL_ROOT_COMPARATOR : DISPLAY_ROOT_COMPARATOR;
        this.namesComparator = equalityUsesCanonicalForm ? CANONICAL_NAMES_COMPARATOR : DISPLAY_NAMES_COMPARATOR;
    }
    public void setFileSystem(FileSystem fileSystem) {
        checkState(this.fileSystem == null, "may not set fileSystem twice");
        this.fileSystem = checkNotNull(fileSystem);
    }
    public FileSystem getFileSystem() {
        return fileSystem;
    }
    public String getSeparator() {
        return type.getSeparator();
    }
    public JimfsPath emptyPath() {
        JimfsPath result = emptyPath;
        if (result == null) {
            result = createPathInternal(null, ImmutableList.of(Name.EMPTY));
            emptyPath = result;
            return result;
        }
        return result;
    }
    public Name name(String name) {
        switch(name) {
            case "":
                return Name.EMPTY;
            case ".":
                return Name.SELF;
            case "..":
                return Name.PARENT;
            default:
                String display = PathNormalization.normalize(name, displayNormalizations);
                String canonical = PathNormalization.normalize(name, canonicalNormalizations);
                return Name.create(display, canonical);
        }
    }
    List<Name> names(Iterable<String> names) {
        List<Name> result = new ArrayList<>();
        for (String name : names) {
            result.add(name(name));
        }
        return result;
    }
    public JimfsPath createRoot(Name root) {
        return createPath(checkNotNull(root), ImmutableList.<Name>of());
    }
    public JimfsPath createFileName(Name name) {
        return createPath(null, ImmutableList.of(name));
    }
    public JimfsPath createRelativePath(Iterable<Name> names) {
        return createPath(null, ImmutableList.copyOf(names));
    }
    public JimfsPath createPath(@Nullable Name root, Iterable<Name> names) {
        ImmutableList<Name> nameList = ImmutableList.copyOf(Iterables.filter(names, NOT_EMPTY));
        if (root == null && nameList.isEmpty()) {
            return emptyPath();
        }
        return createPathInternal(root, nameList);
    }
    final JimfsPath createPathInternal(@Nullable Name root, Iterable<Name> names) {
        return new JimfsPath(this, root, names);
    }
    public JimfsPath parsePath(String first, String... more) {
        String joined = type.joiner().join(Iterables.filter(Lists.asList(first, more), NOT_EMPTY));
        return toPath(type.parsePath(joined));
    }
    private JimfsPath toPath(ParseResult parsed) {
        Name root = parsed.root() == null ? null : name(parsed.root());
        Iterable<Name> names = names(parsed.names());
        return createPath(root, names);
    }
    public String toString(JimfsPath path) {
        Name root = path.root();
        String rootString = root == null ? null : root.toString();
        Iterable<String> names = Iterables.transform(path.names(), Functions.toStringFunction());
        return type.toString(rootString, names);
    }
    public int hash(JimfsPath path) {
        int hash = 31;
        hash = 31 * hash + getFileSystem().hashCode();
        final Name root = path.root();
        final ImmutableList<Name> names = path.names();
        if (equalityUsesCanonicalForm) {
            hash = 31 * hash + (root == null ? 0 : root.hashCode());
            for (Name name : names) {
                hash = 31 * hash + name.hashCode();
            }
        } else {
            hash = 31 * hash + (root == null ? 0 : root.toString().hashCode());
            for (Name name : names) {
                hash = 31 * hash + name.toString().hashCode();
            }
        }
        return hash;
    }
    public int compare(JimfsPath a, JimfsPath b) {
        Comparator<JimfsPath> comparator = Comparator.comparing(JimfsPath::root, rootComparator).thenComparing(JimfsPath::names, namesComparator);
        return comparator.compare(a, b);
    }
    public URI toUri(URI fileSystemUri, JimfsPath path) {
        checkArgument(path.isAbsolute(), "path (%s) must be absolute", path);
        String root = String.valueOf(path.root());
        Iterable<String> names = Iterables.transform(path.names(), Functions.toStringFunction());
        return type.toUri(fileSystemUri, root, names, Files.isDirectory(path, NOFOLLOW_LINKS));
    }
    public JimfsPath fromUri(URI uri) {
        return toPath(type.fromUri(uri));
    }
    public PathMatcher createPathMatcher(String syntaxAndPattern) {
        return PathMatchers.getPathMatcher(syntaxAndPattern, type.getSeparator() + type.getOtherSeparators(), equalityUsesCanonicalForm ? canonicalNormalizations : displayNormalizations);
    }
    private static final Predicate<Object> NOT_EMPTY = new Predicate<Object>() {
        @Override
        public boolean apply(Object input) {
            return !input.toString().isEmpty();
        }
    };
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```