##CONTEXT_SIZE=1406
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.common.jimfs;
final class Directory extends File implements Iterable<DirectoryEntry> {
    private DirectoryEntry entryInParent;
    public static Directory create(int id, FileTime creationTime) {
        return new Directory(id, creationTime);
    }
    public static Directory createRoot(int id, FileTime creationTime, Name name) {
        return new Directory(id, creationTime, name);
    }
    private Directory(int id, FileTime creationTime) {
        super(id, creationTime);
        put(new DirectoryEntry(this, Name.SELF, this));
    }
    private Directory(int id, FileTime creationTime, Name rootName) {
        this(id, creationTime);
        linked(new DirectoryEntry(this, rootName, this));
    }
    Directory copyWithoutContent(int id, FileTime creationTime) {
        return Directory.create(id, creationTime);
    }
    public DirectoryEntry entryInParent() {
        return entryInParent;
    }
    public Directory parent() {
        return entryInParent.directory();
    }
    void linked(DirectoryEntry entry) {
        File parent = entry.directory();
        this.entryInParent = entry;
        forcePut(new DirectoryEntry(this, Name.PARENT, parent));
    }
    void unlinked() {
        parent().decrementLinkCount();
    }
    int entryCount() {
        return entryCount;
    }
    public boolean isEmpty() {
        return entryCount() == 2;
    }
    public DirectoryEntry get(Name name) {
        int index = bucketIndex(name, table.length);
        DirectoryEntry entry = table[index];
        while (entry != null) {
            if (name.equals(entry.name())) {
                return entry;
            }
            entry = entry.next;
        }
        return null;
    }
    public void link(Name name, File file) {
        DirectoryEntry entry = new DirectoryEntry(this, checkNotReserved(name, "link"), file);
        put(entry);
        file.linked(entry);
    }
    public void unlink(Name name) {
        DirectoryEntry entry = remove(checkNotReserved(name, "unlink"));
        entry.file().unlinked();
    }
    public ImmutableSortedSet<Name> snapshot() {
        ImmutableSortedSet.Builder<Name> builder = new ImmutableSortedSet.Builder<>(Name.displayComparator());
        for (DirectoryEntry entry : this) {
            if (!isReserved(entry.name())) {
                builder.add(entry.name());
            }
        }
        return builder.build();
    }
    private static Name checkNotReserved(Name name, String action) {
        if (isReserved(name)) {
            throw new IllegalArgumentException("cannot " + action + ": " + name);
        }
        return name;
    }
    private static boolean isReserved(Name name) {
        return name == Name.SELF || name == Name.PARENT;
    }
    private static final int INITIAL_CAPACITY = 16;
    private static final int INITIAL_RESIZE_THRESHOLD = (int) (INITIAL_CAPACITY * 0.75);
    private DirectoryEntry[] table = new DirectoryEntry[INITIAL_CAPACITY];
    private int resizeThreshold = INITIAL_RESIZE_THRESHOLD;
    private int entryCount;
    private static int bucketIndex(Name name, int tableLength) {
        return name.hashCode() & (tableLength - 1);
    }
    void put(DirectoryEntry entry) {
        put(entry, false);
    }
    private void put(DirectoryEntry entry, boolean overwriteExisting) {
        int index = bucketIndex(entry.name(), table.length);
        DirectoryEntry prev = null;
        DirectoryEntry curr = table[index];
        while (curr != null) {
            if (curr.name().equals(entry.name())) {
                if (overwriteExisting) {
                    if (prev != null) {
                        prev.next = entry;
                    } else {
                        table[index] = entry;
                    }
                    entry.next = curr.next;
                    curr.next = null;
                    entry.file().incrementLinkCount();
                    return;
                } else {
                    throw new IllegalArgumentException("entry '" + entry.name() + "' already exists");
                }
            }
            prev = curr;
            curr = curr.next;
        }
        entryCount++;
        if (expandIfNeeded()) {
            index = bucketIndex(entry.name(), table.length);
            addToBucket(index, table, entry);
        } else {
            if (prev != null) {
                prev.next = entry;
            } else {
                table[index] = entry;
            }
        }
        entry.file().incrementLinkCount();
    }
    private void forcePut(DirectoryEntry entry) {
        put(entry, true);
    }
    private boolean expandIfNeeded() {
        if (entryCount <= resizeThreshold) {
            return false;
        }
        DirectoryEntry[] newTable = new DirectoryEntry[table.length << 1];
        for (DirectoryEntry entry : table) {
            while (entry != null) {
                int index = bucketIndex(entry.name(), newTable.length);
                addToBucket(index, newTable, entry);
                DirectoryEntry next = entry.next;
                entry.next = null;
                entry = next;
            }
        }
        this.table = newTable;
        resizeThreshold <<= 1;
        return true;
    }
    private static void addToBucket(int bucketIndex, DirectoryEntry[] table, DirectoryEntry entryToAdd) {
        DirectoryEntry prev = null;
        DirectoryEntry existing = table[bucketIndex];
        while (existing != null) {
            prev = existing;
            existing = existing.next;
        }
        if (prev != null) {
            prev.next = entryToAdd;
        } else {
            table[bucketIndex] = entryToAdd;
        }
    }
    DirectoryEntry remove(Name name) {
        int index = bucketIndex(name, table.length);
        DirectoryEntry prev = null;
        DirectoryEntry entry = table[index];
        while (entry != null) {
            if (name.equals(entry.name())) {
                if (prev != null) {
                    prev.next = entry.next;
                } else {
                    table[index] = entry.next;
                }
                entry.next = null;
                entryCount--;
                entry.file().decrementLinkCount();
                return entry;
            }
            prev = entry;
            entry = entry.next;
        }
        throw new IllegalArgumentException("no entry matching '" + name + "' in this directory");
    }
    public Iterator<DirectoryEntry> iterator() {
        return new AbstractIterator<DirectoryEntry>() {
            int index;
            @Nullable
            DirectoryEntry entry;
            @Override
            protected DirectoryEntry computeNext() {
                if (entry != null) {
                    entry = entry.next;
                }
                while (entry == null && index < table.length) {
                    entry = table[index++];
                }
                return entry != null ? entry : endOfData();
            }
        };
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```