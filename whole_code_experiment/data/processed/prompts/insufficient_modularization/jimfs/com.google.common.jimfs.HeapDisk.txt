##CONTEXT_SIZE=665
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.common.jimfs;
final class HeapDisk {
    private final int blockSize;
    private final int maxBlockCount;
    private final int maxCachedBlockCount;
    final RegularFile blockCache;
    private int allocatedBlockCount;
    public HeapDisk(Configuration config) {
        this.blockSize = config.blockSize;
        this.maxBlockCount = toBlockCount(config.maxSize, blockSize);
        this.maxCachedBlockCount = config.maxCacheSize == -1 ? maxBlockCount : toBlockCount(config.maxCacheSize, blockSize);
        this.blockCache = createBlockCache(maxCachedBlockCount);
    }
    public HeapDisk(int blockSize, int maxBlockCount, int maxCachedBlockCount) {
        checkArgument(blockSize > 0, "blockSize (%s) must be positive", blockSize);
        checkArgument(maxBlockCount > 0, "maxBlockCount (%s) must be positive", maxBlockCount);
        checkArgument(maxCachedBlockCount >= 0, "maxCachedBlockCount (%s) must be non-negative", maxCachedBlockCount);
        this.blockSize = blockSize;
        this.maxBlockCount = maxBlockCount;
        this.maxCachedBlockCount = maxCachedBlockCount;
        this.blockCache = createBlockCache(maxCachedBlockCount);
    }
    private static int toBlockCount(long size, int blockSize) {
        return (int) LongMath.divide(size, blockSize, RoundingMode.FLOOR);
    }
    private RegularFile createBlockCache(int maxCachedBlockCount) {
        return new RegularFile(-1, SystemFileTimeSource.INSTANCE.now(), this, new byte[min(maxCachedBlockCount, 8192)][], 0, 0);
    }
    public int blockSize() {
        return blockSize;
    }
    public synchronized long getTotalSpace() {
        return maxBlockCount * (long) blockSize;
    }
    public synchronized long getUnallocatedSpace() {
        return (maxBlockCount - allocatedBlockCount) * (long) blockSize;
    }
    public synchronized void allocate(RegularFile file, int count) throws IOException {
        int newAllocatedBlockCount = allocatedBlockCount + count;
        if (newAllocatedBlockCount > maxBlockCount) {
            throw new IOException("out of disk space");
        }
        int newBlocksNeeded = max(count - blockCache.blockCount(), 0);
        for (int i = 0; i < newBlocksNeeded; i++) {
            file.addBlock(new byte[blockSize]);
        }
        if (newBlocksNeeded != count) {
            blockCache.transferBlocksTo(file, count - newBlocksNeeded);
        }
        allocatedBlockCount = newAllocatedBlockCount;
    }
    public void free(RegularFile file) {
        free(file, file.blockCount());
    }
    public synchronized void free(RegularFile file, int count) {
        int remainingCacheSpace = maxCachedBlockCount - blockCache.blockCount();
        if (remainingCacheSpace > 0) {
            file.copyBlocksTo(blockCache, min(count, remainingCacheSpace));
        }
        file.truncateBlocks(file.blockCount() - count);
        allocatedBlockCount -= count;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```