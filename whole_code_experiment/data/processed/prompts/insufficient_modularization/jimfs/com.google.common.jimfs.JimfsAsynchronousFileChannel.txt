##CONTEXT_SIZE=1013
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.common.jimfs;
final class JimfsAsynchronousFileChannel extends AsynchronousFileChannel {
    private final JimfsFileChannel channel;
    private final ListeningExecutorService executor;
    public JimfsAsynchronousFileChannel(JimfsFileChannel channel, ExecutorService executor) {
        this.channel = checkNotNull(channel);
        this.executor = MoreExecutors.listeningDecorator(executor);
    }
    public long size() throws IOException {
        return channel.size();
    }
    private <R, A> void addCallback(ListenableFuture<R> future, CompletionHandler<R, ? super A> handler, @Nullable A attachment) {
        future.addListener(new CompletionHandlerCallback<>(future, handler, attachment), executor);
    }
    public AsynchronousFileChannel truncate(long size) throws IOException {
        channel.truncate(size);
        return this;
    }
    public void force(boolean metaData) throws IOException {
        channel.force(metaData);
    }
    public <A> void lock(long position, long size, boolean shared, @Nullable A attachment, CompletionHandler<FileLock, ? super A> handler) {
        checkNotNull(handler);
        addCallback(lock(position, size, shared), handler, attachment);
    }
    public ListenableFuture<FileLock> lock(final long position, final long size, final boolean shared) {
        Util.checkNotNegative(position, "position");
        Util.checkNotNegative(size, "size");
        if (!isOpen()) {
            return closedChannelFuture();
        }
        if (shared) {
            channel.checkReadable();
        } else {
            channel.checkWritable();
        }
        return executor.submit(new Callable<FileLock>() {
            @Override
            public FileLock call() throws IOException {
                return tryLock(position, size, shared);
            }
        });
    }
    public FileLock tryLock(long position, long size, boolean shared) throws IOException {
        Util.checkNotNegative(position, "position");
        Util.checkNotNegative(size, "size");
        channel.checkOpen();
        if (shared) {
            channel.checkReadable();
        } else {
            channel.checkWritable();
        }
        return new JimfsFileChannel.FakeFileLock(this, position, size, shared);
    }
    public <A> void read(ByteBuffer dst, long position, @Nullable A attachment, CompletionHandler<Integer, ? super A> handler) {
        addCallback(read(dst, position), handler, attachment);
    }
    public ListenableFuture<Integer> read(final ByteBuffer dst, final long position) {
        checkArgument(!dst.isReadOnly(), "dst may not be read-only");
        Util.checkNotNegative(position, "position");
        if (!isOpen()) {
            return closedChannelFuture();
        }
        channel.checkReadable();
        return executor.submit(new Callable<Integer>() {
            @Override
            public Integer call() throws IOException {
                return channel.read(dst, position);
            }
        });
    }
    public <A> void write(ByteBuffer src, long position, @Nullable A attachment, CompletionHandler<Integer, ? super A> handler) {
        addCallback(write(src, position), handler, attachment);
    }
    public ListenableFuture<Integer> write(final ByteBuffer src, final long position) {
        Util.checkNotNegative(position, "position");
        if (!isOpen()) {
            return closedChannelFuture();
        }
        channel.checkWritable();
        return executor.submit(new Callable<Integer>() {
            @Override
            public Integer call() throws IOException {
                return channel.write(src, position);
            }
        });
    }
    public boolean isOpen() {
        return channel.isOpen();
    }
    public void close() throws IOException {
        channel.close();
    }
    private static <V> ListenableFuture<V> closedChannelFuture() {
        SettableFuture<V> future = SettableFuture.create();
        future.setException(new ClosedChannelException());
        return future;
    }
    private static final class CompletionHandlerCallback<R, A> implements Runnable {
        private final ListenableFuture<R> future;
        private final CompletionHandler<R, ? super A> completionHandler;
        private final A attachment;
        private CompletionHandlerCallback(ListenableFuture<R> future, CompletionHandler<R, ? super A> completionHandler, @Nullable A attachment) {
            this.future = checkNotNull(future);
            this.completionHandler = checkNotNull(completionHandler);
            this.attachment = attachment;
        }
        public void run() {
            R result;
            try {
                result = Futures.getDone(future);
            } catch (ExecutionException e) {
                onFailure(e.getCause());
                return;
            } catch (RuntimeException | Error e) {
                onFailure(e);
                return;
            }
            onSuccess(result);
        }
        private void onSuccess(R result) {
            completionHandler.completed(result, attachment);
        }
        private void onFailure(Throwable t) {
            completionHandler.failed(t, attachment);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```