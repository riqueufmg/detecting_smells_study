##CONTEXT_SIZE=801
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.common.jimfs;
final class JimfsFileSystem extends FileSystem {
    private final JimfsFileSystemProvider provider;
    private final URI uri;
    private final JimfsFileStore fileStore;
    private final PathService pathService;
    private final UserPrincipalLookupService userLookupService = new UserLookupService(true);
    private final FileSystemView defaultView;
    private final WatchServiceConfiguration watchServiceConfig;
    JimfsFileSystem(JimfsFileSystemProvider provider, URI uri, JimfsFileStore fileStore, PathService pathService, FileSystemView defaultView, WatchServiceConfiguration watchServiceConfig) {
        this.provider = checkNotNull(provider);
        this.uri = checkNotNull(uri);
        this.fileStore = checkNotNull(fileStore);
        this.pathService = checkNotNull(pathService);
        this.defaultView = checkNotNull(defaultView);
        this.watchServiceConfig = checkNotNull(watchServiceConfig);
    }
    public JimfsFileSystemProvider provider() {
        return provider;
    }
    public URI getUri() {
        return uri;
    }
    public FileSystemView getDefaultView() {
        return defaultView;
    }
    public String getSeparator() {
        return pathService.getSeparator();
    }
    public ImmutableSortedSet<Path> getRootDirectories() {
        ImmutableSortedSet.Builder<JimfsPath> builder = ImmutableSortedSet.orderedBy(pathService);
        for (Name name : fileStore.getRootDirectoryNames()) {
            builder.add(pathService.createRoot(name));
        }
        return (ImmutableSortedSet<Path>) (ImmutableSortedSet<?>) builder.build();
    }
    public JimfsPath getWorkingDirectory() {
        return defaultView.getWorkingDirectoryPath();
    }
    PathService getPathService() {
        return pathService;
    }
    public JimfsFileStore getFileStore() {
        return fileStore;
    }
    public ImmutableSet<FileStore> getFileStores() {
        fileStore.state().checkOpen();
        return ImmutableSet.<FileStore>of(fileStore);
    }
    public ImmutableSet<String> supportedFileAttributeViews() {
        return fileStore.supportedFileAttributeViews();
    }
    public JimfsPath getPath(String first, String... more) {
        fileStore.state().checkOpen();
        return pathService.parsePath(first, more);
    }
    public URI toUri(JimfsPath path) {
        fileStore.state().checkOpen();
        return pathService.toUri(uri, path.toAbsolutePath());
    }
    public JimfsPath toPath(URI uri) {
        fileStore.state().checkOpen();
        return pathService.fromUri(uri);
    }
    public PathMatcher getPathMatcher(String syntaxAndPattern) {
        fileStore.state().checkOpen();
        return pathService.createPathMatcher(syntaxAndPattern);
    }
    public UserPrincipalLookupService getUserPrincipalLookupService() {
        fileStore.state().checkOpen();
        return userLookupService;
    }
    public WatchService newWatchService() throws IOException {
        return watchServiceConfig.newWatchService(defaultView, pathService);
    }
    private ExecutorService defaultThreadPool;
    public synchronized ExecutorService getDefaultThreadPool() {
        if (defaultThreadPool == null) {
            defaultThreadPool = Executors.newCachedThreadPool(new ThreadFactoryBuilder().setDaemon(true).setNameFormat("JimfsFileSystem-" + uri.getHost() + "-defaultThreadPool-%s").build());
            fileStore.state().register(new Closeable() {
                @Override
                public void close() {
                    defaultThreadPool.shutdown();
                }
            });
        }
        return defaultThreadPool;
    }
    public boolean isReadOnly() {
        return false;
    }
    public boolean isOpen() {
        return fileStore.state().isOpen();
    }
    public void close() throws IOException {
        fileStore.state().close();
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```