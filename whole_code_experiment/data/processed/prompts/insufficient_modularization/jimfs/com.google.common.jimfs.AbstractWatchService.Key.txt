##CONTEXT_SIZE=1088
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.common.jimfs;
abstract class AbstractWatchService implements WatchService {
    private final BlockingQueue<WatchKey> queue = new LinkedBlockingQueue<>();
    private final WatchKey poison = new Key(this, null, ImmutableSet.<WatchEvent.Kind<?>>of());
    private final AtomicBoolean open = new AtomicBoolean(true);
    public Key register(Watchable watchable, Iterable<? extends WatchEvent.Kind<?>> eventTypes) throws IOException {
        checkOpen();
        return new Key(this, watchable, eventTypes);
    }
    public boolean isOpen() {
        return open.get();
    }
    final void enqueue(Key key) {
        if (isOpen()) {
            queue.add(key);
        }
    }
    public void cancelled(Key key) {
    }
    ImmutableList<WatchKey> queuedKeys() {
        return ImmutableList.copyOf(queue);
    }
    public WatchKey poll() {
        checkOpen();
        return check(queue.poll());
    }
    public WatchKey poll(long timeout, TimeUnit unit) throws InterruptedException {
        checkOpen();
        return check(queue.poll(timeout, unit));
    }
    public WatchKey take() throws InterruptedException {
        checkOpen();
        return check(queue.take());
    }
    private WatchKey check(@Nullable WatchKey key) {
        if (key == poison) {
            queue.offer(poison);
            throw new ClosedWatchServiceException();
        }
        return key;
    }
    protected final void checkOpen() {
        if (!open.get()) {
            throw new ClosedWatchServiceException();
        }
    }
    public void close() {
        if (open.compareAndSet(true, false)) {
            queue.clear();
            queue.offer(poison);
        }
    }
    static final class Event<T> implements WatchEvent<T> {
        private final Kind<T> kind;
        private final int count;
        private final T context;
        public Event(Kind<T> kind, int count, @Nullable T context) {
            this.kind = checkNotNull(kind);
            checkArgument(count >= 0, "count (%s) must be non-negative", count);
            this.count = count;
            this.context = context;
        }
        public Kind<T> kind() {
            return kind;
        }
        public int count() {
            return count;
        }
        public T context() {
            return context;
        }
        public boolean equals(Object obj) {
            if (obj instanceof Event) {
                Event<?> other = (Event<?>) obj;
                return kind().equals(other.kind()) && count() == other.count() && Objects.equals(context(), other.context());
            }
            return false;
        }
        public int hashCode() {
            return Objects.hash(kind(), count(), context());
        }
        public String toString() {
            return MoreObjects.toStringHelper(this).add("kind", kind()).add("count", count()).add("context", context()).toString();
        }
    }
    static final class Key implements WatchKey {
        static final int MAX_QUEUE_SIZE = 256;
        private static WatchEvent<Object> overflowEvent(int count) {
            return new Event<>(OVERFLOW, count, null);
        }
        private final AbstractWatchService watcher;
        private final Watchable watchable;
        private final ImmutableSet<WatchEvent.Kind<?>> subscribedTypes;
        private final AtomicReference<State> state = new AtomicReference<>(State.READY);
        private final AtomicBoolean valid = new AtomicBoolean(true);
        private final AtomicInteger overflow = new AtomicInteger();
        private final BlockingQueue<WatchEvent<?>> events = new ArrayBlockingQueue<>(MAX_QUEUE_SIZE);
        public Key(AbstractWatchService watcher, @Nullable Watchable watchable, Iterable<? extends WatchEvent.Kind<?>> subscribedTypes) {
            this.watcher = checkNotNull(watcher);
            this.watchable = watchable;
            this.subscribedTypes = ImmutableSet.copyOf(subscribedTypes);
        }
        State state() {
            return state.get();
        }
        public boolean subscribesTo(WatchEvent.Kind<?> eventType) {
            return subscribedTypes.contains(eventType);
        }
        public void post(WatchEvent<?> event) {
            if (!events.offer(event)) {
                overflow.incrementAndGet();
            }
        }
        public void signal() {
            if (state.getAndSet(State.SIGNALLED) == State.READY) {
                watcher.enqueue(this);
            }
        }
        public boolean isValid() {
            return watcher.isOpen() && valid.get();
        }
        public List<WatchEvent<?>> pollEvents() {
            List<WatchEvent<?>> result = new ArrayList<>(events.size());
            events.drainTo(result);
            int overflowCount = overflow.getAndSet(0);
            if (overflowCount != 0) {
                result.add(overflowEvent(overflowCount));
            }
            return Collections.unmodifiableList(result);
        }
        public boolean reset() {
            if (isValid() && state.compareAndSet(State.SIGNALLED, State.READY)) {
                if (!events.isEmpty()) {
                    signal();
                }
            }
            return isValid();
        }
        public void cancel() {
            valid.set(false);
            watcher.cancelled(this);
        }
        public Watchable watchable() {
            return watchable;
        }
        enum State {
            READY, SIGNALLED
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```