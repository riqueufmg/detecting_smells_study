##CONTEXT_SIZE=1562
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.common.jimfs;
final class GlobToRegex {
    public static String toRegex(String glob, String separators) {
        return new GlobToRegex(glob, separators).convert();
    }
    private static final InternalCharMatcher REGEX_RESERVED = InternalCharMatcher.anyOf("^$.?+*\\[]{}()");
    private final String glob;
    private final String separators;
    private final InternalCharMatcher separatorMatcher;
    private final StringBuilder builder = new StringBuilder();
    private final Deque<State> states = new ArrayDeque<>();
    private int index;
    private GlobToRegex(String glob, String separators) {
        this.glob = checkNotNull(glob);
        this.separators = separators;
        this.separatorMatcher = InternalCharMatcher.anyOf(separators);
    }
    private String convert() {
        pushState(NORMAL);
        for (index = 0; index < glob.length(); index++) {
            currentState().process(this, glob.charAt(index));
        }
        currentState().finish(this);
        return builder.toString();
    }
    private void pushState(State state) {
        states.push(state);
    }
    private void popState() {
        states.pop();
    }
    private State currentState() {
        return states.peek();
    }
    private PatternSyntaxException syntaxError(String desc) {
        throw new PatternSyntaxException(desc, glob, index);
    }
    private void appendExact(char c) {
        builder.append(c);
    }
    private void append(char c) {
        if (separatorMatcher.matches(c)) {
            appendSeparator();
        } else {
            appendNormal(c);
        }
    }
    private void appendNormal(char c) {
        if (REGEX_RESERVED.matches(c)) {
            builder.append('\\');
        }
        builder.append(c);
    }
    private void appendSeparator() {
        if (separators.length() == 1) {
            appendNormal(separators.charAt(0));
        } else {
            builder.append('[');
            for (int i = 0; i < separators.length(); i++) {
                appendInBracket(separators.charAt(i));
            }
            builder.append("]");
        }
    }
    private void appendNonSeparator() {
        builder.append("[^");
        for (int i = 0; i < separators.length(); i++) {
            appendInBracket(separators.charAt(i));
        }
        builder.append(']');
    }
    private void appendQuestionMark() {
        appendNonSeparator();
    }
    private void appendStar() {
        appendNonSeparator();
        builder.append('*');
    }
    private void appendStarStar() {
        builder.append(".*");
    }
    private void appendBracketStart() {
        builder.append('[');
        appendNonSeparator();
        builder.append("&&[");
    }
    private void appendBracketEnd() {
        builder.append("]]");
    }
    private void appendInBracket(char c) {
        if (c == '\\') {
            builder.append('\\');
        }
        builder.append(c);
    }
    private void appendCurlyBraceStart() {
        builder.append('(');
    }
    private void appendSubpatternSeparator() {
        builder.append('|');
    }
    private void appendCurlyBraceEnd() {
        builder.append(')');
    }
    private abstract static class State {
        abstract void process(GlobToRegex converter, char c);
        void finish(GlobToRegex converter) {
        }
    }
    private static final State NORMAL = new State() {
        @Override
        void process(GlobToRegex converter, char c) {
            switch(c) {
                case '?':
                    converter.appendQuestionMark();
                    return;
                case '[':
                    converter.appendBracketStart();
                    converter.pushState(BRACKET_FIRST_CHAR);
                    return;
                case '{':
                    converter.appendCurlyBraceStart();
                    converter.pushState(CURLY_BRACE);
                    return;
                case '*':
                    converter.pushState(STAR);
                    return;
                case '\\':
                    converter.pushState(ESCAPE);
                    return;
                default:
                    converter.append(c);
            }
        }
        @Override
        public String toString() {
            return "NORMAL";
        }
    };
    private static final State ESCAPE = new State() {
        @Override
        void process(GlobToRegex converter, char c) {
            converter.append(c);
            converter.popState();
        }
        @Override
        void finish(GlobToRegex converter) {
            throw converter.syntaxError("Hanging escape (\\) at end of pattern");
        }
        @Override
        public String toString() {
            return "ESCAPE";
        }
    };
    private static final State STAR = new State() {
        @Override
        void process(GlobToRegex converter, char c) {
            if (c == '*') {
                converter.appendStarStar();
                converter.popState();
            } else {
                converter.appendStar();
                converter.popState();
                converter.currentState().process(converter, c);
            }
        }
        @Override
        void finish(GlobToRegex converter) {
            converter.appendStar();
        }
        @Override
        public String toString() {
            return "STAR";
        }
    };
    private static final State BRACKET_FIRST_CHAR = new State() {
        @Override
        void process(GlobToRegex converter, char c) {
            if (c == ']') {
                throw converter.syntaxError("Empty []");
            }
            if (c == '!') {
                converter.appendExact('^');
            } else if (c == '-') {
                converter.appendExact(c);
            } else {
                converter.appendInBracket(c);
            }
            converter.popState();
            converter.pushState(BRACKET);
        }
        @Override
        void finish(GlobToRegex converter) {
            throw converter.syntaxError("Unclosed [");
        }
        @Override
        public String toString() {
            return "BRACKET_FIRST_CHAR";
        }
    };
    private static final State BRACKET = new State() {
        @Override
        void process(GlobToRegex converter, char c) {
            if (c == ']') {
                converter.appendBracketEnd();
                converter.popState();
            } else {
                converter.appendInBracket(c);
            }
        }
        @Override
        void finish(GlobToRegex converter) {
            throw converter.syntaxError("Unclosed [");
        }
        @Override
        public String toString() {
            return "BRACKET";
        }
    };
    private static final State CURLY_BRACE = new State() {
        @Override
        void process(GlobToRegex converter, char c) {
            switch(c) {
                case '?':
                    converter.appendQuestionMark();
                    break;
                case '[':
                    converter.appendBracketStart();
                    converter.pushState(BRACKET_FIRST_CHAR);
                    break;
                case '{':
                    throw converter.syntaxError("{ not allowed in subpattern group");
                case '*':
                    converter.pushState(STAR);
                    break;
                case '\\':
                    converter.pushState(ESCAPE);
                    break;
                case '}':
                    converter.appendCurlyBraceEnd();
                    converter.popState();
                    break;
                case ',':
                    converter.appendSubpatternSeparator();
                    break;
                default:
                    converter.append(c);
            }
        }
        @Override
        void finish(GlobToRegex converter) {
            throw converter.syntaxError("Unclosed {");
        }
        @Override
        public String toString() {
            return "CURLY_BRACE";
        }
    };
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```