##CONTEXT_SIZE=614
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.common.jimfs;
public final class Jimfs {
    public static final String URI_SCHEME = "jimfs";
    private static final Logger LOGGER = Logger.getLogger(Jimfs.class.getName());
    private Jimfs() {
    }
    public static FileSystem newFileSystem() {
        return newFileSystem(newRandomFileSystemName());
    }
    public static FileSystem newFileSystem(String name) {
        return newFileSystem(name, Configuration.forCurrentPlatform());
    }
    public static FileSystem newFileSystem(Configuration configuration) {
        return newFileSystem(newRandomFileSystemName(), configuration);
    }
    public static FileSystem newFileSystem(String name, Configuration configuration) {
        try {
            URI uri = new URI(URI_SCHEME, name, null, null);
            return newFileSystem(uri, configuration);
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException(e);
        }
    }
    static FileSystem newFileSystem(URI uri, Configuration config) {
        checkArgument(URI_SCHEME.equals(uri.getScheme()), "uri (%s) must have scheme %s", uri, URI_SCHEME);
        try {
            JimfsFileSystem fileSystem = JimfsFileSystems.newFileSystem(JimfsFileSystemProvider.instance(), uri, config);
            try {
                ImmutableMap<String, ?> env = ImmutableMap.of(FILE_SYSTEM_KEY, fileSystem);
                FileSystems.newFileSystem(uri, env, SystemJimfsFileSystemProvider.class.getClassLoader());
            } catch (ProviderNotFoundException | ServiceConfigurationError ignore) {
            }
            return fileSystem;
        } catch (IOException e) {
            throw new AssertionError(e);
        }
    }
    static final FileSystemProvider systemProvider = getSystemJimfsProvider();
    private static FileSystemProvider getSystemJimfsProvider() {
        try {
            for (FileSystemProvider provider : FileSystemProvider.installedProviders()) {
                if (provider.getScheme().equals(URI_SCHEME)) {
                    return provider;
                }
            }
            ServiceLoader<FileSystemProvider> loader = ServiceLoader.load(FileSystemProvider.class, SystemJimfsFileSystemProvider.class.getClassLoader());
            for (FileSystemProvider provider : loader) {
                if (provider.getScheme().equals(URI_SCHEME)) {
                    return provider;
                }
            }
        } catch (ProviderNotFoundException | ServiceConfigurationError e) {
            LOGGER.log(Level.INFO, "An exception occurred when attempting to find the system-loaded FileSystemProvider " + "for Jimfs. This likely means that your environment does not support loading " + "services via ServiceLoader or is not configured correctly. This does not prevent " + "using Jimfs, but it will mean that methods that look up via URI such as " + "Paths.get(URI) cannot work.", e);
        }
        return null;
    }
    private static String newRandomFileSystemName() {
        return UUID.randomUUID().toString();
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```