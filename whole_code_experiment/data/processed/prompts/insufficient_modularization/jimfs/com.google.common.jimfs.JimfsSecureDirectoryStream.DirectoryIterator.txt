##CONTEXT_SIZE=1017
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.common.jimfs;
final class JimfsSecureDirectoryStream implements SecureDirectoryStream<Path> {
    private final FileSystemView view;
    private final Filter<? super Path> filter;
    private final FileSystemState fileSystemState;
    private boolean open = true;
    private Iterator<Path> iterator = new DirectoryIterator();
    public JimfsSecureDirectoryStream(FileSystemView view, Filter<? super Path> filter, FileSystemState fileSystemState) {
        this.view = checkNotNull(view);
        this.filter = checkNotNull(filter);
        this.fileSystemState = fileSystemState;
        fileSystemState.register(this);
    }
    private JimfsPath path() {
        return view.getWorkingDirectoryPath();
    }
    public synchronized Iterator<Path> iterator() {
        checkOpen();
        Iterator<Path> result = iterator;
        checkState(result != null, "iterator() has already been called once");
        iterator = null;
        return result;
    }
    public synchronized void close() {
        open = false;
        fileSystemState.unregister(this);
    }
    synchronized void checkOpen() {
        if (!open) {
            throw new ClosedDirectoryStreamException();
        }
    }
    private final class DirectoryIterator extends AbstractIterator<Path> {
        private Iterator<Name> fileNames;
        protected synchronized Path computeNext() {
            checkOpen();
            try {
                if (fileNames == null) {
                    fileNames = view.snapshotWorkingDirectoryEntries().iterator();
                }
                while (fileNames.hasNext()) {
                    Name name = fileNames.next();
                    Path path = view.getWorkingDirectoryPath().resolve(name);
                    if (filter.accept(path)) {
                        return path;
                    }
                }
                return endOfData();
            } catch (IOException e) {
                throw new DirectoryIteratorException(e);
            }
        }
    }
    public static final Filter<Object> ALWAYS_TRUE_FILTER = new Filter<Object>() {
        @Override
        public boolean accept(Object entry) throws IOException {
            return true;
        }
    };
    public SecureDirectoryStream<Path> newDirectoryStream(Path path, LinkOption... options) throws IOException {
        checkOpen();
        JimfsPath checkedPath = checkPath(path);
        return (SecureDirectoryStream<Path>) view.newDirectoryStream(checkedPath, ALWAYS_TRUE_FILTER, Options.getLinkOptions(options), path().resolve(checkedPath));
    }
    public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {
        checkOpen();
        JimfsPath checkedPath = checkPath(path);
        ImmutableSet<OpenOption> opts = Options.getOptionsForChannel(options);
        return new JimfsFileChannel(view.getOrCreateRegularFile(checkedPath, opts), opts, fileSystemState);
    }
    public void deleteFile(Path path) throws IOException {
        checkOpen();
        JimfsPath checkedPath = checkPath(path);
        view.deleteFile(checkedPath, FileSystemView.DeleteMode.NON_DIRECTORY_ONLY);
    }
    public void deleteDirectory(Path path) throws IOException {
        checkOpen();
        JimfsPath checkedPath = checkPath(path);
        view.deleteFile(checkedPath, FileSystemView.DeleteMode.DIRECTORY_ONLY);
    }
    public void move(Path srcPath, SecureDirectoryStream<Path> targetDir, Path targetPath) throws IOException {
        checkOpen();
        JimfsPath checkedSrcPath = checkPath(srcPath);
        JimfsPath checkedTargetPath = checkPath(targetPath);
        if (!(targetDir instanceof JimfsSecureDirectoryStream)) {
            throw new ProviderMismatchException("targetDir isn't a secure directory stream associated with this file system");
        }
        JimfsSecureDirectoryStream checkedTargetDir = (JimfsSecureDirectoryStream) targetDir;
        view.copy(checkedSrcPath, checkedTargetDir.view, checkedTargetPath, ImmutableSet.<CopyOption>of(), true);
    }
    public <V extends FileAttributeView> V getFileAttributeView(Class<V> type) {
        return getFileAttributeView(path().getFileSystem().getPath("."), type);
    }
    public <V extends FileAttributeView> V getFileAttributeView(Path path, Class<V> type, LinkOption... options) {
        checkOpen();
        final JimfsPath checkedPath = checkPath(path);
        final ImmutableSet<LinkOption> optionsSet = Options.getLinkOptions(options);
        return view.getFileAttributeView(new FileLookup() {
            @Override
            public File lookup() throws IOException {
                checkOpen();
                return view.lookUpWithLock(checkedPath, optionsSet).requireExists(checkedPath).file();
            }
        }, type);
    }
    private static JimfsPath checkPath(Path path) {
        if (path instanceof JimfsPath) {
            return (JimfsPath) path;
        }
        throw new ProviderMismatchException("path " + path + " is not associated with a Jimfs file system");
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```