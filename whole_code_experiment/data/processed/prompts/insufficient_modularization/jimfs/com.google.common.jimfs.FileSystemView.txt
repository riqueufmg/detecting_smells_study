##CONTEXT_SIZE=3622
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.common.jimfs;
final class FileSystemView {
    private final JimfsFileStore store;
    private final Directory workingDirectory;
    private final JimfsPath workingDirectoryPath;
    public FileSystemView(JimfsFileStore store, Directory workingDirectory, JimfsPath workingDirectoryPath) {
        this.store = checkNotNull(store);
        this.workingDirectory = checkNotNull(workingDirectory);
        this.workingDirectoryPath = checkNotNull(workingDirectoryPath);
    }
    private boolean isSameFileSystem(FileSystemView other) {
        return store == other.store;
    }
    public FileSystemState state() {
        return store.state();
    }
    private FileTime now() {
        return state().now();
    }
    public JimfsPath getWorkingDirectoryPath() {
        return workingDirectoryPath;
    }
    DirectoryEntry lookUpWithLock(JimfsPath path, Set<? super LinkOption> options) throws IOException {
        store.readLock().lock();
        try {
            return lookUp(path, options);
        } finally {
            store.readLock().unlock();
        }
    }
    private DirectoryEntry lookUp(JimfsPath path, Set<? super LinkOption> options) throws IOException {
        return store.lookUp(workingDirectory, path, options);
    }
    public DirectoryStream<Path> newDirectoryStream(JimfsPath dir, DirectoryStream.Filter<? super Path> filter, Set<? super LinkOption> options, JimfsPath basePathForStream) throws IOException {
        Directory file = (Directory) lookUpWithLock(dir, options).requireDirectory(dir).file();
        FileSystemView view = new FileSystemView(store, file, basePathForStream);
        JimfsSecureDirectoryStream stream = new JimfsSecureDirectoryStream(view, filter, state());
        return store.supportsFeature(Feature.SECURE_DIRECTORY_STREAM) ? stream : new DowngradedDirectoryStream(stream);
    }
    public ImmutableSortedSet<Name> snapshotWorkingDirectoryEntries() {
        store.readLock().lock();
        try {
            ImmutableSortedSet<Name> names = workingDirectory.snapshot();
            workingDirectory.setLastAccessTime(now());
            return names;
        } finally {
            store.readLock().unlock();
        }
    }
    public ImmutableMap<Name, FileTime> snapshotModifiedTimes(JimfsPath path) throws IOException {
        ImmutableMap.Builder<Name, FileTime> modifiedTimes = ImmutableMap.builder();
        store.readLock().lock();
        try {
            Directory dir = (Directory) lookUp(path, Options.FOLLOW_LINKS).requireDirectory(path).file();
            for (DirectoryEntry entry : dir) {
                if (!entry.name().equals(Name.SELF) && !entry.name().equals(Name.PARENT)) {
                    modifiedTimes.put(entry.name(), entry.file().getLastModifiedTime());
                }
            }
            return modifiedTimes.build();
        } finally {
            store.readLock().unlock();
        }
    }
    public boolean isSameFile(JimfsPath path, FileSystemView view2, JimfsPath path2) throws IOException {
        if (!isSameFileSystem(view2)) {
            return false;
        }
        store.readLock().lock();
        try {
            File file = lookUp(path, Options.FOLLOW_LINKS).fileOrNull();
            File file2 = view2.lookUp(path2, Options.FOLLOW_LINKS).fileOrNull();
            return file != null && Objects.equals(file, file2);
        } finally {
            store.readLock().unlock();
        }
    }
    public JimfsPath toRealPath(JimfsPath path, PathService pathService, Set<? super LinkOption> options) throws IOException {
        checkNotNull(path);
        checkNotNull(options);
        store.readLock().lock();
        try {
            DirectoryEntry entry = lookUp(path, options).requireExists(path);
            List<Name> names = new ArrayList<>();
            names.add(entry.name());
            while (!entry.file().isRootDirectory()) {
                entry = entry.directory().entryInParent();
                names.add(entry.name());
            }
            List<Name> reversed = Lists.reverse(names);
            Name root = reversed.remove(0);
            return pathService.createPath(root, reversed);
        } finally {
            store.readLock().unlock();
        }
    }
    public Directory createDirectory(JimfsPath path, FileAttribute<?>... attrs) throws IOException {
        return (Directory) createFile(path, store.directoryCreator(), true, attrs);
    }
    public SymbolicLink createSymbolicLink(JimfsPath path, JimfsPath target, FileAttribute<?>... attrs) throws IOException {
        if (!store.supportsFeature(Feature.SYMBOLIC_LINKS)) {
            throw new UnsupportedOperationException();
        }
        return (SymbolicLink) createFile(path, store.symbolicLinkCreator(target), true, attrs);
    }
    private File createFile(JimfsPath path, Supplier<? extends File> fileCreator, boolean failIfExists, FileAttribute<?>... attrs) throws IOException {
        checkNotNull(path);
        checkNotNull(fileCreator);
        store.writeLock().lock();
        try {
            DirectoryEntry entry = lookUp(path, Options.NOFOLLOW_LINKS);
            if (entry.exists()) {
                if (failIfExists) {
                    throw new FileAlreadyExistsException(path.toString());
                }
                return entry.file();
            }
            Directory parent = entry.directory();
            File newFile = fileCreator.get();
            store.setInitialAttributes(newFile, attrs);
            parent.link(path.name(), newFile);
            parent.setLastModifiedTime(now());
            return newFile;
        } finally {
            store.writeLock().unlock();
        }
    }
    public RegularFile getOrCreateRegularFile(JimfsPath path, Set<OpenOption> options, FileAttribute<?>... attrs) throws IOException {
        checkNotNull(path);
        if (!options.contains(CREATE_NEW)) {
            RegularFile file = lookUpRegularFile(path, options);
            if (file != null) {
                return file;
            }
        }
        if (options.contains(CREATE) || options.contains(CREATE_NEW)) {
            return getOrCreateRegularFileWithWriteLock(path, options, attrs);
        } else {
            throw new NoSuchFileException(path.toString());
        }
    }
    private RegularFile lookUpRegularFile(JimfsPath path, Set<OpenOption> options) throws IOException {
        store.readLock().lock();
        try {
            DirectoryEntry entry = lookUp(path, options);
            if (entry.exists()) {
                File file = entry.file();
                if (!file.isRegularFile()) {
                    throw new FileSystemException(path.toString(), null, "not a regular file");
                }
                return open((RegularFile) file, options);
            } else {
                return null;
            }
        } finally {
            store.readLock().unlock();
        }
    }
    private RegularFile getOrCreateRegularFileWithWriteLock(JimfsPath path, Set<OpenOption> options, FileAttribute<?>[] attrs) throws IOException {
        store.writeLock().lock();
        try {
            File file = createFile(path, store.regularFileCreator(), options.contains(CREATE_NEW), attrs);
            if (!file.isRegularFile()) {
                throw new FileSystemException(path.toString(), null, "not a regular file");
            }
            return open((RegularFile) file, options);
        } finally {
            store.writeLock().unlock();
        }
    }
    private static RegularFile open(RegularFile file, Set<OpenOption> options) {
        if (options.contains(TRUNCATE_EXISTING) && options.contains(WRITE)) {
            file.writeLock().lock();
            try {
                file.truncate(0);
            } finally {
                file.writeLock().unlock();
            }
        }
        file.opened();
        return file;
    }
    public JimfsPath readSymbolicLink(JimfsPath path) throws IOException {
        if (!store.supportsFeature(Feature.SYMBOLIC_LINKS)) {
            throw new UnsupportedOperationException();
        }
        SymbolicLink symbolicLink = (SymbolicLink) lookUpWithLock(path, Options.NOFOLLOW_LINKS).requireSymbolicLink(path).file();
        return symbolicLink.target();
    }
    public void checkAccess(JimfsPath path) throws IOException {
        lookUpWithLock(path, Options.FOLLOW_LINKS).requireExists(path);
    }
    public void link(JimfsPath link, FileSystemView existingView, JimfsPath existing) throws IOException {
        checkNotNull(link);
        checkNotNull(existingView);
        checkNotNull(existing);
        if (!store.supportsFeature(Feature.LINKS)) {
            throw new UnsupportedOperationException();
        }
        if (!isSameFileSystem(existingView)) {
            throw new FileSystemException(link.toString(), existing.toString(), "can't link: source and target are in different file system instances");
        }
        Name linkName = link.name();
        store.writeLock().lock();
        try {
            File existingFile = existingView.lookUp(existing, Options.FOLLOW_LINKS).requireExists(existing).file();
            if (!existingFile.isRegularFile()) {
                throw new FileSystemException(link.toString(), existing.toString(), "can't link: not a regular file");
            }
            Directory linkParent = lookUp(link, Options.NOFOLLOW_LINKS).requireDoesNotExist(link).directory();
            linkParent.link(linkName, existingFile);
            linkParent.setLastModifiedTime(now());
        } finally {
            store.writeLock().unlock();
        }
    }
    public void deleteFile(JimfsPath path, DeleteMode deleteMode) throws IOException {
        store.writeLock().lock();
        try {
            DirectoryEntry entry = lookUp(path, Options.NOFOLLOW_LINKS).requireExists(path);
            delete(entry, deleteMode, path);
        } finally {
            store.writeLock().unlock();
        }
    }
    private void delete(DirectoryEntry entry, DeleteMode deleteMode, JimfsPath pathForException) throws IOException {
        Directory parent = entry.directory();
        File file = entry.file();
        checkDeletable(file, deleteMode, pathForException);
        parent.unlink(entry.name());
        parent.setLastModifiedTime(now());
        file.deleted();
    }
    public enum DeleteMode {
        ANY, NON_DIRECTORY_ONLY, DIRECTORY_ONLY
    }
    private void checkDeletable(File file, DeleteMode mode, Path path) throws IOException {
        if (file.isRootDirectory()) {
            throw new FileSystemException(path.toString(), null, "can't delete root directory");
        }
        if (file.isDirectory()) {
            if (mode == DeleteMode.NON_DIRECTORY_ONLY) {
                throw new FileSystemException(path.toString(), null, "can't delete: is a directory");
            }
            checkEmpty(((Directory) file), path);
        } else if (mode == DeleteMode.DIRECTORY_ONLY) {
            throw new FileSystemException(path.toString(), null, "can't delete: is not a directory");
        }
        if (file == workingDirectory && !path.isAbsolute()) {
            throw new FileSystemException(path.toString(), null, "invalid argument");
        }
    }
    private void checkEmpty(Directory dir, Path pathForException) throws FileSystemException {
        if (!dir.isEmpty()) {
            throw new DirectoryNotEmptyException(pathForException.toString());
        }
    }
    public void copy(JimfsPath source, FileSystemView destView, JimfsPath dest, Set<CopyOption> options, boolean move) throws IOException {
        checkNotNull(source);
        checkNotNull(destView);
        checkNotNull(dest);
        checkNotNull(options);
        boolean sameFileSystem = isSameFileSystem(destView);
        File sourceFile;
        File copyFile = null;
        lockBoth(store.writeLock(), destView.store.writeLock());
        try {
            DirectoryEntry sourceEntry = lookUp(source, options).requireExists(source);
            DirectoryEntry destEntry = destView.lookUp(dest, Options.NOFOLLOW_LINKS);
            Directory sourceParent = sourceEntry.directory();
            sourceFile = sourceEntry.file();
            Directory destParent = destEntry.directory();
            if (move && sourceFile.isDirectory()) {
                if (sameFileSystem) {
                    checkMovable(sourceFile, source);
                    checkNotAncestor(sourceFile, destParent, destView);
                } else {
                    checkDeletable(sourceFile, DeleteMode.ANY, source);
                }
            }
            if (destEntry.exists()) {
                if (destEntry.file().equals(sourceFile)) {
                    return;
                } else if (options.contains(REPLACE_EXISTING)) {
                    destView.delete(destEntry, DeleteMode.ANY, dest);
                } else {
                    throw new FileAlreadyExistsException(dest.toString());
                }
            }
            if (move && sameFileSystem) {
                sourceParent.unlink(source.name());
                sourceParent.setLastModifiedTime(now());
                destParent.link(dest.name(), sourceFile);
                destParent.setLastModifiedTime(now());
            } else {
                AttributeCopyOption attributeCopyOption = AttributeCopyOption.NONE;
                if (move) {
                    attributeCopyOption = AttributeCopyOption.BASIC;
                } else if (options.contains(COPY_ATTRIBUTES)) {
                    attributeCopyOption = sameFileSystem ? AttributeCopyOption.ALL : AttributeCopyOption.BASIC;
                }
                copyFile = destView.store.copyWithoutContent(sourceFile, attributeCopyOption);
                destParent.link(dest.name(), copyFile);
                destParent.setLastModifiedTime(now());
                lockSourceAndCopy(sourceFile, copyFile);
                if (move) {
                    delete(sourceEntry, DeleteMode.ANY, source);
                }
            }
        } finally {
            destView.store.writeLock().unlock();
            store.writeLock().unlock();
        }
        if (copyFile != null) {
            try {
                sourceFile.copyContentTo(copyFile);
            } finally {
                unlockSourceAndCopy(sourceFile, copyFile);
            }
        }
    }
    private void checkMovable(File file, JimfsPath path) throws FileSystemException {
        if (file.isRootDirectory()) {
            throw new FileSystemException(path.toString(), null, "can't move root directory");
        }
    }
    private static void lockBoth(Lock sourceWriteLock, Lock destWriteLock) {
        while (true) {
            sourceWriteLock.lock();
            if (destWriteLock.tryLock()) {
                return;
            } else {
                sourceWriteLock.unlock();
            }
            destWriteLock.lock();
            if (sourceWriteLock.tryLock()) {
                return;
            } else {
                destWriteLock.unlock();
            }
        }
    }
    private void checkNotAncestor(File source, Directory destParent, FileSystemView destView) throws IOException {
        if (!isSameFileSystem(destView)) {
            return;
        }
        Directory current = destParent;
        while (true) {
            if (current.equals(source)) {
                throw new IOException("invalid argument: can't move directory into a subdirectory of itself");
            }
            if (current.isRootDirectory()) {
                return;
            } else {
                current = current.parent();
            }
        }
    }
    private void lockSourceAndCopy(File sourceFile, File copyFile) {
        sourceFile.opened();
        ReadWriteLock sourceLock = sourceFile.contentLock();
        if (sourceLock != null) {
            sourceLock.readLock().lock();
        }
        ReadWriteLock copyLock = copyFile.contentLock();
        if (copyLock != null) {
            copyLock.writeLock().lock();
        }
    }
    private void unlockSourceAndCopy(File sourceFile, File copyFile) {
        ReadWriteLock sourceLock = sourceFile.contentLock();
        if (sourceLock != null) {
            sourceLock.readLock().unlock();
        }
        ReadWriteLock copyLock = copyFile.contentLock();
        if (copyLock != null) {
            copyLock.writeLock().unlock();
        }
        sourceFile.closed();
    }
    public <V extends FileAttributeView> V getFileAttributeView(FileLookup lookup, Class<V> type) {
        return store.getFileAttributeView(lookup, type);
    }
    public <V extends FileAttributeView> V getFileAttributeView(final JimfsPath path, Class<V> type, final Set<? super LinkOption> options) {
        return store.getFileAttributeView(new FileLookup() {
            @Override
            public File lookup() throws IOException {
                return lookUpWithLock(path, options).requireExists(path).file();
            }
        }, type);
    }
    public <A extends BasicFileAttributes> A readAttributes(JimfsPath path, Class<A> type, Set<? super LinkOption> options) throws IOException {
        File file = lookUpWithLock(path, options).requireExists(path).file();
        return store.readAttributes(file, type);
    }
    public ImmutableMap<String, Object> readAttributes(JimfsPath path, String attributes, Set<? super LinkOption> options) throws IOException {
        File file = lookUpWithLock(path, options).requireExists(path).file();
        return store.readAttributes(file, attributes);
    }
    public void setAttribute(JimfsPath path, String attribute, Object value, Set<? super LinkOption> options) throws IOException {
        File file = lookUpWithLock(path, options).requireExists(path).file();
        store.setAttribute(file, attribute, value);
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```