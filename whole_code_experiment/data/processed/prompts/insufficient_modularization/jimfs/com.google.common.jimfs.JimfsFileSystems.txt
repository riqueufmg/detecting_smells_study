##CONTEXT_SIZE=679
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.common.jimfs;
final class JimfsFileSystems {
    private JimfsFileSystems() {
    }
    private static final Runnable DO_NOTHING = new Runnable() {
        @Override
        public void run() {
        }
    };
    private static Runnable removeFileSystemRunnable(URI uri) {
        if (Jimfs.systemProvider == null) {
            return DO_NOTHING;
        }
        try {
            Method method = Jimfs.systemProvider.getClass().getDeclaredMethod("removeFileSystemRunnable", URI.class);
            return (Runnable) method.invoke(null, uri);
        } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
            throw new RuntimeException("Unable to get Runnable for removing the FileSystem from the cache when it is closed", e);
        }
    }
    public static JimfsFileSystem newFileSystem(JimfsFileSystemProvider provider, URI uri, Configuration config) throws IOException {
        PathService pathService = new PathService(config);
        FileSystemState state = new FileSystemState(config.fileTimeSource, removeFileSystemRunnable(uri));
        JimfsFileStore fileStore = createFileStore(config, pathService, state);
        FileSystemView defaultView = createDefaultView(config, fileStore, pathService);
        WatchServiceConfiguration watchServiceConfig = config.watchServiceConfig;
        JimfsFileSystem fileSystem = new JimfsFileSystem(provider, uri, fileStore, pathService, defaultView, watchServiceConfig);
        pathService.setFileSystem(fileSystem);
        return fileSystem;
    }
    private static JimfsFileStore createFileStore(Configuration config, PathService pathService, FileSystemState state) {
        AttributeService attributeService = new AttributeService(config);
        HeapDisk disk = new HeapDisk(config);
        FileFactory fileFactory = new FileFactory(disk, config.fileTimeSource);
        Map<Name, Directory> roots = new HashMap<>();
        for (String root : config.roots) {
            JimfsPath path = pathService.parsePath(root);
            if (!path.isAbsolute() && path.getNameCount() == 0) {
                throw new IllegalArgumentException("Invalid root path: " + root);
            }
            Name rootName = path.root();
            Directory rootDir = fileFactory.createRootDirectory(rootName);
            attributeService.setInitialAttributes(rootDir);
            roots.put(rootName, rootDir);
        }
        return new JimfsFileStore(new FileTree(roots), fileFactory, disk, attributeService, config.supportedFeatures, state);
    }
    private static FileSystemView createDefaultView(Configuration config, JimfsFileStore fileStore, PathService pathService) throws IOException {
        JimfsPath workingDirPath = pathService.parsePath(config.workingDirectory);
        Directory dir = fileStore.getRoot(workingDirPath.root());
        if (dir == null) {
            throw new IllegalArgumentException("Invalid working dir path: " + workingDirPath);
        }
        for (Name name : workingDirPath.names()) {
            Directory newDir = fileStore.directoryCreator().get();
            fileStore.setInitialAttributes(newDir);
            dir.link(name, newDir);
            dir = newDir;
        }
        return new FileSystemView(fileStore, dir, workingDirPath);
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```