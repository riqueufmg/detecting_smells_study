##CONTEXT_SIZE=2910
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.common.jimfs;
final class JimfsFileChannel extends FileChannel {
    private final Set<Thread> blockingThreads = new HashSet<Thread>();
    private final RegularFile file;
    private final FileSystemState fileSystemState;
    private final boolean read;
    private final boolean write;
    private final boolean append;
    private long position;
    public JimfsFileChannel(RegularFile file, Set<OpenOption> options, FileSystemState fileSystemState) {
        this.file = file;
        this.fileSystemState = fileSystemState;
        this.read = options.contains(READ);
        this.write = options.contains(WRITE);
        this.append = options.contains(APPEND);
        fileSystemState.register(this);
    }
    public AsynchronousFileChannel asAsynchronousFileChannel(ExecutorService executor) {
        return new JimfsAsynchronousFileChannel(this, executor);
    }
    void checkReadable() {
        if (!read) {
            throw new NonReadableChannelException();
        }
    }
    void checkWritable() {
        if (!write) {
            throw new NonWritableChannelException();
        }
    }
    void checkOpen() throws ClosedChannelException {
        if (!isOpen()) {
            throw new ClosedChannelException();
        }
    }
    private boolean beginBlocking() {
        begin();
        synchronized (blockingThreads) {
            if (isOpen()) {
                blockingThreads.add(Thread.currentThread());
                return true;
            }
            return false;
        }
    }
    private void endBlocking(boolean completed) throws AsynchronousCloseException {
        synchronized (blockingThreads) {
            blockingThreads.remove(Thread.currentThread());
        }
        end(completed);
    }
    public int read(ByteBuffer dst) throws IOException {
        checkNotNull(dst);
        checkOpen();
        checkReadable();
        int read = 0;
        synchronized (this) {
            boolean completed = false;
            try {
                if (!beginBlocking()) {
                    return 0;
                }
                file.readLock().lockInterruptibly();
                try {
                    read = file.read(position, dst);
                    if (read != -1) {
                        position += read;
                    }
                    file.setLastAccessTime(fileSystemState.now());
                    completed = true;
                } finally {
                    file.readLock().unlock();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                endBlocking(completed);
            }
        }
        return read;
    }
    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {
        checkPositionIndexes(offset, offset + length, dsts.length);
        List<ByteBuffer> buffers = Arrays.asList(dsts).subList(offset, offset + length);
        Util.checkNoneNull(buffers);
        checkOpen();
        checkReadable();
        long read = 0;
        synchronized (this) {
            boolean completed = false;
            try {
                if (!beginBlocking()) {
                    return 0;
                }
                file.readLock().lockInterruptibly();
                try {
                    read = file.read(position, buffers);
                    if (read != -1) {
                        position += read;
                    }
                    file.setLastAccessTime(fileSystemState.now());
                    completed = true;
                } finally {
                    file.readLock().unlock();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                endBlocking(completed);
            }
        }
        return read;
    }
    public int read(ByteBuffer dst, long position) throws IOException {
        checkNotNull(dst);
        Util.checkNotNegative(position, "position");
        checkOpen();
        checkReadable();
        int read = 0;
        boolean completed = false;
        try {
            if (!beginBlocking()) {
                return 0;
            }
            file.readLock().lockInterruptibly();
            try {
                read = file.read(position, dst);
                file.setLastAccessTime(fileSystemState.now());
                completed = true;
            } finally {
                file.readLock().unlock();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            endBlocking(completed);
        }
        return read;
    }
    public int write(ByteBuffer src) throws IOException {
        checkNotNull(src);
        checkOpen();
        checkWritable();
        int written = 0;
        synchronized (this) {
            boolean completed = false;
            try {
                if (!beginBlocking()) {
                    return 0;
                }
                file.writeLock().lockInterruptibly();
                try {
                    if (append) {
                        position = file.size();
                    }
                    written = file.write(position, src);
                    position += written;
                    file.setLastModifiedTime(fileSystemState.now());
                    completed = true;
                } finally {
                    file.writeLock().unlock();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                endBlocking(completed);
            }
        }
        return written;
    }
    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {
        checkPositionIndexes(offset, offset + length, srcs.length);
        List<ByteBuffer> buffers = Arrays.asList(srcs).subList(offset, offset + length);
        Util.checkNoneNull(buffers);
        checkOpen();
        checkWritable();
        long written = 0;
        synchronized (this) {
            boolean completed = false;
            try {
                if (!beginBlocking()) {
                    return 0;
                }
                file.writeLock().lockInterruptibly();
                try {
                    if (append) {
                        position = file.size();
                    }
                    written = file.write(position, buffers);
                    position += written;
                    file.setLastModifiedTime(fileSystemState.now());
                    completed = true;
                } finally {
                    file.writeLock().unlock();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                endBlocking(completed);
            }
        }
        return written;
    }
    public int write(ByteBuffer src, long position) throws IOException {
        checkNotNull(src);
        Util.checkNotNegative(position, "position");
        checkOpen();
        checkWritable();
        int written = 0;
        if (append) {
            synchronized (this) {
                boolean completed = false;
                try {
                    if (!beginBlocking()) {
                        return 0;
                    }
                    file.writeLock().lockInterruptibly();
                    try {
                        position = file.sizeWithoutLocking();
                        written = file.write(position, src);
                        this.position = position + written;
                        file.setLastModifiedTime(fileSystemState.now());
                        completed = true;
                    } finally {
                        file.writeLock().unlock();
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    endBlocking(completed);
                }
            }
        } else {
            boolean completed = false;
            try {
                if (!beginBlocking()) {
                    return 0;
                }
                file.writeLock().lockInterruptibly();
                try {
                    written = file.write(position, src);
                    file.setLastModifiedTime(fileSystemState.now());
                    completed = true;
                } finally {
                    file.writeLock().unlock();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                endBlocking(completed);
            }
        }
        return written;
    }
    public long position() throws IOException {
        checkOpen();
        long pos;
        synchronized (this) {
            boolean completed = false;
            try {
                begin();
                if (!isOpen()) {
                    return 0;
                }
                pos = this.position;
                completed = true;
            } finally {
                end(completed);
            }
        }
        return pos;
    }
    public FileChannel position(long newPosition) throws IOException {
        Util.checkNotNegative(newPosition, "newPosition");
        checkOpen();
        synchronized (this) {
            boolean completed = false;
            try {
                begin();
                if (!isOpen()) {
                    return this;
                }
                this.position = newPosition;
                completed = true;
            } finally {
                end(completed);
            }
        }
        return this;
    }
    public long size() throws IOException {
        checkOpen();
        long size = 0;
        boolean completed = false;
        try {
            if (!beginBlocking()) {
                return 0;
            }
            file.readLock().lockInterruptibly();
            try {
                size = file.sizeWithoutLocking();
                completed = true;
            } finally {
                file.readLock().unlock();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            endBlocking(completed);
        }
        return size;
    }
    public FileChannel truncate(long size) throws IOException {
        Util.checkNotNegative(size, "size");
        checkOpen();
        checkWritable();
        synchronized (this) {
            boolean completed = false;
            try {
                if (!beginBlocking()) {
                    return this;
                }
                file.writeLock().lockInterruptibly();
                try {
                    file.truncate(size);
                    if (position > size) {
                        position = size;
                    }
                    file.setLastModifiedTime(fileSystemState.now());
                    completed = true;
                } finally {
                    file.writeLock().unlock();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                endBlocking(completed);
            }
        }
        return this;
    }
    public void force(boolean metaData) throws IOException {
        checkOpen();
        boolean completed = false;
        try {
            begin();
            completed = true;
        } finally {
            end(completed);
        }
    }
    public long transferTo(long position, long count, WritableByteChannel target) throws IOException {
        checkNotNull(target);
        Util.checkNotNegative(position, "position");
        Util.checkNotNegative(count, "count");
        checkOpen();
        checkReadable();
        long transferred = 0;
        boolean completed = false;
        try {
            if (!beginBlocking()) {
                return 0;
            }
            file.readLock().lockInterruptibly();
            try {
                transferred = file.transferTo(position, count, target);
                file.setLastAccessTime(fileSystemState.now());
                completed = true;
            } finally {
                file.readLock().unlock();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            endBlocking(completed);
        }
        return transferred;
    }
    public long transferFrom(ReadableByteChannel src, long position, long count) throws IOException {
        checkNotNull(src);
        Util.checkNotNegative(position, "position");
        Util.checkNotNegative(count, "count");
        checkOpen();
        checkWritable();
        long transferred = 0;
        if (append) {
            synchronized (this) {
                boolean completed = false;
                try {
                    if (!beginBlocking()) {
                        return 0;
                    }
                    file.writeLock().lockInterruptibly();
                    try {
                        position = file.sizeWithoutLocking();
                        transferred = file.transferFrom(src, position, count);
                        this.position = position + transferred;
                        file.setLastModifiedTime(fileSystemState.now());
                        completed = true;
                    } finally {
                        file.writeLock().unlock();
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    endBlocking(completed);
                }
            }
        } else {
            boolean completed = false;
            try {
                if (!beginBlocking()) {
                    return 0;
                }
                file.writeLock().lockInterruptibly();
                try {
                    transferred = file.transferFrom(src, position, count);
                    file.setLastModifiedTime(fileSystemState.now());
                    completed = true;
                } finally {
                    file.writeLock().unlock();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                endBlocking(completed);
            }
        }
        return transferred;
    }
    public MappedByteBuffer map(MapMode mode, long position, long size) throws IOException {
        throw new UnsupportedOperationException();
    }
    public FileLock lock(long position, long size, boolean shared) throws IOException {
        checkLockArguments(position, size, shared);
        boolean completed = false;
        try {
            begin();
            completed = true;
            return new FakeFileLock(this, position, size, shared);
        } finally {
            try {
                end(completed);
            } catch (ClosedByInterruptException e) {
                throw new FileLockInterruptionException();
            }
        }
    }
    public FileLock tryLock(long position, long size, boolean shared) throws IOException {
        checkLockArguments(position, size, shared);
        return new FakeFileLock(this, position, size, shared);
    }
    private void checkLockArguments(long position, long size, boolean shared) throws IOException {
        Util.checkNotNegative(position, "position");
        Util.checkNotNegative(size, "size");
        checkOpen();
        if (shared) {
            checkReadable();
        } else {
            checkWritable();
        }
    }
    protected void implCloseChannel() {
        try {
            synchronized (blockingThreads) {
                for (Thread thread : blockingThreads) {
                    thread.interrupt();
                }
            }
        } finally {
            fileSystemState.unregister(this);
            file.closed();
        }
    }
    static final class FakeFileLock extends FileLock {
        private final AtomicBoolean valid = new AtomicBoolean(true);
        public FakeFileLock(FileChannel channel, long position, long size, boolean shared) {
            super(channel, position, size, shared);
        }
        public FakeFileLock(AsynchronousFileChannel channel, long position, long size, boolean shared) {
            super(channel, position, size, shared);
        }
        public boolean isValid() {
            return valid.get();
        }
        public void release() throws IOException {
            valid.set(false);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```