##CONTEXT_SIZE=915
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.common.jimfs;
final class FileTree {
    private static final int MAX_SYMBOLIC_LINK_DEPTH = 40;
    private static final ImmutableList<Name> EMPTY_PATH_NAMES = ImmutableList.of(Name.SELF);
    private final ImmutableSortedMap<Name, Directory> roots;
    FileTree(Map<Name, Directory> roots) {
        this.roots = ImmutableSortedMap.copyOf(roots, Name.canonicalComparator());
    }
    public ImmutableSortedSet<Name> getRootDirectoryNames() {
        return roots.keySet();
    }
    public DirectoryEntry getRoot(Name name) {
        Directory dir = roots.get(name);
        return dir == null ? null : dir.entryInParent();
    }
    public DirectoryEntry lookUp(File workingDirectory, JimfsPath path, Set<? super LinkOption> options) throws IOException {
        checkNotNull(path);
        checkNotNull(options);
        DirectoryEntry result = lookUp(workingDirectory, path, options, 0);
        if (result == null) {
            throw new NoSuchFileException(path.toString());
        }
        return result;
    }
    private DirectoryEntry lookUp(File dir, JimfsPath path, Set<? super LinkOption> options, int linkDepth) throws IOException {
        ImmutableList<Name> names = path.names();
        if (path.isAbsolute()) {
            DirectoryEntry entry = getRoot(path.root());
            if (entry == null) {
                return null;
            } else if (names.isEmpty()) {
                return entry;
            } else {
                dir = entry.file();
            }
        } else if (isEmpty(names)) {
            names = EMPTY_PATH_NAMES;
        }
        return lookUp(dir, names, options, linkDepth);
    }
    private DirectoryEntry lookUp(File dir, Iterable<Name> names, Set<? super LinkOption> options, int linkDepth) throws IOException {
        Iterator<Name> nameIterator = names.iterator();
        Name name = nameIterator.next();
        while (nameIterator.hasNext()) {
            Directory directory = toDirectory(dir);
            if (directory == null) {
                return null;
            }
            DirectoryEntry entry = directory.get(name);
            if (entry == null) {
                return null;
            }
            File file = entry.file();
            if (file.isSymbolicLink()) {
                DirectoryEntry linkResult = followSymbolicLink(dir, (SymbolicLink) file, linkDepth);
                if (linkResult == null) {
                    return null;
                }
                dir = linkResult.fileOrNull();
            } else {
                dir = file;
            }
            name = nameIterator.next();
        }
        return lookUpLast(dir, name, options, linkDepth);
    }
    private DirectoryEntry lookUpLast(@Nullable File dir, Name name, Set<? super LinkOption> options, int linkDepth) throws IOException {
        Directory directory = toDirectory(dir);
        if (directory == null) {
            return null;
        }
        DirectoryEntry entry = directory.get(name);
        if (entry == null) {
            return new DirectoryEntry(directory, name, null);
        }
        File file = entry.file();
        if (!options.contains(LinkOption.NOFOLLOW_LINKS) && file.isSymbolicLink()) {
            return followSymbolicLink(dir, (SymbolicLink) file, linkDepth);
        }
        return getRealEntry(entry);
    }
    private DirectoryEntry followSymbolicLink(File dir, SymbolicLink link, int linkDepth) throws IOException {
        if (linkDepth >= MAX_SYMBOLIC_LINK_DEPTH) {
            throw new IOException("too many levels of symbolic links");
        }
        return lookUp(dir, link.target(), Options.FOLLOW_LINKS, linkDepth + 1);
    }
    private DirectoryEntry getRealEntry(DirectoryEntry entry) {
        Name name = entry.name();
        if (name.equals(Name.SELF) || name.equals(Name.PARENT)) {
            Directory dir = toDirectory(entry.file());
            assert dir != null;
            return dir.entryInParent();
        } else {
            return entry;
        }
    }
    private Directory toDirectory(@Nullable File file) {
        return file == null || !file.isDirectory() ? null : (Directory) file;
    }
    private static boolean isEmpty(ImmutableList<Name> names) {
        return names.isEmpty() || (names.size() == 1 && names.get(0).toString().isEmpty());
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```