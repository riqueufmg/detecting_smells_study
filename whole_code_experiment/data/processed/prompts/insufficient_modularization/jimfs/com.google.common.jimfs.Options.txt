##CONTEXT_SIZE=696
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.common.jimfs;
final class Options {
    private Options() {
    }
    public static final ImmutableSet<LinkOption> NOFOLLOW_LINKS = ImmutableSet.of(LinkOption.NOFOLLOW_LINKS);
    public static final ImmutableSet<LinkOption> FOLLOW_LINKS = ImmutableSet.of();
    private static final ImmutableSet<OpenOption> DEFAULT_READ = ImmutableSet.<OpenOption>of(READ);
    private static final ImmutableSet<OpenOption> DEFAULT_READ_NOFOLLOW_LINKS = ImmutableSet.<OpenOption>of(READ, LinkOption.NOFOLLOW_LINKS);
    private static final ImmutableSet<OpenOption> DEFAULT_WRITE = ImmutableSet.<OpenOption>of(WRITE, CREATE, TRUNCATE_EXISTING);
    public static ImmutableSet<LinkOption> getLinkOptions(LinkOption... options) {
        return options.length == 0 ? FOLLOW_LINKS : NOFOLLOW_LINKS;
    }
    public static ImmutableSet<OpenOption> getOptionsForChannel(Set<? extends OpenOption> options) {
        if (options.isEmpty()) {
            return DEFAULT_READ;
        }
        boolean append = options.contains(APPEND);
        boolean write = append || options.contains(WRITE);
        boolean read = !write || options.contains(READ);
        if (read) {
            if (append) {
                throw new UnsupportedOperationException("'READ' + 'APPEND' not allowed");
            }
            if (!write) {
                return options.contains(LinkOption.NOFOLLOW_LINKS) ? DEFAULT_READ_NOFOLLOW_LINKS : DEFAULT_READ;
            }
        }
        return addWrite(options);
    }
    public static ImmutableSet<OpenOption> getOptionsForInputStream(OpenOption... options) {
        boolean nofollowLinks = false;
        for (OpenOption option : options) {
            if (checkNotNull(option) != READ) {
                if (option == LinkOption.NOFOLLOW_LINKS) {
                    nofollowLinks = true;
                } else {
                    throw new UnsupportedOperationException("'" + option + "' not allowed");
                }
            }
        }
        return (ImmutableSet<OpenOption>) (ImmutableSet<?>) (nofollowLinks ? NOFOLLOW_LINKS : FOLLOW_LINKS);
    }
    public static ImmutableSet<OpenOption> getOptionsForOutputStream(OpenOption... options) {
        if (options.length == 0) {
            return DEFAULT_WRITE;
        }
        ImmutableSet<OpenOption> result = addWrite(Arrays.asList(options));
        if (result.contains(READ)) {
            throw new UnsupportedOperationException("'READ' not allowed");
        }
        return result;
    }
    private static ImmutableSet<OpenOption> addWrite(Collection<? extends OpenOption> options) {
        return options.contains(WRITE) ? ImmutableSet.copyOf(options) : ImmutableSet.<OpenOption>builder().add(WRITE).addAll(options).build();
    }
    public static ImmutableSet<CopyOption> getMoveOptions(CopyOption... options) {
        return ImmutableSet.copyOf(Lists.asList(LinkOption.NOFOLLOW_LINKS, options));
    }
    public static ImmutableSet<CopyOption> getCopyOptions(CopyOption... options) {
        ImmutableSet<CopyOption> result = ImmutableSet.copyOf(options);
        if (result.contains(ATOMIC_MOVE)) {
            throw new UnsupportedOperationException("'ATOMIC_MOVE' not allowed");
        }
        return result;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```