##CONTEXT_SIZE=2477
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.common.jimfs;
public final class Configuration {
    public static Configuration unix() {
        return UnixHolder.UNIX;
    }
    private static final class UnixHolder {
        private static final Configuration UNIX = Configuration.builder(PathType.unix()).setDisplayName("Unix").setRoots("/").setWorkingDirectory("/work").setAttributeViews("basic").setSupportedFeatures(LINKS, SYMBOLIC_LINKS, SECURE_DIRECTORY_STREAM, FILE_CHANNEL).build();
    }
    public static Configuration osX() {
        return OsxHolder.OS_X;
    }
    private static final class OsxHolder {
        private static final Configuration OS_X = unix().toBuilder().setDisplayName("OSX").setNameDisplayNormalization(NFC).setNameCanonicalNormalization(NFD, CASE_FOLD_ASCII).setSupportedFeatures(LINKS, SYMBOLIC_LINKS, FILE_CHANNEL).build();
    }
    public static Configuration windows() {
        return WindowsHolder.WINDOWS;
    }
    private static final class WindowsHolder {
        private static final Configuration WINDOWS = Configuration.builder(PathType.windows()).setDisplayName("Windows").setRoots("C:\\").setWorkingDirectory("C:\\work").setNameCanonicalNormalization(CASE_FOLD_ASCII).setPathEqualityUsesCanonicalForm(true).setAttributeViews("basic").setSupportedFeatures(LINKS, SYMBOLIC_LINKS, FILE_CHANNEL).build();
    }
    public static Configuration forCurrentPlatform() {
        String os = System.getProperty("os.name");
        if (os.contains("Windows")) {
            return windows();
        } else if (os.contains("OS X")) {
            return osX();
        } else {
            return unix();
        }
    }
    public static Builder builder(PathType pathType) {
        return new Builder(pathType);
    }
    final PathType pathType;
    final ImmutableSet<PathNormalization> nameDisplayNormalization;
    final ImmutableSet<PathNormalization> nameCanonicalNormalization;
    final boolean pathEqualityUsesCanonicalForm;
    final int blockSize;
    final long maxSize;
    final long maxCacheSize;
    final ImmutableSet<String> attributeViews;
    final ImmutableSet<AttributeProvider> attributeProviders;
    final ImmutableMap<String, Object> defaultAttributeValues;
    final FileTimeSource fileTimeSource;
    final WatchServiceConfiguration watchServiceConfig;
    final ImmutableSet<String> roots;
    final String workingDirectory;
    final ImmutableSet<Feature> supportedFeatures;
    private final String displayName;
    private Configuration(Builder builder) {
        this.pathType = builder.pathType;
        this.nameDisplayNormalization = builder.nameDisplayNormalization;
        this.nameCanonicalNormalization = builder.nameCanonicalNormalization;
        this.pathEqualityUsesCanonicalForm = builder.pathEqualityUsesCanonicalForm;
        this.blockSize = builder.blockSize;
        this.maxSize = builder.maxSize;
        this.maxCacheSize = builder.maxCacheSize;
        this.attributeViews = builder.attributeViews;
        this.attributeProviders = builder.attributeProviders == null ? ImmutableSet.<AttributeProvider>of() : ImmutableSet.copyOf(builder.attributeProviders);
        this.defaultAttributeValues = builder.defaultAttributeValues == null ? ImmutableMap.<String, Object>of() : ImmutableMap.copyOf(builder.defaultAttributeValues);
        this.fileTimeSource = builder.fileTimeSource;
        this.watchServiceConfig = builder.watchServiceConfig;
        this.roots = builder.roots;
        this.workingDirectory = builder.workingDirectory;
        this.supportedFeatures = builder.supportedFeatures;
        this.displayName = builder.displayName;
    }
    public String toString() {
        if (displayName != null) {
            return MoreObjects.toStringHelper(this).addValue(displayName).toString();
        }
        MoreObjects.ToStringHelper helper = MoreObjects.toStringHelper(this).add("pathType", pathType).add("roots", roots).add("supportedFeatures", supportedFeatures).add("workingDirectory", workingDirectory);
        if (!nameDisplayNormalization.isEmpty()) {
            helper.add("nameDisplayNormalization", nameDisplayNormalization);
        }
        if (!nameCanonicalNormalization.isEmpty()) {
            helper.add("nameCanonicalNormalization", nameCanonicalNormalization);
        }
        helper.add("pathEqualityUsesCanonicalForm", pathEqualityUsesCanonicalForm).add("blockSize", blockSize).add("maxSize", maxSize);
        if (maxCacheSize != Builder.DEFAULT_MAX_CACHE_SIZE) {
            helper.add("maxCacheSize", maxCacheSize);
        }
        if (!attributeViews.isEmpty()) {
            helper.add("attributeViews", attributeViews);
        }
        if (!attributeProviders.isEmpty()) {
            helper.add("attributeProviders", attributeProviders);
        }
        if (!defaultAttributeValues.isEmpty()) {
            helper.add("defaultAttributeValues", defaultAttributeValues);
        }
        helper.add("fileTimeSource", fileTimeSource);
        if (watchServiceConfig != WatchServiceConfiguration.DEFAULT) {
            helper.add("watchServiceConfig", watchServiceConfig);
        }
        return helper.toString();
    }
    public Builder toBuilder() {
        return new Builder(this);
    }
    public static final class Builder {
        public static final int DEFAULT_BLOCK_SIZE = 8192;
        public static final long DEFAULT_MAX_SIZE = 4L * 1024 * 1024 * 1024;
        public static final long DEFAULT_MAX_CACHE_SIZE = -1;
        private final PathType pathType;
        private ImmutableSet<PathNormalization> nameDisplayNormalization = ImmutableSet.of();
        private ImmutableSet<PathNormalization> nameCanonicalNormalization = ImmutableSet.of();
        private boolean pathEqualityUsesCanonicalForm = false;
        private int blockSize = DEFAULT_BLOCK_SIZE;
        private long maxSize = DEFAULT_MAX_SIZE;
        private long maxCacheSize = DEFAULT_MAX_CACHE_SIZE;
        private ImmutableSet<String> attributeViews = ImmutableSet.of();
        private Set<AttributeProvider> attributeProviders = null;
        private Map<String, Object> defaultAttributeValues;
        private FileTimeSource fileTimeSource = SystemFileTimeSource.INSTANCE;
        private WatchServiceConfiguration watchServiceConfig = WatchServiceConfiguration.DEFAULT;
        private ImmutableSet<String> roots = ImmutableSet.of();
        private String workingDirectory;
        private ImmutableSet<Feature> supportedFeatures = ImmutableSet.of();
        private String displayName;
        private Builder(PathType pathType) {
            this.pathType = checkNotNull(pathType);
        }
        private Builder(Configuration configuration) {
            this.pathType = configuration.pathType;
            this.nameDisplayNormalization = configuration.nameDisplayNormalization;
            this.nameCanonicalNormalization = configuration.nameCanonicalNormalization;
            this.pathEqualityUsesCanonicalForm = configuration.pathEqualityUsesCanonicalForm;
            this.blockSize = configuration.blockSize;
            this.maxSize = configuration.maxSize;
            this.maxCacheSize = configuration.maxCacheSize;
            this.attributeViews = configuration.attributeViews;
            this.attributeProviders = configuration.attributeProviders.isEmpty() ? null : new HashSet<>(configuration.attributeProviders);
            this.defaultAttributeValues = configuration.defaultAttributeValues.isEmpty() ? null : new HashMap<>(configuration.defaultAttributeValues);
            this.fileTimeSource = configuration.fileTimeSource;
            this.watchServiceConfig = configuration.watchServiceConfig;
            this.roots = configuration.roots;
            this.workingDirectory = configuration.workingDirectory;
            this.supportedFeatures = configuration.supportedFeatures;
        }
        public Builder setNameDisplayNormalization(PathNormalization first, PathNormalization... more) {
            this.nameDisplayNormalization = checkNormalizations(Lists.asList(first, more));
            return this;
        }
        public Builder setNameCanonicalNormalization(PathNormalization first, PathNormalization... more) {
            this.nameCanonicalNormalization = checkNormalizations(Lists.asList(first, more));
            return this;
        }
        private ImmutableSet<PathNormalization> checkNormalizations(List<PathNormalization> normalizations) {
            PathNormalization none = null;
            PathNormalization normalization = null;
            PathNormalization caseFold = null;
            for (PathNormalization n : normalizations) {
                checkNotNull(n);
                checkNormalizationNotSet(n, none);
                switch(n) {
                    case NONE:
                        none = n;
                        break;
                    case NFC:
                    case NFD:
                        checkNormalizationNotSet(n, normalization);
                        normalization = n;
                        break;
                    case CASE_FOLD_UNICODE:
                    case CASE_FOLD_ASCII:
                        checkNormalizationNotSet(n, caseFold);
                        caseFold = n;
                        break;
                    default:
                        throw new AssertionError();
                }
            }
            if (none != null) {
                return ImmutableSet.of();
            }
            return Sets.immutableEnumSet(normalizations);
        }
        private static void checkNormalizationNotSet(PathNormalization n, @Nullable PathNormalization set) {
            if (set != null) {
                throw new IllegalArgumentException("can't set normalization " + n + ": normalization " + set + " already set");
            }
        }
        public Builder setPathEqualityUsesCanonicalForm(boolean useCanonicalForm) {
            this.pathEqualityUsesCanonicalForm = useCanonicalForm;
            return this;
        }
        public Builder setBlockSize(int blockSize) {
            checkArgument(blockSize > 0, "blockSize (%s) must be positive", blockSize);
            this.blockSize = blockSize;
            return this;
        }
        public Builder setMaxSize(long maxSize) {
            checkArgument(maxSize > 0, "maxSize (%s) must be positive", maxSize);
            this.maxSize = maxSize;
            return this;
        }
        public Builder setMaxCacheSize(long maxCacheSize) {
            checkArgument(maxCacheSize >= 0, "maxCacheSize (%s) may not be negative", maxCacheSize);
            this.maxCacheSize = maxCacheSize;
            return this;
        }
        public Builder setAttributeViews(String first, String... more) {
            this.attributeViews = ImmutableSet.copyOf(Lists.asList(first, more));
            return this;
        }
        public Builder addAttributeProvider(AttributeProvider provider) {
            checkNotNull(provider);
            if (attributeProviders == null) {
                attributeProviders = new HashSet<>();
            }
            attributeProviders.add(provider);
            return this;
        }
        public Builder setDefaultAttributeValue(String attribute, Object value) {
            checkArgument(ATTRIBUTE_PATTERN.matcher(attribute).matches(), "attribute (%s) must be of the form \"view:attribute\"", attribute);
            checkNotNull(value);
            if (defaultAttributeValues == null) {
                defaultAttributeValues = new HashMap<>();
            }
            defaultAttributeValues.put(attribute, value);
            return this;
        }
        private static final Pattern ATTRIBUTE_PATTERN = Pattern.compile("[^:]+:[^:]+");
        public Builder setFileTimeSource(FileTimeSource source) {
            this.fileTimeSource = checkNotNull(source);
            return this;
        }
        public Builder setRoots(String first, String... more) {
            List<String> roots = Lists.asList(first, more);
            for (String root : roots) {
                PathType.ParseResult parseResult = pathType.parsePath(root);
                checkArgument(parseResult.isRoot(), "invalid root: %s", root);
            }
            this.roots = ImmutableSet.copyOf(roots);
            return this;
        }
        public Builder setWorkingDirectory(String workingDirectory) {
            PathType.ParseResult parseResult = pathType.parsePath(workingDirectory);
            checkArgument(parseResult.isAbsolute(), "working directory must be an absolute path: %s", workingDirectory);
            this.workingDirectory = checkNotNull(workingDirectory);
            return this;
        }
        public Builder setSupportedFeatures(Feature... features) {
            supportedFeatures = Sets.immutableEnumSet(Arrays.asList(features));
            return this;
        }
        public Builder setWatchServiceConfiguration(WatchServiceConfiguration config) {
            this.watchServiceConfig = checkNotNull(config);
            return this;
        }
        private Builder setDisplayName(String displayName) {
            this.displayName = checkNotNull(displayName);
            return this;
        }
        public Configuration build() {
            return new Configuration(this);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```