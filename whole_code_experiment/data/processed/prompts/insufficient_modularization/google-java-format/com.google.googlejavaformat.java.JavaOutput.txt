##CONTEXT_SIZE=2228
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.googlejavaformat.java;
public final class JavaOutput extends Output {
    private final String lineSeparator;
    private final Input javaInput;
    private final CommentsHelper commentsHelper;
    private final Map<Integer, BlankLineWanted> blankLines = new HashMap<>();
    private final RangeSet<Integer> partialFormatRanges = TreeRangeSet.create();
    private final List<String> mutableLines = new ArrayList<>();
    private final int kN;
    private int iLine = 0;
    private int lastK = -1;
    private int newlinesPending = 0;
    private StringBuilder lineBuilder = new StringBuilder();
    private StringBuilder spacesPending = new StringBuilder();
    public JavaOutput(String lineSeparator, Input javaInput, CommentsHelper commentsHelper) {
        this.lineSeparator = lineSeparator;
        this.javaInput = javaInput;
        this.commentsHelper = commentsHelper;
        kN = javaInput.getkN();
    }
    public void blankLine(int k, BlankLineWanted wanted) {
        if (blankLines.containsKey(k)) {
            blankLines.put(k, blankLines.get(k).merge(wanted));
        } else {
            blankLines.put(k, wanted);
        }
    }
    public void markForPartialFormat(Token start, Token end) {
        int lo = JavaOutput.startTok(start).getIndex();
        int hi = JavaOutput.endTok(end).getIndex();
        partialFormatRanges.add(Range.closed(lo, hi));
    }
    public void append(String text, Range<Integer> range) {
        if (!range.isEmpty()) {
            boolean sawNewlines = false;
            int iN = javaInput.getLineCount();
            while (iLine < iN && (javaInput.getRanges(iLine).isEmpty() || javaInput.getRanges(iLine).upperEndpoint() <= range.lowerEndpoint())) {
                if (javaInput.getRanges(iLine).isEmpty()) {
                    sawNewlines = true;
                }
                ++iLine;
            }
            BlankLineWanted wanted = blankLines.getOrDefault(lastK, BlankLineWanted.NO);
            if ((sawNewlines && isComment(text)) || wanted.wanted().orElse(sawNewlines)) {
                ++newlinesPending;
            }
        }
        if (Newlines.isNewline(text)) {
            if (newlinesPending == 0) {
                ++newlinesPending;
            }
            spacesPending = new StringBuilder();
        } else {
            boolean rangesSet = false;
            int textN = text.length();
            for (int i = 0; i < textN; i++) {
                char c = text.charAt(i);
                switch(c) {
                    case ' ':
                        spacesPending.append(' ');
                        break;
                    case '\t':
                        spacesPending.append('\t');
                        break;
                    case '\r':
                        if (i + 1 < text.length() && text.charAt(i + 1) == '\n') {
                            i++;
                        }
                    case '\n':
                        spacesPending = new StringBuilder();
                        ++newlinesPending;
                        break;
                    default:
                        while (newlinesPending > 0) {
                            if (!mutableLines.isEmpty() || lineBuilder.length() > 0) {
                                mutableLines.add(lineBuilder.toString());
                            }
                            lineBuilder = new StringBuilder();
                            rangesSet = false;
                            --newlinesPending;
                        }
                        if (spacesPending.length() > 0) {
                            lineBuilder.append(spacesPending);
                            spacesPending = new StringBuilder();
                        }
                        lineBuilder.append(c);
                        if (!range.isEmpty()) {
                            if (!rangesSet) {
                                while (ranges.size() <= mutableLines.size()) {
                                    ranges.add(Formatter.EMPTY_RANGE);
                                }
                                ranges.set(mutableLines.size(), union(ranges.get(mutableLines.size()), range));
                                rangesSet = true;
                            }
                        }
                }
            }
        }
        if (!range.isEmpty()) {
            lastK = range.upperEndpoint();
        }
    }
    public void indent(int indent) {
        spacesPending.append(Strings.repeat(" ", indent));
    }
    public void flush() {
        String lastLine = lineBuilder.toString();
        if (!CharMatcher.whitespace().matchesAllOf(lastLine)) {
            mutableLines.add(lastLine);
        }
        int jN = mutableLines.size();
        Range<Integer> eofRange = Range.closedOpen(kN, kN + 1);
        while (ranges.size() < jN) {
            ranges.add(Formatter.EMPTY_RANGE);
        }
        ranges.add(eofRange);
        setLines(ImmutableList.copyOf(mutableLines));
    }
    public CommentsHelper getCommentsHelper() {
        return commentsHelper;
    }
    public ImmutableList<Replacement> getFormatReplacements(RangeSet<Integer> iRangeSet0) {
        ImmutableList.Builder<Replacement> result = ImmutableList.builder();
        Map<Integer, Range<Integer>> kToJ = JavaOutput.makeKToIJ(this);
        RangeSet<Integer> breakableRanges = TreeRangeSet.create();
        RangeSet<Integer> iRangeSet = iRangeSet0.subRangeSet(Range.closed(0, javaInput.getkN()));
        for (Range<Integer> iRange : iRangeSet.asRanges()) {
            Range<Integer> range = expandToBreakableRegions(iRange.canonical(DiscreteDomain.integers()));
            if (range.equals(EMPTY_RANGE)) {
                continue;
            }
            breakableRanges.add(range);
        }
        for (Range<Integer> range : breakableRanges.asRanges()) {
            Input.Tok startTok = startTok(javaInput.getToken(range.lowerEndpoint()));
            Input.Tok endTok = endTok(javaInput.getToken(range.upperEndpoint() - 1));
            StringBuilder replacement = new StringBuilder();
            int replaceFrom = startTok.getPosition();
            while (replaceFrom > 0) {
                char previous = javaInput.getText().charAt(replaceFrom - 1);
                if (!CharMatcher.whitespace().matches(previous)) {
                    break;
                }
                replaceFrom--;
            }
            int i = kToJ.get(startTok.getIndex()).lowerEndpoint();
            while (i > 0 && getLine(i - 1).isEmpty()) {
                i--;
            }
            for (; i < kToJ.get(endTok.getIndex()).upperEndpoint(); i++) {
                if (i < getLineCount()) {
                    if (i > 0) {
                        replacement.append(lineSeparator);
                    }
                    replacement.append(getLine(i));
                }
            }
            int replaceTo = min(endTok.getPosition() + endTok.length(), javaInput.getText().length());
            if (endTok.getIndex() == javaInput.getkN() - 1) {
                replaceTo = javaInput.getText().length();
            }
            int newline = -1;
            while (replaceTo < javaInput.getText().length()) {
                char next = javaInput.getText().charAt(replaceTo);
                if (!CharMatcher.whitespace().matches(next)) {
                    break;
                }
                int newlineLength = Newlines.hasNewlineAt(javaInput.getText(), replaceTo);
                if (newlineLength != -1) {
                    newline = replaceTo;
                    replaceTo += newlineLength;
                } else {
                    replaceTo++;
                }
            }
            if (newline != -1) {
                replaceTo = newline;
            }
            if (newline == -1) {
                replacement.append(lineSeparator);
            }
            for (; i < getLineCount(); i++) {
                String after = getLine(i);
                int idx = CharMatcher.whitespace().negate().indexIn(after);
                if (idx == -1) {
                    replacement.append(lineSeparator);
                } else {
                    if (newline == -1) {
                        replacement.append(after, 0, idx);
                    }
                    break;
                }
            }
            result.add(Replacement.create(replaceFrom, replaceTo, replacement.toString()));
        }
        return result.build();
    }
    private Range<Integer> expandToBreakableRegions(Range<Integer> iRange) {
        int loTok = iRange.lowerEndpoint();
        int hiTok = iRange.upperEndpoint() - 1;
        if (!partialFormatRanges.contains(loTok) || !partialFormatRanges.contains(hiTok)) {
            return EMPTY_RANGE;
        }
        loTok = partialFormatRanges.rangeContaining(loTok).lowerEndpoint();
        hiTok = partialFormatRanges.rangeContaining(hiTok).upperEndpoint();
        return Range.closedOpen(loTok, hiTok + 1);
    }
    public static String applyReplacements(String input, List<Replacement> replacements) {
        replacements = new ArrayList<>(replacements);
        replacements.sort(comparing((Replacement r) -> r.getReplaceRange().lowerEndpoint()).reversed());
        StringBuilder writer = new StringBuilder(input);
        for (Replacement replacement : replacements) {
            writer.replace(replacement.getReplaceRange().lowerEndpoint(), replacement.getReplaceRange().upperEndpoint(), replacement.getReplacementString());
        }
        return writer.toString();
    }
    public static int startPosition(Token token) {
        int min = token.getTok().getPosition();
        for (Input.Tok tok : token.getToksBefore()) {
            min = min(min, tok.getPosition());
        }
        return min;
    }
    public static Input.Tok startTok(Token token) {
        for (Input.Tok tok : token.getToksBefore()) {
            if (tok.getIndex() >= 0) {
                return tok;
            }
        }
        return token.getTok();
    }
    public static Input.Tok endTok(Token token) {
        for (int i = token.getToksAfter().size() - 1; i >= 0; i--) {
            Input.Tok tok = token.getToksAfter().get(i);
            if (tok.getIndex() >= 0) {
                return tok;
            }
        }
        return token.getTok();
    }
    private boolean isComment(String text) {
        return text.startsWith("//") || text.startsWith("/*");
    }
    private static Range<Integer> union(Range<Integer> x, Range<Integer> y) {
        return x.isEmpty() ? y : y.isEmpty() ? x : x.span(y).canonical(DiscreteDomain.integers());
    }
    public String toString() {
        return MoreObjects.toStringHelper(this).add("iLine", iLine).add("lastK", lastK).add("spacesPending", spacesPending.toString().replace("\t", "\\t")).add("newlinesPending", newlinesPending).add("blankLines", blankLines).add("super", super.toString()).toString();
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```