##CONTEXT_SIZE=2924
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.googlejavaformat.java;
public final class StringWrapper {
    public static final String TEXT_BLOCK_DELIMITER = "\"\"\"";
    public static String wrap(String input, Formatter formatter) throws FormatterException {
        return StringWrapper.wrap(Formatter.MAX_LINE_LENGTH, input, formatter);
    }
    static String wrap(final int columnLimit, String input, Formatter formatter) throws FormatterException {
        if (!needWrapping(columnLimit, input)) {
            return input;
        }
        TreeRangeMap<Integer, String> replacements = getReflowReplacements(columnLimit, input);
        String firstPass = formatter.formatSource(input, replacements.asMapOfRanges().keySet());
        if (!firstPass.equals(input)) {
            input = firstPass;
            replacements = getReflowReplacements(columnLimit, input);
        }
        String result = applyReplacements(input, replacements);
        {
            String expected = parse(input, true).toString();
            String actual = parse(result, true).toString();
            if (!expected.equals(actual)) {
                throw new FormatterException(String.format("Something has gone terribly wrong. We planned to make the below formatting change," + " but have aborted because it would unexpectedly change the AST.\n" + "Please file a bug: " + "https://github.com/google/google-java-format/issues/new" + "\n\n=== Actual: ===\n%s\n=== Expected: ===\n%s\n", actual, expected));
            }
        }
        return result;
    }
    private static TreeRangeMap<Integer, String> getReflowReplacements(int columnLimit, final String input) throws FormatterException {
        return new Reflower(columnLimit, input).getReflowReplacements();
    }
    private static class Reflower {
        private final String input;
        private final int columnLimit;
        private final String separator;
        private final JCTree.JCCompilationUnit unit;
        private final Position.LineMap lineMap;
        Reflower(int columnLimit, String input) throws FormatterException {
            this.columnLimit = columnLimit;
            this.input = input;
            this.separator = Newlines.guessLineSeparator(input);
            this.unit = parse(input, false);
            this.lineMap = unit.getLineMap();
        }
        TreeRangeMap<Integer, String> getReflowReplacements() {
            List<TreePath> longStringLiterals = new ArrayList<>();
            List<Tree> textBlocks = new ArrayList<>();
            new LongStringsAndTextBlockScanner(longStringLiterals, textBlocks).scan(new TreePath(unit), null);
            TreeRangeMap<Integer, String> replacements = TreeRangeMap.create();
            indentTextBlocks(replacements, textBlocks);
            wrapLongStrings(replacements, longStringLiterals);
            return replacements;
        }
        private class LongStringsAndTextBlockScanner extends TreePathScanner<Void, Void> {
            private final List<TreePath> longStringLiterals;
            private final List<Tree> textBlocks;
            LongStringsAndTextBlockScanner(List<TreePath> longStringLiterals, List<Tree> textBlocks) {
                this.longStringLiterals = longStringLiterals;
                this.textBlocks = textBlocks;
            }
            public Void visitLiteral(LiteralTree literalTree, Void aVoid) {
                if (literalTree.getKind() != Kind.STRING_LITERAL) {
                    return null;
                }
                int pos = getStartPosition(literalTree);
                if (input.substring(pos, min(input.length(), pos + 3)).equals(TEXT_BLOCK_DELIMITER)) {
                    textBlocks.add(literalTree);
                    return null;
                }
                Tree parent = getCurrentPath().getParentPath().getLeaf();
                if (parent instanceof MemberSelectTree && ((MemberSelectTree) parent).getExpression().equals(literalTree)) {
                    return null;
                }
                int endPosition = getEndPosition(literalTree, unit);
                int lineEnd = endPosition;
                while (Newlines.hasNewlineAt(input, lineEnd) == -1) {
                    lineEnd++;
                }
                if (lineMap.getColumnNumber(lineEnd) - 1 <= columnLimit) {
                    return null;
                }
                longStringLiterals.add(getCurrentPath());
                return null;
            }
        }
        private void indentTextBlocks(TreeRangeMap<Integer, String> replacements, List<Tree> textBlocks) {
            for (Tree tree : textBlocks) {
                int startPosition = lineMap.getStartPosition(lineMap.getLineNumber(getStartPosition(tree)));
                int endPosition = getEndPosition(tree, unit);
                String text = input.substring(startPosition, endPosition);
                int leadingWhitespace = CharMatcher.whitespace().negate().indexIn(text);
                ImmutableList<String> initialLines = text.lines().collect(toImmutableList());
                String stripped = initialLines.stream().skip(1).collect(joining(separator)).stripIndent();
                ImmutableList<String> lines = stripped.lines().collect(toImmutableList());
                boolean deindent = getLast(initialLines).stripTrailing().length() == getLast(lines).stripTrailing().length();
                String prefix = deindent ? "" : " ".repeat(leadingWhitespace);
                StringBuilder output = new StringBuilder(prefix).append(initialLines.get(0).stripLeading());
                for (int i = 0; i < lines.size(); i++) {
                    String line = lines.get(i);
                    String trimmed = line.stripTrailing();
                    output.append(separator);
                    if (!trimmed.isEmpty()) {
                        output.append(prefix);
                    }
                    if (i == lines.size() - 1) {
                        String withoutDelimiter = trimmed.substring(0, trimmed.length() - TEXT_BLOCK_DELIMITER.length()).stripTrailing();
                        if (!withoutDelimiter.stripLeading().isEmpty()) {
                            output.append(withoutDelimiter).append('\\').append(separator).append(prefix);
                        }
                        output.append(TEXT_BLOCK_DELIMITER);
                    } else {
                        output.append(line);
                    }
                }
                replacements.put(Range.closedOpen(startPosition, endPosition), output.toString());
            }
        }
        private void wrapLongStrings(TreeRangeMap<Integer, String> replacements, List<TreePath> longStringLiterals) {
            for (TreePath path : longStringLiterals) {
                TreePath enclosing = path;
                while (enclosing.getParentPath().getLeaf().getKind() == Kind.PLUS) {
                    enclosing = enclosing.getParentPath();
                }
                AtomicBoolean first = new AtomicBoolean(false);
                List<Tree> flat = flatten(input, unit, path, enclosing, first);
                int startColumn = lineMap.getColumnNumber(getStartPosition(flat.get(0))) - 1;
                int end = getEndPosition(getLast(flat), unit);
                int lineEnd = end;
                while (Newlines.hasNewlineAt(input, lineEnd) == -1) {
                    lineEnd++;
                }
                int trailing = lineEnd - end;
                ImmutableList<String> components = stringComponents(input, unit, flat);
                replacements.put(Range.closedOpen(getStartPosition(flat.get(0)), getEndPosition(getLast(flat), unit)), reflow(separator, columnLimit, startColumn, trailing, components, first.get()));
            }
        }
    }
    private static ImmutableList<String> stringComponents(String input, JCTree.JCCompilationUnit unit, List<Tree> flat) {
        ImmutableList.Builder<String> result = ImmutableList.builder();
        StringBuilder piece = new StringBuilder();
        for (Tree tree : flat) {
            String text = input.substring(getStartPosition(tree) + 1, getEndPosition(tree, unit) - 1);
            int start = 0;
            for (int idx = 0; idx < text.length(); idx++) {
                if (CharMatcher.whitespace().matches(text.charAt(idx))) {
                } else if (hasEscapedWhitespaceAt(text, idx) != -1) {
                } else if (hasEscapedNewlineAt(text, idx) != -1) {
                    int length;
                    while ((length = hasEscapedNewlineAt(text, idx)) != -1) {
                        idx += length;
                    }
                } else {
                    continue;
                }
                piece.append(text, start, idx);
                result.add(piece.toString());
                piece = new StringBuilder();
                start = idx;
            }
            if (piece.length() > 0) {
                result.add(piece.toString());
                piece = new StringBuilder();
            }
            if (start < text.length()) {
                piece.append(text, start, text.length());
            }
        }
        if (piece.length() > 0) {
            result.add(piece.toString());
        }
        return result.build();
    }
    static int hasEscapedWhitespaceAt(String input, int idx) {
        if (input.startsWith("\\t", idx)) {
            return 2;
        }
        return -1;
    }
    static int hasEscapedNewlineAt(String input, int idx) {
        int offset = 0;
        if (input.startsWith("\\r", idx)) {
            offset += 2;
        }
        if (input.startsWith("\\n", idx)) {
            offset += 2;
        }
        return offset > 0 ? offset : -1;
    }
    private static String reflow(String separator, int columnLimit, int startColumn, int trailing, ImmutableList<String> components, boolean first0) {
        int width = columnLimit - startColumn - 2;
        Deque<String> input = new ArrayDeque<>(components);
        List<String> lines = new ArrayList<>();
        boolean first = first0;
        while (!input.isEmpty()) {
            int length = 0;
            List<String> line = new ArrayList<>();
            if (totalLengthLessThanOrEqual(input, width)) {
                width -= trailing;
            }
            while (!input.isEmpty() && (length <= 4 || (length + input.peekFirst().length()) <= width)) {
                String text = input.removeFirst();
                line.add(text);
                length += text.length();
                if (text.endsWith("\\n") || text.endsWith("\\r")) {
                    break;
                }
            }
            if (line.isEmpty()) {
                line.add(input.removeFirst());
            }
            lines.add(String.join("", line));
            if (first) {
                width -= 6;
                first = false;
            }
        }
        return lines.stream().collect(joining("\"" + separator + Strings.repeat(" ", startColumn + (first0 ? 4 : -2)) + "+ \"", "\"", "\""));
    }
    private static boolean totalLengthLessThanOrEqual(Iterable<String> input, int length) {
        int total = 0;
        for (String s : input) {
            total += s.length();
            if (total > length) {
                return false;
            }
        }
        return true;
    }
    private static List<Tree> flatten(String input, JCTree.JCCompilationUnit unit, TreePath path, TreePath parent, AtomicBoolean firstInChain) {
        List<Tree> flat = new ArrayList<>();
        ArrayDeque<Tree> todo = new ArrayDeque<>();
        todo.add(parent.getLeaf());
        while (!todo.isEmpty()) {
            Tree first = todo.removeFirst();
            if (first.getKind() == Tree.Kind.PLUS) {
                BinaryTree bt = (BinaryTree) first;
                todo.addFirst(bt.getRightOperand());
                todo.addFirst(bt.getLeftOperand());
            } else {
                flat.add(first);
            }
        }
        int idx = flat.indexOf(path.getLeaf());
        Verify.verify(idx != -1);
        int startIdx = idx;
        int endIdx = idx + 1;
        while (startIdx > 0 && flat.get(startIdx - 1).getKind() == Tree.Kind.STRING_LITERAL && noComments(input, unit, flat.get(startIdx - 1), flat.get(startIdx))) {
            startIdx--;
        }
        while (endIdx < flat.size() && flat.get(endIdx).getKind() == Tree.Kind.STRING_LITERAL && noComments(input, unit, flat.get(endIdx - 1), flat.get(endIdx))) {
            endIdx++;
        }
        firstInChain.set(startIdx == 0);
        return ImmutableList.copyOf(flat.subList(startIdx, endIdx));
    }
    private static boolean noComments(String input, JCTree.JCCompilationUnit unit, Tree one, Tree two) {
        return STRING_CONCAT_DELIMITER.matchesAllOf(input.subSequence(getEndPosition(one, unit), getStartPosition(two)));
    }
    public static final CharMatcher STRING_CONCAT_DELIMITER = CharMatcher.whitespace().or(CharMatcher.anyOf("\"+"));
    private static boolean needWrapping(int columnLimit, String input) {
        Iterator<String> it = Newlines.lineIterator(input);
        while (it.hasNext()) {
            String line = it.next();
            if (line.length() > columnLimit || line.contains(TEXT_BLOCK_DELIMITER)) {
                return true;
            }
        }
        return false;
    }
    private static JCTree.JCCompilationUnit parse(String source, boolean allowStringFolding) throws FormatterException {
        List<Diagnostic<? extends JavaFileObject>> errorDiagnostics = new ArrayList<>();
        Context context = new Context();
        JCTree.JCCompilationUnit unit = Trees.parse(context, errorDiagnostics, allowStringFolding, source);
        if (!errorDiagnostics.isEmpty()) {
            throw FormatterException.fromJavacDiagnostics(errorDiagnostics);
        }
        return unit;
    }
    private static String applyReplacements(String javaInput, TreeRangeMap<Integer, String> replacementMap) throws FormatterException {
        Map<Range<Integer>, String> ranges = replacementMap.asDescendingMapOfRanges();
        if (ranges.isEmpty()) {
            return javaInput;
        }
        StringBuilder sb = new StringBuilder(javaInput);
        for (Map.Entry<Range<Integer>, String> entry : ranges.entrySet()) {
            Range<Integer> range = entry.getKey();
            sb.replace(range.lowerEndpoint(), range.upperEndpoint(), entry.getValue());
        }
        return sb.toString();
    }
    private StringWrapper() {
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```