##CONTEXT_SIZE=978
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.googlejavaformat.java;

import com.google.common.base.Verify;
import java.util.List;
import java.util.Optional;

/** Heuristics for classifying qualified names as types. */
public final class TypeNameClassifier {

  private TypeNameClassifier() {}

  /** A state machine for classifying qualified names. */
  private enum TyParseState {

    /** The start state. */
    START(false) {
      @Override
      public TyParseState next(JavaCaseFormat n) {
        return switch (n) {
          case UPPERCASE ->
              // if we see an UpperCamel later, assume this was a class
              // e.g. com.google.FOO.Bar
              TyParseState.AMBIGUOUS;
          case LOWER_CAMEL -> TyParseState.REJECT;
          case LOWERCASE ->
              // could be a package
              TyParseState.START;
          case UPPER_CAMEL -> TyParseState.TYPE;
        };
      }
    },

    /** The current prefix is a type. */
    TYPE(true) {
      @Override
      public TyParseState next(JavaCaseFormat n) {
        return switch (n) {
          case UPPERCASE, LOWER_CAMEL, LOWERCASE -> TyParseState.FIRST_STATIC_MEMBER;
          case UPPER_CAMEL -> TyParseState.TYPE;
        };
      }
    },

    /** The current prefix is a type, followed by a single static member access. */
    FIRST_STATIC_MEMBER(true) {
      @Override
      public TyParseState next(JavaCaseFormat n) {
        return TyParseState.REJECT;
      }
    },

    /** Anything not represented by one of the other states. */
    REJECT(false) {
      @Override
      public TyParseState next(JavaCaseFormat n) {
        return TyParseState.REJECT;
      }
    },

    /** An ambiguous type prefix. */
    AMBIGUOUS(false) {
      @Override
      public TyParseState next(JavaCaseFormat n) {
        return switch (n) {
          case UPPERCASE -> AMBIGUOUS;
          case LOWER_CAMEL, LOWERCASE -> TyParseState.REJECT;
          case UPPER_CAMEL -> TyParseState.TYPE;
        };
      }
    };

    private final boolean isSingleUnit;

    TyParseState(boolean isSingleUnit) {
      this.isSingleUnit = isSingleUnit;
    }

    public boolean isSingleUnit() {
      return isSingleUnit;
    }

    /** Transition function. */
    public abstract TyParseState next(JavaCaseFormat n);
  }

  /**
   * Returns the end index (inclusive) of the longest prefix that matches the naming conventions of
   * a type or static field access, or -1 if no such prefix was found.
   *
   * <p>Examples:
   *
   * <ul>
   *   <li>ClassName
   *   <li>ClassName.staticMemberName
   *   <li>com.google.ClassName.InnerClass.staticMemberName
   * </ul>
   */
  static Optional<Integer> typePrefixLength(List<String> nameParts) {
    TyParseState state = TyParseState.START;
    Optional<Integer> typeLength = Optional.empty();
    for (int i = 0; i < nameParts.size(); i++) {
      state = state.next(JavaCaseFormat.from(nameParts.get(i)));
      if (state == TyParseState.REJECT) {
        break;
      }
      if (state.isSingleUnit()) {
        typeLength = Optional.of(i);
      }
    }
    return typeLength;
  }

  /** Case formats used in Java identifiers. */
  public enum JavaCaseFormat {
    UPPERCASE,
    LOWERCASE,
    UPPER_CAMEL,
    LOWER_CAMEL;

    /** Classifies an identifier's case format. */
    static JavaCaseFormat from(String name) {
      Verify.verify(!name.isEmpty());
      boolean firstUppercase = false;
      boolean hasUppercase = false;
      boolean hasLowercase = false;
      boolean first = true;
      for (int i = 0; i < name.length(); i++) {
        char c = name.charAt(i);
        if (!Character.isAlphabetic(c)) {
          continue;
        }
        if (first) {
          firstUppercase = Character.isUpperCase(c);
          first = false;
        }
        hasUppercase |= Character.isUpperCase(c);
        hasLowercase |= Character.isLowerCase(c);
      }
      if (firstUppercase) {
        return (hasLowercase || name.length() == 1) ? UPPER_CAMEL : UPPERCASE;
      } else {
        return hasUppercase ? LOWER_CAMEL : LOWERCASE;
      }
    }
  }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```