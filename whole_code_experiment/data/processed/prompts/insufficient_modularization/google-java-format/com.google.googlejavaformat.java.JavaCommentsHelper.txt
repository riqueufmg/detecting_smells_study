##CONTEXT_SIZE=1060
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.googlejavaformat.java;
public final class JavaCommentsHelper implements CommentsHelper {
    private final String lineSeparator;
    private final JavaFormatterOptions options;
    public JavaCommentsHelper(String lineSeparator, JavaFormatterOptions options) {
        this.lineSeparator = lineSeparator;
        this.options = options;
    }
    public String rewrite(Tok tok, int maxWidth, int column0) {
        if (!tok.isComment()) {
            return tok.getOriginalText();
        }
        String text = tok.getOriginalText();
        if (tok.isJavadocComment() && options.formatJavadoc()) {
            text = JavadocFormatter.formatJavadoc(text, column0);
        }
        List<String> lines = new ArrayList<>();
        Iterator<String> it = Newlines.lineIterator(text);
        while (it.hasNext()) {
            if (tok.isSlashSlashComment()) {
                lines.add(CharMatcher.whitespace().trimFrom(it.next()));
            } else {
                lines.add(CharMatcher.whitespace().trimTrailingFrom(it.next()));
            }
        }
        if (tok.isSlashSlashComment()) {
            return indentLineComments(lines, column0);
        }
        return CommentsHelper.reformatParameterComment(tok).orElseGet(() -> javadocShaped(lines) ? indentJavadoc(lines, column0) : preserveIndentation(lines, column0));
    }
    private String preserveIndentation(List<String> lines, int column0) {
        StringBuilder builder = new StringBuilder();
        int startCol = -1;
        for (int i = 1; i < lines.size(); i++) {
            int lineIdx = CharMatcher.whitespace().negate().indexIn(lines.get(i));
            if (lineIdx >= 0 && (startCol == -1 || lineIdx < startCol)) {
                startCol = lineIdx;
            }
        }
        builder.append(lines.get(0));
        for (int i = 1; i < lines.size(); ++i) {
            builder.append(lineSeparator).append(Strings.repeat(" ", column0));
            if (lines.get(i).length() >= startCol) {
                builder.append(lines.get(i).substring(startCol));
            } else {
                builder.append(lines.get(i));
            }
        }
        return builder.toString();
    }
    private String indentLineComments(List<String> lines, int column0) {
        lines = wrapLineComments(lines, column0);
        StringBuilder builder = new StringBuilder();
        builder.append(lines.get(0).trim());
        String indentString = Strings.repeat(" ", column0);
        for (int i = 1; i < lines.size(); ++i) {
            builder.append(lineSeparator).append(indentString).append(lines.get(i).trim());
        }
        return builder.toString();
    }
    private static final Pattern LINE_COMMENT_MISSING_SPACE_PREFIX = Pattern.compile("^(//+)(?!noinspection|\\$NON-NLS-\\d+\\$)[^\\s/]");
    private List<String> wrapLineComments(List<String> lines, int column0) {
        List<String> result = new ArrayList<>();
        for (String line : lines) {
            Matcher matcher = LINE_COMMENT_MISSING_SPACE_PREFIX.matcher(line);
            if (matcher.find()) {
                int length = matcher.group(1).length();
                line = Strings.repeat("/", length) + " " + line.substring(length);
            }
            if (line.startsWith("// MOE:")) {
                result.add(line);
                continue;
            }
            while (line.length() + column0 > Formatter.MAX_LINE_LENGTH) {
                int idx = Formatter.MAX_LINE_LENGTH - column0;
                while (idx >= 2 && !CharMatcher.whitespace().matches(line.charAt(idx))) {
                    idx--;
                }
                if (idx <= 2) {
                    break;
                }
                result.add(line.substring(0, idx));
                line = "//" + line.substring(idx);
            }
            result.add(line);
        }
        return result;
    }
    private String indentJavadoc(List<String> lines, int column0) {
        StringBuilder builder = new StringBuilder();
        builder.append(lines.get(0).trim());
        int indent = column0 + 1;
        String indentString = Strings.repeat(" ", indent);
        for (int i = 1; i < lines.size(); ++i) {
            builder.append(lineSeparator).append(indentString);
            String line = lines.get(i).trim();
            if (!line.startsWith("*")) {
                builder.append("* ");
            }
            builder.append(line);
        }
        return builder.toString();
    }
    private static boolean javadocShaped(List<String> lines) {
        Iterator<String> it = lines.iterator();
        if (!it.hasNext()) {
            return false;
        }
        String first = it.next().trim();
        if (first.startsWith("/**")) {
            return true;
        }
        if (!first.startsWith("/*")) {
            return false;
        }
        while (it.hasNext()) {
            if (!it.next().trim().startsWith("*")) {
                return false;
            }
        }
        return true;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```