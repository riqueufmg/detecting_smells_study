##CONTEXT_SIZE=663
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.googlejavaformat.intellij;
public class GoogleJavaFormatFormattingService extends AsyncDocumentFormattingService {
    public static final ImmutableSet<ImportOptimizer> IMPORT_OPTIMIZERS = ImmutableSet.of(new GoogleJavaFormatImportOptimizer());
    protected FormattingTask createFormattingTask(AsyncFormattingRequest request) {
        Project project = request.getContext().getProject();
        if (!JreConfigurationChecker.checkJreConfiguration(project)) {
            return null;
        }
        Style style = GoogleJavaFormatSettings.getInstance(project).getStyle();
        Formatter formatter = createFormatter(style, request.canChangeWhitespaceOnly());
        return new GoogleJavaFormatFormattingTask(formatter, request);
    }
    protected String getNotificationGroupId() {
        return Notifications.PARSING_ERROR_NOTIFICATION_GROUP;
    }
    protected String getName() {
        return "google-java-format";
    }
    private static Formatter createFormatter(Style style, boolean canChangeWhiteSpaceOnly) {
        JavaFormatterOptions.Builder optBuilder = JavaFormatterOptions.builder().style(style);
        if (canChangeWhiteSpaceOnly) {
            optBuilder.formatJavadoc(false).reorderModifiers(false);
        }
        return new Formatter(optBuilder.build());
    }
    public Set<Feature> getFeatures() {
        return Set.of(Feature.FORMAT_FRAGMENTS, Feature.OPTIMIZE_IMPORTS);
    }
    public boolean canFormat(@NotNull PsiFile file) {
        return JavaFileType.INSTANCE.equals(file.getFileType()) && GoogleJavaFormatSettings.getInstance(file.getProject()).isEnabled();
    }
    public Set<ImportOptimizer> getImportOptimizers(@NotNull PsiFile file) {
        return IMPORT_OPTIMIZERS;
    }
    private static final class GoogleJavaFormatFormattingTask implements FormattingTask {
        private final Formatter formatter;
        private final AsyncFormattingRequest request;
        private GoogleJavaFormatFormattingTask(Formatter formatter, AsyncFormattingRequest request) {
            this.formatter = formatter;
            this.request = request;
        }
        public void run() {
            try {
                String formattedText = formatter.formatSource(request.getDocumentText(), toRanges(request));
                request.onTextReady(formattedText);
            } catch (FormatterException e) {
                request.onError(Notifications.PARSING_ERROR_TITLE, Notifications.parsingErrorMessage(request.getContext().getContainingFile().getName()));
            }
        }
        private static Collection<Range<Integer>> toRanges(AsyncFormattingRequest request) {
            if (isWholeFile(request)) {
                return ImmutableList.of(Range.closedOpen(0, request.getDocumentText().length()));
            }
            return request.getFormattingRanges().stream().map(textRange -> Range.closedOpen(textRange.getStartOffset(), textRange.getEndOffset())).collect(ImmutableList.toImmutableList());
        }
        private static boolean isWholeFile(AsyncFormattingRequest request) {
            List<TextRange> ranges = request.getFormattingRanges();
            return ranges.size() == 1 && ranges.get(0).getStartOffset() == 0 && ranges.get(0).getEndOffset() >= request.getDocumentText().length();
        }
        public boolean isRunUnderProgress() {
            return true;
        }
        public boolean cancel() {
            return false;
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```