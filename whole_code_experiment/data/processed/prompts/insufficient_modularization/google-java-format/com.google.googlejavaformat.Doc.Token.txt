##CONTEXT_SIZE=3128
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.googlejavaformat;
public abstract class Doc {
    public enum FillMode {
        UNIFIED, INDEPENDENT, FORCED
    }
    public static final int MAX_LINE_WIDTH = 1000;
    public static final class State {
        final int lastIndent;
        final int indent;
        final int column;
        final boolean mustBreak;
        State(int lastIndent, int indent, int column, boolean mustBreak) {
            this.lastIndent = lastIndent;
            this.indent = indent;
            this.column = column;
            this.mustBreak = mustBreak;
        }
        public State(int indent0, int column0) {
            this(indent0, indent0, column0, false);
        }
        State withColumn(int column) {
            return new State(lastIndent, indent, column, mustBreak);
        }
        State withMustBreak(boolean mustBreak) {
            return new State(lastIndent, indent, column, mustBreak);
        }
        public String toString() {
            return MoreObjects.toStringHelper(this).add("lastIndent", lastIndent).add("indent", indent).add("column", column).add("mustBreak", mustBreak).toString();
        }
    }
    private static final Range<Integer> EMPTY_RANGE = Range.closedOpen(-1, -1);
    private static final DiscreteDomain<Integer> INTEGERS = DiscreteDomain.integers();
    private final Supplier<Integer> width = Suppliers.memoize(this::computeWidth);
    private final Supplier<String> flat = Suppliers.memoize(this::computeFlat);
    private final Supplier<Range<Integer>> range = Suppliers.memoize(this::computeRange);
    final int getWidth() {
        return width.get();
    }
    final String getFlat() {
        return flat.get();
    }
    final Range<Integer> range() {
        return range.get();
    }
    abstract int computeWidth();
    abstract String computeFlat();
    abstract Range<Integer> computeRange();
    public abstract State computeBreaks(CommentsHelper commentsHelper, int maxWidth, State state);
    public abstract void write(Output output);
    static final class Level extends Doc {
        private final Indent plusIndent;
        private final List<Doc> docs = new ArrayList<>();
        private Level(Indent plusIndent) {
            this.plusIndent = plusIndent;
        }
        static Level make(Indent plusIndent) {
            return new Level(plusIndent);
        }
        void add(Doc doc) {
            docs.add(doc);
        }
        int computeWidth() {
            return getWidth(docs);
        }
        String computeFlat() {
            StringBuilder builder = new StringBuilder();
            for (Doc doc : docs) {
                builder.append(doc.getFlat());
            }
            return builder.toString();
        }
        Range<Integer> computeRange() {
            Range<Integer> docRange = EMPTY_RANGE;
            for (Doc doc : docs) {
                docRange = union(docRange, doc.range());
            }
            return docRange;
        }
        boolean oneLine = false;
        List<List<Doc>> splits = new ArrayList<>();
        List<Break> breaks = new ArrayList<>();
        public State computeBreaks(CommentsHelper commentsHelper, int maxWidth, State state) {
            int thisWidth = getWidth();
            if (state.column + thisWidth <= maxWidth) {
                oneLine = true;
                return state.withColumn(state.column + thisWidth);
            }
            State broken = computeBroken(commentsHelper, maxWidth, new State(state.indent + plusIndent.eval(), state.column));
            return state.withColumn(broken.column);
        }
        private static void splitByBreaks(List<Doc> docs, List<List<Doc>> splits, List<Break> breaks) {
            splits.clear();
            breaks.clear();
            splits.add(new ArrayList<>());
            for (Doc doc : docs) {
                if (doc instanceof Break) {
                    breaks.add((Break) doc);
                    splits.add(new ArrayList<>());
                } else {
                    getLast(splits).add(doc);
                }
            }
        }
        private State computeBroken(CommentsHelper commentsHelper, int maxWidth, State state) {
            splitByBreaks(docs, splits, breaks);
            state = computeBreakAndSplit(commentsHelper, maxWidth, state, Optional.empty(), splits.get(0));
            for (int i = 0; i < breaks.size(); i++) {
                state = computeBreakAndSplit(commentsHelper, maxWidth, state, Optional.of(breaks.get(i)), splits.get(i + 1));
            }
            return state;
        }
        private static State computeBreakAndSplit(CommentsHelper commentsHelper, int maxWidth, State state, Optional<Break> optBreakDoc, List<Doc> split) {
            int breakWidth = optBreakDoc.isPresent() ? optBreakDoc.get().getWidth() : 0;
            int splitWidth = getWidth(split);
            boolean shouldBreak = (optBreakDoc.isPresent() && optBreakDoc.get().fillMode == FillMode.UNIFIED) || state.mustBreak || state.column + breakWidth + splitWidth > maxWidth;
            if (optBreakDoc.isPresent()) {
                state = optBreakDoc.get().computeBreaks(state, state.lastIndent, shouldBreak);
            }
            boolean enoughRoom = state.column + splitWidth <= maxWidth;
            state = computeSplit(commentsHelper, maxWidth, split, state.withMustBreak(false));
            if (!enoughRoom) {
                state = state.withMustBreak(true);
            }
            return state;
        }
        private static State computeSplit(CommentsHelper commentsHelper, int maxWidth, List<Doc> docs, State state) {
            for (Doc doc : docs) {
                state = doc.computeBreaks(commentsHelper, maxWidth, state);
            }
            return state;
        }
        public void write(Output output) {
            if (oneLine) {
                output.append(getFlat(), range());
            } else {
                writeFilled(output);
            }
        }
        private void writeFilled(Output output) {
            for (Doc doc : splits.get(0)) {
                doc.write(output);
            }
            for (int i = 0; i < breaks.size(); i++) {
                breaks.get(i).write(output);
                for (Doc doc : splits.get(i + 1)) {
                    doc.write(output);
                }
            }
        }
        static int getWidth(List<Doc> docs) {
            int width = 0;
            for (Doc doc : docs) {
                width += doc.getWidth();
                if (width >= MAX_LINE_WIDTH) {
                    return MAX_LINE_WIDTH;
                }
            }
            return width;
        }
        private static Range<Integer> union(Range<Integer> x, Range<Integer> y) {
            return x.isEmpty() ? y : y.isEmpty() ? x : x.span(y).canonical(INTEGERS);
        }
        public String toString() {
            return MoreObjects.toStringHelper(this).add("plusIndent", plusIndent).add("docs", docs).toString();
        }
    }
    public static final class Token extends Doc implements Op {
        public enum RealOrImaginary {
            REAL, IMAGINARY;
            boolean isReal() {
                return this == REAL;
            }
        }
        private final Input.Token token;
        private final RealOrImaginary realOrImaginary;
        private final Indent plusIndentCommentsBefore;
        private final Optional<Indent> breakAndIndentTrailingComment;
        private Input.Tok tok() {
            return token.getTok();
        }
        private Token(Input.Token token, RealOrImaginary realOrImaginary, Indent plusIndentCommentsBefore, Optional<Indent> breakAndIndentTrailingComment) {
            this.token = token;
            this.realOrImaginary = realOrImaginary;
            this.plusIndentCommentsBefore = plusIndentCommentsBefore;
            this.breakAndIndentTrailingComment = breakAndIndentTrailingComment;
        }
        Indent getPlusIndentCommentsBefore() {
            return plusIndentCommentsBefore;
        }
        Optional<Indent> breakAndIndentTrailingComment() {
            return breakAndIndentTrailingComment;
        }
        static Op make(Input.Token token, Doc.Token.RealOrImaginary realOrImaginary, Indent plusIndentCommentsBefore, Optional<Indent> breakAndIndentTrailingComment) {
            return new Token(token, realOrImaginary, plusIndentCommentsBefore, breakAndIndentTrailingComment);
        }
        Input.Token getToken() {
            return token;
        }
        RealOrImaginary realOrImaginary() {
            return realOrImaginary;
        }
        public void add(DocBuilder builder) {
            builder.add(this);
        }
        int computeWidth() {
            int idx = Newlines.firstBreak(tok().getOriginalText());
            return (idx >= 0) ? MAX_LINE_WIDTH : tok().length();
        }
        String computeFlat() {
            return token.getTok().getOriginalText();
        }
        Range<Integer> computeRange() {
            return Range.singleton(token.getTok().getIndex()).canonical(INTEGERS);
        }
        public State computeBreaks(CommentsHelper commentsHelper, int maxWidth, State state) {
            return state.withColumn(state.column + computeWidth());
        }
        public void write(Output output) {
            String text = token.getTok().getOriginalText();
            output.append(text, range());
        }
        public String toString() {
            return MoreObjects.toStringHelper(this).add("token", token).add("realOrImaginary", realOrImaginary).add("plusIndentCommentsBefore", plusIndentCommentsBefore).toString();
        }
    }
    static final class Space extends Doc implements Op {
        private static final Space SPACE = new Space();
        private Space() {
        }
        static Space make() {
            return SPACE;
        }
        public void add(DocBuilder builder) {
            builder.add(this);
        }
        int computeWidth() {
            return 1;
        }
        String computeFlat() {
            return " ";
        }
        Range<Integer> computeRange() {
            return EMPTY_RANGE;
        }
        public State computeBreaks(CommentsHelper commentsHelper, int maxWidth, State state) {
            return state.withColumn(state.column + 1);
        }
        public void write(Output output) {
            output.append(" ", range());
        }
        public String toString() {
            return MoreObjects.toStringHelper(this).toString();
        }
    }
    public static final class Break extends Doc implements Op {
        private final FillMode fillMode;
        private final String flat;
        private final Indent plusIndent;
        private final Optional<BreakTag> optTag;
        private Break(FillMode fillMode, String flat, Indent plusIndent, Optional<BreakTag> optTag) {
            this.fillMode = fillMode;
            this.flat = flat;
            this.plusIndent = plusIndent;
            this.optTag = optTag;
        }
        public static Break make(FillMode fillMode, String flat, Indent plusIndent) {
            return new Break(fillMode, flat, plusIndent, Optional.empty());
        }
        public static Break make(FillMode fillMode, String flat, Indent plusIndent, Optional<BreakTag> optTag) {
            return new Break(fillMode, flat, plusIndent, optTag);
        }
        public static Break makeForced() {
            return make(FillMode.FORCED, "", Indent.Const.ZERO);
        }
        int getPlusIndent() {
            return plusIndent.eval();
        }
        boolean isForced() {
            return fillMode == FillMode.FORCED;
        }
        public void add(DocBuilder builder) {
            builder.breakDoc(this);
        }
        int computeWidth() {
            return isForced() ? MAX_LINE_WIDTH : flat.length();
        }
        String computeFlat() {
            return flat;
        }
        Range<Integer> computeRange() {
            return EMPTY_RANGE;
        }
        boolean broken;
        int newIndent;
        public State computeBreaks(State state, int lastIndent, boolean broken) {
            if (optTag.isPresent()) {
                optTag.get().recordBroken(broken);
            }
            if (broken) {
                this.broken = true;
                this.newIndent = max(lastIndent + plusIndent.eval(), 0);
                return state.withColumn(newIndent);
            } else {
                this.broken = false;
                this.newIndent = -1;
                return state.withColumn(state.column + flat.length());
            }
        }
        public State computeBreaks(CommentsHelper commentsHelper, int maxWidth, State state) {
            throw new UnsupportedOperationException("Did you mean computeBreaks(State, int, boolean)?");
        }
        public void write(Output output) {
            if (broken) {
                output.append("\n", EMPTY_RANGE);
                output.indent(newIndent);
            } else {
                output.append(flat, range());
            }
        }
        public String toString() {
            return MoreObjects.toStringHelper(this).add("fillMode", fillMode).add("flat", flat).add("plusIndent", plusIndent).add("optTag", optTag).toString();
        }
    }
    static final class Tok extends Doc implements Op {
        private final Input.Tok tok;
        private Tok(Input.Tok tok) {
            this.tok = tok;
        }
        static Tok make(Input.Tok tok) {
            return new Tok(tok);
        }
        public void add(DocBuilder builder) {
            builder.add(this);
        }
        int computeWidth() {
            int idx = Newlines.firstBreak(tok.getOriginalText());
            if (tok.isComment()) {
                if (idx > 0) {
                    return idx;
                } else if (tok.isSlashSlashComment() && !tok.getOriginalText().startsWith("// ")) {
                    return tok.length() + 1;
                } else {
                    return reformatParameterComment(tok).map(String::length).orElse(tok.length());
                }
            }
            return idx != -1 ? MAX_LINE_WIDTH : tok.length();
        }
        String computeFlat() {
            if (tok.isSlashSlashComment() && !tok.getOriginalText().startsWith("// ")) {
                return "// " + tok.getOriginalText().substring("//".length());
            }
            return reformatParameterComment(tok).orElse(tok.getOriginalText());
        }
        Range<Integer> computeRange() {
            return Range.singleton(tok.getIndex()).canonical(INTEGERS);
        }
        String text;
        public State computeBreaks(CommentsHelper commentsHelper, int maxWidth, State state) {
            text = commentsHelper.rewrite(tok, maxWidth, state.column);
            int firstLineLength = text.length() - Iterators.getLast(Newlines.lineOffsetIterator(text));
            return state.withColumn(state.column + firstLineLength);
        }
        public void write(Output output) {
            output.append(text, range());
        }
        public String toString() {
            return MoreObjects.toStringHelper(this).add("tok", tok).toString();
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```