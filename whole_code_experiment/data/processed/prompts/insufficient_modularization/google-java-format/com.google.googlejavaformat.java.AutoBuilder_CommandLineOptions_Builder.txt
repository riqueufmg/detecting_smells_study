##CONTEXT_SIZE=1312
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.googlejavaformat.java;
class AutoBuilder_CommandLineOptions_Builder implements CommandLineOptions.Builder {
    private ImmutableList.Builder<String> filesBuilder$;
    private ImmutableList<String> files;
    private Boolean inPlace;
    private ImmutableRangeSet<Integer> lines;
    private ImmutableList.Builder<Integer> offsetsBuilder$;
    private ImmutableList<Integer> offsets;
    private ImmutableList.Builder<Integer> lengthsBuilder$;
    private ImmutableList<Integer> lengths;
    private Boolean aosp;
    private Boolean version;
    private Boolean help;
    private Boolean stdin;
    private Boolean fixImportsOnly;
    private Boolean sortImports;
    private Boolean removeUnusedImports;
    private Boolean dryRun;
    private Boolean setExitIfChanged;
    private Optional<String> assumeFilename = Optional.empty();
    private Boolean reflowLongStrings;
    private Boolean formatJavadoc;
    AutoBuilder_CommandLineOptions_Builder() {
    }
    public ImmutableList.Builder<String> filesBuilder() {
        if (filesBuilder$ == null) {
            filesBuilder$ = ImmutableList.builder();
        }
        return filesBuilder$;
    }
    public CommandLineOptions.Builder inPlace(boolean inPlace) {
        this.inPlace = inPlace;
        return this;
    }
    public CommandLineOptions.Builder lines(ImmutableRangeSet<Integer> lines) {
        if (lines == null) {
            throw new NullPointerException("Null lines");
        }
        this.lines = lines;
        return this;
    }
    public ImmutableList.Builder<Integer> offsetsBuilder() {
        if (offsetsBuilder$ == null) {
            offsetsBuilder$ = ImmutableList.builder();
        }
        return offsetsBuilder$;
    }
    public ImmutableList.Builder<Integer> lengthsBuilder() {
        if (lengthsBuilder$ == null) {
            lengthsBuilder$ = ImmutableList.builder();
        }
        return lengthsBuilder$;
    }
    public CommandLineOptions.Builder aosp(boolean aosp) {
        this.aosp = aosp;
        return this;
    }
    public CommandLineOptions.Builder version(boolean version) {
        this.version = version;
        return this;
    }
    public CommandLineOptions.Builder help(boolean help) {
        this.help = help;
        return this;
    }
    public CommandLineOptions.Builder stdin(boolean stdin) {
        this.stdin = stdin;
        return this;
    }
    public CommandLineOptions.Builder fixImportsOnly(boolean fixImportsOnly) {
        this.fixImportsOnly = fixImportsOnly;
        return this;
    }
    public CommandLineOptions.Builder sortImports(boolean sortImports) {
        this.sortImports = sortImports;
        return this;
    }
    public CommandLineOptions.Builder removeUnusedImports(boolean removeUnusedImports) {
        this.removeUnusedImports = removeUnusedImports;
        return this;
    }
    public CommandLineOptions.Builder dryRun(boolean dryRun) {
        this.dryRun = dryRun;
        return this;
    }
    public CommandLineOptions.Builder setExitIfChanged(boolean setExitIfChanged) {
        this.setExitIfChanged = setExitIfChanged;
        return this;
    }
    public CommandLineOptions.Builder assumeFilename(String assumeFilename) {
        this.assumeFilename = Optional.of(assumeFilename);
        return this;
    }
    public CommandLineOptions.Builder reflowLongStrings(boolean reflowLongStrings) {
        this.reflowLongStrings = reflowLongStrings;
        return this;
    }
    public CommandLineOptions.Builder formatJavadoc(boolean formatJavadoc) {
        this.formatJavadoc = formatJavadoc;
        return this;
    }
    public CommandLineOptions build() {
        if (filesBuilder$ != null) {
            this.files = filesBuilder$.build();
        } else if (this.files == null) {
            this.files = ImmutableList.of();
        }
        if (offsetsBuilder$ != null) {
            this.offsets = offsetsBuilder$.build();
        } else if (this.offsets == null) {
            this.offsets = ImmutableList.of();
        }
        if (lengthsBuilder$ != null) {
            this.lengths = lengthsBuilder$.build();
        } else if (this.lengths == null) {
            this.lengths = ImmutableList.of();
        }
        if (this.inPlace == null || this.lines == null || this.aosp == null || this.version == null || this.help == null || this.stdin == null || this.fixImportsOnly == null || this.sortImports == null || this.removeUnusedImports == null || this.dryRun == null || this.setExitIfChanged == null || this.reflowLongStrings == null || this.formatJavadoc == null) {
            StringBuilder missing = new StringBuilder();
            if (this.inPlace == null) {
                missing.append(" inPlace");
            }
            if (this.lines == null) {
                missing.append(" lines");
            }
            if (this.aosp == null) {
                missing.append(" aosp");
            }
            if (this.version == null) {
                missing.append(" version");
            }
            if (this.help == null) {
                missing.append(" help");
            }
            if (this.stdin == null) {
                missing.append(" stdin");
            }
            if (this.fixImportsOnly == null) {
                missing.append(" fixImportsOnly");
            }
            if (this.sortImports == null) {
                missing.append(" sortImports");
            }
            if (this.removeUnusedImports == null) {
                missing.append(" removeUnusedImports");
            }
            if (this.dryRun == null) {
                missing.append(" dryRun");
            }
            if (this.setExitIfChanged == null) {
                missing.append(" setExitIfChanged");
            }
            if (this.reflowLongStrings == null) {
                missing.append(" reflowLongStrings");
            }
            if (this.formatJavadoc == null) {
                missing.append(" formatJavadoc");
            }
            throw new IllegalStateException("Missing required properties:" + missing);
        }
        return new CommandLineOptions(this.files, this.inPlace, this.lines, this.offsets, this.lengths, this.aosp, this.version, this.help, this.stdin, this.fixImportsOnly, this.sortImports, this.removeUnusedImports, this.dryRun, this.setExitIfChanged, this.assumeFilename, this.reflowLongStrings, this.formatJavadoc);
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```