##CONTEXT_SIZE=3314
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.googlejavaformat;
public final class OpsBuilder {
    public int actualSize(int position, int length) {
        Token startToken = input.getPositionTokenMap().get(position);
        int start = startToken.getTok().getPosition();
        for (Tok tok : startToken.getToksBefore()) {
            if (tok.isComment()) {
                start = min(start, tok.getPosition());
            }
        }
        Token endToken = input.getPositionTokenMap().get(position + length - 1);
        int end = endToken.getTok().getPosition() + endToken.getTok().length();
        for (Tok tok : endToken.getToksAfter()) {
            if (tok.isComment()) {
                end = max(end, tok.getPosition() + tok.length());
            }
        }
        return end - start;
    }
    public Integer actualStartColumn(int position) {
        Token startToken = input.getPositionTokenMap().get(position);
        int start = startToken.getTok().getPosition();
        int line0 = input.getLineNumber(start);
        for (Tok tok : startToken.getToksBefore()) {
            if (line0 != input.getLineNumber(tok.getPosition())) {
                return start;
            }
            if (tok.isComment()) {
                start = min(start, tok.getPosition());
            }
        }
        return start;
    }
    public abstract static class BlankLineWanted {
        public static final BlankLineWanted YES = new SimpleBlankLine(Optional.of(true));
        public static final BlankLineWanted NO = new SimpleBlankLine(Optional.of(false));
        public static final BlankLineWanted PRESERVE = new SimpleBlankLine(Optional.empty());
        public abstract Optional<Boolean> wanted();
        public abstract BlankLineWanted merge(BlankLineWanted wanted);
        public static BlankLineWanted conditional(BreakTag breakTag) {
            return new ConditionalBlankLine(ImmutableList.of(breakTag));
        }
        private static final class SimpleBlankLine extends BlankLineWanted {
            private final Optional<Boolean> wanted;
            SimpleBlankLine(Optional<Boolean> wanted) {
                this.wanted = wanted;
            }
            public Optional<Boolean> wanted() {
                return wanted;
            }
            public BlankLineWanted merge(BlankLineWanted other) {
                return this;
            }
        }
        private static final class ConditionalBlankLine extends BlankLineWanted {
            private final ImmutableList<BreakTag> tags;
            ConditionalBlankLine(Iterable<BreakTag> tags) {
                this.tags = ImmutableList.copyOf(tags);
            }
            public Optional<Boolean> wanted() {
                for (BreakTag tag : tags) {
                    if (tag.wasBreakTaken()) {
                        return Optional.of(true);
                    }
                }
                return Optional.empty();
            }
            public BlankLineWanted merge(BlankLineWanted other) {
                if (!(other instanceof ConditionalBlankLine)) {
                    return other;
                }
                return new ConditionalBlankLine(Iterables.concat(this.tags, ((ConditionalBlankLine) other).tags));
            }
        }
    }
    private final Input input;
    private final List<Op> ops = new ArrayList<>();
    private final Output output;
    private static final Indent.Const ZERO = Indent.Const.ZERO;
    private int tokenI = 0;
    private int inputPosition = Integer.MIN_VALUE;
    int depth = 0;
    public final void add(Op op) {
        if (op instanceof OpenOp) {
            depth++;
        } else if (op instanceof CloseOp) {
            depth--;
            if (depth < 0) {
                throw new AssertionError();
            }
        }
        ops.add(op);
    }
    public final void addAll(List<Op> ops) {
        for (Op op : ops) {
            add(op);
        }
    }
    public OpsBuilder(Input input, Output output) {
        this.input = input;
        this.output = output;
    }
    public final Input getInput() {
        return input;
    }
    public int depth() {
        return depth;
    }
    public void checkClosed(int previous) {
        if (depth != previous) {
            throw new FormattingError(diagnostic(String.format("saw %d unclosed ops", depth)));
        }
    }
    public FormatterDiagnostic diagnostic(String message) {
        return input.createDiagnostic(inputPosition, message);
    }
    public final void sync(int inputPosition) {
        if (inputPosition > this.inputPosition) {
            ImmutableList<? extends Input.Token> tokens = input.getTokens();
            int tokensN = tokens.size();
            this.inputPosition = inputPosition;
            if (tokenI < tokensN && inputPosition > tokens.get(tokenI).getTok().getPosition()) {
                Input.Token token = tokens.get(tokenI++);
                throw new FormattingError(diagnostic(String.format("did not generate token \"%s\"", token.getTok().getText())));
            }
        }
    }
    public final void drain() {
        int inputPosition = input.getText().length() + 1;
        if (inputPosition > this.inputPosition) {
            ImmutableList<? extends Input.Token> tokens = input.getTokens();
            int tokensN = tokens.size();
            while (tokenI < tokensN && inputPosition > tokens.get(tokenI).getTok().getPosition()) {
                Input.Token token = tokens.get(tokenI++);
                add(Doc.Token.make(token, Doc.Token.RealOrImaginary.IMAGINARY, ZERO, Optional.empty()));
            }
        }
        this.inputPosition = inputPosition;
        checkClosed(0);
    }
    public final void open(Indent plusIndent) {
        add(OpenOp.make(plusIndent));
    }
    public final void close() {
        add(CloseOp.make());
    }
    public final Optional<String> peekToken() {
        return peekToken(0);
    }
    public final Optional<String> peekToken(int skip) {
        ImmutableList<? extends Input.Token> tokens = input.getTokens();
        int idx = tokenI + skip;
        return idx < tokens.size() ? Optional.of(tokens.get(idx).getTok().getOriginalText()) : Optional.empty();
    }
    public ImmutableList<Tok> peekTokens(int startPosition, Predicate<Input.Tok> predicate) {
        ImmutableList<? extends Input.Token> tokens = input.getTokens();
        Preconditions.checkState(tokens.get(tokenI).getTok().getPosition() == startPosition, "Expected the current token to be at position %s, found: %s", startPosition, tokens.get(tokenI));
        ImmutableList.Builder<Tok> result = ImmutableList.builder();
        for (int idx = tokenI; idx < tokens.size(); idx++) {
            Tok tok = tokens.get(idx).getTok();
            if (!predicate.apply(tok)) {
                break;
            }
            result.add(tok);
        }
        return result.build();
    }
    public final void guessToken(String token) {
        token(token, Doc.Token.RealOrImaginary.IMAGINARY, ZERO, Optional.empty());
    }
    public final void token(String token, Doc.Token.RealOrImaginary realOrImaginary, Indent plusIndentCommentsBefore, Optional<Indent> breakAndIndentTrailingComment) {
        ImmutableList<? extends Input.Token> tokens = input.getTokens();
        if (token.equals(peekToken().orElse(null))) {
            add(Doc.Token.make(tokens.get(tokenI++), Doc.Token.RealOrImaginary.REAL, plusIndentCommentsBefore, breakAndIndentTrailingComment));
        } else {
            if (realOrImaginary.isReal()) {
                throw new FormattingError(diagnostic(String.format("expected token: '%s'; generated %s instead", peekToken().orElse(null), token)));
            }
        }
    }
    public final void op(String op) {
        int opN = op.length();
        for (int i = 0; i < opN; i++) {
            token(op.substring(i, i + 1), Doc.Token.RealOrImaginary.REAL, ZERO, Optional.empty());
        }
    }
    public final void space() {
        add(Doc.Space.make());
    }
    public final void breakOp() {
        breakOp(Doc.FillMode.UNIFIED, "", ZERO);
    }
    public final void breakOp(Indent plusIndent) {
        breakOp(Doc.FillMode.UNIFIED, "", plusIndent);
    }
    public final void breakToFill() {
        breakOp(Doc.FillMode.INDEPENDENT, "", ZERO);
    }
    public final void forcedBreak() {
        breakOp(Doc.FillMode.FORCED, "", ZERO);
    }
    public final void forcedBreak(Indent plusIndent) {
        breakOp(Doc.FillMode.FORCED, "", plusIndent);
    }
    public final void breakOp(String flat) {
        breakOp(Doc.FillMode.UNIFIED, flat, ZERO);
    }
    public final void breakToFill(String flat) {
        breakOp(Doc.FillMode.INDEPENDENT, flat, ZERO);
    }
    public final void breakOp(Doc.FillMode fillMode, String flat, Indent plusIndent) {
        breakOp(fillMode, flat, plusIndent, Optional.empty());
    }
    public final void breakOp(Doc.FillMode fillMode, String flat, Indent plusIndent, Optional<BreakTag> optionalTag) {
        add(Doc.Break.make(fillMode, flat, plusIndent, optionalTag));
    }
    private int lastPartialFormatBoundary = -1;
    public void markForPartialFormat() {
        if (lastPartialFormatBoundary == -1) {
            lastPartialFormatBoundary = tokenI;
            return;
        }
        if (tokenI == lastPartialFormatBoundary) {
            return;
        }
        Token start = input.getTokens().get(lastPartialFormatBoundary);
        Token end = input.getTokens().get(tokenI - 1);
        output.markForPartialFormat(start, end);
        lastPartialFormatBoundary = tokenI;
    }
    public final void blankLineWanted(BlankLineWanted wanted) {
        output.blankLine(getI(input.getTokens().get(tokenI)), wanted);
    }
    private static int getI(Input.Token token) {
        for (Input.Tok tok : token.getToksBefore()) {
            if (tok.getIndex() >= 0) {
                return tok.getIndex();
            }
        }
        return token.getTok().getIndex();
    }
    private static final Doc.Space SPACE = Doc.Space.make();
    public final ImmutableList<Op> build() {
        markForPartialFormat();
        Multimap<Integer, Op> tokOps = ArrayListMultimap.create();
        int opsN = ops.size();
        for (int i = 0; i < opsN; i++) {
            Op op = ops.get(i);
            if (op instanceof Doc.Token) {
                Doc.Token tokenOp = (Doc.Token) op;
                Input.Token token = tokenOp.getToken();
                int j = i;
                while (0 < j && ops.get(j - 1) instanceof OpenOp) {
                    --j;
                }
                int k = i;
                while (k + 1 < opsN && ops.get(k + 1) instanceof CloseOp) {
                    ++k;
                }
                if (tokenOp.realOrImaginary().isReal()) {
                    int newlines = 0;
                    boolean space = false;
                    boolean lastWasComment = false;
                    boolean allowBlankAfterLastComment = false;
                    for (Input.Tok tokBefore : token.getToksBefore()) {
                        if (tokBefore.isNewline()) {
                            newlines++;
                        } else if (tokBefore.isComment()) {
                            tokOps.put(j, Doc.Break.make(tokBefore.isSlashSlashComment() ? Doc.FillMode.FORCED : Doc.FillMode.UNIFIED, "", tokenOp.getPlusIndentCommentsBefore()));
                            tokOps.putAll(j, makeComment(tokBefore));
                            space = tokBefore.isSlashStarComment();
                            newlines = 0;
                            lastWasComment = true;
                            if (tokBefore.isJavadocComment()) {
                                tokOps.put(j, Doc.Break.makeForced());
                            }
                            allowBlankAfterLastComment = tokBefore.isSlashSlashComment() || (tokBefore.isSlashStarComment() && !tokBefore.isJavadocComment());
                        }
                    }
                    if (allowBlankAfterLastComment && newlines > 1) {
                        output.blankLine(token.getTok().getIndex(), BlankLineWanted.YES);
                    }
                    if (lastWasComment && newlines > 0) {
                        tokOps.put(j, Doc.Break.makeForced());
                    } else if (space) {
                        tokOps.put(j, SPACE);
                    }
                    for (Input.Tok tokAfter : token.getToksAfter()) {
                        if (tokAfter.isComment()) {
                            boolean breakAfter = tokAfter.isJavadocComment() || (tokAfter.isSlashStarComment() && tokenOp.breakAndIndentTrailingComment().isPresent());
                            if (breakAfter) {
                                tokOps.put(k + 1, Doc.Break.make(Doc.FillMode.FORCED, "", tokenOp.breakAndIndentTrailingComment().orElse(Const.ZERO)));
                            } else {
                                tokOps.put(k + 1, SPACE);
                            }
                            tokOps.putAll(k + 1, makeComment(tokAfter));
                            if (breakAfter) {
                                tokOps.put(k + 1, Doc.Break.make(Doc.FillMode.FORCED, "", ZERO));
                            }
                        }
                    }
                } else {
                    int newlines = 0;
                    boolean lastWasComment = false;
                    for (Input.Tok tokBefore : token.getToksBefore()) {
                        if (tokBefore.isNewline()) {
                            newlines++;
                        } else if (tokBefore.isComment()) {
                            newlines = 0;
                            lastWasComment = tokBefore.isComment();
                        }
                        if (lastWasComment && newlines > 0) {
                            tokOps.put(j, Doc.Break.makeForced());
                        }
                        tokOps.put(j, Doc.Tok.make(tokBefore));
                    }
                    for (Input.Tok tokAfter : token.getToksAfter()) {
                        tokOps.put(k + 1, Doc.Tok.make(tokAfter));
                    }
                }
            }
        }
        ImmutableList.Builder<Op> newOps = ImmutableList.builder();
        boolean afterForcedBreak = false;
        for (int i = 0; i < opsN; i++) {
            for (Op op : tokOps.get(i)) {
                if (!(afterForcedBreak && op instanceof Doc.Space)) {
                    newOps.add(op);
                    afterForcedBreak = isForcedBreak(op);
                }
            }
            Op op = ops.get(i);
            if (afterForcedBreak && (op instanceof Doc.Space || (op instanceof Doc.Break && ((Doc.Break) op).getPlusIndent() == 0 && " ".equals(((Doc) op).getFlat())))) {
                continue;
            }
            newOps.add(op);
            if (!(op instanceof OpenOp)) {
                afterForcedBreak = isForcedBreak(op);
            }
        }
        for (Op op : tokOps.get(opsN)) {
            if (!(afterForcedBreak && op instanceof Doc.Space)) {
                newOps.add(op);
                afterForcedBreak = isForcedBreak(op);
            }
        }
        return newOps.build();
    }
    private static boolean isForcedBreak(Op op) {
        return op instanceof Doc.Break && ((Doc.Break) op).isForced();
    }
    private static List<Op> makeComment(Input.Tok comment) {
        return comment.isSlashStarComment() ? ImmutableList.of(Doc.Tok.make(comment)) : ImmutableList.of(Doc.Tok.make(comment), Doc.Break.makeForced());
    }
    public final String toString() {
        return MoreObjects.toStringHelper(this).add("input", input).add("ops", ops).add("output", output).add("tokenI", tokenI).add("inputPosition", inputPosition).toString();
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```