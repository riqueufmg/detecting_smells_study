##CONTEXT_SIZE=1120
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.googlejavaformat.java;
final class JavacTokens {
    private static final CharSequence EOF_COMMENT = "\n//EOF";
    static class RawTok {
        private final String stringVal;
        private final TokenKind kind;
        private final int pos;
        private final int endPos;
        RawTok(String stringVal, TokenKind kind, int pos, int endPos) {
            this.stringVal = stringVal;
            this.kind = kind;
            this.pos = pos;
            this.endPos = endPos;
        }
        public TokenKind kind() {
            return kind;
        }
        public int pos() {
            return pos;
        }
        public int endPos() {
            return endPos;
        }
        public String stringVal() {
            return stringVal;
        }
    }
    public static ImmutableList<RawTok> getTokens(String source, Context context, Set<TokenKind> stopTokens) {
        if (source == null) {
            return ImmutableList.of();
        }
        ScannerFactory fac = ScannerFactory.instance(context);
        char[] buffer = (source + EOF_COMMENT).toCharArray();
        CommentSavingTokenizer tokenizer = new CommentSavingTokenizer(fac, buffer, buffer.length);
        Scanner scanner = new AccessibleScanner(fac, tokenizer);
        ImmutableList.Builder<RawTok> tokens = ImmutableList.builder();
        int end = source.length();
        int last = 0;
        do {
            scanner.nextToken();
            Token t = scanner.token();
            if (t.comments != null) {
                for (CommentWithTextAndPosition c : getComments(t, tokenizer.comments())) {
                    if (last < c.getSourcePos(0)) {
                        tokens.add(new RawTok(null, null, last, c.getSourcePos(0)));
                    }
                    tokens.add(new RawTok(null, null, c.getSourcePos(0), c.getSourcePos(0) + c.getText().length()));
                    last = c.getSourcePos(0) + c.getText().length();
                }
            }
            if (stopTokens.contains(t.kind)) {
                if (t.kind != TokenKind.EOF) {
                    end = t.pos;
                }
                break;
            }
            if (last < t.pos) {
                tokens.add(new RawTok(null, null, last, t.pos));
            }
            tokens.add(new RawTok(t.kind == TokenKind.STRINGLITERAL ? "\"" + t.stringVal() + "\"" : null, t.kind, t.pos, t.endPos));
            last = t.endPos;
        } while (scanner.token().kind != TokenKind.EOF);
        if (last < end) {
            tokens.add(new RawTok(null, null, last, end));
        }
        return tokens.build();
    }
    private static ImmutableList<CommentWithTextAndPosition> getComments(Token token, Map<Comment, CommentWithTextAndPosition> comments) {
        if (token.comments == null) {
            return ImmutableList.of();
        }
        return token.comments.stream().map(comments::get).collect(toImmutableList()).reverse();
    }
    static class CommentSavingTokenizer extends JavaTokenizer {
        private final Map<Comment, CommentWithTextAndPosition> comments = new HashMap<>();
        CommentSavingTokenizer(ScannerFactory fac, char[] buffer, int length) {
            super(fac, buffer, length);
        }
        Map<Comment, CommentWithTextAndPosition> comments() {
            return comments;
        }
        protected Comment processComment(int pos, int endPos, CommentStyle style) {
            char[] buf = getRawCharactersReflectively(pos, endPos);
            Comment comment = super.processComment(pos, endPos, style);
            CommentWithTextAndPosition commentWithTextAndPosition = new CommentWithTextAndPosition(pos, endPos, new String(buf));
            comments.put(comment, commentWithTextAndPosition);
            return comment;
        }
        private char[] getRawCharactersReflectively(int beginIndex, int endIndex) {
            Object instance;
            try {
                instance = JavaTokenizer.class.getDeclaredField("reader").get(this);
            } catch (ReflectiveOperationException e) {
                instance = this;
            }
            try {
                return (char[]) instance.getClass().getMethod("getRawCharacters", int.class, int.class).invoke(instance, beginIndex, endIndex);
            } catch (ReflectiveOperationException e) {
                throw new LinkageError(e.getMessage(), e);
            }
        }
    }
    static class CommentWithTextAndPosition {
        private final int pos;
        private final int endPos;
        private final String text;
        public CommentWithTextAndPosition(int pos, int endPos, String text) {
            this.pos = pos;
            this.endPos = endPos;
            this.text = text;
        }
        public int getSourcePos(int index) {
            checkArgument(0 <= index && index < (endPos - pos), "Expected %s in the range [0, %s)", index, endPos - pos);
            return pos + index;
        }
        public String getText() {
            return text;
        }
        public String toString() {
            return String.format("Comment: '%s'", getText());
        }
    }
    static class AccessibleScanner extends Scanner {
        protected AccessibleScanner(ScannerFactory fac, JavaTokenizer tokenizer) {
            super(fac, tokenizer);
        }
    }
    private JavacTokens() {
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```