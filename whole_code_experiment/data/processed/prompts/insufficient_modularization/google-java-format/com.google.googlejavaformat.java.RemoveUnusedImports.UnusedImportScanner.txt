##CONTEXT_SIZE=1784
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.googlejavaformat.java;
public class RemoveUnusedImports {
    private static class UnusedImportScanner extends TreePathScanner<Void, Void> {
        private final Set<String> usedNames = new LinkedHashSet<>();
        private final Multimap<String, Range<Integer>> usedInJavadoc = HashMultimap.create();
        final JavacTrees trees;
        final DocTreeScanner docTreeSymbolScanner;
        private UnusedImportScanner(JavacTrees trees) {
            this.trees = trees;
            docTreeSymbolScanner = new DocTreeScanner();
        }
        public Void visitImport(ImportTree importTree, Void usedSymbols) {
            return null;
        }
        public Void visitIdentifier(IdentifierTree tree, Void unused) {
            if (tree == null) {
                return null;
            }
            usedNames.add(tree.getName().toString());
            return null;
        }
        public Void visitCase(CaseTree tree, Void unused) {
            if (CASE_TREE_GET_LABELS != null) {
                try {
                    scan((List<? extends Tree>) CASE_TREE_GET_LABELS.invoke(tree), null);
                } catch (ReflectiveOperationException e) {
                    throw new LinkageError(e.getMessage(), e);
                }
            }
            return super.visitCase(tree, null);
        }
        private static final Method CASE_TREE_GET_LABELS = caseTreeGetLabels();
        private static Method caseTreeGetLabels() {
            try {
                return CaseTree.class.getMethod("getLabels");
            } catch (NoSuchMethodException e) {
                return null;
            }
        }
        public Void scan(Tree tree, Void unused) {
            if (tree == null) {
                return null;
            }
            scanJavadoc();
            return super.scan(tree, unused);
        }
        private void scanJavadoc() {
            if (getCurrentPath() == null) {
                return;
            }
            DocCommentTree commentTree = trees.getDocCommentTree(getCurrentPath());
            if (commentTree == null) {
                return;
            }
            docTreeSymbolScanner.scan(new DocTreePath(getCurrentPath(), commentTree), null);
        }
        class DocTreeScanner extends DocTreePathScanner<Void, Void> {
            public Void visitIdentifier(com.sun.source.doctree.IdentifierTree node, Void aVoid) {
                return null;
            }
            public Void visitReference(ReferenceTree referenceTree, Void unused) {
                DCReference reference = (DCReference) referenceTree;
                long basePos = reference.pos((DCTree.DCDocComment) getCurrentPath().getDocComment()).getStartPosition();
                if (reference.qualifierExpression != null) {
                    new ReferenceScanner(basePos).scan(reference.qualifierExpression, null);
                }
                if (reference.paramTypes != null) {
                    for (JCTree param : reference.paramTypes) {
                        new ReferenceScanner(-1).scan(param, null);
                    }
                }
                return null;
            }
            private class ReferenceScanner extends TreeScanner<Void, Void> {
                private final long basePos;
                public ReferenceScanner(long basePos) {
                    this.basePos = basePos;
                }
                public Void visitIdentifier(IdentifierTree node, Void aVoid) {
                    usedInJavadoc.put(node.getName().toString(), basePos != -1 ? Range.closedOpen((int) basePos, (int) basePos + node.getName().length()) : null);
                    return super.visitIdentifier(node, aVoid);
                }
            }
        }
    }
    public static String removeUnusedImports(final String contents) throws FormatterException {
        Context context = new Context();
        JCCompilationUnit unit = parse(context, contents);
        if (unit == null) {
            return contents;
        }
        UnusedImportScanner scanner = new UnusedImportScanner(JavacTrees.instance(context));
        scanner.scan(unit, null);
        return applyReplacements(contents, buildReplacements(contents, unit, scanner.usedNames, scanner.usedInJavadoc));
    }
    private static JCCompilationUnit parse(Context context, String javaInput) throws FormatterException {
        List<Diagnostic<? extends JavaFileObject>> errorDiagnostics = new ArrayList<>();
        JCTree.JCCompilationUnit unit = Trees.parse(context, errorDiagnostics, false, javaInput);
        if (!errorDiagnostics.isEmpty()) {
            throw FormatterException.fromJavacDiagnostics(errorDiagnostics);
        }
        return unit;
    }
    private static RangeMap<Integer, String> buildReplacements(String contents, JCCompilationUnit unit, Set<String> usedNames, Multimap<String, Range<Integer>> usedInJavadoc) {
        RangeMap<Integer, String> replacements = TreeRangeMap.create();
        for (JCTree importTree : unit.getImports()) {
            if (isModuleImport(importTree)) {
                continue;
            }
            String simpleName = getSimpleName(importTree);
            if (!isUnused(unit, usedNames, usedInJavadoc, importTree, simpleName)) {
                continue;
            }
            int endPosition = getEndPosition(importTree, unit);
            endPosition = max(CharMatcher.isNot(' ').indexIn(contents, endPosition), endPosition);
            String sep = Newlines.guessLineSeparator(contents);
            if (endPosition + sep.length() < contents.length() && contents.subSequence(endPosition, endPosition + sep.length()).toString().equals(sep)) {
                endPosition += sep.length();
            }
            replacements.put(Range.closedOpen(importTree.getStartPosition(), endPosition), "");
        }
        return replacements;
    }
    private static String getSimpleName(JCTree importTree) {
        return getQualifiedIdentifier(importTree).getIdentifier().toString();
    }
    private static boolean isUnused(JCCompilationUnit unit, Set<String> usedNames, Multimap<String, Range<Integer>> usedInJavadoc, JCTree importTree, String simpleName) {
        JCFieldAccess qualifiedIdentifier = getQualifiedIdentifier(importTree);
        String qualifier = qualifiedIdentifier.getExpression().toString();
        if (qualifier.equals("java.lang")) {
            return true;
        }
        if (unit.getPackageName() != null && unit.getPackageName().toString().equals(qualifier)) {
            return true;
        }
        if (qualifiedIdentifier.getIdentifier().contentEquals("*")) {
            return false;
        }
        if (usedNames.contains(simpleName)) {
            return false;
        }
        if (usedInJavadoc.containsKey(simpleName)) {
            return false;
        }
        return true;
    }
    private static final Method GET_QUALIFIED_IDENTIFIER_METHOD = getQualifiedIdentifierMethod();
    private static Method getQualifiedIdentifierMethod() {
        try {
            return JCImport.class.getMethod("getQualifiedIdentifier");
        } catch (NoSuchMethodException e) {
            return null;
        }
    }
    private static JCFieldAccess getQualifiedIdentifier(JCTree importTree) {
        checkArgument(!isModuleImport(importTree));
        try {
            return (JCFieldAccess) GET_QUALIFIED_IDENTIFIER_METHOD.invoke(importTree);
        } catch (ReflectiveOperationException e) {
            throw new LinkageError(e.getMessage(), e);
        }
    }
    private static final Method IS_MODULE_METHOD = getIsModuleMethod();
    private static Method getIsModuleMethod() {
        try {
            return ImportTree.class.getMethod("isModule");
        } catch (NoSuchMethodException ignored) {
            return null;
        }
    }
    private static boolean isModuleImport(JCTree importTree) {
        if (IS_MODULE_METHOD == null) {
            return false;
        }
        try {
            return (boolean) IS_MODULE_METHOD.invoke(importTree);
        } catch (ReflectiveOperationException e) {
            throw new LinkageError(e.getMessage(), e);
        }
    }
    private static String applyReplacements(String source, RangeMap<Integer, String> replacements) {
        RangeSet<Integer> fixedRanges = TreeRangeSet.create();
        StringBuilder sb = new StringBuilder(source);
        int offset = 0;
        for (Map.Entry<Range<Integer>, String> replacement : replacements.asMapOfRanges().entrySet()) {
            Range<Integer> range = replacement.getKey();
            String replaceWith = replacement.getValue();
            int start = offset + range.lowerEndpoint();
            int end = offset + range.upperEndpoint();
            sb.replace(start, end, replaceWith);
            if (!replaceWith.isEmpty()) {
                fixedRanges.add(Range.closedOpen(start, end));
            }
            offset += replaceWith.length() - (range.upperEndpoint() - range.lowerEndpoint());
        }
        return sb.toString();
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```