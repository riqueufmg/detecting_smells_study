##CONTEXT_SIZE=557
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.googlejavaformat;
public abstract class InputOutput {
    private ImmutableList<String> lines = ImmutableList.of();
    protected static final Range<Integer> EMPTY_RANGE = Range.closedOpen(-1, -1);
    private static final DiscreteDomain<Integer> INTEGERS = DiscreteDomain.integers();
    protected final void setLines(ImmutableList<String> lines) {
        this.lines = lines;
    }
    public final int getLineCount() {
        return lines.size();
    }
    public final String getLine(int lineI) {
        return lines.get(lineI);
    }
    protected final List<Range<Integer>> ranges = new ArrayList<>();
    private static void addToRanges(List<Range<Integer>> ranges, int i, int k) {
        while (ranges.size() <= i) {
            ranges.add(EMPTY_RANGE);
        }
        Range<Integer> oldValue = ranges.get(i);
        ranges.set(i, Range.closedOpen(oldValue.isEmpty() ? k : oldValue.lowerEndpoint(), k + 1));
    }
    protected final void computeRanges(List<? extends Input.Tok> toks) {
        int lineI = 0;
        for (Input.Tok tok : toks) {
            String txt = tok.getOriginalText();
            int lineI0 = lineI;
            lineI += Newlines.count(txt);
            int k = tok.getIndex();
            if (k >= 0) {
                for (int i = lineI0; i <= lineI; i++) {
                    addToRanges(ranges, i, k);
                }
            }
        }
    }
    public static Map<Integer, Range<Integer>> makeKToIJ(InputOutput put) {
        Map<Integer, Range<Integer>> map = new HashMap<>();
        int ijN = put.getLineCount();
        for (int ij = 0; ij <= ijN; ij++) {
            Range<Integer> range = put.getRanges(ij).canonical(INTEGERS);
            for (int k = range.lowerEndpoint(); k < range.upperEndpoint(); k++) {
                if (map.containsKey(k)) {
                    map.put(k, Range.closedOpen(map.get(k).lowerEndpoint(), ij + 1));
                } else {
                    map.put(k, Range.closedOpen(ij, ij + 1));
                }
            }
        }
        return map;
    }
    public final Range<Integer> getRanges(int lineI) {
        return 0 <= lineI && lineI < ranges.size() ? ranges.get(lineI) : EMPTY_RANGE;
    }
    public String toString() {
        return "InputOutput{" + "lines=" + lines + ", ranges=" + ranges + '}';
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```