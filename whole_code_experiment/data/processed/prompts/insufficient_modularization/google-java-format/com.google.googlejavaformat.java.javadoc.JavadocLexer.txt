##CONTEXT_SIZE=3343
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.googlejavaformat.java.javadoc;
final class JavadocLexer {
    static ImmutableList<Token> lex(String input) throws LexException {
        input = stripJavadocBeginAndEnd(input);
        input = normalizeLineEndings(input);
        return new JavadocLexer(new CharStream(input)).generateTokens();
    }
    private static String normalizeLineEndings(String input) {
        return NON_UNIX_LINE_ENDING.matcher(input).replaceAll("\n");
    }
    private static final Pattern NON_UNIX_LINE_ENDING = Pattern.compile("\r\n?");
    private static String stripJavadocBeginAndEnd(String input) {
        checkArgument(input.startsWith("/**"), "Missing /**: %s", input);
        checkArgument(input.endsWith("*/") && input.length() > 4, "Missing */: %s", input);
        return input.substring("/**".length(), input.length() - "*/".length());
    }
    private final CharStream input;
    private final NestingCounter braceDepth = new NestingCounter();
    private final NestingCounter preDepth = new NestingCounter();
    private final NestingCounter codeDepth = new NestingCounter();
    private final NestingCounter tableDepth = new NestingCounter();
    private boolean outerInlineTagIsSnippet;
    private boolean somethingSinceNewline;
    private JavadocLexer(CharStream input) {
        this.input = checkNotNull(input);
    }
    private ImmutableList<Token> generateTokens() throws LexException {
        ImmutableList.Builder<Token> tokens = ImmutableList.builder();
        Token token = new Token(BEGIN_JAVADOC, "/**");
        tokens.add(token);
        while (!input.isExhausted()) {
            token = readToken();
            tokens.add(token);
        }
        checkMatchingTags();
        token = new Token(END_JAVADOC, "*/");
        tokens.add(token);
        ImmutableList<Token> result = tokens.build();
        result = joinAdjacentLiteralsAndAdjacentWhitespace(result);
        result = inferParagraphTags(result);
        result = optionalizeSpacesAfterLinks(result);
        result = deindentPreCodeBlocks(result);
        return result;
    }
    private Token readToken() throws LexException {
        Type type = consumeToken();
        String value = input.readAndResetRecorded();
        return new Token(type, value);
    }
    private Type consumeToken() throws LexException {
        boolean preserveExistingFormatting = preserveExistingFormatting();
        if (input.tryConsumeRegex(NEWLINE_PATTERN)) {
            somethingSinceNewline = false;
            return preserveExistingFormatting ? FORCED_NEWLINE : WHITESPACE;
        } else if (input.tryConsume(" ") || input.tryConsume("\t")) {
            return preserveExistingFormatting ? LITERAL : WHITESPACE;
        }
        if (!somethingSinceNewline && input.tryConsumeRegex(FOOTER_TAG_PATTERN)) {
            checkMatchingTags();
            somethingSinceNewline = true;
            return FOOTER_JAVADOC_TAG_START;
        }
        somethingSinceNewline = true;
        if (input.tryConsumeRegex(SNIPPET_TAG_OPEN_PATTERN)) {
            if (braceDepth.value() == 0) {
                braceDepth.increment();
                outerInlineTagIsSnippet = true;
                return SNIPPET_BEGIN;
            }
            braceDepth.increment();
            return LITERAL;
        } else if (input.tryConsumeRegex(INLINE_TAG_OPEN_PATTERN)) {
            braceDepth.increment();
            return LITERAL;
        } else if (input.tryConsume("{")) {
            braceDepth.incrementIfPositive();
            return LITERAL;
        } else if (input.tryConsume("}")) {
            if (outerInlineTagIsSnippet && braceDepth.value() == 1) {
                braceDepth.decrementIfPositive();
                outerInlineTagIsSnippet = false;
                return SNIPPET_END;
            }
            braceDepth.decrementIfPositive();
            return LITERAL;
        }
        if (braceDepth.isPositive()) {
            verify(input.tryConsumeRegex(LITERAL_PATTERN));
            return LITERAL;
        }
        if (input.tryConsumeRegex(PRE_OPEN_PATTERN)) {
            preDepth.increment();
            return preserveExistingFormatting ? LITERAL : PRE_OPEN_TAG;
        } else if (input.tryConsumeRegex(PRE_CLOSE_PATTERN)) {
            preDepth.decrementIfPositive();
            return preserveExistingFormatting() ? LITERAL : PRE_CLOSE_TAG;
        }
        if (input.tryConsumeRegex(CODE_OPEN_PATTERN)) {
            codeDepth.increment();
            return preserveExistingFormatting ? LITERAL : CODE_OPEN_TAG;
        } else if (input.tryConsumeRegex(CODE_CLOSE_PATTERN)) {
            codeDepth.decrementIfPositive();
            return preserveExistingFormatting() ? LITERAL : CODE_CLOSE_TAG;
        }
        if (input.tryConsumeRegex(TABLE_OPEN_PATTERN)) {
            tableDepth.increment();
            return preserveExistingFormatting ? LITERAL : TABLE_OPEN_TAG;
        } else if (input.tryConsumeRegex(TABLE_CLOSE_PATTERN)) {
            tableDepth.decrementIfPositive();
            return preserveExistingFormatting() ? LITERAL : TABLE_CLOSE_TAG;
        }
        if (preserveExistingFormatting) {
            verify(input.tryConsumeRegex(LITERAL_PATTERN));
            return LITERAL;
        }
        if (input.tryConsumeRegex(PARAGRAPH_OPEN_PATTERN)) {
            return PARAGRAPH_OPEN_TAG;
        } else if (input.tryConsumeRegex(PARAGRAPH_CLOSE_PATTERN)) {
            return PARAGRAPH_CLOSE_TAG;
        } else if (input.tryConsumeRegex(LIST_OPEN_PATTERN)) {
            return LIST_OPEN_TAG;
        } else if (input.tryConsumeRegex(LIST_CLOSE_PATTERN)) {
            return LIST_CLOSE_TAG;
        } else if (input.tryConsumeRegex(LIST_ITEM_OPEN_PATTERN)) {
            return LIST_ITEM_OPEN_TAG;
        } else if (input.tryConsumeRegex(LIST_ITEM_CLOSE_PATTERN)) {
            return LIST_ITEM_CLOSE_TAG;
        } else if (input.tryConsumeRegex(BLOCKQUOTE_OPEN_PATTERN)) {
            return BLOCKQUOTE_OPEN_TAG;
        } else if (input.tryConsumeRegex(BLOCKQUOTE_CLOSE_PATTERN)) {
            return BLOCKQUOTE_CLOSE_TAG;
        } else if (input.tryConsumeRegex(HEADER_OPEN_PATTERN)) {
            return HEADER_OPEN_TAG;
        } else if (input.tryConsumeRegex(HEADER_CLOSE_PATTERN)) {
            return HEADER_CLOSE_TAG;
        } else if (input.tryConsumeRegex(BR_PATTERN)) {
            return BR_TAG;
        } else if (input.tryConsumeRegex(MOE_BEGIN_STRIP_COMMENT_PATTERN)) {
            return MOE_BEGIN_STRIP_COMMENT;
        } else if (input.tryConsumeRegex(MOE_END_STRIP_COMMENT_PATTERN)) {
            return MOE_END_STRIP_COMMENT;
        } else if (input.tryConsumeRegex(HTML_COMMENT_PATTERN)) {
            return HTML_COMMENT;
        } else if (input.tryConsumeRegex(LITERAL_PATTERN)) {
            return LITERAL;
        }
        throw new AssertionError();
    }
    private boolean preserveExistingFormatting() {
        return preDepth.isPositive() || tableDepth.isPositive() || codeDepth.isPositive() || outerInlineTagIsSnippet;
    }
    private void checkMatchingTags() throws LexException {
        if (braceDepth.isPositive() || preDepth.isPositive() || tableDepth.isPositive() || codeDepth.isPositive()) {
            throw new LexException();
        }
    }
    private static ImmutableList<Token> joinAdjacentLiteralsAndAdjacentWhitespace(List<Token> input) {
        ImmutableList.Builder<Token> output = ImmutableList.builder();
        StringBuilder accumulated = new StringBuilder();
        for (PeekingIterator<Token> tokens = peekingIterator(input.iterator()); tokens.hasNext(); ) {
            if (tokens.peek().getType() == LITERAL) {
                accumulated.append(tokens.peek().getValue());
                tokens.next();
                continue;
            }
            if (accumulated.length() == 0) {
                output.add(tokens.peek());
                tokens.next();
                continue;
            }
            StringBuilder seenWhitespace = new StringBuilder();
            while (tokens.peek().getType() == WHITESPACE) {
                seenWhitespace.append(tokens.next().getValue());
            }
            if (tokens.peek().getType() == LITERAL && tokens.peek().getValue().startsWith("@")) {
                accumulated.append(" ");
                accumulated.append(tokens.peek().getValue());
                tokens.next();
                continue;
            }
            output.add(new Token(LITERAL, accumulated.toString()));
            accumulated.setLength(0);
            if (seenWhitespace.length() > 0) {
                output.add(new Token(WHITESPACE, seenWhitespace.toString()));
            }
        }
        return output.build();
    }
    private static ImmutableList<Token> inferParagraphTags(List<Token> input) {
        ImmutableList.Builder<Token> output = ImmutableList.builder();
        for (PeekingIterator<Token> tokens = peekingIterator(input.iterator()); tokens.hasNext(); ) {
            if (tokens.peek().getType() == LITERAL) {
                output.add(tokens.next());
                if (tokens.peek().getType() == WHITESPACE && hasMultipleNewlines(tokens.peek().getValue())) {
                    output.add(tokens.next());
                    if (tokens.peek().getType() == LITERAL) {
                        output.add(new Token(PARAGRAPH_OPEN_TAG, "<p>"));
                    }
                }
            } else {
                output.add(tokens.next());
            }
        }
        return output.build();
    }
    private static ImmutableList<Token> optionalizeSpacesAfterLinks(List<Token> input) {
        ImmutableList.Builder<Token> output = ImmutableList.builder();
        for (PeekingIterator<Token> tokens = peekingIterator(input.iterator()); tokens.hasNext(); ) {
            if (tokens.peek().getType() == LITERAL && tokens.peek().getValue().matches("^href=[^>]*>")) {
                output.add(tokens.next());
                if (tokens.peek().getType() == WHITESPACE) {
                    output.add(new Token(OPTIONAL_LINE_BREAK, tokens.next().getValue()));
                }
            } else {
                output.add(tokens.next());
            }
        }
        return output.build();
    }
    private static ImmutableList<Token> deindentPreCodeBlocks(List<Token> input) {
        ImmutableList.Builder<Token> output = ImmutableList.builder();
        for (PeekingIterator<Token> tokens = peekingIterator(input.iterator()); tokens.hasNext(); ) {
            if (tokens.peek().getType() != PRE_OPEN_TAG) {
                output.add(tokens.next());
                continue;
            }
            output.add(tokens.next());
            List<Token> initialNewlines = new ArrayList<>();
            while (tokens.hasNext() && tokens.peek().getType() == FORCED_NEWLINE) {
                initialNewlines.add(tokens.next());
            }
            if (tokens.peek().getType() != LITERAL || !tokens.peek().getValue().matches("[ \t]*[{]@code")) {
                output.addAll(initialNewlines);
                output.add(tokens.next());
                continue;
            }
            deindentPreCodeBlock(output, tokens);
        }
        return output.build();
    }
    private static void deindentPreCodeBlock(ImmutableList.Builder<Token> output, PeekingIterator<Token> tokens) {
        Deque<Token> saved = new ArrayDeque<>();
        output.add(new Token(LITERAL, tokens.next().getValue().trim()));
        while (tokens.hasNext() && tokens.peek().getType() != PRE_CLOSE_TAG) {
            Token token = tokens.next();
            saved.addLast(token);
        }
        while (!saved.isEmpty() && saved.peekFirst().getType() == FORCED_NEWLINE) {
            saved.removeFirst();
        }
        while (!saved.isEmpty() && saved.peekLast().getType() == FORCED_NEWLINE) {
            saved.removeLast();
        }
        if (saved.isEmpty()) {
            return;
        }
        Token last = saved.peekLast();
        boolean trailingBrace = false;
        if (last.getType() == LITERAL && last.getValue().endsWith("}")) {
            saved.removeLast();
            if (last.length() > 1) {
                saved.addLast(new Token(LITERAL, last.getValue().substring(0, last.getValue().length() - 1)));
                saved.addLast(new Token(FORCED_NEWLINE, null));
            }
            trailingBrace = true;
        }
        int trim = -1;
        for (Token token : saved) {
            if (token.getType() == LITERAL) {
                int idx = CharMatcher.isNot(' ').indexIn(token.getValue());
                if (idx != -1 && (trim == -1 || idx < trim)) {
                    trim = idx;
                }
            }
        }
        output.add(new Token(FORCED_NEWLINE, "\n"));
        for (Token token : saved) {
            if (token.getType() == LITERAL) {
                output.add(new Token(LITERAL, trim > 0 && token.length() > trim ? token.getValue().substring(trim) : token.getValue()));
            } else {
                output.add(token);
            }
        }
        if (trailingBrace) {
            output.add(new Token(LITERAL, "}"));
        } else {
            output.add(new Token(FORCED_NEWLINE, "\n"));
        }
    }
    private static final CharMatcher NEWLINE = CharMatcher.is('\n');
    private static boolean hasMultipleNewlines(String s) {
        return NEWLINE.countIn(s) > 1;
    }
    private static final Pattern NEWLINE_PATTERN = compile("^[ \t]*\n[ \t]*[*]?[ \t]?");
    private static final Pattern FOOTER_TAG_PATTERN = compile("^@(param\\s+<\\w+>|[a-z]\\w*)");
    private static final Pattern MOE_BEGIN_STRIP_COMMENT_PATTERN = compile("^<!--\\s*M" + "OE:begin_intracomment_strip\\s*-->");
    private static final Pattern MOE_END_STRIP_COMMENT_PATTERN = compile("^<!--\\s*M" + "OE:end_intracomment_strip\\s*-->");
    private static final Pattern HTML_COMMENT_PATTERN = fullCommentPattern();
    private static final Pattern PRE_OPEN_PATTERN = openTagPattern("pre");
    private static final Pattern PRE_CLOSE_PATTERN = closeTagPattern("pre");
    private static final Pattern CODE_OPEN_PATTERN = openTagPattern("code");
    private static final Pattern CODE_CLOSE_PATTERN = closeTagPattern("code");
    private static final Pattern TABLE_OPEN_PATTERN = openTagPattern("table");
    private static final Pattern TABLE_CLOSE_PATTERN = closeTagPattern("table");
    private static final Pattern LIST_OPEN_PATTERN = openTagPattern("ul|ol|dl");
    private static final Pattern LIST_CLOSE_PATTERN = closeTagPattern("ul|ol|dl");
    private static final Pattern LIST_ITEM_OPEN_PATTERN = openTagPattern("li|dt|dd");
    private static final Pattern LIST_ITEM_CLOSE_PATTERN = closeTagPattern("li|dt|dd");
    private static final Pattern HEADER_OPEN_PATTERN = openTagPattern("h[1-6]");
    private static final Pattern HEADER_CLOSE_PATTERN = closeTagPattern("h[1-6]");
    private static final Pattern PARAGRAPH_OPEN_PATTERN = openTagPattern("p");
    private static final Pattern PARAGRAPH_CLOSE_PATTERN = closeTagPattern("p");
    private static final Pattern BLOCKQUOTE_OPEN_PATTERN = openTagPattern("blockquote");
    private static final Pattern BLOCKQUOTE_CLOSE_PATTERN = closeTagPattern("blockquote");
    private static final Pattern BR_PATTERN = openTagPattern("br");
    private static final Pattern SNIPPET_TAG_OPEN_PATTERN = compile("^[{]@snippet\\b");
    private static final Pattern INLINE_TAG_OPEN_PATTERN = compile("^[{]@\\w*");
    private static final Pattern LITERAL_PATTERN = compile("^.[^ \t\n@<{}*]*", DOTALL);
    private static Pattern fullCommentPattern() {
        return compile("^<!--.*?-->", DOTALL);
    }
    private static Pattern openTagPattern(String namePattern) {
        return compile(format("^<(?:%s)\\b[^>]*>", namePattern), CASE_INSENSITIVE);
    }
    private static Pattern closeTagPattern(String namePattern) {
        return compile(format("^</(?:%s)\\b[^>]*>", namePattern), CASE_INSENSITIVE);
    }
    static class LexException extends Exception {
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```