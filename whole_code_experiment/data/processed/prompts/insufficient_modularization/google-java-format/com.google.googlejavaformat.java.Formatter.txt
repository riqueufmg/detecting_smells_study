##CONTEXT_SIZE=837
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.googlejavaformat.java;
public final class Formatter {
    public static final int MAX_LINE_LENGTH = 100;
    static final Range<Integer> EMPTY_RANGE = Range.closedOpen(-1, -1);
    private final JavaFormatterOptions options;
    public Formatter() {
        this(JavaFormatterOptions.defaultOptions());
    }
    public Formatter(JavaFormatterOptions options) {
        this.options = options;
    }
    static void format(final JavaInput javaInput, JavaOutput javaOutput, JavaFormatterOptions options) throws FormatterException {
        Context context = new Context();
        List<Diagnostic<? extends JavaFileObject>> errorDiagnostics = new ArrayList<>();
        JCCompilationUnit unit = Trees.parse(context, errorDiagnostics, false, javaInput.getText());
        javaInput.setCompilationUnit(unit);
        if (!errorDiagnostics.isEmpty()) {
            throw FormatterException.fromJavacDiagnostics(errorDiagnostics);
        }
        OpsBuilder builder = new OpsBuilder(javaInput, javaOutput);
        JavaInputAstVisitor visitor = new JavaInputAstVisitor(builder, options.indentationMultiplier());
        visitor.scan(unit, null);
        builder.sync(javaInput.getText().length());
        builder.drain();
        Doc doc = new DocBuilder().withOps(builder.build()).build();
        doc.computeBreaks(javaOutput.getCommentsHelper(), MAX_LINE_LENGTH, new Doc.State(+0, 0));
        doc.write(javaOutput);
        javaOutput.flush();
    }
    static boolean errorDiagnostic(Diagnostic<?> input) {
        if (input.getKind() != Diagnostic.Kind.ERROR) {
            return false;
        }
        return !input.getCode().equals("compiler.err.invalid.meth.decl.ret.type.req");
    }
    public void formatSource(CharSource input, CharSink output) throws FormatterException, IOException {
        output.write(formatSource(input.read()));
    }
    public String formatSource(String input) throws FormatterException {
        return formatSource(input, ImmutableList.of(Range.closedOpen(0, input.length())));
    }
    public String formatSourceAndFixImports(String input) throws FormatterException {
        input = ImportOrderer.reorderImports(input, options.style());
        input = RemoveUnusedImports.removeUnusedImports(input);
        String formatted = formatSource(input);
        formatted = StringWrapper.wrap(formatted, this);
        return formatted;
    }
    public String formatSource(String input, Collection<Range<Integer>> characterRanges) throws FormatterException {
        return JavaOutput.applyReplacements(input, getFormatReplacements(input, characterRanges));
    }
    public ImmutableList<Replacement> getFormatReplacements(String input, Collection<Range<Integer>> characterRanges) throws FormatterException {
        JavaInput javaInput = new JavaInput(input);
        if (options.reorderModifiers()) {
            javaInput = ModifierOrderer.reorderModifiers(javaInput, characterRanges);
        }
        String lineSeparator = Newlines.guessLineSeparator(input);
        JavaOutput javaOutput = new JavaOutput(lineSeparator, javaInput, new JavaCommentsHelper(lineSeparator, options));
        try {
            format(javaInput, javaOutput, options);
        } catch (FormattingError e) {
            throw new FormatterException(e.diagnostics());
        }
        RangeSet<Integer> tokenRangeSet = javaInput.characterRangesToTokenRanges(characterRanges);
        return javaOutput.getFormatReplacements(tokenRangeSet);
    }
    public static RangeSet<Integer> lineRangesToCharRanges(String input, RangeSet<Integer> lineRanges) {
        List<Integer> lines = new ArrayList<>();
        Iterators.addAll(lines, Newlines.lineOffsetIterator(input));
        lines.add(input.length() + 1);
        final RangeSet<Integer> characterRanges = TreeRangeSet.create();
        for (Range<Integer> lineRange : lineRanges.subRangeSet(Range.closedOpen(0, lines.size() - 1)).asRanges()) {
            int lineStart = lines.get(lineRange.lowerEndpoint());
            int lineEnd = lines.get(lineRange.upperEndpoint()) - 1;
            Range<Integer> range = Range.closedOpen(lineStart, lineEnd);
            characterRanges.add(range);
        }
        return characterRanges;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```