##CONTEXT_SIZE=1635
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.googlejavaformat.java.javadoc;
final class JavadocWriter {
    private final int blockIndent;
    private final StringBuilder output = new StringBuilder();
    private boolean continuingListItemOfInnermostList;
    private boolean continuingFooterTag;
    private final NestingCounter continuingListItemCount = new NestingCounter();
    private final NestingCounter continuingListCount = new NestingCounter();
    private final NestingCounter postWriteModifiedContinuingListCount = new NestingCounter();
    private int remainingOnLine;
    private boolean atStartOfLine;
    private RequestedWhitespace requestedWhitespace = NONE;
    private Token requestedMoeBeginStripComment;
    private int indentForMoeEndStripComment;
    private boolean wroteAnythingSignificant;
    JavadocWriter(int blockIndent) {
        this.blockIndent = blockIndent;
    }
    void requestWhitespace() {
        requestWhitespace(WHITESPACE);
    }
    void requestMoeBeginStripComment(Token token) {
        requestedMoeBeginStripComment = checkNotNull(token);
    }
    void writeBeginJavadoc() {
        output.append("/**");
        writeNewline();
    }
    void writeEndJavadoc() {
        output.append("\n");
        appendSpaces(blockIndent + 1);
        output.append("*/");
    }
    void writeFooterJavadocTagStart(Token token) {
        continuingListItemOfInnermostList = false;
        continuingListItemCount.reset();
        continuingListCount.reset();
        postWriteModifiedContinuingListCount.reset();
        if (!wroteAnythingSignificant) {
        } else if (!continuingFooterTag) {
            requestBlankLine();
        } else {
            continuingFooterTag = false;
            requestNewline();
        }
        writeToken(token);
        continuingFooterTag = true;
    }
    void writeSnippetBegin(Token token) {
        requestBlankLine();
        writeToken(token);
    }
    void writeSnippetEnd(Token token) {
        writeToken(token);
        requestBlankLine();
    }
    void writeListOpen(Token token) {
        requestBlankLine();
        writeToken(token);
        continuingListItemOfInnermostList = false;
        continuingListCount.increment();
        postWriteModifiedContinuingListCount.increment();
        requestNewline();
    }
    void writeListClose(Token token) {
        requestNewline();
        continuingListItemCount.decrementIfPositive();
        continuingListCount.decrementIfPositive();
        writeToken(token);
        postWriteModifiedContinuingListCount.decrementIfPositive();
        requestBlankLine();
    }
    void writeListItemOpen(Token token) {
        requestNewline();
        if (continuingListItemOfInnermostList) {
            continuingListItemOfInnermostList = false;
            continuingListItemCount.decrementIfPositive();
        }
        writeToken(token);
        continuingListItemOfInnermostList = true;
        continuingListItemCount.increment();
    }
    void writeHeaderOpen(Token token) {
        requestBlankLine();
        writeToken(token);
    }
    void writeHeaderClose(Token token) {
        writeToken(token);
        requestBlankLine();
    }
    void writeParagraphOpen(Token token) {
        if (!wroteAnythingSignificant) {
            return;
        }
        requestBlankLine();
        writeToken(token);
    }
    void writeBlockquoteOpenOrClose(Token token) {
        requestBlankLine();
        writeToken(token);
        requestBlankLine();
    }
    void writePreOpen(Token token) {
        requestBlankLine();
        writeToken(token);
    }
    void writePreClose(Token token) {
        writeToken(token);
        requestBlankLine();
    }
    void writeCodeOpen(Token token) {
        writeToken(token);
    }
    void writeCodeClose(Token token) {
        writeToken(token);
    }
    void writeTableOpen(Token token) {
        requestBlankLine();
        writeToken(token);
    }
    void writeTableClose(Token token) {
        writeToken(token);
        requestBlankLine();
    }
    void writeMoeEndStripComment(Token token) {
        writeLineBreakNoAutoIndent();
        appendSpaces(indentForMoeEndStripComment);
        writeToken(token);
        requestNewline();
    }
    void writeHtmlComment(Token token) {
        requestNewline();
        writeToken(token);
        requestNewline();
    }
    void writeBr(Token token) {
        writeToken(token);
        requestNewline();
    }
    void writeLineBreakNoAutoIndent() {
        writeNewline(NO_AUTO_INDENT);
    }
    void writeLiteral(Token token) {
        writeToken(token);
    }
    public String toString() {
        return output.toString();
    }
    private void requestBlankLine() {
        requestWhitespace(BLANK_LINE);
    }
    private void requestNewline() {
        requestWhitespace(NEWLINE);
    }
    private void requestWhitespace(RequestedWhitespace requestedWhitespace) {
        this.requestedWhitespace = max(requestedWhitespace, this.requestedWhitespace);
    }
    enum RequestedWhitespace {
        NONE, WHITESPACE, NEWLINE, BLANK_LINE
    }
    private void writeToken(Token token) {
        if (requestedMoeBeginStripComment != null) {
            requestNewline();
        }
        if (requestedWhitespace == BLANK_LINE && (postWriteModifiedContinuingListCount.isPositive() || continuingFooterTag)) {
            requestedWhitespace = NEWLINE;
        }
        if (requestedWhitespace == BLANK_LINE) {
            writeBlankLine();
            requestedWhitespace = NONE;
        } else if (requestedWhitespace == NEWLINE) {
            writeNewline();
            requestedWhitespace = NONE;
        }
        boolean needWhitespace = (requestedWhitespace == WHITESPACE);
        if (!atStartOfLine && token.length() + (needWhitespace ? 1 : 0) > remainingOnLine) {
            writeNewline();
        }
        if (!atStartOfLine && needWhitespace) {
            output.append(" ");
            remainingOnLine--;
        }
        if (requestedMoeBeginStripComment != null) {
            output.append(requestedMoeBeginStripComment.getValue());
            requestedMoeBeginStripComment = null;
            indentForMoeEndStripComment = innerIndent();
            requestNewline();
            writeToken(token);
            return;
        }
        output.append(token.getValue());
        if (!START_OF_LINE_TOKENS.contains(token.getType())) {
            atStartOfLine = false;
        }
        remainingOnLine -= token.length();
        requestedWhitespace = NONE;
        wroteAnythingSignificant = true;
    }
    private void writeBlankLine() {
        output.append("\n");
        appendSpaces(blockIndent + 1);
        output.append("*");
        writeNewline();
    }
    private void writeNewline() {
        writeNewline(AUTO_INDENT);
    }
    private void writeNewline(AutoIndent autoIndent) {
        output.append("\n");
        appendSpaces(blockIndent + 1);
        output.append("*");
        appendSpaces(1);
        remainingOnLine = JavadocFormatter.MAX_LINE_LENGTH - blockIndent - 3;
        if (autoIndent == AUTO_INDENT) {
            appendSpaces(innerIndent());
            remainingOnLine -= innerIndent();
        }
        atStartOfLine = true;
    }
    enum AutoIndent {
        AUTO_INDENT, NO_AUTO_INDENT
    }
    private int innerIndent() {
        int innerIndent = continuingListItemCount.value() * 4 + continuingListCount.value() * 2;
        if (continuingFooterTag) {
            innerIndent += 4;
        }
        return innerIndent;
    }
    private void appendSpaces(int count) {
        output.append(" ".repeat(count));
    }
    private static final ImmutableSet<Type> START_OF_LINE_TOKENS = immutableEnumSet(LIST_ITEM_OPEN_TAG, PARAGRAPH_OPEN_TAG, HEADER_OPEN_TAG);
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```