##CONTEXT_SIZE=2692
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.parser;
abstract class Token {
    static final int UnsetPos = -1;
    final TokenType type;
    int startPos, endPos = UnsetPos;
    private Token(TokenType type) {
        this.type = type;
    }
    String tokenType() {
        return this.getClass().getSimpleName();
    }
    Token reset() {
        startPos = UnsetPos;
        endPos = UnsetPos;
        return this;
    }
    int startPos() {
        return startPos;
    }
    void startPos(int pos) {
        startPos = pos;
    }
    int endPos() {
        return endPos;
    }
    void endPos(int pos) {
        endPos = pos;
    }
    static final class Doctype extends Token {
        final TokenData name = new TokenData();
        String pubSysKey = null;
        final TokenData publicIdentifier = new TokenData();
        final TokenData systemIdentifier = new TokenData();
        boolean forceQuirks = false;
        Doctype() {
            super(TokenType.Doctype);
        }
        Token reset() {
            super.reset();
            name.reset();
            pubSysKey = null;
            publicIdentifier.reset();
            systemIdentifier.reset();
            forceQuirks = false;
            return this;
        }
        String getName() {
            return name.value();
        }
        String getPubSysKey() {
            return pubSysKey;
        }
        String getPublicIdentifier() {
            return publicIdentifier.value();
        }
        public String getSystemIdentifier() {
            return systemIdentifier.value();
        }
        public boolean isForceQuirks() {
            return forceQuirks;
        }
        public String toString() {
            return "<!doctype " + getName() + ">";
        }
    }
    static abstract class Tag extends Token {
        protected TokenData tagName = new TokenData();
        protected String normalName;
        boolean selfClosing = false;
        Attributes attributes;
        final private TokenData attrName = new TokenData();
        final private TokenData attrValue = new TokenData();
        private boolean hasEmptyAttrValue = false;
        final TreeBuilder treeBuilder;
        final boolean trackSource;
        int attrNameStart, attrNameEnd, attrValStart, attrValEnd;
        Tag(TokenType type, TreeBuilder treeBuilder) {
            super(type);
            this.treeBuilder = treeBuilder;
            this.trackSource = treeBuilder.trackSourceRange;
        }
        Tag reset() {
            super.reset();
            tagName.reset();
            normalName = null;
            selfClosing = false;
            attributes = null;
            resetPendingAttr();
            return this;
        }
        private void resetPendingAttr() {
            attrName.reset();
            attrValue.reset();
            hasEmptyAttrValue = false;
            if (trackSource)
                attrNameStart = attrNameEnd = attrValStart = attrValEnd = UnsetPos;
        }
        private static final int MaxAttributes = 512;
        final void newAttribute() {
            if (attributes == null)
                attributes = new Attributes();
            if (attrName.hasData() && attributes.size() < MaxAttributes) {
                String name = attrName.value();
                name = name.trim();
                if (!name.isEmpty()) {
                    String value;
                    if (attrValue.hasData())
                        value = attrValue.value();
                    else if (hasEmptyAttrValue)
                        value = "";
                    else
                        value = null;
                    attributes.add(name, value);
                    trackAttributeRange(name);
                }
            }
            resetPendingAttr();
        }
        private void trackAttributeRange(String name) {
            if (trackSource && isStartTag()) {
                final StartTag start = asStartTag();
                final CharacterReader r = start.treeBuilder.reader;
                final boolean preserve = start.treeBuilder.settings.preserveAttributeCase();
                assert attributes != null;
                if (!preserve)
                    name = Normalizer.lowerCase(name);
                if (attributes.sourceRange(name).nameRange().isTracked())
                    return;
                if (!attrValue.hasData())
                    attrValStart = attrValEnd = attrNameEnd;
                Range.AttributeRange range = new Range.AttributeRange(new Range(new Range.Position(attrNameStart, r.lineNumber(attrNameStart), r.columnNumber(attrNameStart)), new Range.Position(attrNameEnd, r.lineNumber(attrNameEnd), r.columnNumber(attrNameEnd))), new Range(new Range.Position(attrValStart, r.lineNumber(attrValStart), r.columnNumber(attrValStart)), new Range.Position(attrValEnd, r.lineNumber(attrValEnd), r.columnNumber(attrValEnd))));
                attributes.sourceRange(name, range);
            }
        }
        final boolean hasAttributes() {
            return attributes != null;
        }
        final boolean hasAttributeIgnoreCase(String key) {
            return attributes != null && attributes.hasKeyIgnoreCase(key);
        }
        final void finaliseTag() {
            if (attrName.hasData()) {
                newAttribute();
            }
        }
        final String name() {
            return tagName.value();
        }
        final String normalName() {
            Validate.isFalse(normalName == null || normalName.isEmpty());
            return normalName;
        }
        final String toStringName() {
            String name = tagName.value();
            return (name.isEmpty()) ? "[unset]" : name;
        }
        final Tag name(String name) {
            tagName.set(name);
            normalName = ParseSettings.normalName(tagName.value());
            return this;
        }
        final boolean isSelfClosing() {
            return selfClosing;
        }
        final void appendTagName(String append) {
            append = append.replace(TokeniserState.nullChar, Tokeniser.replacementChar);
            tagName.append(append);
            normalName = ParseSettings.normalName(tagName.value());
        }
        final void appendTagName(char append) {
            appendTagName(String.valueOf(append));
        }
        final void appendAttributeName(String append, int startPos, int endPos) {
            append = append.replace(TokeniserState.nullChar, Tokeniser.replacementChar);
            attrName.append(append);
            attrNamePos(startPos, endPos);
        }
        final void appendAttributeName(char append, int startPos, int endPos) {
            attrName.append(append);
            attrNamePos(startPos, endPos);
        }
        final void appendAttributeValue(String append, int startPos, int endPos) {
            attrValue.append(append);
            attrValPos(startPos, endPos);
        }
        final void appendAttributeValue(char append, int startPos, int endPos) {
            attrValue.append(append);
            attrValPos(startPos, endPos);
        }
        final void appendAttributeValue(int[] appendCodepoints, int startPos, int endPos) {
            for (int codepoint : appendCodepoints) {
                attrValue.appendCodePoint(codepoint);
            }
            attrValPos(startPos, endPos);
        }
        final void setEmptyAttributeValue() {
            hasEmptyAttrValue = true;
        }
        private void attrNamePos(int startPos, int endPos) {
            if (trackSource) {
                attrNameStart = attrNameStart > UnsetPos ? attrNameStart : startPos;
                attrNameEnd = endPos;
            }
        }
        private void attrValPos(int startPos, int endPos) {
            if (trackSource) {
                attrValStart = attrValStart > UnsetPos ? attrValStart : startPos;
                attrValEnd = endPos;
            }
        }
        abstract public String toString();
    }
    final static class StartTag extends Tag {
        StartTag(TreeBuilder treeBuilder) {
            super(TokenType.StartTag, treeBuilder);
        }
        Tag reset() {
            super.reset();
            attributes = null;
            return this;
        }
        StartTag nameAttr(String name, Attributes attributes) {
            this.tagName.set(name);
            this.attributes = attributes;
            normalName = ParseSettings.normalName(name);
            return this;
        }
        public String toString() {
            String closer = isSelfClosing() ? "/>" : ">";
            if (hasAttributes() && attributes.size() > 0)
                return "<" + toStringName() + " " + attributes.toString() + closer;
            else
                return "<" + toStringName() + closer;
        }
    }
    final static class EndTag extends Tag {
        EndTag(TreeBuilder treeBuilder) {
            super(TokenType.EndTag, treeBuilder);
        }
        public String toString() {
            return "</" + toStringName() + ">";
        }
    }
    final static class Comment extends Token {
        private final TokenData data = new TokenData();
        boolean bogus = false;
        Token reset() {
            super.reset();
            data.reset();
            bogus = false;
            return this;
        }
        Comment() {
            super(TokenType.Comment);
        }
        String getData() {
            return data.value();
        }
        Comment append(String append) {
            data.append(append);
            return this;
        }
        Comment append(char append) {
            data.append(append);
            return this;
        }
        public String toString() {
            return "<!--" + getData() + "-->";
        }
    }
    static class Character extends Token {
        final TokenData data = new TokenData();
        Character() {
            super(TokenType.Character);
        }
        Character(Character source) {
            super(TokenType.Character);
            this.startPos = source.startPos;
            this.endPos = source.endPos;
            this.data.set(source.data.value());
        }
        Token reset() {
            super.reset();
            data.reset();
            return this;
        }
        Character data(String str) {
            data.set(str);
            return this;
        }
        Character append(String str) {
            data.append(str);
            return this;
        }
        String getData() {
            return data.value();
        }
        public String toString() {
            return getData();
        }
        public void normalizeNulls(boolean replace) {
            String data = this.data.value();
            if (data.indexOf(TokeniserState.nullChar) == -1)
                return;
            data = (replace ? data.replace(TokeniserState.nullChar, Tokeniser.replacementChar) : data.replace(nullString, ""));
            this.data.set(data);
        }
        private static final String nullString = String.valueOf(TokeniserState.nullChar);
    }
    final static class CData extends Character {
        CData(String data) {
            super();
            this.data(data);
        }
        public String toString() {
            return "<![CDATA[" + getData() + "]]>";
        }
    }
    final static class XmlDecl extends Tag {
        boolean isDeclaration = true;
        public XmlDecl(TreeBuilder treeBuilder) {
            super(TokenType.XmlDecl, treeBuilder);
        }
        XmlDecl reset() {
            super.reset();
            isDeclaration = true;
            return this;
        }
        public String toString() {
            String open = isDeclaration ? "<!" : "<?";
            String close = isDeclaration ? ">" : "?>";
            if (hasAttributes() && attributes.size() > 0)
                return open + toStringName() + " " + attributes.toString() + close;
            else
                return open + toStringName() + close;
        }
    }
    final static class EOF extends Token {
        EOF() {
            super(Token.TokenType.EOF);
        }
        Token reset() {
            super.reset();
            return this;
        }
        public String toString() {
            return "";
        }
    }
    final boolean isDoctype() {
        return type == TokenType.Doctype;
    }
    final Doctype asDoctype() {
        return (Doctype) this;
    }
    final boolean isStartTag() {
        return type == TokenType.StartTag;
    }
    final StartTag asStartTag() {
        return (StartTag) this;
    }
    final boolean isEndTag() {
        return type == TokenType.EndTag;
    }
    final EndTag asEndTag() {
        return (EndTag) this;
    }
    final boolean isComment() {
        return type == TokenType.Comment;
    }
    final Comment asComment() {
        return (Comment) this;
    }
    final boolean isCharacter() {
        return type == TokenType.Character;
    }
    final boolean isCData() {
        return this instanceof CData;
    }
    final Character asCharacter() {
        return (Character) this;
    }
    final XmlDecl asXmlDecl() {
        return (XmlDecl) this;
    }
    final boolean isEOF() {
        return type == TokenType.EOF;
    }
    public enum TokenType {
        Doctype,
        StartTag,
        EndTag,
        Comment,
        Character,
        XmlDecl,
        EOF
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```