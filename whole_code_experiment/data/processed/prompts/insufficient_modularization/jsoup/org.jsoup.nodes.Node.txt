##CONTEXT_SIZE=3484
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.nodes;
public abstract class Node implements Cloneable {
    static final List<Node> EmptyNodes = Collections.emptyList();
    static final String EmptyString = "";
    Element parentNode;
    int siblingIndex;
    protected Node() {
    }
    public abstract String nodeName();
    public String normalName() {
        return nodeName();
    }
    public String nodeValue() {
        return "";
    }
    public boolean nameIs(String normalName) {
        return normalName().equals(normalName);
    }
    public boolean parentNameIs(String normalName) {
        return parentNode != null && parentNode.normalName().equals(normalName);
    }
    public boolean parentElementIs(String normalName, String namespace) {
        return parentNode != null && parentNode instanceof Element && ((Element) parentNode).elementIs(normalName, namespace);
    }
    protected abstract boolean hasAttributes();
    public boolean hasParent() {
        return parentNode != null;
    }
    public String attr(String attributeKey) {
        Validate.notNull(attributeKey);
        if (!hasAttributes())
            return EmptyString;
        String val = attributes().getIgnoreCase(attributeKey);
        if (val.length() > 0)
            return val;
        else if (attributeKey.startsWith("abs:"))
            return absUrl(attributeKey.substring("abs:".length()));
        else
            return "";
    }
    public abstract Attributes attributes();
    public int attributesSize() {
        return hasAttributes() ? attributes().size() : 0;
    }
    public Node attr(String attributeKey, String attributeValue) {
        Document doc = ownerDocument();
        ParseSettings settings = doc != null ? doc.parser().settings() : ParseSettings.htmlDefault;
        attributeKey = settings.normalizeAttribute(attributeKey);
        attributes().putIgnoreCase(attributeKey, attributeValue);
        return this;
    }
    public boolean hasAttr(String attributeKey) {
        Validate.notNull(attributeKey);
        if (!hasAttributes())
            return false;
        if (attributeKey.startsWith("abs:")) {
            String key = attributeKey.substring("abs:".length());
            if (attributes().hasKeyIgnoreCase(key) && !absUrl(key).isEmpty())
                return true;
        }
        return attributes().hasKeyIgnoreCase(attributeKey);
    }
    public Node removeAttr(String attributeKey) {
        Validate.notNull(attributeKey);
        if (hasAttributes())
            attributes().removeIgnoreCase(attributeKey);
        return this;
    }
    public Node clearAttributes() {
        if (hasAttributes()) {
            Iterator<Attribute> it = attributes().iterator();
            while (it.hasNext()) {
                it.next();
                it.remove();
            }
        }
        return this;
    }
    public abstract String baseUri();
    protected abstract void doSetBaseUri(String baseUri);
    public void setBaseUri(final String baseUri) {
        Validate.notNull(baseUri);
        doSetBaseUri(baseUri);
    }
    public String absUrl(String attributeKey) {
        Validate.notEmpty(attributeKey);
        if (!(hasAttributes() && attributes().hasKeyIgnoreCase(attributeKey)))
            return "";
        return StringUtil.resolve(baseUri(), attributes().getIgnoreCase(attributeKey));
    }
    protected abstract List<Node> ensureChildNodes();
    public Node childNode(int index) {
        return ensureChildNodes().get(index);
    }
    public List<Node> childNodes() {
        if (childNodeSize() == 0)
            return EmptyNodes;
        List<Node> children = ensureChildNodes();
        List<Node> rewrap = new ArrayList<>(children.size());
        rewrap.addAll(children);
        return Collections.unmodifiableList(rewrap);
    }
    public List<Node> childNodesCopy() {
        final List<Node> nodes = ensureChildNodes();
        final ArrayList<Node> children = new ArrayList<>(nodes.size());
        for (Node node : nodes) {
            children.add(node.clone());
        }
        return children;
    }
    public abstract int childNodeSize();
    protected Node[] childNodesAsArray() {
        return ensureChildNodes().toArray(new Node[0]);
    }
    public abstract Node empty();
    public Node parent() {
        return parentNode;
    }
    public Element parentElement() {
        return parentNode;
    }
    public final Node parentNode() {
        return parentNode;
    }
    public Node root() {
        Node node = this;
        while (node.parentNode != null) node = node.parentNode;
        return node;
    }
    public Document ownerDocument() {
        Node node = this;
        while (node != null) {
            if (node instanceof Document)
                return (Document) node;
            node = node.parentNode;
        }
        return null;
    }
    public void remove() {
        if (parentNode != null)
            parentNode.removeChild(this);
    }
    public Node before(String html) {
        addSiblingHtml(siblingIndex(), html);
        return this;
    }
    public Node before(Node node) {
        Validate.notNull(node);
        Validate.notNull(parentNode);
        if (node.parentNode == parentNode)
            node.remove();
        parentNode.addChildren(siblingIndex(), node);
        return this;
    }
    public Node after(String html) {
        addSiblingHtml(siblingIndex() + 1, html);
        return this;
    }
    public Node after(Node node) {
        Validate.notNull(node);
        Validate.notNull(parentNode);
        if (node.parentNode == parentNode)
            node.remove();
        parentNode.addChildren(siblingIndex() + 1, node);
        return this;
    }
    private void addSiblingHtml(int index, String html) {
        Validate.notNull(html);
        Validate.notNull(parentNode);
        Element context = parentNode instanceof Element ? (Element) parentNode : null;
        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());
        parentNode.addChildren(index, nodes.toArray(new Node[0]));
    }
    public Node wrap(String html) {
        Validate.notEmpty(html);
        Element context = parentNode != null && parentNode instanceof Element ? (Element) parentNode : this instanceof Element ? (Element) this : null;
        List<Node> wrapChildren = NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());
        Node wrapNode = wrapChildren.get(0);
        if (!(wrapNode instanceof Element))
            return this;
        Element wrap = (Element) wrapNode;
        Element deepest = getDeepChild(wrap);
        if (parentNode != null)
            parentNode.replaceChild(this, wrap);
        deepest.addChildren(this);
        if (wrapChildren.size() > 0) {
            for (int i = 0; i < wrapChildren.size(); i++) {
                Node remainder = wrapChildren.get(i);
                if (wrap == remainder)
                    continue;
                if (remainder.parentNode != null)
                    remainder.parentNode.removeChild(remainder);
                wrap.after(remainder);
            }
        }
        return this;
    }
    public Node unwrap() {
        Validate.notNull(parentNode);
        Node firstChild = firstChild();
        parentNode.addChildren(siblingIndex(), this.childNodesAsArray());
        this.remove();
        return firstChild;
    }
    private static Element getDeepChild(Element el) {
        Element child = el.firstElementChild();
        while (child != null) {
            el = child;
            child = child.firstElementChild();
        }
        return el;
    }
    public void replaceWith(Node in) {
        Validate.notNull(in);
        if (parentNode == null)
            parentNode = in.parentNode;
        Validate.notNull(parentNode);
        parentNode.replaceChild(this, in);
    }
    protected void setParentNode(Node parentNode) {
        Validate.notNull(parentNode);
        if (this.parentNode != null)
            this.parentNode.removeChild(this);
        assert parentNode instanceof Element;
        this.parentNode = (Element) parentNode;
    }
    protected void replaceChild(Node out, Node in) {
        Validate.isTrue(out.parentNode == this);
        Validate.notNull(in);
        if (out == in)
            return;
        if (in.parentNode != null)
            in.parentNode.removeChild(in);
        final int index = out.siblingIndex();
        ensureChildNodes().set(index, in);
        in.parentNode = (Element) this;
        in.setSiblingIndex(index);
        out.parentNode = null;
        ((Element) this).childNodes.incrementMod();
    }
    protected void removeChild(Node out) {
        Validate.isTrue(out.parentNode == this);
        Element el = (Element) this;
        if (el.hasValidChildren())
            ensureChildNodes().remove(out.siblingIndex);
        else
            ensureChildNodes().remove(out);
        el.invalidateChildren();
        out.parentNode = null;
    }
    protected void addChildren(Node... children) {
        final List<Node> nodes = ensureChildNodes();
        for (Node child : children) {
            reparentChild(child);
            nodes.add(child);
            child.setSiblingIndex(nodes.size() - 1);
        }
    }
    protected void addChildren(int index, Node... children) {
        Validate.notNull(children);
        if (children.length == 0)
            return;
        final List<Node> nodes = ensureChildNodes();
        final Node firstParent = children[0].parent();
        if (firstParent != null && firstParent.childNodeSize() == children.length) {
            boolean sameList = true;
            final List<Node> firstParentNodes = firstParent.ensureChildNodes();
            int i = children.length;
            while (i-- > 0) {
                if (children[i] != firstParentNodes.get(i)) {
                    sameList = false;
                    break;
                }
            }
            if (sameList) {
                firstParent.empty();
                nodes.addAll(index, Arrays.asList(children));
                i = children.length;
                assert this instanceof Element;
                while (i-- > 0) {
                    children[i].parentNode = (Element) this;
                }
                ((Element) this).invalidateChildren();
                return;
            }
        }
        Validate.noNullElements(children);
        for (Node child : children) {
            reparentChild(child);
        }
        nodes.addAll(index, Arrays.asList(children));
        ((Element) this).invalidateChildren();
    }
    protected void reparentChild(Node child) {
        child.setParentNode(this);
    }
    public List<Node> siblingNodes() {
        if (parentNode == null)
            return Collections.emptyList();
        List<Node> nodes = parentNode.ensureChildNodes();
        List<Node> siblings = new ArrayList<>(nodes.size() - 1);
        for (Node node : nodes) if (node != this)
            siblings.add(node);
        return siblings;
    }
    public Node nextSibling() {
        if (parentNode == null)
            return null;
        final List<Node> siblings = parentNode.ensureChildNodes();
        final int index = siblingIndex() + 1;
        if (siblings.size() > index) {
            Node node = siblings.get(index);
            assert (node.siblingIndex == index);
            return node;
        } else
            return null;
    }
    public Node previousSibling() {
        if (parentNode == null)
            return null;
        if (siblingIndex() > 0)
            return parentNode.ensureChildNodes().get(siblingIndex - 1);
        else
            return null;
    }
    public int siblingIndex() {
        if (parentNode != null && !parentNode.childNodes.validChildren)
            parentNode.reindexChildren();
        return siblingIndex;
    }
    protected void setSiblingIndex(int siblingIndex) {
        this.siblingIndex = siblingIndex;
    }
    public Node firstChild() {
        if (childNodeSize() == 0)
            return null;
        return ensureChildNodes().get(0);
    }
    public Node lastChild() {
        final int size = childNodeSize();
        if (size == 0)
            return null;
        List<Node> children = ensureChildNodes();
        return children.get(size - 1);
    }
    public Node firstSibling() {
        if (parentNode != null) {
            return parentNode.firstChild();
        } else
            return this;
    }
    public Node lastSibling() {
        if (parentNode != null) {
            return parentNode.lastChild();
        } else
            return this;
    }
    public Element nextElementSibling() {
        Node next = this;
        while ((next = next.nextSibling()) != null) {
            if (next instanceof Element)
                return (Element) next;
        }
        return null;
    }
    public Element previousElementSibling() {
        Node prev = this;
        while ((prev = prev.previousSibling()) != null) {
            if (prev instanceof Element)
                return (Element) prev;
        }
        return null;
    }
    public Node traverse(NodeVisitor nodeVisitor) {
        Validate.notNull(nodeVisitor);
        nodeVisitor.traverse(this);
        return this;
    }
    public Node forEachNode(Consumer<? super Node> action) {
        Validate.notNull(action);
        nodeStream().forEach(action);
        return this;
    }
    public Node filter(NodeFilter nodeFilter) {
        Validate.notNull(nodeFilter);
        nodeFilter.traverse(this);
        return this;
    }
    public Stream<Node> nodeStream() {
        return NodeUtils.stream(this, Node.class);
    }
    public <T extends Node> Stream<T> nodeStream(Class<T> type) {
        return NodeUtils.stream(this, type);
    }
    public String outerHtml() {
        StringBuilder sb = StringUtil.borrowBuilder();
        outerHtml(QuietAppendable.wrap(sb));
        return StringUtil.releaseBuilder(sb);
    }
    protected void outerHtml(Appendable accum) {
        outerHtml(QuietAppendable.wrap(accum));
    }
    protected void outerHtml(QuietAppendable accum) {
        Printer printer = Printer.printerFor(this, accum);
        printer.traverse(this);
    }
    abstract void outerHtmlHead(final QuietAppendable accum, final Document.OutputSettings out);
    abstract void outerHtmlTail(final QuietAppendable accum, final Document.OutputSettings out);
    public <T extends Appendable> T html(T appendable) {
        outerHtml(appendable);
        return appendable;
    }
    public Range sourceRange() {
        return Range.of(this, true);
    }
    public String toString() {
        return outerHtml();
    }
    protected void indent(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
        accum.append('\n').append(StringUtil.padding(depth * out.indentAmount(), out.maxPaddingWidth()));
    }
    public boolean equals(@Nullable Object o) {
        return this == o;
    }
    public int hashCode() {
        return super.hashCode();
    }
    public boolean hasSameValue(@Nullable Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        return this.outerHtml().equals(((Node) o).outerHtml());
    }
    public Node clone() {
        Node thisClone = doClone(null);
        final LinkedList<Node> nodesToProcess = new LinkedList<>();
        nodesToProcess.add(thisClone);
        while (!nodesToProcess.isEmpty()) {
            Node currParent = nodesToProcess.remove();
            final int size = currParent.childNodeSize();
            for (int i = 0; i < size; i++) {
                final List<Node> childNodes = currParent.ensureChildNodes();
                Node childClone = childNodes.get(i).doClone(currParent);
                childNodes.set(i, childClone);
                nodesToProcess.add(childClone);
            }
        }
        return thisClone;
    }
    public Node shallowClone() {
        return doClone(null);
    }
    protected Node doClone(@Nullable Node parent) {
        assert parent == null || parent instanceof Element;
        Node clone;
        try {
            clone = (Node) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
        clone.parentNode = (Element) parent;
        clone.siblingIndex = parent == null ? 0 : siblingIndex();
        if (parent == null && !(this instanceof Document)) {
            Document doc = ownerDocument();
            if (doc != null) {
                Document docClone = doc.shallowClone();
                clone.parentNode = docClone;
                docClone.ensureChildNodes().add(clone);
            }
        }
        return clone;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```