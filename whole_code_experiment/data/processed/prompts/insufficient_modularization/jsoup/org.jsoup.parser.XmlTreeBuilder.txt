##CONTEXT_SIZE=1596
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.parser;
public class XmlTreeBuilder extends TreeBuilder {
    static final String XmlnsKey = "xmlns";
    static final String XmlnsPrefix = "xmlns:";
    private final ArrayDeque<HashMap<String, String>> namespacesStack = new ArrayDeque<>();
    ParseSettings defaultSettings() {
        return ParseSettings.preserveCase;
    }
    protected void initialiseParse(Reader input, String baseUri, Parser parser) {
        super.initialiseParse(input, baseUri, parser);
        doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml).escapeMode(Entities.EscapeMode.xhtml).prettyPrint(false);
        namespacesStack.clear();
        HashMap<String, String> ns = new HashMap<>();
        ns.put("xml", NamespaceXml);
        ns.put("", NamespaceXml);
        namespacesStack.push(ns);
    }
    void initialiseParseFragment(@Nullable Element context) {
        super.initialiseParseFragment(context);
        if (context == null)
            return;
        TokeniserState textState = context.tag().textState();
        if (textState != null)
            tokeniser.transition(textState);
        Elements chain = context.parents();
        chain.add(0, context);
        for (int i = chain.size() - 1; i >= 0; i--) {
            Element el = chain.get(i);
            HashMap<String, String> namespaces = new HashMap<>(namespacesStack.peek());
            namespacesStack.push(namespaces);
            if (el.attributesSize() > 0) {
                processNamespaces(el.attributes(), namespaces);
            }
        }
    }
    Document parse(Reader input, String baseUri) {
        return parse(input, baseUri, new Parser(this));
    }
    Document parse(String input, String baseUri) {
        return parse(new StringReader(input), baseUri, new Parser(this));
    }
    List<Node> completeParseFragment() {
        return doc.childNodes();
    }
    XmlTreeBuilder newInstance() {
        return new XmlTreeBuilder();
    }
    public String defaultNamespace() {
        return NamespaceXml;
    }
    TagSet defaultTagSet() {
        return new TagSet();
    }
    int defaultMaxDepth() {
        return Integer.MAX_VALUE;
    }
    protected boolean process(Token token) {
        currentToken = token;
        switch(token.type) {
            case StartTag:
                insertElementFor(token.asStartTag());
                break;
            case EndTag:
                popStackToClose(token.asEndTag());
                break;
            case Comment:
                insertCommentFor(token.asComment());
                break;
            case Character:
                insertCharacterFor(token.asCharacter());
                break;
            case Doctype:
                insertDoctypeFor(token.asDoctype());
                break;
            case XmlDecl:
                insertXmlDeclarationFor(token.asXmlDecl());
                break;
            case EOF:
                break;
            default:
                Validate.fail("Unexpected token type: " + token.type);
        }
        return true;
    }
    void insertElementFor(Token.StartTag startTag) {
        HashMap<String, String> namespaces = new HashMap<>(namespacesStack.peek());
        namespacesStack.push(namespaces);
        Attributes attributes = startTag.attributes;
        if (attributes != null) {
            settings.normalizeAttributes(attributes);
            attributes.deduplicate(settings);
            processNamespaces(attributes, namespaces);
            applyNamespacesToAttributes(attributes, namespaces);
        }
        enforceStackDepthLimit();
        String tagName = startTag.tagName.value();
        String ns = resolveNamespace(tagName, namespaces);
        Tag tag = tagFor(tagName, startTag.normalName, ns, settings);
        Element el = new Element(tag, null, attributes);
        currentElement().appendChild(el);
        push(el);
        if (startTag.isSelfClosing()) {
            tag.setSeenSelfClose();
            pop();
        } else if (tag.isEmpty()) {
            pop();
        } else {
            TokeniserState textState = tag.textState();
            if (textState != null)
                tokeniser.transition(textState);
        }
    }
    private static void processNamespaces(Attributes attributes, HashMap<String, String> namespaces) {
        for (Attribute attr : attributes) {
            String key = attr.getKey();
            String value = attr.getValue();
            if (key.equals(XmlnsKey)) {
                namespaces.put("", value);
            } else if (key.startsWith(XmlnsPrefix)) {
                String nsPrefix = key.substring(XmlnsPrefix.length());
                namespaces.put(nsPrefix, value);
            }
        }
    }
    private static void applyNamespacesToAttributes(Attributes attributes, HashMap<String, String> namespaces) {
        Map<String, String> attrPrefix = new HashMap<>();
        for (Attribute attr : attributes) {
            String prefix = attr.prefix();
            if (!prefix.isEmpty()) {
                if (prefix.equals(XmlnsKey))
                    continue;
                String ns = namespaces.get(prefix);
                if (ns != null)
                    attrPrefix.put(SharedConstants.XmlnsAttr + prefix, ns);
            }
        }
        for (Map.Entry<String, String> entry : attrPrefix.entrySet()) attributes.userData(entry.getKey(), entry.getValue());
    }
    private static String resolveNamespace(String tagName, HashMap<String, String> namespaces) {
        String ns = namespaces.get("");
        int pos = tagName.indexOf(':');
        if (pos > 0) {
            String prefix = tagName.substring(0, pos);
            if (namespaces.containsKey(prefix))
                ns = namespaces.get(prefix);
        }
        return ns;
    }
    void insertLeafNode(LeafNode node) {
        currentElement().appendChild(node);
        onNodeInserted(node);
    }
    void insertCommentFor(Token.Comment commentToken) {
        Comment comment = new Comment(commentToken.getData());
        insertLeafNode(comment);
    }
    void insertCharacterFor(Token.Character token) {
        final String data = token.getData();
        LeafNode node;
        if (token.isCData())
            node = new CDataNode(data);
        else if (currentElement().tag().is(Tag.Data))
            node = new DataNode(data);
        else
            node = new TextNode(data);
        insertLeafNode(node);
    }
    void insertDoctypeFor(Token.Doctype token) {
        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(token.getName()), token.getPublicIdentifier(), token.getSystemIdentifier());
        doctypeNode.setPubSysKey(token.getPubSysKey());
        insertLeafNode(doctypeNode);
    }
    void insertXmlDeclarationFor(Token.XmlDecl token) {
        XmlDeclaration decl = new XmlDeclaration(token.name(), token.isDeclaration);
        if (token.attributes != null)
            decl.attributes().addAll(token.attributes);
        insertLeafNode(decl);
    }
    Element pop() {
        namespacesStack.pop();
        return super.pop();
    }
    protected void popStackToClose(Token.EndTag endTag) {
        String elName = settings.normalizeTag(endTag.name());
        Element firstFound = null;
        final int bottom = stack.size() - 1;
        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;
        for (int pos = stack.size() - 1; pos >= upper; pos--) {
            Element next = stack.get(pos);
            if (next.nodeName().equals(elName)) {
                firstFound = next;
                break;
            }
        }
        if (firstFound == null)
            return;
        for (int pos = stack.size() - 1; pos >= 0; pos--) {
            Element next = pop();
            if (next == firstFound) {
                break;
            }
        }
    }
    private static final int maxQueueDepth = 256;
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```