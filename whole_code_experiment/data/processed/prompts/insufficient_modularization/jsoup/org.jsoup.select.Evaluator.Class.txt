##CONTEXT_SIZE=4521
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.select;
public abstract class Evaluator {
    protected Evaluator() {
    }
    public Predicate<Element> asPredicate(Element root) {
        return element -> matches(root, element);
    }
    Predicate<Node> asNodePredicate(Element root) {
        return node -> matches(root, node);
    }
    public abstract boolean matches(Element root, Element element);
    final boolean matches(Element root, Node node) {
        if (node instanceof Element) {
            return matches(root, (Element) node);
        } else if (node instanceof LeafNode && wantsNodes()) {
            return matches(root, (LeafNode) node);
        }
        return false;
    }
    boolean matches(Element root, LeafNode leafNode) {
        return false;
    }
    boolean wantsNodes() {
        return false;
    }
    protected void reset() {
    }
    protected int cost() {
        return 5;
    }
    public static final class Tag extends Evaluator {
        private final String tagName;
        public Tag(String tagName) {
            this.tagName = tagName;
        }
        public boolean matches(Element root, Element element) {
            return (element.nameIs(tagName));
        }
        protected int cost() {
            return 1;
        }
        public String toString() {
            return String.format("%s", tagName);
        }
    }
    public static final class TagStartsWith extends Evaluator {
        private final String tagName;
        public TagStartsWith(String tagName) {
            this.tagName = tagName;
        }
        public boolean matches(Element root, Element element) {
            return (element.normalName().startsWith(tagName));
        }
        public String toString() {
            return String.format("%s|*", tagName);
        }
    }
    public static final class TagEndsWith extends Evaluator {
        private final String tagName;
        public TagEndsWith(String tagName) {
            this.tagName = tagName;
        }
        public boolean matches(Element root, Element element) {
            return (element.normalName().endsWith(tagName));
        }
        public String toString() {
            return String.format("*|%s", tagName);
        }
    }
    public static final class Id extends Evaluator {
        private final String id;
        public Id(String id) {
            this.id = id;
        }
        public boolean matches(Element root, Element element) {
            return (id.equals(element.id()));
        }
        protected int cost() {
            return 2;
        }
        public String toString() {
            return String.format("#%s", id);
        }
    }
    public static final class Class extends Evaluator {
        private final String className;
        public Class(String className) {
            this.className = className;
        }
        public boolean matches(Element root, Element element) {
            return (element.hasClass(className));
        }
        protected int cost() {
            return 8;
        }
        public String toString() {
            return String.format(".%s", className);
        }
    }
    public static final class Attribute extends Evaluator {
        private final String key;
        public Attribute(String key) {
            this.key = key;
        }
        public boolean matches(Element root, Element element) {
            return element.hasAttr(key);
        }
        protected int cost() {
            return 2;
        }
        public String toString() {
            return String.format("[%s]", key);
        }
    }
    public static final class AttributeStarting extends Evaluator {
        private final String keyPrefix;
        public AttributeStarting(String keyPrefix) {
            Validate.notNull(keyPrefix);
            this.keyPrefix = lowerCase(keyPrefix);
        }
        public boolean matches(Element root, Element element) {
            List<org.jsoup.nodes.Attribute> values = element.attributes().asList();
            for (org.jsoup.nodes.Attribute attribute : values) {
                if (lowerCase(attribute.getKey()).startsWith(keyPrefix))
                    return true;
            }
            return false;
        }
        protected int cost() {
            return 6;
        }
        public String toString() {
            return String.format("[^%s]", keyPrefix);
        }
    }
    public static final class AttributeWithValue extends AttributeKeyPair {
        public AttributeWithValue(String key, String value) {
            super(key, value);
        }
        public boolean matches(Element root, Element element) {
            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key));
        }
        protected int cost() {
            return 3;
        }
        public String toString() {
            return String.format("[%s=%s]", key, value);
        }
    }
    public static final class AttributeWithValueNot extends AttributeKeyPair {
        public AttributeWithValueNot(String key, String value) {
            super(key, value);
        }
        public boolean matches(Element root, Element element) {
            return !value.equalsIgnoreCase(element.attr(key));
        }
        protected int cost() {
            return 3;
        }
        public String toString() {
            return String.format("[%s!=%s]", key, value);
        }
    }
    public static final class AttributeWithValueStarting extends AttributeKeyPair {
        public AttributeWithValueStarting(String key, String value) {
            super(key, value);
        }
        public boolean matches(Element root, Element element) {
            return element.hasAttr(key) && lowerCase(element.attr(key)).startsWith(value);
        }
        protected int cost() {
            return 4;
        }
        public String toString() {
            return String.format("[%s^=%s]", key, value);
        }
    }
    public static final class AttributeWithValueEnding extends AttributeKeyPair {
        public AttributeWithValueEnding(String key, String value) {
            super(key, value);
        }
        public boolean matches(Element root, Element element) {
            return element.hasAttr(key) && lowerCase(element.attr(key)).endsWith(value);
        }
        protected int cost() {
            return 4;
        }
        public String toString() {
            return String.format("[%s$=%s]", key, value);
        }
    }
    public static final class AttributeWithValueContaining extends AttributeKeyPair {
        public AttributeWithValueContaining(String key, String value) {
            super(key, value);
        }
        public boolean matches(Element root, Element element) {
            return element.hasAttr(key) && lowerCase(element.attr(key)).contains(value);
        }
        protected int cost() {
            return 6;
        }
        public String toString() {
            return String.format("[%s*=%s]", key, value);
        }
    }
    public static final class AttributeWithValueMatching extends Evaluator {
        final String key;
        final Regex pattern;
        public AttributeWithValueMatching(String key, Regex pattern) {
            this.key = normalize(key);
            this.pattern = pattern;
        }
        public AttributeWithValueMatching(String key, Pattern pattern) {
            this(key, Regex.fromPattern(pattern));
        }
        public boolean matches(Element root, Element element) {
            return element.hasAttr(key) && pattern.matcher(element.attr(key)).find();
        }
        protected int cost() {
            return 8;
        }
        public String toString() {
            return String.format("[%s~=%s]", key, pattern.toString());
        }
    }
    public abstract static class AttributeKeyPair extends Evaluator {
        final String key;
        final String value;
        public AttributeKeyPair(String key, String value) {
            Validate.notEmpty(key);
            Validate.notNull(value);
            this.key = normalize(key);
            boolean quoted = value.startsWith("'") && value.endsWith("'") || value.startsWith("\"") && value.endsWith("\"");
            if (quoted) {
                Validate.isTrue(value.length() > 1, "Quoted value must have content");
                value = value.substring(1, value.length() - 1);
            }
            this.value = lowerCase(value);
        }
        @Deprecated
        public AttributeKeyPair(String key, String value, boolean ignored) {
            this(key, value);
        }
    }
    public static final class AllElements extends Evaluator {
        public boolean matches(Element root, Element element) {
            return true;
        }
        protected int cost() {
            return 10;
        }
        public String toString() {
            return "*";
        }
    }
    public static final class IndexLessThan extends IndexEvaluator {
        public IndexLessThan(int index) {
            super(index);
        }
        public boolean matches(Element root, Element element) {
            return root != element && element.elementSiblingIndex() < index;
        }
        public String toString() {
            return String.format(":lt(%d)", index);
        }
    }
    public static final class IndexGreaterThan extends IndexEvaluator {
        public IndexGreaterThan(int index) {
            super(index);
        }
        public boolean matches(Element root, Element element) {
            return element.elementSiblingIndex() > index;
        }
        public String toString() {
            return String.format(":gt(%d)", index);
        }
    }
    public static final class IndexEquals extends IndexEvaluator {
        public IndexEquals(int index) {
            super(index);
        }
        public boolean matches(Element root, Element element) {
            return element.elementSiblingIndex() == index;
        }
        public String toString() {
            return String.format(":eq(%d)", index);
        }
    }
    public static final class IsLastChild extends Evaluator {
        public boolean matches(Element root, Element element) {
            final Element p = element.parent();
            return p != null && !(p instanceof Document) && element == p.lastElementChild();
        }
        public String toString() {
            return ":last-child";
        }
    }
    public static final class IsFirstOfType extends IsNthOfType {
        public IsFirstOfType() {
            super(0, 1);
        }
        public String toString() {
            return ":first-of-type";
        }
    }
    public static final class IsLastOfType extends IsNthLastOfType {
        public IsLastOfType() {
            super(0, 1);
        }
        public String toString() {
            return ":last-of-type";
        }
    }
    public static abstract class CssNthEvaluator extends Evaluator {
        protected final int a;
        protected final int b;
        public CssNthEvaluator(int step, int offset) {
            this.a = step;
            this.b = offset;
        }
        public CssNthEvaluator(int offset) {
            this(0, offset);
        }
        public boolean matches(Element root, Element element) {
            final Element p = element.parent();
            if (p == null || (p instanceof Document))
                return false;
            final int pos = calculatePosition(root, element);
            if (a == 0)
                return pos == b;
            return (pos - b) * a >= 0 && (pos - b) % a == 0;
        }
        public String toString() {
            String format = // only offset (b)
            (a == 0) ? ":%s(%3$d)" : // only step (a)
            (b == 0) ? ":%s(%2$dn)" : ":%s(%2$dn%3$+d)";
            return String.format(format, getPseudoClass(), a, b);
        }
        protected abstract String getPseudoClass();
        protected abstract int calculatePosition(Element root, Element element);
    }
    public static final class IsNthChild extends CssNthEvaluator {
        public IsNthChild(int step, int offset) {
            super(step, offset);
        }
        protected int calculatePosition(Element root, Element element) {
            return element.elementSiblingIndex() + 1;
        }
        protected String getPseudoClass() {
            return "nth-child";
        }
    }
    public static final class IsNthLastChild extends CssNthEvaluator {
        public IsNthLastChild(int step, int offset) {
            super(step, offset);
        }
        protected int calculatePosition(Element root, Element element) {
            if (element.parent() == null)
                return 0;
            return element.parent().childrenSize() - element.elementSiblingIndex();
        }
        protected String getPseudoClass() {
            return "nth-last-child";
        }
    }
    public static class IsNthOfType extends CssNthEvaluator {
        public IsNthOfType(int step, int offset) {
            super(step, offset);
        }
        protected int calculatePosition(Element root, Element element) {
            Element parent = element.parent();
            if (parent == null)
                return 0;
            int pos = 0;
            final int size = parent.childNodeSize();
            for (int i = 0; i < size; i++) {
                Node node = parent.childNode(i);
                if (node.normalName().equals(element.normalName()))
                    pos++;
                if (node == element)
                    break;
            }
            return pos;
        }
        protected String getPseudoClass() {
            return "nth-of-type";
        }
    }
    public static class IsNthLastOfType extends CssNthEvaluator {
        public IsNthLastOfType(int step, int offset) {
            super(step, offset);
        }
        protected int calculatePosition(Element root, Element element) {
            Element parent = element.parent();
            if (parent == null)
                return 0;
            int pos = 0;
            Element next = element;
            while (next != null) {
                if (next.normalName().equals(element.normalName()))
                    pos++;
                next = next.nextElementSibling();
            }
            return pos;
        }
        protected String getPseudoClass() {
            return "nth-last-of-type";
        }
    }
    public static final class IsFirstChild extends Evaluator {
        public boolean matches(Element root, Element element) {
            final Element p = element.parent();
            return p != null && !(p instanceof Document) && element == p.firstElementChild();
        }
        public String toString() {
            return ":first-child";
        }
    }
    public static final class IsRoot extends Evaluator {
        public boolean matches(Element root, Element element) {
            final Element r = root instanceof Document ? root.firstElementChild() : root;
            return element == r;
        }
        protected int cost() {
            return 1;
        }
        public String toString() {
            return ":root";
        }
    }
    public static final class IsOnlyChild extends Evaluator {
        public boolean matches(Element root, Element element) {
            final Element p = element.parent();
            return p != null && !(p instanceof Document) && element.siblingElements().isEmpty();
        }
        public String toString() {
            return ":only-child";
        }
    }
    public static final class IsOnlyOfType extends Evaluator {
        public boolean matches(Element root, Element element) {
            final Element p = element.parent();
            if (p == null || p instanceof Document)
                return false;
            int pos = 0;
            Element next = p.firstElementChild();
            while (next != null) {
                if (next.normalName().equals(element.normalName()))
                    pos++;
                if (pos > 1)
                    break;
                next = next.nextElementSibling();
            }
            return pos == 1;
        }
        public String toString() {
            return ":only-of-type";
        }
    }
    public static final class IsEmpty extends Evaluator {
        public boolean matches(Element root, Element el) {
            for (Node n = el.firstChild(); n != null; n = n.nextSibling()) {
                if (n instanceof TextNode) {
                    if (!((TextNode) n).isBlank())
                        return false;
                } else if (!(n instanceof Comment || n instanceof XmlDeclaration || n instanceof DocumentType))
                    return false;
            }
            return true;
        }
        public String toString() {
            return ":empty";
        }
    }
    public abstract static class IndexEvaluator extends Evaluator {
        final int index;
        public IndexEvaluator(int index) {
            this.index = index;
        }
    }
    public static final class ContainsText extends Evaluator {
        private final String searchText;
        public ContainsText(String searchText) {
            this.searchText = lowerCase(normaliseWhitespace(searchText));
        }
        public boolean matches(Element root, Element element) {
            return lowerCase(element.text()).contains(searchText);
        }
        protected int cost() {
            return 10;
        }
        public String toString() {
            return String.format(":contains(%s)", searchText);
        }
    }
    public static final class ContainsWholeText extends Evaluator {
        private final String searchText;
        public ContainsWholeText(String searchText) {
            this.searchText = searchText;
        }
        public boolean matches(Element root, Element element) {
            return element.wholeText().contains(searchText);
        }
        protected int cost() {
            return 10;
        }
        public String toString() {
            return String.format(":containsWholeText(%s)", searchText);
        }
    }
    public static final class ContainsWholeOwnText extends Evaluator {
        private final String searchText;
        public ContainsWholeOwnText(String searchText) {
            this.searchText = searchText;
        }
        public boolean matches(Element root, Element element) {
            return element.wholeOwnText().contains(searchText);
        }
        public String toString() {
            return String.format(":containsWholeOwnText(%s)", searchText);
        }
    }
    public static final class ContainsData extends Evaluator {
        private final String searchText;
        public ContainsData(String searchText) {
            this.searchText = lowerCase(searchText);
        }
        public boolean matches(Element root, Element element) {
            return lowerCase(element.data()).contains(searchText);
        }
        public String toString() {
            return String.format(":containsData(%s)", searchText);
        }
    }
    public static final class ContainsOwnText extends Evaluator {
        private final String searchText;
        public ContainsOwnText(String searchText) {
            this.searchText = lowerCase(normaliseWhitespace(searchText));
        }
        public boolean matches(Element root, Element element) {
            return lowerCase(element.ownText()).contains(searchText);
        }
        public String toString() {
            return String.format(":containsOwn(%s)", searchText);
        }
    }
    public static final class Matches extends Evaluator {
        private final Regex pattern;
        public Matches(Regex pattern) {
            this.pattern = pattern;
        }
        public Matches(Pattern pattern) {
            this(Regex.fromPattern(pattern));
        }
        public boolean matches(Element root, Element element) {
            return pattern.matcher(element.text()).find();
        }
        protected int cost() {
            return 8;
        }
        public String toString() {
            return String.format(":matches(%s)", pattern);
        }
    }
    public static final class MatchesOwn extends Evaluator {
        private final Regex pattern;
        public MatchesOwn(Regex pattern) {
            this.pattern = pattern;
        }
        public MatchesOwn(Pattern pattern) {
            this(Regex.fromPattern(pattern));
        }
        public boolean matches(Element root, Element element) {
            return pattern.matcher(element.ownText()).find();
        }
        protected int cost() {
            return 7;
        }
        public String toString() {
            return String.format(":matchesOwn(%s)", pattern);
        }
    }
    public static final class MatchesWholeText extends Evaluator {
        private final Regex pattern;
        public MatchesWholeText(Regex pattern) {
            this.pattern = pattern;
        }
        public MatchesWholeText(Pattern pattern) {
            this.pattern = Regex.fromPattern(pattern);
        }
        public boolean matches(Element root, Element element) {
            return pattern.matcher(element.wholeText()).find();
        }
        protected int cost() {
            return 8;
        }
        public String toString() {
            return String.format(":matchesWholeText(%s)", pattern);
        }
    }
    public static final class MatchesWholeOwnText extends Evaluator {
        private final Regex pattern;
        public MatchesWholeOwnText(Regex pattern) {
            this.pattern = pattern;
        }
        public MatchesWholeOwnText(Pattern pattern) {
            this(Regex.fromPattern(pattern));
        }
        public boolean matches(Element root, Element element) {
            Regex.Matcher m = pattern.matcher(element.wholeOwnText());
            return m.find();
        }
        protected int cost() {
            return 7;
        }
        public String toString() {
            return String.format(":matchesWholeOwnText(%s)", pattern);
        }
    }
    public static final class MatchText extends Evaluator {
        private static boolean loggedError = false;
        public MatchText() {
            if (!loggedError) {
                loggedError = true;
                System.err.println("WARNING: :matchText selector is deprecated and will be removed in jsoup 1.24.1. Use Element#selectNodes(String, Class) with selector ::textnode and class TextNode instead.");
            }
        }
        public boolean matches(Element root, Element element) {
            if (element instanceof PseudoTextElement)
                return true;
            List<TextNode> textNodes = element.textNodes();
            for (TextNode textNode : textNodes) {
                PseudoTextElement pel = new PseudoTextElement(org.jsoup.parser.Tag.valueOf(element.tagName(), element.tag().namespace(), ParseSettings.preserveCase), element.baseUri(), element.attributes());
                textNode.replaceWith(pel);
                pel.appendChild(textNode);
            }
            return false;
        }
        protected int cost() {
            return -1;
        }
        public String toString() {
            return ":matchText";
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```