##CONTEXT_SIZE=817
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.nodes;
public class Range {
    private static final Position UntrackedPos = new Position(-1, -1, -1);
    private final Position start, end;
    static final Range Untracked = new Range(UntrackedPos, UntrackedPos);
    public Range(Position start, Position end) {
        this.start = start;
        this.end = end;
    }
    public Position start() {
        return start;
    }
    public int startPos() {
        return start.pos;
    }
    public Position end() {
        return end;
    }
    public int endPos() {
        return end.pos;
    }
    public boolean isTracked() {
        return this != Untracked;
    }
    public boolean isImplicit() {
        if (!isTracked())
            return false;
        return start.equals(end);
    }
    static Range of(Node node, boolean start) {
        final String key = start ? RangeKey : EndRangeKey;
        if (!node.hasAttributes())
            return Untracked;
        Object range = node.attributes().userData(key);
        return range != null ? (Range) range : Untracked;
    }
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        Range range = (Range) o;
        if (!start.equals(range.start))
            return false;
        return end.equals(range.end);
    }
    public int hashCode() {
        return Objects.hash(start, end);
    }
    public String toString() {
        return start + "-" + end;
    }
    public static class Position {
        private final int pos, lineNumber, columnNumber;
        public Position(int pos, int lineNumber, int columnNumber) {
            this.pos = pos;
            this.lineNumber = lineNumber;
            this.columnNumber = columnNumber;
        }
        public int pos() {
            return pos;
        }
        public int lineNumber() {
            return lineNumber;
        }
        public int columnNumber() {
            return columnNumber;
        }
        public boolean isTracked() {
            return this != UntrackedPos;
        }
        public String toString() {
            return lineNumber + "," + columnNumber + ":" + pos;
        }
        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            Position position = (Position) o;
            if (pos != position.pos)
                return false;
            if (lineNumber != position.lineNumber)
                return false;
            return columnNumber == position.columnNumber;
        }
        public int hashCode() {
            return Objects.hash(pos, lineNumber, columnNumber);
        }
    }
    public static class AttributeRange {
        static final AttributeRange UntrackedAttr = new AttributeRange(Range.Untracked, Range.Untracked);
        private final Range nameRange;
        private final Range valueRange;
        public AttributeRange(Range nameRange, Range valueRange) {
            this.nameRange = nameRange;
            this.valueRange = valueRange;
        }
        public Range nameRange() {
            return nameRange;
        }
        public Range valueRange() {
            return valueRange;
        }
        public String toString() {
            StringBuilder sb = StringUtil.borrowBuilder().append(nameRange).append('=').append(valueRange);
            return StringUtil.releaseBuilder(sb);
        }
        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            AttributeRange that = (AttributeRange) o;
            if (!nameRange.equals(that.nameRange))
                return false;
            return valueRange.equals(that.valueRange);
        }
        public int hashCode() {
            return Objects.hash(nameRange, valueRange);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```