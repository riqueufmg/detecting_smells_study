##CONTEXT_SIZE=652
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.helper;
class CookieUtil {
    private static final Map<String, List<String>> EmptyRequestHeaders = Collections.unmodifiableMap(new HashMap<>());
    private static final String Sep = "; ";
    private static final String CookieName = "Cookie";
    private static final String Cookie2Name = "Cookie2";
    static void applyCookiesToRequest(HttpConnection.Request req, BiConsumer<String, String> setter) throws IOException {
        Set<String> cookieSet = requestCookieSet(req);
        Set<String> cookies2 = null;
        Map<String, List<String>> storedCookies = req.cookieManager().get(asUri(req.url), EmptyRequestHeaders);
        for (Map.Entry<String, List<String>> entry : storedCookies.entrySet()) {
            List<String> cookies = entry.getValue();
            if (cookies == null || cookies.size() == 0)
                continue;
            String key = entry.getKey();
            Set<String> set;
            if (CookieName.equals(key))
                set = cookieSet;
            else if (Cookie2Name.equals(key)) {
                set = new HashSet<>();
                cookies2 = set;
            } else {
                continue;
            }
            set.addAll(cookies);
        }
        if (cookieSet.size() > 0)
            setter.accept(CookieName, StringUtil.join(cookieSet, Sep));
        if (cookies2 != null && cookies2.size() > 0)
            setter.accept(Cookie2Name, StringUtil.join(cookies2, Sep));
    }
    private static LinkedHashSet<String> requestCookieSet(Connection.Request req) {
        LinkedHashSet<String> set = new LinkedHashSet<>();
        for (Map.Entry<String, String> cookie : req.cookies().entrySet()) {
            set.add(cookie.getKey() + "=" + cookie.getValue());
        }
        return set;
    }
    static URI asUri(URL url) throws IOException {
        try {
            return url.toURI();
        } catch (URISyntaxException e) {
            MalformedURLException ue = new MalformedURLException(e.getMessage());
            ue.initCause(e);
            throw ue;
        }
    }
    static void storeCookies(HttpConnection.Request req, HttpConnection.Response res, URL url, Map<String, List<String>> resHeaders) throws IOException {
        CookieManager manager = req.cookieManager();
        URI uri = CookieUtil.asUri(url);
        manager.put(uri, resHeaders);
        for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {
            String name = entry.getKey();
            List<String> values = entry.getValue();
            if (name.equalsIgnoreCase("Set-Cookie")) {
                for (String value : values) {
                    parseCookie(value, res);
                }
            }
        }
    }
    static void parseCookie(@Nullable String value, HttpConnection.Response res) {
        if (value == null)
            return;
        CharacterReader reader = new CharacterReader(value);
        String cookieName = reader.consumeTo('=').trim();
        reader.advance();
        String cookieVal = reader.consumeTo(';').trim();
        if (!cookieName.isEmpty())
            res.cookie(cookieName, cookieVal);
        reader.close();
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```