##CONTEXT_SIZE=1036
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.helper;
class HttpClientExecutor extends RequestExecutor {
    static ThreadLocal<@Nullable Proxy> perRequestProxy = new ThreadLocal<>();
    HttpResponse<InputStream> hRes;
    public HttpClientExecutor(HttpConnection.Request request, HttpConnection.@Nullable Response previousResponse) {
        super(request, previousResponse);
    }
    HttpClient client() {
        if (req.connection.client != null) {
            HttpClient client = (HttpClient) req.connection.client;
            boolean reuse = true;
            RequestAuthenticator prevAuth = req.connection.lastAuth;
            req.connection.lastAuth = req.authenticator;
            if (prevAuth != req.authenticator)
                reuse = false;
            if (req.sslContext != null && !(client.sslContext() == req.sslContext))
                reuse = false;
            if (reuse)
                return client;
        }
        HttpClient.Builder builder = HttpClient.newBuilder();
        builder.followRedirects(HttpClient.Redirect.NEVER);
        builder.proxy(new ProxyWrap());
        if (req.authenticator != null)
            builder.authenticator(new AuthenticationHandler(req.authenticator));
        if (req.sslContext != null)
            builder.sslContext(req.sslContext);
        HttpClient client = builder.build();
        req.connection.client = client;
        return client;
    }
    HttpConnection.Response execute() throws IOException {
        try {
            HttpRequest.Builder reqBuilder = HttpRequest.newBuilder(req.url.toURI()).method(req.method.name(), requestBody(req));
            if (req.timeout() > 0)
                reqBuilder.timeout(Duration.ofMillis(req.timeout()));
            CookieUtil.applyCookiesToRequest(req, reqBuilder::header);
            req.multiHeaders().forEach((key, values) -> {
                values.forEach(value -> reqBuilder.header(key, value));
            });
            if (req.proxy() != null)
                perRequestProxy.set(req.proxy());
            HttpRequest hReq = reqBuilder.build();
            HttpClient client = client();
            hRes = client.send(hReq, HttpResponse.BodyHandlers.ofInputStream());
            HttpHeaders headers = hRes.headers();
            Response res = new Response(req);
            res.executor = this;
            res.method = Connection.Method.valueOf(hRes.request().method());
            res.url = hRes.uri().toURL();
            res.statusCode = hRes.statusCode();
            res.statusMessage = StatusMessage(res.statusCode);
            res.contentType = headers.firstValue("content-type").orElse("");
            long length = headers.firstValueAsLong("content-length").orElse(-1);
            res.contentLength = length < Integer.MAX_VALUE ? (int) length : -1;
            res.prepareResponse(headers.map(), prevRes);
            return res;
        } catch (IOException e) {
            safeClose();
            throw e;
        } catch (InterruptedException e) {
            safeClose();
            Thread.currentThread().interrupt();
            throw new IOException(e);
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Malformed URL: " + req.url, e);
        } finally {
            perRequestProxy.remove();
        }
    }
    static String StatusMessage(int statusCode) {
        if (statusCode < 400)
            return "OK";
        if (statusCode == 404)
            return "Not Found";
        return "Error " + statusCode;
    }
    InputStream responseBody() throws IOException {
        if (hRes == null)
            throw new IllegalStateException("Not yet executed");
        return hRes.body();
    }
    void safeClose() {
        if (hRes != null) {
            InputStream body = hRes.body();
            if (body != null) {
                try {
                    body.close();
                } catch (IOException ignored) {
                }
            }
            hRes = null;
        }
    }
    static HttpRequest.BodyPublisher requestBody(final HttpConnection.Request req) throws IOException {
        if (req.method.hasBody()) {
            ByteArrayOutputStream buf = new ByteArrayOutputStream();
            writePost(req, buf);
            return HttpRequest.BodyPublishers.ofByteArray(buf.toByteArray());
        } else {
            return HttpRequest.BodyPublishers.noBody();
        }
    }
    static class ProxyWrap extends ProxySelector {
        static final List<Proxy> NoProxy = new ArrayList<>(0);
        public List<Proxy> select(URI uri) {
            Proxy proxy = perRequestProxy.get();
            if (proxy != null) {
                return Collections.singletonList(proxy);
            }
            ProxySelector defaultSelector = ProxySelector.getDefault();
            if (defaultSelector != null && defaultSelector != this) {
                return defaultSelector.select(uri);
            }
            return NoProxy;
        }
        public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
            if (perRequestProxy.get() != null) {
                return;
            }
            ProxySelector defaultSelector = ProxySelector.getDefault();
            if (defaultSelector != null && defaultSelector != this) {
                defaultSelector.connectFailed(uri, sa, ioe);
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```