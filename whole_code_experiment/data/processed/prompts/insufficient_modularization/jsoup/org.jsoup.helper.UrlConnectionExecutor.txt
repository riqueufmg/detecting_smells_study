##CONTEXT_SIZE=736
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.helper;
class UrlConnectionExecutor extends RequestExecutor {
    HttpURLConnection conn;
    UrlConnectionExecutor(HttpConnection.Request req, HttpConnection.@Nullable Response prevRes) {
        super(req, prevRes);
    }
    HttpConnection.Response execute() throws IOException {
        try {
            conn = createConnection(req);
            conn.connect();
            if (conn.getDoOutput()) {
                try (OutputStream out = conn.getOutputStream()) {
                    Response.writePost(req, out);
                } catch (IOException e) {
                    conn.disconnect();
                    throw e;
                }
            }
            Response res = new Response(req);
            res.executor = this;
            res.method = Connection.Method.valueOf(conn.getRequestMethod());
            res.url = conn.getURL();
            res.statusCode = conn.getResponseCode();
            res.statusMessage = conn.getResponseMessage();
            if (res.statusMessage == null)
                res.statusMessage = "";
            res.contentType = conn.getContentType();
            res.contentLength = conn.getContentLength();
            Map<String, List<String>> resHeaders = createHeaderMap(conn);
            res.prepareResponse(resHeaders, prevRes);
            return res;
        } catch (IOException e) {
            safeClose();
            throw e;
        }
    }
    InputStream responseBody() throws IOException {
        if (conn == null)
            throw new IllegalStateException("Not yet executed");
        return conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();
    }
    void safeClose() {
        if (conn != null) {
            conn.disconnect();
            conn = null;
        }
    }
    private static HttpURLConnection createConnection(HttpConnection.Request req) throws IOException {
        Proxy proxy = req.proxy();
        final HttpURLConnection conn = (HttpURLConnection) (proxy == null ? req.url().openConnection() : req.url().openConnection(proxy));
        conn.setRequestMethod(req.method().name());
        conn.setInstanceFollowRedirects(false);
        conn.setConnectTimeout(req.timeout());
        conn.setReadTimeout(req.timeout() / 2);
        if (conn instanceof HttpsURLConnection) {
            HttpsURLConnection scon = (HttpsURLConnection) conn;
            if (req.sslContext != null)
                scon.setSSLSocketFactory(req.sslContext.getSocketFactory());
            else if (req.sslSocketFactory() != null)
                scon.setSSLSocketFactory(req.sslSocketFactory());
        }
        if (req.authenticator != null)
            AuthenticationHandler.handler.enable(req.authenticator, conn);
        if (req.method().hasBody())
            conn.setDoOutput(true);
        CookieUtil.applyCookiesToRequest(req, conn::addRequestProperty);
        for (Map.Entry<String, List<String>> header : req.multiHeaders().entrySet()) {
            for (String value : header.getValue()) {
                conn.addRequestProperty(header.getKey(), value);
            }
        }
        return conn;
    }
    private static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) {
        final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<>();
        int i = 0;
        while (true) {
            final String key = conn.getHeaderFieldKey(i);
            final String val = conn.getHeaderField(i);
            if (key == null && val == null)
                break;
            i++;
            if (key == null || val == null)
                continue;
            final List<String> vals = headers.computeIfAbsent(key, k -> new java.util.ArrayList<>());
            vals.add(val);
        }
        return headers;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```