##CONTEXT_SIZE=1117
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup;
public interface Connection {
    enum Method {
        GET(false),
        POST(true),
        PUT(true),
        DELETE(true),
        PATCH(true),
        HEAD(false),
        OPTIONS(false),
        TRACE(false);
        private final boolean hasBody;
        Method(boolean hasBody) {
            this.hasBody = hasBody;
        }
        public final boolean hasBody() {
            return hasBody;
        }
    }
    Connection newRequest();
    default Connection newRequest(String url) {
        return newRequest().url(url);
    }
    default Connection newRequest(URL url) {
        return newRequest().url(url);
    }
    Connection url(URL url);
    Connection url(String url);
    Connection proxy(@Nullable Proxy proxy);
    Connection proxy(String host, int port);
    Connection userAgent(String userAgent);
    Connection timeout(int millis);
    Connection maxBodySize(int bytes);
    Connection referrer(String referrer);
    Connection followRedirects(boolean followRedirects);
    Connection method(Method method);
    Connection ignoreHttpErrors(boolean ignoreHttpErrors);
    Connection ignoreContentType(boolean ignoreContentType);
    Connection sslSocketFactory(SSLSocketFactory sslSocketFactory);
    default Connection sslContext(SSLContext sslContext) {
        throw new UnsupportedOperationException();
    }
    Connection data(String key, String value);
    Connection data(String key, String filename, InputStream inputStream);
    Connection data(String key, String filename, InputStream inputStream, String contentType);
    Connection data(Collection<KeyVal> data);
    Connection data(Map<String, String> data);
    Connection data(String... keyvals);
    KeyVal data(String key);
    Connection requestBody(String body);
    default Connection requestBodyStream(InputStream stream) {
        throw new UnsupportedOperationException();
    }
    Connection header(String name, String value);
    Connection headers(Map<String, String> headers);
    Connection cookie(String name, String value);
    Connection cookies(Map<String, String> cookies);
    Connection cookieStore(CookieStore cookieStore);
    CookieStore cookieStore();
    Connection parser(Parser parser);
    Connection postDataCharset(String charset);
    default Connection auth(@Nullable RequestAuthenticator authenticator) {
        throw new UnsupportedOperationException();
    }
    Document get() throws IOException;
    Document post() throws IOException;
    Response execute() throws IOException;
    Request request();
    Connection request(Request request);
    Response response();
    Connection response(Response response);
    default Connection onResponseProgress(Progress<Response> handler) {
        throw new UnsupportedOperationException();
    }
    interface Base<T extends Base<T>> {
        URL url();
        T url(URL url);
        Method method();
        T method(Method method);
        String header(String name);
        List<String> headers(String name);
        T header(String name, String value);
        T addHeader(String name, String value);
        boolean hasHeader(String name);
        boolean hasHeaderWithValue(String name, String value);
        T removeHeader(String name);
        Map<String, String> headers();
        Map<String, List<String>> multiHeaders();
        String cookie(String name);
        T cookie(String name, String value);
        boolean hasCookie(String name);
        T removeCookie(String name);
        Map<String, String> cookies();
    }
    interface Request extends Base<Request> {
        Proxy proxy();
        Request proxy(@Nullable Proxy proxy);
        Request proxy(String host, int port);
        int timeout();
        Request timeout(int millis);
        int maxBodySize();
        Request maxBodySize(int bytes);
        boolean followRedirects();
        Request followRedirects(boolean followRedirects);
        boolean ignoreHttpErrors();
        Request ignoreHttpErrors(boolean ignoreHttpErrors);
        boolean ignoreContentType();
        Request ignoreContentType(boolean ignoreContentType);
        SSLSocketFactory sslSocketFactory();
        void sslSocketFactory(SSLSocketFactory sslSocketFactory);
        default SSLContext sslContext() {
            throw new UnsupportedOperationException();
        }
        default Request sslContext(SSLContext sslContext) {
            throw new UnsupportedOperationException();
        }
        Request data(KeyVal keyval);
        Collection<KeyVal> data();
        Request requestBody(@Nullable String body);
        String requestBody();
        default Request requestBodyStream(InputStream stream) {
            throw new UnsupportedOperationException();
        }
        Request parser(Parser parser);
        Parser parser();
        Request postDataCharset(String charset);
        String postDataCharset();
        default Request auth(@Nullable RequestAuthenticator authenticator) {
            throw new UnsupportedOperationException();
        }
        default RequestAuthenticator auth() {
            throw new UnsupportedOperationException();
        }
    }
    interface Response extends Base<Response> {
        int statusCode();
        String statusMessage();
        String charset();
        Response charset(String charset);
        String contentType();
        Document parse() throws IOException;
        default String readBody() throws IOException {
            throw new UnsupportedOperationException();
        }
        String body();
        byte[] bodyAsBytes();
        default Response readFully() throws IOException {
            throw new UnsupportedOperationException();
        }
        Response bufferUp();
        BufferedInputStream bodyStream();
        default StreamParser streamParser() throws IOException {
            throw new UnsupportedOperationException();
        }
    }
    interface KeyVal {
        KeyVal key(String key);
        String key();
        KeyVal value(String value);
        String value();
        KeyVal inputStream(InputStream inputStream);
        InputStream inputStream();
        boolean hasInputStream();
        KeyVal contentType(String contentType);
        String contentType();
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```