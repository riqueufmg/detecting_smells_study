##CONTEXT_SIZE=1448
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.select;
abstract class StructuralEvaluator extends Evaluator {
    final Evaluator evaluator;
    boolean wantsNodes;
    public StructuralEvaluator(Evaluator evaluator) {
        this.evaluator = evaluator;
        wantsNodes = evaluator.wantsNodes();
    }
    boolean wantsNodes() {
        return wantsNodes;
    }
    final ThreadLocal<Map<Node, Map<Node, Boolean>>> threadMemo = ThreadLocal.withInitial(WeakHashMap::new);
    boolean memoMatches(final Element root, final Node node) {
        Map<Node, Map<Node, Boolean>> rootMemo = threadMemo.get();
        Map<Node, Boolean> memo = rootMemo.computeIfAbsent(root, r -> new WeakHashMap<>());
        return memo.computeIfAbsent(node, test -> evaluator.matches(root, test));
    }
    protected void reset() {
        threadMemo.remove();
        evaluator.reset();
        super.reset();
    }
    public boolean matches(Element root, Element element) {
        return evaluateMatch(root, element);
    }
    boolean matches(Element root, LeafNode leafNode) {
        return evaluateMatch(root, leafNode);
    }
    abstract boolean evaluateMatch(Element root, Node node);
    static class Root extends Evaluator {
        public boolean matches(Element root, Element element) {
            return root == element;
        }
        protected int cost() {
            return 1;
        }
        public String toString() {
            return ">";
        }
    }
    static class Has extends StructuralEvaluator {
        static final SoftPool<NodeIterator<Node>> NodeIterPool = new SoftPool<>(() -> new NodeIterator<>(new TextNode(""), Node.class));
        private final boolean checkSiblings;
        public Has(Evaluator evaluator) {
            super(evaluator);
            checkSiblings = evalWantsSiblings(evaluator);
        }
        public boolean matches(Element root, Element element) {
            if (checkSiblings) {
                for (Element sib = element.firstElementSibling(); sib != null; sib = sib.nextElementSibling()) {
                    if (sib != element && evaluator.matches(element, sib)) {
                        return true;
                    }
                }
            }
            NodeIterator<Node> it = NodeIterPool.borrow();
            it.restart(element);
            try {
                while (it.hasNext()) {
                    Node node = it.next();
                    if (node == element)
                        continue;
                    if (evaluator.matches(element, node)) {
                        return true;
                    }
                }
            } finally {
                NodeIterPool.release(it);
            }
            return false;
        }
        boolean evaluateMatch(Element root, Node node) {
            return false;
        }
        private static boolean evalWantsSiblings(Evaluator eval) {
            if (eval instanceof CombiningEvaluator) {
                CombiningEvaluator ce = (CombiningEvaluator) eval;
                for (Evaluator innerEval : ce.evaluators) {
                    if (innerEval instanceof PreviousSibling || innerEval instanceof ImmediatePreviousSibling)
                        return true;
                }
            }
            return false;
        }
        protected int cost() {
            return 10 * evaluator.cost();
        }
        public String toString() {
            return String.format(":has(%s)", evaluator);
        }
    }
    static class Is extends StructuralEvaluator {
        public Is(Evaluator evaluator) {
            super(evaluator);
        }
        boolean evaluateMatch(Element root, Node node) {
            return evaluator.matches(root, node);
        }
        protected int cost() {
            return 2 + evaluator.cost();
        }
        public String toString() {
            return String.format(":is(%s)", evaluator);
        }
    }
    static class Not extends StructuralEvaluator {
        public Not(Evaluator evaluator) {
            super(evaluator);
        }
        boolean evaluateMatch(Element root, Node node) {
            return !memoMatches(root, node);
        }
        protected int cost() {
            return 2 + evaluator.cost();
        }
        public String toString() {
            return String.format(":not(%s)", evaluator);
        }
    }
    static class Ancestor extends StructuralEvaluator {
        public Ancestor(Evaluator evaluator) {
            super(evaluator);
        }
        boolean evaluateMatch(Element root, Node node) {
            if (root == node)
                return false;
            for (Node parent = node.parent(); parent != null; parent = parent.parent()) {
                if (memoMatches(root, parent))
                    return true;
                if (parent == root)
                    break;
            }
            return false;
        }
        protected int cost() {
            return 8 * evaluator.cost();
        }
        public String toString() {
            return String.format("%s ", evaluator);
        }
    }
    static class ImmediateParentRun extends StructuralEvaluator {
        final ArrayList<Evaluator> evaluators = new ArrayList<>();
        int cost = 2;
        public ImmediateParentRun(Evaluator evaluator) {
            super(evaluator);
            evaluators.add(evaluator);
            cost += evaluator.cost();
        }
        void add(Evaluator evaluator) {
            evaluators.add(evaluator);
            cost += evaluator.cost();
            wantsNodes |= evaluator.wantsNodes();
        }
        boolean evaluateMatch(Element root, Node node) {
            if (node == root)
                return false;
            for (int i = evaluators.size() - 1; i >= 0; --i) {
                if (node == null)
                    return false;
                Evaluator eval = evaluators.get(i);
                if (!eval.matches(root, node))
                    return false;
                node = node.parent();
            }
            return true;
        }
        protected int cost() {
            return cost;
        }
        protected void reset() {
            for (Evaluator evaluator : evaluators) {
                evaluator.reset();
            }
            super.reset();
        }
        public String toString() {
            return StringUtil.join(evaluators, " > ");
        }
    }
    static class PreviousSibling extends StructuralEvaluator {
        public PreviousSibling(Evaluator evaluator) {
            super(evaluator);
        }
        boolean evaluateMatch(Element root, Node node) {
            if (root == node)
                return false;
            for (Node sib = node.firstSibling(); sib != null; sib = sib.nextSibling()) {
                if (sib == node)
                    break;
                if (memoMatches(root, sib))
                    return true;
            }
            return false;
        }
        protected int cost() {
            return 3 * evaluator.cost();
        }
        public String toString() {
            return String.format("%s ~ ", evaluator);
        }
    }
    static class ImmediatePreviousSibling extends StructuralEvaluator {
        public ImmediatePreviousSibling(Evaluator evaluator) {
            super(evaluator);
        }
        boolean evaluateMatch(Element root, Node node) {
            if (root == node)
                return false;
            Node prev = wantsNodes ? node.previousSibling() : node.previousElementSibling();
            return prev != null && memoMatches(root, prev);
        }
        protected int cost() {
            return 2 + evaluator.cost();
        }
        public String toString() {
            return String.format("%s + ", evaluator);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```