##CONTEXT_SIZE=422
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.select;
abstract class NodeEvaluator extends Evaluator {
    public boolean matches(Element root, Element element) {
        return evaluateMatch(element);
    }
    boolean matches(Element root, LeafNode leaf) {
        return evaluateMatch(leaf);
    }
    abstract boolean evaluateMatch(Node node);
    boolean wantsNodes() {
        return true;
    }
    static class InstanceType extends NodeEvaluator {
        final java.lang.Class<? extends Node> type;
        final String selector;
        InstanceType(java.lang.Class<? extends Node> type, String selector) {
            super();
            this.type = type;
            this.selector = "::" + selector;
        }
        boolean evaluateMatch(Node node) {
            return type.isInstance(node);
        }
        protected int cost() {
            return 1;
        }
        public String toString() {
            return selector;
        }
    }
    static class ContainsValue extends NodeEvaluator {
        private final String searchText;
        public ContainsValue(String searchText) {
            this.searchText = lowerCase(normaliseWhitespace(searchText));
        }
        boolean evaluateMatch(Node node) {
            return lowerCase(node.nodeValue()).contains(searchText);
        }
        protected int cost() {
            return 6;
        }
        public String toString() {
            return String.format(":contains(%s)", searchText);
        }
    }
    static class BlankValue extends NodeEvaluator {
        boolean evaluateMatch(Node node) {
            return StringUtil.isBlank(node.nodeValue());
        }
        protected int cost() {
            return 4;
        }
        public String toString() {
            return ":blank";
        }
    }
    static class MatchesValue extends NodeEvaluator {
        private final Regex pattern;
        protected MatchesValue(Regex pattern) {
            this.pattern = pattern;
        }
        boolean evaluateMatch(Node node) {
            return pattern.matcher(node.nodeValue()).find();
        }
        protected int cost() {
            return 8;
        }
        public String toString() {
            return String.format(":matches(%s)", pattern);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```