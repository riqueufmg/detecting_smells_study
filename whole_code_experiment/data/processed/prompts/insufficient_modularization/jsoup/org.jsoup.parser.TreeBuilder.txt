##CONTEXT_SIZE=1563
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.parser;
abstract class TreeBuilder {
    protected Parser parser;
    CharacterReader reader;
    Tokeniser tokeniser;
    Document doc;
    ArrayList<Element> stack;
    String baseUri;
    Token currentToken;
    ParseSettings settings;
    TagSet tagSet;
    NodeVisitor nodeListener;
    private Token.StartTag start;
    private final Token.EndTag end = new Token.EndTag(this);
    abstract ParseSettings defaultSettings();
    boolean trackSourceRange;
    void initialiseParse(Reader input, String baseUri, Parser parser) {
        Validate.notNullParam(input, "input");
        Validate.notNullParam(baseUri, "baseUri");
        Validate.notNull(parser);
        doc = new Document(parser.defaultNamespace(), baseUri);
        doc.parser(parser);
        this.parser = parser;
        settings = parser.settings();
        reader = new CharacterReader(input);
        trackSourceRange = parser.isTrackPosition();
        reader.trackNewlines(parser.isTrackErrors() || trackSourceRange);
        if (parser.isTrackErrors())
            parser.getErrors().clear();
        tokeniser = new Tokeniser(this);
        stack = new ArrayList<>(32);
        tagSet = parser.tagSet();
        start = new Token.StartTag(this);
        currentToken = start;
        this.baseUri = baseUri;
        onNodeInserted(doc);
    }
    void completeParse() {
        if (reader == null)
            return;
        reader.close();
        reader = null;
        tokeniser = null;
        stack = null;
    }
    Document parse(Reader input, String baseUri, Parser parser) {
        initialiseParse(input, baseUri, parser);
        runParser();
        return doc;
    }
    List<Node> parseFragment(Reader inputFragment, @Nullable Element context, String baseUri, Parser parser) {
        initialiseParse(inputFragment, baseUri, parser);
        initialiseParseFragment(context);
        runParser();
        return completeParseFragment();
    }
    void initialiseParseFragment(@Nullable Element context) {
    }
    abstract List<Node> completeParseFragment();
    void nodeListener(NodeVisitor nodeListener) {
        this.nodeListener = nodeListener;
    }
    abstract TreeBuilder newInstance();
    void runParser() {
        do {
        } while (stepParser());
        completeParse();
    }
    boolean stepParser() {
        if (currentToken.type == Token.TokenType.EOF) {
            if (stack == null) {
                return false;
            }
            if (stack.isEmpty()) {
                onNodeClosed(doc);
                stack = null;
                return true;
            }
            pop();
            return true;
        }
        final Token token = tokeniser.read();
        currentToken = token;
        process(token);
        token.reset();
        return true;
    }
    abstract boolean process(Token token);
    boolean processStartTag(String name) {
        final Token.StartTag start = this.start;
        if (currentToken == start) {
            return process(new Token.StartTag(this).name(name));
        }
        return process(start.reset().name(name));
    }
    boolean processStartTag(String name, Attributes attrs) {
        final Token.StartTag start = this.start;
        if (currentToken == start) {
            return process(new Token.StartTag(this).nameAttr(name, attrs));
        }
        start.reset();
        start.nameAttr(name, attrs);
        return process(start);
    }
    boolean processEndTag(String name) {
        if (currentToken == end) {
            return process(new Token.EndTag(this).name(name));
        }
        return process(end.reset().name(name));
    }
    Element pop() {
        int size = stack.size();
        Element removed = stack.remove(size - 1);
        onNodeClosed(removed);
        return removed;
    }
    final void push(Element element) {
        stack.add(element);
        onNodeInserted(element);
    }
    final void enforceStackDepthLimit() {
        final int maxDepth = parser.getMaxDepth();
        if (maxDepth == Integer.MAX_VALUE)
            return;
        while (stack.size() >= maxDepth) {
            Element trimmed = pop();
            onStackPrunedForDepth(trimmed);
        }
    }
    void onStackPrunedForDepth(Element element) {
    }
    int defaultMaxDepth() {
        return 512;
    }
    Element currentElement() {
        int size = stack.size();
        return size > 0 ? stack.get(size - 1) : doc;
    }
    boolean currentElementIs(String normalName) {
        if (stack.size() == 0)
            return false;
        Element current = currentElement();
        return current != null && current.normalName().equals(normalName) && current.tag().namespace().equals(NamespaceHtml);
    }
    boolean currentElementIs(String normalName, String namespace) {
        if (stack.size() == 0)
            return false;
        Element current = currentElement();
        return current != null && current.normalName().equals(normalName) && current.tag().namespace().equals(namespace);
    }
    void error(String msg) {
        error(msg, (Object[]) null);
    }
    void error(String msg, Object... args) {
        ParseErrorList errors = parser.getErrors();
        if (errors.canAddError())
            errors.add(new ParseError(reader, msg, args));
    }
    Tag tagFor(String tagName, String normalName, String namespace, ParseSettings settings) {
        return tagSet.valueOf(tagName, normalName, namespace, settings.preserveTagCase());
    }
    Tag tagFor(Token.Tag token) {
        return tagSet.valueOf(token.name(), token.normalName, defaultNamespace(), settings.preserveTagCase());
    }
    String defaultNamespace() {
        return NamespaceHtml;
    }
    TagSet defaultTagSet() {
        return TagSet.Html();
    }
    void onNodeInserted(Node node) {
        trackNodePosition(node, true);
        if (nodeListener != null)
            nodeListener.head(node, stack.size());
    }
    void onNodeClosed(Node node) {
        trackNodePosition(node, false);
        if (nodeListener != null)
            nodeListener.tail(node, stack.size());
    }
    void trackNodePosition(Node node, boolean isStart) {
        if (!trackSourceRange)
            return;
        final Token token = currentToken;
        int startPos = token.startPos();
        int endPos = token.endPos();
        if (node instanceof Element) {
            final Element el = (Element) node;
            if (token.isEOF()) {
                if (el.endSourceRange().isTracked())
                    return;
                startPos = endPos = reader.pos();
            } else if (isStart) {
                if (!token.isStartTag() || !el.normalName().equals(token.asStartTag().normalName)) {
                    endPos = startPos;
                }
            } else {
                if (!el.tag().isEmpty() && !el.tag().isSelfClosing()) {
                    if (!token.isEndTag() || !el.normalName().equals(token.asEndTag().normalName)) {
                        endPos = startPos;
                    }
                }
            }
        }
        Range.Position startPosition = new Range.Position(startPos, reader.lineNumber(startPos), reader.columnNumber(startPos));
        Range.Position endPosition = new Range.Position(endPos, reader.lineNumber(endPos), reader.columnNumber(endPos));
        Range range = new Range(startPosition, endPosition);
        node.attributes().userData(isStart ? SharedConstants.RangeKey : SharedConstants.EndRangeKey, range);
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```