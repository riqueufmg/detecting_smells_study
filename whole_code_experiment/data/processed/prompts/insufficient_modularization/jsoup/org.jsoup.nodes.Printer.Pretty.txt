##CONTEXT_SIZE=1545
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.nodes;
class Printer implements NodeVisitor {
    final Node root;
    final QuietAppendable accum;
    final OutputSettings settings;
    Printer(Node root, QuietAppendable accum, OutputSettings settings) {
        this.root = root;
        this.accum = accum;
        this.settings = settings;
    }
    void addHead(Element el, int depth) {
        el.outerHtmlHead(accum, settings);
    }
    void addTail(Element el, int depth) {
        el.outerHtmlTail(accum, settings);
    }
    void addText(TextNode textNode, int textOptions, int depth) {
        int options = Entities.ForText | textOptions;
        Entities.escape(accum, textNode.coreValue(), settings, options);
    }
    void addNode(LeafNode node, int depth) {
        node.outerHtmlHead(accum, settings);
    }
    void indent(int depth) {
        accum.append('\n').append(StringUtil.padding(depth * settings.indentAmount(), settings.maxPaddingWidth()));
    }
    public void head(Node node, int depth) {
        if (// Excludes CData; falls to addNode
        node.getClass() == TextNode.class)
            addText((TextNode) node, 0, depth);
        else if (node instanceof Element)
            addHead((Element) node, depth);
        else
            addNode((LeafNode) node, depth);
    }
    public void tail(Node node, int depth) {
        if (node instanceof Element) {
            addTail((Element) node, depth);
        }
    }
    static class Pretty extends Printer {
        boolean preserveWhitespace = false;
        Pretty(Node root, QuietAppendable accum, OutputSettings settings) {
            super(root, accum, settings);
            for (Node node = root; node != null; node = node.parentNode()) {
                if (tagIs(Tag.PreserveWhitespace, node)) {
                    preserveWhitespace = true;
                    break;
                }
            }
        }
        void addHead(Element el, int depth) {
            if (shouldIndent(el))
                indent(depth);
            super.addHead(el, depth);
            if (tagIs(Tag.PreserveWhitespace, el))
                preserveWhitespace = true;
        }
        void addTail(Element el, int depth) {
            if (shouldIndent(nextNonBlank(el.firstChild()))) {
                indent(depth);
            }
            super.addTail(el, depth);
            if (preserveWhitespace && el.tag.is(Tag.PreserveWhitespace)) {
                for (Element parent = el.parent(); parent != null; parent = parent.parent()) {
                    if (parent.tag().preserveWhitespace())
                        return;
                }
                preserveWhitespace = false;
            }
        }
        void addNode(LeafNode node, int depth) {
            if (shouldIndent(node))
                indent(depth);
            super.addNode(node, depth);
        }
        void addText(TextNode node, int textOptions, int depth) {
            if (!preserveWhitespace) {
                textOptions |= Entities.Normalise;
                textOptions = textTrim(node, textOptions);
                if (!node.isBlank() && isBlockEl(node.parentNode) && shouldIndent(node))
                    indent(depth);
            }
            super.addText(node, textOptions, depth);
        }
        int textTrim(TextNode node, int options) {
            if (!isBlockEl(node.parentNode))
                return options;
            Node prev = node.previousSibling();
            Node next = node.nextSibling();
            if (!(prev instanceof Element && !isBlockEl(prev))) {
                if (prev == null || !(prev instanceof TextNode) && shouldIndent(prev))
                    options |= Entities.TrimLeading;
            }
            if (next == null || !(next instanceof TextNode) && shouldIndent(next)) {
                options |= Entities.TrimTrailing;
            } else {
                next = nextNonBlank(next);
                if (next instanceof TextNode && StringUtil.isWhitespace(next.nodeValue().codePointAt(0)))
                    options |= Entities.TrimTrailing;
            }
            return options;
        }
        boolean shouldIndent(@Nullable Node node) {
            if (node == null || node == root || preserveWhitespace || isBlankText(node))
                return false;
            if (isBlockEl(node))
                return true;
            Node prevSib = previousNonblank(node);
            if (isBlockEl(prevSib))
                return true;
            Element parent = node.parentNode;
            if (!isBlockEl(parent) || parent.tag().is(Tag.InlineContainer) || !hasNonTextNodes(parent))
                return false;
            return prevSib == null || (!(prevSib instanceof TextNode) && (isBlockEl(prevSib) || !(prevSib instanceof Element)));
        }
        boolean isBlockEl(@Nullable Node node) {
            if (node == null)
                return false;
            if (node instanceof Element) {
                Element el = (Element) node;
                if (el.nameIs("br"))
                    return true;
                return el.isBlock() || (!el.tag.isKnownTag() && (el.parentNode instanceof Document || hasChildBlocks(el)));
            }
            return false;
        }
        static boolean hasChildBlocks(Element el) {
            Element child = el.firstElementChild();
            for (int i = 0; i < maxScan && child != null; i++) {
                if (child.isBlock() || !child.tag.isKnownTag())
                    return true;
                child = child.nextElementSibling();
            }
            return false;
        }
        static private final int maxScan = 5;
        static boolean hasNonTextNodes(Element el) {
            Node child = el.firstChild();
            for (int i = 0; i < maxScan && child != null; i++) {
                if (!(child instanceof TextNode))
                    return true;
                child = child.nextSibling();
            }
            return false;
        }
        static Node previousNonblank(Node node) {
            Node prev = node.previousSibling();
            while (isBlankText(prev)) prev = prev.previousSibling();
            return prev;
        }
        static Node nextNonBlank(@Nullable Node node) {
            while (isBlankText(node)) node = node.nextSibling();
            return node;
        }
        static boolean isBlankText(@Nullable Node node) {
            return node instanceof TextNode && ((TextNode) node).isBlank();
        }
        static boolean tagIs(int option, @Nullable Node node) {
            return node instanceof Element && ((Element) node).tag.is(option);
        }
    }
    static class Outline extends Pretty {
        Outline(Node root, QuietAppendable accum, OutputSettings settings) {
            super(root, accum, settings);
        }
        boolean isBlockEl(@Nullable Node node) {
            return node != null;
        }
        boolean shouldIndent(@Nullable Node node) {
            if (node == null || node == root || preserveWhitespace || isBlankText(node))
                return false;
            if (node instanceof TextNode) {
                return node.previousSibling() != null || node.nextSibling() != null;
            }
            return true;
        }
    }
    static Printer printerFor(Node root, QuietAppendable accum) {
        OutputSettings settings = NodeUtils.outputSettings(root);
        if (settings.outline())
            return new Printer.Outline(root, accum, settings);
        if (settings.prettyPrint())
            return new Printer.Pretty(root, accum, settings);
        return new Printer(root, accum, settings);
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```