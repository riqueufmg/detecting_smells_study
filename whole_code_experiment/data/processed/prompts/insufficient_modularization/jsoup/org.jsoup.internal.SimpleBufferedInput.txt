##CONTEXT_SIZE=879
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.internal;
class SimpleBufferedInput extends FilterInputStream {
    static final int BufferSize = DefaultBufferSize;
    static final SoftPool<byte[]> BufferPool = new SoftPool<>(() -> new byte[BufferSize]);
    private byte @Nullable [] byteBuf;
    private int bufPos;
    private int bufLength;
    private int bufMark = -1;
    private boolean inReadFully = false;
    SimpleBufferedInput(@Nullable InputStream in) {
        super(in);
        if (in == null)
            inReadFully = true;
    }
    public int read() throws IOException {
        if (bufPos >= bufLength) {
            fill();
            if (bufPos >= bufLength)
                return -1;
        }
        return getBuf()[bufPos++] & 0xff;
    }
    public int read(byte[] dest, int offset, int desiredLen) throws IOException {
        Validate.notNull(dest);
        if (offset < 0 || desiredLen < 0 || desiredLen > dest.length - offset) {
            throw new IndexOutOfBoundsException();
        } else if (desiredLen == 0) {
            return 0;
        }
        int bufAvail = bufLength - bufPos;
        if (bufAvail <= 0) {
            if (!inReadFully && bufMark < 0) {
                int read = in.read(dest, offset, desiredLen);
                closeIfDone(read);
                return read;
            }
            fill();
            bufAvail = bufLength - bufPos;
        }
        int read = Math.min(bufAvail, desiredLen);
        if (read <= 0) {
            return -1;
        }
        System.arraycopy(getBuf(), bufPos, dest, offset, read);
        bufPos += read;
        return read;
    }
    private void fill() throws IOException {
        if (inReadFully)
            return;
        if (byteBuf == null) {
            byteBuf = BufferPool.borrow();
        }
        if (bufMark < 0) {
            bufPos = 0;
        } else if (bufPos >= BufferSize) {
            if (bufMark > 0) {
                int size = bufPos - bufMark;
                System.arraycopy(byteBuf, bufMark, byteBuf, 0, size);
                bufPos = size;
                bufMark = 0;
            } else {
                bufMark = -1;
                bufPos = 0;
            }
        }
        bufLength = bufPos;
        int read = in.read(byteBuf, bufPos, byteBuf.length - bufPos);
        if (read > 0) {
            bufLength = read + bufPos;
            while (byteBuf.length - bufLength > 0) {
                if (in.available() < 1)
                    break;
                read = in.read(byteBuf, bufLength, byteBuf.length - bufLength);
                if (read <= 0)
                    break;
                bufLength += read;
            }
        }
        closeIfDone(read);
    }
    private void closeIfDone(int read) throws IOException {
        if (read == -1) {
            inReadFully = true;
            super.close();
        }
    }
    byte[] getBuf() {
        Validate.notNull(byteBuf);
        return byteBuf;
    }
    boolean baseReadFully() {
        return inReadFully;
    }
    public int available() throws IOException {
        if (byteBuf != null && bufLength - bufPos > 0)
            return bufLength - bufPos;
        return inReadFully ? 0 : in.available();
    }
    public void mark(int readlimit) {
        if (readlimit > BufferSize) {
            throw new IllegalArgumentException("Read-ahead limit is greater than buffer size");
        }
        bufMark = bufPos;
    }
    public void reset() throws IOException {
        if (bufMark < 0)
            throw new IOException("Resetting to invalid mark");
        bufPos = bufMark;
    }
    public void close() throws IOException {
        if (in != null)
            super.close();
        if (byteBuf == null)
            return;
        BufferPool.release(byteBuf);
        byteBuf = null;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```