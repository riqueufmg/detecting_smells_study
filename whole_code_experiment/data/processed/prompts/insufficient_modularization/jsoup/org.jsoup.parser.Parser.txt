##CONTEXT_SIZE=1239
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.parser;
public class Parser implements Cloneable {
    public static final String NamespaceHtml = "http://www.w3.org/1999/xhtml";
    public static final String NamespaceXml = "http://www.w3.org/XML/1998/namespace";
    public static final String NamespaceMathml = "http://www.w3.org/1998/Math/MathML";
    public static final String NamespaceSvg = "http://www.w3.org/2000/svg";
    private final TreeBuilder treeBuilder;
    private ParseErrorList errors;
    private ParseSettings settings;
    private boolean trackPosition = false;
    private TagSet tagSet;
    private final ReentrantLock lock = new ReentrantLock();
    private int maxDepth;
    public Parser(TreeBuilder treeBuilder) {
        this.treeBuilder = treeBuilder;
        settings = treeBuilder.defaultSettings();
        errors = ParseErrorList.noTracking();
        maxDepth = treeBuilder.defaultMaxDepth();
    }
    public Parser newInstance() {
        return new Parser(this);
    }
    public Parser clone() {
        return new Parser(this);
    }
    private Parser(Parser copy) {
        treeBuilder = copy.treeBuilder.newInstance();
        errors = new ParseErrorList(copy.errors);
        settings = new ParseSettings(copy.settings);
        trackPosition = copy.trackPosition;
        maxDepth = copy.maxDepth;
        tagSet = new TagSet(copy.tagSet());
    }
    public Document parseInput(String html, String baseUri) {
        return parseInput(new StringReader(html), baseUri);
    }
    public Document parseInput(Reader inputHtml, String baseUri) {
        try {
            lock.lock();
            return treeBuilder.parse(inputHtml, baseUri, this);
        } finally {
            lock.unlock();
        }
    }
    public List<Node> parseFragmentInput(String fragment, @Nullable Element context, String baseUri) {
        return parseFragmentInput(new StringReader(fragment), context, baseUri);
    }
    public List<Node> parseFragmentInput(Reader fragment, @Nullable Element context, String baseUri) {
        try {
            lock.lock();
            return treeBuilder.parseFragment(fragment, context, baseUri, this);
        } finally {
            lock.unlock();
        }
    }
    public TreeBuilder getTreeBuilder() {
        return treeBuilder;
    }
    public boolean isTrackErrors() {
        return errors.getMaxSize() > 0;
    }
    public Parser setTrackErrors(int maxErrors) {
        errors = maxErrors > 0 ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();
        return this;
    }
    public ParseErrorList getErrors() {
        return errors;
    }
    public boolean isTrackPosition() {
        return trackPosition;
    }
    public Parser setTrackPosition(boolean trackPosition) {
        this.trackPosition = trackPosition;
        return this;
    }
    public Parser settings(ParseSettings settings) {
        this.settings = settings;
        return this;
    }
    public ParseSettings settings() {
        return settings;
    }
    public Parser setMaxDepth(int maxDepth) {
        Validate.isTrue(maxDepth >= 1, "maxDepth must be >= 1");
        this.maxDepth = maxDepth;
        return this;
    }
    public int getMaxDepth() {
        return maxDepth;
    }
    public Parser tagSet(TagSet tagSet) {
        Validate.notNull(tagSet);
        this.tagSet = new TagSet(tagSet);
        return this;
    }
    public TagSet tagSet() {
        if (tagSet == null)
            tagSet = treeBuilder.defaultTagSet();
        return tagSet;
    }
    public String defaultNamespace() {
        return getTreeBuilder().defaultNamespace();
    }
    public static Document parse(String html, String baseUri) {
        TreeBuilder treeBuilder = new HtmlTreeBuilder();
        return treeBuilder.parse(new StringReader(html), baseUri, new Parser(treeBuilder));
    }
    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {
        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();
        return treeBuilder.parseFragment(new StringReader(fragmentHtml), context, baseUri, new Parser(treeBuilder));
    }
    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) {
        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();
        Parser parser = new Parser(treeBuilder);
        parser.errors = errorList;
        return treeBuilder.parseFragment(new StringReader(fragmentHtml), context, baseUri, parser);
    }
    public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {
        XmlTreeBuilder treeBuilder = new XmlTreeBuilder();
        return treeBuilder.parseFragment(new StringReader(fragmentXml), null, baseUri, new Parser(treeBuilder));
    }
    public static Document parseBodyFragment(String bodyHtml, String baseUri) {
        Document doc = Document.createShell(baseUri);
        Element body = doc.body();
        List<Node> nodeList = parseFragment(bodyHtml, body, baseUri);
        body.appendChildren(nodeList);
        return doc;
    }
    public static String unescapeEntities(String string, boolean inAttribute) {
        Validate.notNull(string);
        if (string.indexOf('&') < 0)
            return string;
        return Parser.htmlParser().unescape(string, inAttribute);
    }
    public String unescape(String string, boolean inAttribute) {
        Validate.notNull(string);
        if (string.indexOf('&') < 0)
            return string;
        this.treeBuilder.initialiseParse(new StringReader(string), "", this);
        Tokeniser tokeniser = new Tokeniser(this.treeBuilder);
        return tokeniser.unescapeEntities(inAttribute);
    }
    public static Parser htmlParser() {
        return new Parser(new HtmlTreeBuilder());
    }
    public static Parser xmlParser() {
        return new Parser(new XmlTreeBuilder()).setMaxDepth(Integer.MAX_VALUE);
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```