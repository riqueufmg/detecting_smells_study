##CONTEXT_SIZE=2056
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.parser;
public class TokenQueue implements AutoCloseable {
    private static final char Esc = '\\';
    private static final char Hyphen_Minus = '-';
    private static final char Unicode_Null = '\u0000';
    private static final char Replacement = '\uFFFD';
    private final CharacterReader reader;
    public TokenQueue(String data) {
        reader = new CharacterReader(data);
    }
    public boolean isEmpty() {
        return reader.isEmpty();
    }
    public char consume() {
        return reader.consume();
    }
    public void advance() {
        if (!isEmpty())
            reader.advance();
    }
    char current() {
        return reader.current();
    }
    public boolean matches(String seq) {
        return reader.matchesIgnoreCase(seq);
    }
    public boolean matches(char c) {
        return reader.matches(c);
    }
    public boolean matchesAny(char... seq) {
        return reader.matchesAny(seq);
    }
    public boolean matchChomp(String seq) {
        return reader.matchConsumeIgnoreCase(seq);
    }
    public boolean matchChomp(char c) {
        if (reader.matches(c)) {
            consume();
            return true;
        }
        return false;
    }
    public boolean matchesWhitespace() {
        return StringUtil.isWhitespace(reader.current());
    }
    public boolean matchesWord() {
        return Character.isLetterOrDigit(reader.current());
    }
    public void consume(String seq) {
        boolean found = reader.matchConsumeIgnoreCase(seq);
        if (!found)
            throw new IllegalStateException("Queue did not match expected sequence");
    }
    public String consumeTo(String seq) {
        return reader.consumeTo(seq);
    }
    public String consumeToAny(String... seq) {
        StringBuilder sb = StringUtil.borrowBuilder();
        OUT: while (!isEmpty()) {
            for (String s : seq) {
                if (reader.matchesIgnoreCase(s))
                    break OUT;
            }
            sb.append(consume());
        }
        return StringUtil.releaseBuilder(sb);
    }
    public String chompBalanced(char open, char close) {
        StringBuilder accum = StringUtil.borrowBuilder();
        int depth = 0;
        char prev = 0;
        boolean inSingle = false;
        boolean inDouble = false;
        boolean inRegexQE = false;
        reader.mark();
        do {
            if (isEmpty())
                break;
            char c = consume();
            if (prev == Esc) {
                if (c == 'Q')
                    inRegexQE = true;
                else if (c == 'E')
                    inRegexQE = false;
                accum.append(c);
            } else {
                if (c == '\'' && c != open && !inDouble)
                    inSingle = !inSingle;
                else if (c == '"' && c != open && !inSingle)
                    inDouble = !inDouble;
                if (inSingle || inDouble || inRegexQE) {
                    accum.append(c);
                } else if (c == open) {
                    depth++;
                    if (depth > 1)
                        accum.append(c);
                } else if (c == close) {
                    depth--;
                    if (depth > 0)
                        accum.append(c);
                } else {
                    accum.append(c);
                }
            }
            prev = c;
        } while (depth > 0);
        String out = StringUtil.releaseBuilder(accum);
        if (depth > 0) {
            reader.rewindToMark();
            Validate.fail("Did not find balanced marker at '" + out + "'");
        }
        return out;
    }
    public static String unescape(String in) {
        if (in.indexOf(Esc) == -1)
            return in;
        StringBuilder out = StringUtil.borrowBuilder();
        char last = 0;
        for (char c : in.toCharArray()) {
            if (c == Esc) {
                if (last == Esc) {
                    out.append(c);
                    c = 0;
                }
            } else
                out.append(c);
            last = c;
        }
        return StringUtil.releaseBuilder(out);
    }
    public static String escapeCssIdentifier(String in) {
        if (in.isEmpty())
            return in;
        StringBuilder out = StringUtil.borrowBuilder();
        TokenQueue q = new TokenQueue(in);
        char firstChar = q.current();
        if (firstChar == Hyphen_Minus) {
            q.advance();
            if (q.isEmpty()) {
                appendEscaped(out, Hyphen_Minus);
            } else {
                out.append(Hyphen_Minus);
                char secondChar = q.current();
                if (StringUtil.isDigit(secondChar)) {
                    appendEscapedCodepoint(out, q.consume());
                }
            }
        } else if (StringUtil.isDigit(firstChar)) {
            appendEscapedCodepoint(out, q.consume());
        }
        while (!q.isEmpty()) {
            char c = q.consume();
            if (c == Unicode_Null) {
                out.append(Replacement);
            } else if (c <= '\u001F' || c == '\u007F') {
                appendEscapedCodepoint(out, c);
            } else if (isIdent(c)) {
                out.append(c);
            } else {
                appendEscaped(out, c);
            }
        }
        q.close();
        return StringUtil.releaseBuilder(out);
    }
    private static void appendEscaped(StringBuilder out, char c) {
        out.append(Esc).append(c);
    }
    private static void appendEscapedCodepoint(StringBuilder out, char c) {
        out.append(Esc).append(Integer.toHexString(c)).append(' ');
    }
    public boolean consumeWhitespace() {
        boolean seen = false;
        while (matchesWhitespace()) {
            advance();
            seen = true;
        }
        return seen;
    }
    public String consumeElementSelector() {
        return consumeEscapedCssIdentifier(ElementSelectorChars);
    }
    private static final char[] ElementSelectorChars = { '*', '|', '_', '-' };
    public String consumeCssIdentifier() {
        if (isEmpty())
            throw new IllegalArgumentException("CSS identifier expected, but end of input found");
        String identifier = reader.consumeMatching(TokenQueue::isIdent);
        char c = current();
        if (c != Esc && c != Unicode_Null) {
            return identifier;
        }
        StringBuilder out = StringUtil.borrowBuilder();
        if (!identifier.isEmpty()) {
            out.append(identifier);
        }
        while (!isEmpty()) {
            c = current();
            if (isIdent(c)) {
                out.append(consume());
            } else if (c == Unicode_Null) {
                advance();
                out.append(Replacement);
            } else if (c == Esc) {
                advance();
                if (!isEmpty() && isNewline(current())) {
                    reader.unconsume();
                    break;
                } else {
                    consumeCssEscapeSequenceInto(out);
                }
            } else {
                break;
            }
        }
        return StringUtil.releaseBuilder(out);
    }
    private void consumeCssEscapeSequenceInto(StringBuilder out) {
        if (isEmpty()) {
            out.append(Replacement);
            return;
        }
        char firstEscaped = consume();
        if (!StringUtil.isHexDigit(firstEscaped)) {
            out.append(firstEscaped);
        } else {
            reader.unconsume();
            String hexString = reader.consumeMatching(StringUtil::isHexDigit, 6);
            int codePoint;
            try {
                codePoint = Integer.parseInt(hexString, 16);
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException("Invalid escape sequence: " + hexString, e);
            }
            if (isValidCodePoint(codePoint)) {
                out.appendCodePoint(codePoint);
            } else {
                out.append(Replacement);
            }
            if (!isEmpty()) {
                char c = current();
                if (c == '\r') {
                    advance();
                    if (!isEmpty() && current() == '\n')
                        advance();
                } else if (c == ' ' || c == '\t' || isNewline(c)) {
                    advance();
                }
            }
        }
    }
    private static boolean isNonAscii(char c) {
        return c >= '\u0080';
    }
    private static boolean isIdentStart(char c) {
        return c == '_' || StringUtil.isAsciiLetter(c) || isNonAscii(c);
    }
    private static boolean isIdent(char c) {
        return c == Hyphen_Minus || StringUtil.isDigit(c) || isIdentStart(c);
    }
    private static boolean isNewline(char c) {
        return c == '\n' || c == '\r' || c == '\f';
    }
    private static boolean isValidCodePoint(int codePoint) {
        return codePoint != 0 && Character.isValidCodePoint(codePoint) && !Character.isSurrogate((char) codePoint);
    }
    private static final char[] CssIdentifierChars = { '-', '_' };
    private String consumeEscapedCssIdentifier(char... matches) {
        StringBuilder sb = StringUtil.borrowBuilder();
        while (!isEmpty()) {
            char c = current();
            if (c == Esc) {
                advance();
                if (!isEmpty())
                    sb.append(consume());
                else
                    break;
            } else if (matchesCssIdentifier(matches)) {
                sb.append(c);
                advance();
            } else {
                break;
            }
        }
        return StringUtil.releaseBuilder(sb);
    }
    private boolean matchesCssIdentifier(char... matches) {
        return matchesWord() || reader.matchesAny(matches);
    }
    public String remainder() {
        return reader.consumeToEnd();
    }
    public String toString() {
        return reader.toString();
    }
    public void close() {
        reader.close();
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```