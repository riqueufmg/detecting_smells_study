##CONTEXT_SIZE=1826
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.nodes;
public class Document extends Element {
    private Connection connection;
    private OutputSettings outputSettings = new OutputSettings();
    private Parser parser;
    private QuirksMode quirksMode = QuirksMode.noQuirks;
    private final String location;
    public Document(String namespace, String baseUri) {
        this(namespace, baseUri, Parser.htmlParser());
    }
    private Document(String namespace, String baseUri, Parser parser) {
        super(new Tag("#root", namespace), baseUri);
        this.location = baseUri;
        this.parser = parser;
    }
    public Document(String baseUri) {
        this(NamespaceHtml, baseUri);
    }
    public static Document createShell(String baseUri) {
        Validate.notNull(baseUri);
        Document doc = new Document(baseUri);
        Element html = doc.appendElement("html");
        html.appendElement("head");
        html.appendElement("body");
        return doc;
    }
    public String location() {
        return location;
    }
    public Connection connection() {
        if (connection == null)
            return Jsoup.newSession();
        else
            return connection;
    }
    public DocumentType documentType() {
        for (Node node : childNodes) {
            if (node instanceof DocumentType)
                return (DocumentType) node;
            else if (!(node instanceof LeafNode))
                break;
        }
        return null;
    }
    private Element htmlEl() {
        Element el = firstElementChild();
        while (el != null) {
            if (el.nameIs("html"))
                return el;
            el = el.nextElementSibling();
        }
        return appendElement("html");
    }
    public Element head() {
        final Element html = htmlEl();
        Element el = html.firstElementChild();
        while (el != null) {
            if (el.nameIs("head"))
                return el;
            el = el.nextElementSibling();
        }
        return html.prependElement("head");
    }
    public Element body() {
        final Element html = htmlEl();
        Element el = html.firstElementChild();
        while (el != null) {
            if (el.nameIs("body") || el.nameIs("frameset"))
                return el;
            el = el.nextElementSibling();
        }
        return html.appendElement("body");
    }
    public List<FormElement> forms() {
        return select("form").forms();
    }
    public FormElement expectForm(String cssQuery) {
        Elements els = select(cssQuery);
        for (Element el : els) {
            if (el instanceof FormElement)
                return (FormElement) el;
        }
        Validate.fail("No form elements matched the query '%s' in the document.", cssQuery);
        return null;
    }
    public String title() {
        Element titleEl = head().selectFirst(titleEval);
        return titleEl != null ? StringUtil.normaliseWhitespace(titleEl.text()).trim() : "";
    }
    private static final Evaluator titleEval = new Evaluator.Tag("title");
    public void title(String title) {
        Validate.notNull(title);
        Element titleEl = head().selectFirst(titleEval);
        if (titleEl == null)
            titleEl = head().appendElement("title");
        titleEl.text(title);
    }
    public Element createElement(String tagName) {
        return new Element(parser.tagSet().valueOf(tagName, parser.defaultNamespace(), ParseSettings.preserveCase), searchUpForAttribute(this, BaseUriKey));
    }
    public String outerHtml() {
        return super.html();
    }
    public Element text(String text) {
        body().text(text);
        return this;
    }
    public String nodeName() {
        return "#document";
    }
    public void charset(Charset charset) {
        outputSettings.charset(charset);
        ensureMetaCharsetElement();
    }
    public Charset charset() {
        return outputSettings.charset();
    }
    public Document clone() {
        Document clone = (Document) super.clone();
        if (attributes != null)
            clone.attributes = attributes.clone();
        clone.outputSettings = this.outputSettings.clone();
        return clone;
    }
    public Document shallowClone() {
        Document clone = new Document(this.tag().namespace(), baseUri(), parser);
        if (attributes != null)
            clone.attributes = attributes.clone();
        clone.outputSettings = this.outputSettings.clone();
        return clone;
    }
    private void ensureMetaCharsetElement() {
        OutputSettings.Syntax syntax = outputSettings().syntax();
        if (syntax == OutputSettings.Syntax.html) {
            Element metaCharset = selectFirst("meta[charset]");
            if (metaCharset != null) {
                metaCharset.attr("charset", charset().displayName());
            } else {
                head().appendElement("meta").attr("charset", charset().displayName());
            }
            select("meta[name=charset]").remove();
        } else if (syntax == OutputSettings.Syntax.xml) {
            XmlDeclaration decl = ensureXmlDecl();
            decl.attr("version", "1.0");
            decl.attr("encoding", charset().displayName());
        }
    }
    private XmlDeclaration ensureXmlDecl() {
        Node node = firstChild();
        if (node instanceof XmlDeclaration) {
            XmlDeclaration decl = (XmlDeclaration) node;
            if (decl.name().equals("xml"))
                return decl;
        }
        XmlDeclaration decl = new XmlDeclaration("xml", false);
        prependChild(decl);
        return decl;
    }
    public static class OutputSettings implements Cloneable {
        public enum Syntax {
            html, xml
        }
        private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;
        private Charset charset = DataUtil.UTF_8;
        private boolean prettyPrint = true;
        private boolean outline = false;
        private int indentAmount = 1;
        private int maxPaddingWidth = 30;
        private Syntax syntax = Syntax.html;
        public OutputSettings() {
        }
        public Entities.EscapeMode escapeMode() {
            return escapeMode;
        }
        public OutputSettings escapeMode(Entities.EscapeMode escapeMode) {
            this.escapeMode = escapeMode;
            return this;
        }
        public Charset charset() {
            return charset;
        }
        public OutputSettings charset(Charset charset) {
            this.charset = charset;
            return this;
        }
        public OutputSettings charset(String charset) {
            charset(Charset.forName(charset));
            return this;
        }
        public Syntax syntax() {
            return syntax;
        }
        public OutputSettings syntax(Syntax syntax) {
            this.syntax = syntax;
            if (syntax == Syntax.xml)
                this.escapeMode(Entities.EscapeMode.xhtml);
            return this;
        }
        public boolean prettyPrint() {
            return prettyPrint;
        }
        public OutputSettings prettyPrint(boolean pretty) {
            prettyPrint = pretty;
            return this;
        }
        public boolean outline() {
            return outline;
        }
        public OutputSettings outline(boolean outlineMode) {
            outline = outlineMode;
            return this;
        }
        public int indentAmount() {
            return indentAmount;
        }
        public OutputSettings indentAmount(int indentAmount) {
            Validate.isTrue(indentAmount >= 0);
            this.indentAmount = indentAmount;
            return this;
        }
        public int maxPaddingWidth() {
            return maxPaddingWidth;
        }
        public OutputSettings maxPaddingWidth(int maxPaddingWidth) {
            Validate.isTrue(maxPaddingWidth >= -1);
            this.maxPaddingWidth = maxPaddingWidth;
            return this;
        }
        public OutputSettings clone() {
            OutputSettings clone;
            try {
                clone = (OutputSettings) super.clone();
            } catch (CloneNotSupportedException e) {
                throw new RuntimeException(e);
            }
            clone.charset(charset.name());
            clone.escapeMode = Entities.EscapeMode.valueOf(escapeMode.name());
            return clone;
        }
    }
    public OutputSettings outputSettings() {
        return outputSettings;
    }
    public Document outputSettings(OutputSettings outputSettings) {
        Validate.notNull(outputSettings);
        this.outputSettings = outputSettings;
        return this;
    }
    public enum QuirksMode {
        noQuirks, quirks, limitedQuirks
    }
    public QuirksMode quirksMode() {
        return quirksMode;
    }
    public Document quirksMode(QuirksMode quirksMode) {
        this.quirksMode = quirksMode;
        return this;
    }
    public Parser parser() {
        return parser;
    }
    public Document parser(Parser parser) {
        this.parser = parser;
        return this;
    }
    public Document connection(Connection connection) {
        Validate.notNull(connection);
        this.connection = connection;
        return this;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```