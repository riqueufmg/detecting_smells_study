##CONTEXT_SIZE=3309
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.parser;
public final class CharacterReader implements AutoCloseable {
    static final char EOF = (char) -1;
    private static final int MaxStringCacheLen = 12;
    private static final int StringCacheSize = 512;
    private String[] stringCache;
    private static final SoftPool<String[]> StringPool = new SoftPool<>(() -> new String[StringCacheSize]);
    static final int BufferSize = 1024 * 2;
    static final int RefillPoint = BufferSize / 2;
    private static final int RewindLimit = 1024;
    private Reader reader;
    private char[] charBuf;
    private int bufPos;
    private int bufLength;
    private int fillPoint = 0;
    private int consumed;
    private int bufMark = -1;
    private boolean readFully;
    private static final SoftPool<char[]> BufferPool = new SoftPool<>(() -> new char[BufferSize]);
    private ArrayList<Integer> newlinePositions = null;
    private int lineNumberOffset = 1;
    public CharacterReader(Reader input, int sz) {
        this(input);
    }
    public CharacterReader(Reader input) {
        Validate.notNull(input);
        reader = input;
        charBuf = BufferPool.borrow();
        stringCache = StringPool.borrow();
        bufferUp();
    }
    public CharacterReader(String input) {
        this(new StringReader(input));
    }
    public void close() {
        if (reader == null)
            return;
        try {
            reader.close();
        } catch (IOException ignored) {
        } finally {
            reader = null;
            Arrays.fill(charBuf, (char) 0);
            BufferPool.release(charBuf);
            charBuf = null;
            StringPool.release(stringCache);
            stringCache = null;
        }
    }
    private void bufferUp() {
        if (readFully || bufPos < fillPoint || bufMark != -1)
            return;
        doBufferUp();
    }
    private void doBufferUp() {
        consumed += bufPos;
        bufLength -= bufPos;
        if (bufLength > 0)
            System.arraycopy(charBuf, bufPos, charBuf, 0, bufLength);
        bufPos = 0;
        while (bufLength < BufferSize) {
            try {
                int read = reader.read(charBuf, bufLength, charBuf.length - bufLength);
                if (read == -1) {
                    readFully = true;
                    break;
                }
                if (read == 0) {
                    break;
                }
                bufLength += read;
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }
        fillPoint = Math.min(bufLength, RefillPoint);
        scanBufferForNewlines();
        lastIcSeq = null;
    }
    void mark() {
        if (bufLength - bufPos < RewindLimit)
            fillPoint = 0;
        bufferUp();
        bufMark = bufPos;
    }
    void unmark() {
        bufMark = -1;
    }
    void rewindToMark() {
        if (bufMark == -1)
            throw new UncheckedIOException(new IOException("Mark invalid"));
        bufPos = bufMark;
        unmark();
    }
    public int pos() {
        return consumed + bufPos;
    }
    boolean readFully() {
        return readFully;
    }
    public void trackNewlines(boolean track) {
        if (track && newlinePositions == null) {
            newlinePositions = new ArrayList<>(BufferSize / 80);
            scanBufferForNewlines();
        } else if (!track)
            newlinePositions = null;
    }
    public boolean isTrackNewlines() {
        return newlinePositions != null;
    }
    public int lineNumber() {
        return lineNumber(pos());
    }
    int lineNumber(int pos) {
        if (!isTrackNewlines())
            return 1;
        int i = lineNumIndex(pos);
        if (i == -1)
            return lineNumberOffset;
        return i + lineNumberOffset + 1;
    }
    public int columnNumber() {
        return columnNumber(pos());
    }
    int columnNumber(int pos) {
        if (!isTrackNewlines())
            return pos + 1;
        int i = lineNumIndex(pos);
        if (i == -1)
            return pos + 1;
        return pos - newlinePositions.get(i) + 1;
    }
    String posLineCol() {
        return lineNumber() + ":" + columnNumber();
    }
    private int lineNumIndex(int pos) {
        if (!isTrackNewlines())
            return 0;
        int i = Collections.binarySearch(newlinePositions, pos);
        if (i < -1)
            i = Math.abs(i) - 2;
        return i;
    }
    private void scanBufferForNewlines() {
        if (!isTrackNewlines())
            return;
        if (newlinePositions.size() > 0) {
            int index = lineNumIndex(consumed);
            if (index == -1)
                index = 0;
            int linePos = newlinePositions.get(index);
            lineNumberOffset += index;
            newlinePositions.clear();
            newlinePositions.add(linePos);
        }
        for (int i = bufPos; i < bufLength; i++) {
            if (charBuf[i] == '\n')
                newlinePositions.add(1 + consumed + i);
        }
    }
    public boolean isEmpty() {
        bufferUp();
        return bufPos >= bufLength;
    }
    private boolean isEmptyNoBufferUp() {
        return bufPos >= bufLength;
    }
    public char current() {
        bufferUp();
        return isEmptyNoBufferUp() ? EOF : charBuf[bufPos];
    }
    public char consume() {
        bufferUp();
        char val = isEmptyNoBufferUp() ? EOF : charBuf[bufPos];
        bufPos++;
        return val;
    }
    void unconsume() {
        if (bufPos < 1)
            throw new UncheckedIOException(new IOException("WTF: No buffer left to unconsume."));
        bufPos--;
    }
    public void advance() {
        bufPos++;
    }
    int nextIndexOf(char c) {
        bufferUp();
        for (int i = bufPos; i < bufLength; i++) {
            if (c == charBuf[i])
                return i - bufPos;
        }
        return -1;
    }
    int nextIndexOf(CharSequence seq) {
        bufferUp();
        char startChar = seq.charAt(0);
        for (int offset = bufPos; offset < bufLength; offset++) {
            if (startChar != charBuf[offset])
                while (++offset < bufLength && startChar != charBuf[offset]) {
                }
            int i = offset + 1;
            int last = i + seq.length() - 1;
            if (offset < bufLength && last <= bufLength) {
                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) {
                }
                if (i == last)
                    return offset - bufPos;
            }
        }
        return -1;
    }
    public String consumeTo(char c) {
        int offset = nextIndexOf(c);
        if (offset != -1) {
            String consumed = cacheString(charBuf, stringCache, bufPos, offset);
            bufPos += offset;
            return consumed;
        } else {
            return consumeToEnd();
        }
    }
    public String consumeTo(String seq) {
        int offset = nextIndexOf(seq);
        if (offset != -1) {
            String consumed = cacheString(charBuf, stringCache, bufPos, offset);
            bufPos += offset;
            return consumed;
        } else if (bufLength - bufPos < seq.length()) {
            return consumeToEnd();
        } else {
            int endPos = bufLength - seq.length() + 1;
            String consumed = cacheString(charBuf, stringCache, bufPos, endPos - bufPos);
            bufPos = endPos;
            return consumed;
        }
    }
    String consumeMatching(CharPredicate func) {
        return consumeMatching(func, -1);
    }
    String consumeMatching(CharPredicate func, int maxLength) {
        bufferUp();
        int pos = bufPos;
        final int start = pos;
        final int remaining = bufLength;
        final char[] val = charBuf;
        while (pos < remaining && (maxLength == -1 || pos - start < maxLength) && func.test(val[pos])) {
            pos++;
        }
        bufPos = pos;
        return pos > start ? cacheString(charBuf, stringCache, start, pos - start) : "";
    }
    public String consumeToAny(final char... chars) {
        return consumeMatching(c -> {
            for (char seek : chars) if (c == seek)
                return false;
            return true;
        });
    }
    String consumeToAnySorted(final char... chars) {
        return consumeMatching(c -> Arrays.binarySearch(chars, c) < 0);
    }
    String consumeData() {
        return consumeMatching(c -> c != '&' && c != '<' && c != TokeniserState.nullChar);
    }
    String consumeAttributeQuoted(final boolean single) {
        return consumeMatching(c -> c != TokeniserState.nullChar && c != '&' && (single ? c != '\'' : c != '"'));
    }
    String consumeRawData() {
        return consumeMatching(c -> c != '<' && c != TokeniserState.nullChar);
    }
    String consumeTagName() {
        return consumeMatching(c -> {
            switch(c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                case '/':
                case '>':
                    return false;
            }
            return true;
        });
    }
    String consumeToEnd() {
        bufferUp();
        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);
        bufPos = bufLength;
        return data;
    }
    String consumeLetterSequence() {
        return consumeMatching(Character::isLetter);
    }
    String consumeLetterThenDigitSequence() {
        bufferUp();
        int start = bufPos;
        while (bufPos < bufLength) {
            if (StringUtil.isAsciiLetter(charBuf[bufPos]))
                bufPos++;
            else
                break;
        }
        while (!isEmptyNoBufferUp()) {
            if (StringUtil.isDigit(charBuf[bufPos]))
                bufPos++;
            else
                break;
        }
        return cacheString(charBuf, stringCache, start, bufPos - start);
    }
    String consumeHexSequence() {
        return consumeMatching(StringUtil::isHexDigit);
    }
    String consumeDigitSequence() {
        return consumeMatching(c -> c >= '0' && c <= '9');
    }
    boolean matches(char c) {
        return !isEmpty() && charBuf[bufPos] == c;
    }
    boolean matches(String seq) {
        bufferUp();
        int scanLength = seq.length();
        if (scanLength > bufLength - bufPos)
            return false;
        for (int offset = 0; offset < scanLength; offset++) if (seq.charAt(offset) != charBuf[bufPos + offset])
            return false;
        return true;
    }
    boolean matchesIgnoreCase(String seq) {
        bufferUp();
        int scanLength = seq.length();
        if (scanLength > bufLength - bufPos)
            return false;
        for (int offset = 0; offset < scanLength; offset++) {
            char scan = seq.charAt(offset);
            char target = charBuf[bufPos + offset];
            if (scan == target)
                continue;
            scan = Character.toUpperCase(scan);
            target = Character.toUpperCase(target);
            if (scan != target)
                return false;
        }
        return true;
    }
    boolean matchesAny(char... seq) {
        if (isEmpty())
            return false;
        bufferUp();
        char c = charBuf[bufPos];
        for (char seek : seq) {
            if (seek == c)
                return true;
        }
        return false;
    }
    boolean matchesAnySorted(char[] seq) {
        bufferUp();
        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;
    }
    boolean matchesAsciiAlpha() {
        if (isEmpty())
            return false;
        return StringUtil.isAsciiLetter(charBuf[bufPos]);
    }
    boolean matchesDigit() {
        if (isEmpty())
            return false;
        return StringUtil.isDigit(charBuf[bufPos]);
    }
    boolean matchConsume(String seq) {
        bufferUp();
        if (matches(seq)) {
            bufPos += seq.length();
            return true;
        } else {
            return false;
        }
    }
    boolean matchConsumeIgnoreCase(String seq) {
        if (matchesIgnoreCase(seq)) {
            bufPos += seq.length();
            return true;
        } else {
            return false;
        }
    }
    private String lastIcSeq;
    private int lastIcIndex;
    boolean containsIgnoreCase(String seq) {
        if (seq.equals(lastIcSeq)) {
            if (lastIcIndex == -1)
                return false;
            if (lastIcIndex >= bufPos)
                return true;
        }
        lastIcSeq = seq;
        String loScan = seq.toLowerCase(Locale.ENGLISH);
        int lo = nextIndexOf(loScan);
        if (lo > -1) {
            lastIcIndex = bufPos + lo;
            return true;
        }
        String hiScan = seq.toUpperCase(Locale.ENGLISH);
        int hi = nextIndexOf(hiScan);
        boolean found = hi > -1;
        lastIcIndex = found ? bufPos + hi : -1;
        return found;
    }
    public String toString() {
        if (bufLength - bufPos < 0)
            return "";
        return new String(charBuf, bufPos, bufLength - bufPos);
    }
    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {
        if (count > MaxStringCacheLen)
            return new String(charBuf, start, count);
        if (count < 1)
            return "";
        int hash = 0;
        int end = count + start;
        for (int i = start; i < end; i++) {
            hash = 31 * hash + charBuf[i];
        }
        final int index = hash & StringCacheSize - 1;
        String cached = stringCache[index];
        if (cached != null && rangeEquals(charBuf, start, count, cached))
            return cached;
        else {
            cached = new String(charBuf, start, count);
            stringCache[index] = cached;
        }
        return cached;
    }
    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {
        if (count == cached.length()) {
            int i = start;
            int j = 0;
            while (count-- != 0) {
                if (charBuf[i++] != cached.charAt(j++))
                    return false;
            }
            return true;
        }
        return false;
    }
    boolean rangeEquals(final int start, final int count, final String cached) {
        return rangeEquals(charBuf, start, count, cached);
    }
    interface CharPredicate {
        boolean test(char c);
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```