##CONTEXT_SIZE=7137
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.nodes;
public class Element extends Node implements Iterable<Element> {
    private static final List<Element> EmptyChildren = Collections.emptyList();
    private static final NodeList EmptyNodeList = new NodeList(0);
    private static final Pattern ClassSplit = Pattern.compile("\\s+");
    static final String BaseUriKey = Attributes.internalKey("baseUri");
    Tag tag;
    NodeList childNodes;
    Attributes attributes;
    public Element(String tag, String namespace) {
        this(Tag.valueOf(tag, namespace, ParseSettings.preserveCase), null);
    }
    public Element(String tag) {
        this(tag, Parser.NamespaceHtml);
    }
    public Element(Tag tag, @Nullable String baseUri, @Nullable Attributes attributes) {
        Validate.notNull(tag);
        childNodes = EmptyNodeList;
        this.attributes = attributes;
        this.tag = tag;
        if (!StringUtil.isBlank(baseUri))
            this.setBaseUri(baseUri);
    }
    public Element(Tag tag, @Nullable String baseUri) {
        this(tag, baseUri, null);
    }
    protected boolean hasChildNodes() {
        return childNodes != EmptyNodeList;
    }
    protected List<Node> ensureChildNodes() {
        if (childNodes == EmptyNodeList) {
            childNodes = new NodeList(4);
        }
        return childNodes;
    }
    protected boolean hasAttributes() {
        return attributes != null;
    }
    public Attributes attributes() {
        if (attributes == null)
            attributes = new Attributes();
        return attributes;
    }
    public String baseUri() {
        String baseUri = searchUpForAttribute(this, BaseUriKey);
        return baseUri != null ? baseUri : "";
    }
    static String searchUpForAttribute(final Element start, final String key) {
        Element el = start;
        while (el != null) {
            if (el.attributes != null && el.attributes.hasKey(key))
                return el.attributes.get(key);
            el = el.parent();
        }
        return null;
    }
    protected void doSetBaseUri(String baseUri) {
        attributes().put(BaseUriKey, baseUri);
    }
    public int childNodeSize() {
        return childNodes.size();
    }
    public String nodeName() {
        return tag.getName();
    }
    public String tagName() {
        return tag.getName();
    }
    public String normalName() {
        return tag.normalName();
    }
    public boolean elementIs(String normalName, String namespace) {
        return tag.normalName().equals(normalName) && tag.namespace().equals(namespace);
    }
    public Element tagName(String tagName) {
        return tagName(tagName, tag.namespace());
    }
    public Element tagName(String tagName, String namespace) {
        Validate.notEmptyParam(tagName, "tagName");
        Validate.notEmptyParam(namespace, "namespace");
        Parser parser = NodeUtils.parser(this);
        tag = parser.tagSet().valueOf(tagName, namespace, parser.settings());
        return this;
    }
    public Tag tag() {
        return tag;
    }
    public Element tag(Tag tag) {
        Validate.notNull(tag);
        this.tag = tag;
        return this;
    }
    public boolean isBlock() {
        return tag.isBlock();
    }
    public String id() {
        return attributes != null ? attributes.getIgnoreCase("id") : "";
    }
    public Element id(String id) {
        Validate.notNull(id);
        attr("id", id);
        return this;
    }
    public Element attr(String attributeKey, String attributeValue) {
        super.attr(attributeKey, attributeValue);
        return this;
    }
    public Element attr(String attributeKey, boolean attributeValue) {
        attributes().put(attributeKey, attributeValue);
        return this;
    }
    public Attribute attribute(String key) {
        return hasAttributes() ? attributes().attribute(key) : null;
    }
    public Map<String, String> dataset() {
        return attributes().dataset();
    }
    public final Element parent() {
        return (Element) parentNode;
    }
    public Elements parents() {
        Elements parents = new Elements();
        Element parent = this.parent();
        while (parent != null && !parent.nameIs("#root")) {
            parents.add(parent);
            parent = parent.parent();
        }
        return parents;
    }
    public Element child(int index) {
        Validate.isTrue(index >= 0, "Index must be >= 0");
        List<Element> cached = cachedChildren();
        if (cached != null)
            return cached.get(index);
        int size = childNodes.size();
        for (int i = 0, e = 0; i < size; i++) {
            Node node = childNodes.get(i);
            if (node instanceof Element) {
                if (e++ == index)
                    return (Element) node;
            }
        }
        throw new IndexOutOfBoundsException("No child at index: " + index);
    }
    public int childrenSize() {
        if (childNodeSize() == 0)
            return 0;
        return childElementsList().size();
    }
    public Elements children() {
        return new Elements(childElementsList());
    }
    List<Element> childElementsList() {
        if (childNodeSize() == 0)
            return EmptyChildren;
        synchronized (childNodes) {
            List<Element> children = cachedChildren();
            if (children == null) {
                children = filterNodes(Element.class);
                stashChildren(children);
            }
            return children;
        }
    }
    private static final String childElsKey = "jsoup.childEls";
    private static final String childElsMod = "jsoup.childElsMod";
    List<Element> cachedChildren() {
        if (attributes == null || !attributes.hasUserData())
            return null;
        Map<String, Object> userData = attributes.userData();
        WeakReference<List<Element>> ref = (WeakReference<List<Element>>) userData.get(childElsKey);
        if (ref != null) {
            List<Element> els = ref.get();
            if (els != null) {
                Integer modCount = (Integer) userData.get(childElsMod);
                if (modCount != null && modCount == childNodes.modCount())
                    return els;
            }
        }
        return null;
    }
    private void stashChildren(List<Element> els) {
        Map<String, Object> userData = attributes().userData();
        WeakReference<List<Element>> ref = new WeakReference<>(els);
        userData.put(childElsKey, ref);
        userData.put(childElsMod, childNodes.modCount());
    }
    public Stream<Element> stream() {
        return NodeUtils.stream(this, Element.class);
    }
    private <T> List<T> filterNodes(Class<T> clazz) {
        return childNodes.stream().filter(clazz::isInstance).map(clazz::cast).collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList));
    }
    public List<TextNode> textNodes() {
        return filterNodes(TextNode.class);
    }
    public List<DataNode> dataNodes() {
        return filterNodes(DataNode.class);
    }
    public Elements select(String cssQuery) {
        return Selector.select(cssQuery, this);
    }
    public Elements select(Evaluator evaluator) {
        return Selector.select(evaluator, this);
    }
    public Stream<Element> selectStream(String cssQuery) {
        return Selector.selectStream(cssQuery, this);
    }
    public Stream<Element> selectStream(Evaluator evaluator) {
        return Selector.selectStream(evaluator, this);
    }
    public Element selectFirst(String cssQuery) {
        return Selector.selectFirst(cssQuery, this);
    }
    public Element selectFirst(Evaluator evaluator) {
        return Collector.findFirst(evaluator, this);
    }
    public Element expectFirst(String cssQuery) {
        return Validate.expectNotNull(Selector.selectFirst(cssQuery, this), parent() != null ? "No elements matched the query '%s' on element '%s'." : "No elements matched the query '%s' in the document.", cssQuery, this.tagName());
    }
    public Nodes<Node> selectNodes(Evaluator evaluator) {
        return selectNodes(evaluator, Node.class);
    }
    public Nodes<Node> selectNodes(String cssQuery) {
        return selectNodes(cssQuery, Node.class);
    }
    public <T extends Node> Nodes<T> selectNodes(Evaluator evaluator, Class<T> type) {
        Validate.notNull(evaluator);
        return Collector.collectNodes(evaluator, this, type);
    }
    public <T extends Node> Nodes<T> selectNodes(String cssQuery, Class<T> type) {
        Validate.notEmpty(cssQuery);
        return selectNodes(evaluatorOf(cssQuery), type);
    }
    public <T extends Node> T selectFirstNode(String cssQuery, Class<T> type) {
        return selectFirstNode(evaluatorOf(cssQuery), type);
    }
    public <T extends Node> T selectFirstNode(Evaluator evaluator, Class<T> type) {
        return Collector.findFirstNode(evaluator, this, type);
    }
    public <T extends Node> T expectFirstNode(String cssQuery, Class<T> type) {
        return Validate.expectNotNull(selectFirstNode(cssQuery, type), parent() != null ? "No nodes matched the query '%s' on element '%s'." : "No nodes matched the query '%s' in the document.", cssQuery, this.tagName());
    }
    public boolean is(String cssQuery) {
        return is(evaluatorOf(cssQuery));
    }
    public boolean is(Evaluator evaluator) {
        return evaluator.matches(this.root(), this);
    }
    public Element closest(String cssQuery) {
        return closest(evaluatorOf(cssQuery));
    }
    public Element closest(Evaluator evaluator) {
        Validate.notNull(evaluator);
        Element el = this;
        final Element root = root();
        do {
            if (evaluator.matches(root, el))
                return el;
            el = el.parent();
        } while (el != null);
        return null;
    }
    public Elements selectXpath(String xpath) {
        return new Elements(NodeUtils.selectXpath(xpath, this, Element.class));
    }
    public <T extends Node> List<T> selectXpath(String xpath, Class<T> nodeType) {
        return NodeUtils.selectXpath(xpath, this, nodeType);
    }
    public Element appendChild(Node child) {
        Validate.notNull(child);
        reparentChild(child);
        ensureChildNodes();
        childNodes.add(child);
        child.setSiblingIndex(childNodes.size() - 1);
        return this;
    }
    public Element appendChildren(Collection<? extends Node> children) {
        insertChildren(-1, children);
        return this;
    }
    public Element appendTo(Element parent) {
        Validate.notNull(parent);
        parent.appendChild(this);
        return this;
    }
    public Element prependChild(Node child) {
        Validate.notNull(child);
        addChildren(0, child);
        return this;
    }
    public Element prependChildren(Collection<? extends Node> children) {
        insertChildren(0, children);
        return this;
    }
    public Element insertChildren(int index, Collection<? extends Node> children) {
        Validate.notNull(children, "Children collection to be inserted must not be null.");
        int currentSize = childNodeSize();
        if (index < 0)
            index += currentSize + 1;
        Validate.isTrue(index >= 0 && index <= currentSize, "Insert position out of bounds.");
        addChildren(index, children.toArray(new Node[0]));
        return this;
    }
    public Element insertChildren(int index, Node... children) {
        Validate.notNull(children, "Children collection to be inserted must not be null.");
        int currentSize = childNodeSize();
        if (index < 0)
            index += currentSize + 1;
        Validate.isTrue(index >= 0 && index <= currentSize, "Insert position out of bounds.");
        addChildren(index, children);
        return this;
    }
    public Element appendElement(String tagName) {
        return appendElement(tagName, tag.namespace());
    }
    public Element appendElement(String tagName, String namespace) {
        Parser parser = NodeUtils.parser(this);
        Element child = new Element(parser.tagSet().valueOf(tagName, namespace, parser.settings()), baseUri());
        appendChild(child);
        return child;
    }
    public Element prependElement(String tagName) {
        return prependElement(tagName, tag.namespace());
    }
    public Element prependElement(String tagName, String namespace) {
        Parser parser = NodeUtils.parser(this);
        Element child = new Element(parser.tagSet().valueOf(tagName, namespace, parser.settings()), baseUri());
        prependChild(child);
        return child;
    }
    public Element appendText(String text) {
        Validate.notNull(text);
        TextNode node = new TextNode(text);
        appendChild(node);
        return this;
    }
    public Element prependText(String text) {
        Validate.notNull(text);
        TextNode node = new TextNode(text);
        prependChild(node);
        return this;
    }
    public Element append(String html) {
        Validate.notNull(html);
        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());
        addChildren(nodes.toArray(new Node[0]));
        return this;
    }
    public Element prepend(String html) {
        Validate.notNull(html);
        List<Node> nodes = NodeUtils.parser(this).parseFragmentInput(html, this, baseUri());
        addChildren(0, nodes.toArray(new Node[0]));
        return this;
    }
    public Element before(String html) {
        return (Element) super.before(html);
    }
    public Element before(Node node) {
        return (Element) super.before(node);
    }
    public Element after(String html) {
        return (Element) super.after(html);
    }
    public Element after(Node node) {
        return (Element) super.after(node);
    }
    public Element empty() {
        int size = childNodes.size();
        for (int i = 0; i < size; i++) childNodes.get(i).parentNode = null;
        childNodes.clear();
        return this;
    }
    public Element wrap(String html) {
        return (Element) super.wrap(html);
    }
    private String uniqueIdSelector(@Nullable Document ownerDoc) {
        String id = id();
        if (!id.isEmpty()) {
            String idSel = "#" + escapeCssIdentifier(id);
            if (ownerDoc != null) {
                Elements els = ownerDoc.select(idSel);
                if (els.size() == 1 && els.get(0) == this)
                    return idSel;
            } else {
                return idSel;
            }
        }
        return EmptyString;
    }
    public String cssSelector() {
        Document ownerDoc = ownerDocument();
        String idSel = uniqueIdSelector(ownerDoc);
        if (!idSel.isEmpty())
            return idSel;
        StringBuilder selector = StringUtil.borrowBuilder();
        Element el = this;
        while (el != null && !(el instanceof Document)) {
            idSel = el.uniqueIdSelector(ownerDoc);
            if (!idSel.isEmpty()) {
                selector.insert(0, idSel);
                break;
            }
            selector.insert(0, el.cssSelectorComponent());
            el = el.parent();
        }
        return StringUtil.releaseBuilder(selector);
    }
    private String cssSelectorComponent() {
        String tagName = escapeCssIdentifier(tagName()).replace("\\:", "|");
        StringBuilder selector = StringUtil.borrowBuilder().append(tagName);
        String classes = classNames().stream().map(TokenQueue::escapeCssIdentifier).collect(StringUtil.joining("."));
        if (!classes.isEmpty())
            selector.append('.').append(classes);
        if (parent() == null || parent() instanceof Document)
            return StringUtil.releaseBuilder(selector);
        selector.insert(0, " > ");
        if (parent().select(selector.toString()).size() > 1)
            selector.append(String.format(":nth-child(%d)", elementSiblingIndex() + 1));
        return StringUtil.releaseBuilder(selector);
    }
    public Elements siblingElements() {
        if (parentNode == null)
            return new Elements(0);
        List<Element> elements = parent().childElementsList();
        Elements siblings = new Elements(elements.size() - 1);
        for (Element el : elements) if (el != this)
            siblings.add(el);
        return siblings;
    }
    public Elements nextElementSiblings() {
        return nextElementSiblings(true);
    }
    public Elements previousElementSiblings() {
        return nextElementSiblings(false);
    }
    private Elements nextElementSiblings(boolean next) {
        Elements els = new Elements();
        if (parentNode == null)
            return els;
        els.add(this);
        return next ? els.nextAll() : els.prevAll();
    }
    public Element firstElementSibling() {
        if (parent() != null) {
            return parent().firstElementChild();
        } else
            return this;
    }
    public int elementSiblingIndex() {
        if (parent() == null)
            return 0;
        return indexInList(this, parent().childElementsList());
    }
    public Element lastElementSibling() {
        if (parent() != null) {
            return parent().lastElementChild();
        } else
            return this;
    }
    private static <E extends Element> int indexInList(Element search, List<E> elements) {
        final int size = elements.size();
        for (int i = 0; i < size; i++) {
            if (elements.get(i) == search)
                return i;
        }
        return 0;
    }
    public Element firstElementChild() {
        int size = childNodes.size();
        for (int i = 0; i < size; i++) {
            Node node = childNodes.get(i);
            if (node instanceof Element)
                return (Element) node;
        }
        return null;
    }
    public Element lastElementChild() {
        for (int i = childNodes.size() - 1; i >= 0; i--) {
            Node node = childNodes.get(i);
            if (node instanceof Element)
                return (Element) node;
        }
        return null;
    }
    public Elements getElementsByTag(String tagName) {
        Validate.notEmpty(tagName);
        tagName = normalize(tagName);
        return Collector.collect(new Evaluator.Tag(tagName), this);
    }
    public Element getElementById(String id) {
        Validate.notEmpty(id);
        return Collector.findFirst(new Evaluator.Id(id), this);
    }
    public Elements getElementsByClass(String className) {
        Validate.notEmpty(className);
        return Collector.collect(new Evaluator.Class(className), this);
    }
    public Elements getElementsByAttribute(String key) {
        Validate.notEmpty(key);
        key = key.trim();
        return Collector.collect(new Evaluator.Attribute(key), this);
    }
    public Elements getElementsByAttributeStarting(String keyPrefix) {
        Validate.notEmpty(keyPrefix);
        keyPrefix = keyPrefix.trim();
        return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);
    }
    public Elements getElementsByAttributeValue(String key, String value) {
        return Collector.collect(new Evaluator.AttributeWithValue(key, value), this);
    }
    public Elements getElementsByAttributeValueNot(String key, String value) {
        return Collector.collect(new Evaluator.AttributeWithValueNot(key, value), this);
    }
    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {
        return Collector.collect(new Evaluator.AttributeWithValueStarting(key, valuePrefix), this);
    }
    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {
        return Collector.collect(new Evaluator.AttributeWithValueEnding(key, valueSuffix), this);
    }
    public Elements getElementsByAttributeValueContaining(String key, String match) {
        return Collector.collect(new Evaluator.AttributeWithValueContaining(key, match), this);
    }
    public Elements getElementsByAttributeValueMatching(String key, Pattern pattern) {
        return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this);
    }
    public Elements getElementsByAttributeValueMatching(String key, String regex) {
        Regex pattern;
        try {
            pattern = Regex.compile(regex);
        } catch (PatternSyntaxException e) {
            throw new IllegalArgumentException("Pattern syntax error: " + regex, e);
        }
        return Collector.collect(new Evaluator.AttributeWithValueMatching(key, pattern), this);
    }
    public Elements getElementsByIndexLessThan(int index) {
        return Collector.collect(new Evaluator.IndexLessThan(index), this);
    }
    public Elements getElementsByIndexGreaterThan(int index) {
        return Collector.collect(new Evaluator.IndexGreaterThan(index), this);
    }
    public Elements getElementsByIndexEquals(int index) {
        return Collector.collect(new Evaluator.IndexEquals(index), this);
    }
    public Elements getElementsContainingText(String searchText) {
        return Collector.collect(new Evaluator.ContainsText(searchText), this);
    }
    public Elements getElementsContainingOwnText(String searchText) {
        return Collector.collect(new Evaluator.ContainsOwnText(searchText), this);
    }
    public Elements getElementsMatchingText(Pattern pattern) {
        return Collector.collect(new Evaluator.Matches(pattern), this);
    }
    public Elements getElementsMatchingText(String regex) {
        Regex pattern;
        try {
            pattern = Regex.compile(regex);
        } catch (PatternSyntaxException e) {
            throw new IllegalArgumentException("Pattern syntax error: " + regex, e);
        }
        return Collector.collect(new Evaluator.Matches(pattern), this);
    }
    public Elements getElementsMatchingOwnText(Pattern pattern) {
        return Collector.collect(new Evaluator.MatchesOwn(pattern), this);
    }
    public Elements getElementsMatchingOwnText(String regex) {
        Regex pattern;
        try {
            pattern = Regex.compile(regex);
        } catch (PatternSyntaxException e) {
            throw new IllegalArgumentException("Pattern syntax error: " + regex, e);
        }
        return Collector.collect(new Evaluator.MatchesOwn(pattern), this);
    }
    public Elements getAllElements() {
        return Collector.collect(new Evaluator.AllElements(), this);
    }
    public String text() {
        final StringBuilder accum = StringUtil.borrowBuilder();
        new TextAccumulator(accum).traverse(this);
        return StringUtil.releaseBuilder(accum).trim();
    }
    private static class TextAccumulator implements NodeVisitor {
        private final StringBuilder accum;
        public TextAccumulator(StringBuilder accum) {
            this.accum = accum;
        }
        public void head(Node node, int depth) {
            if (node instanceof TextNode) {
                TextNode textNode = (TextNode) node;
                appendNormalisedText(accum, textNode);
            } else if (node instanceof Element) {
                Element element = (Element) node;
                if (accum.length() > 0 && (element.isBlock() || element.nameIs("br")) && !lastCharIsWhitespace(accum))
                    accum.append(' ');
            }
        }
        public void tail(Node node, int depth) {
            if (node instanceof Element) {
                Element element = (Element) node;
                Node next = node.nextSibling();
                if (!element.tag.isInline() && (next instanceof TextNode || next instanceof Element && ((Element) next).tag.isInline()) && !lastCharIsWhitespace(accum))
                    accum.append(' ');
            }
        }
    }
    public String wholeText() {
        return wholeTextOf(nodeStream());
    }
    public String nodeValue() {
        return wholeOwnText();
    }
    private static String wholeTextOf(Stream<Node> stream) {
        return stream.map(node -> {
            if (node instanceof TextNode)
                return ((TextNode) node).getWholeText();
            if (node.nameIs("br"))
                return "\n";
            return "";
        }).collect(StringUtil.joining(""));
    }
    public String wholeOwnText() {
        return wholeTextOf(childNodes.stream());
    }
    public String ownText() {
        StringBuilder sb = StringUtil.borrowBuilder();
        ownText(sb);
        return StringUtil.releaseBuilder(sb).trim();
    }
    private void ownText(StringBuilder accum) {
        for (int i = 0; i < childNodeSize(); i++) {
            Node child = childNodes.get(i);
            if (child instanceof TextNode) {
                TextNode textNode = (TextNode) child;
                appendNormalisedText(accum, textNode);
            } else if (child.nameIs("br") && !lastCharIsWhitespace(accum)) {
                accum.append(" ");
            }
        }
    }
    private static void appendNormalisedText(StringBuilder accum, TextNode textNode) {
        String text = textNode.getWholeText();
        if (preserveWhitespace(textNode.parentNode) || textNode instanceof CDataNode)
            accum.append(text);
        else
            StringUtil.appendNormalisedWhitespace(accum, text, lastCharIsWhitespace(accum));
    }
    static boolean preserveWhitespace(@Nullable Node node) {
        if (node instanceof Element) {
            Element el = (Element) node;
            int i = 0;
            do {
                if (el.tag.preserveWhitespace())
                    return true;
                el = el.parent();
                i++;
            } while (i < 6 && el != null);
        }
        return false;
    }
    public Element text(String text) {
        Validate.notNull(text);
        empty();
        if (tag().is(Tag.Data))
            appendChild(new DataNode(text));
        else
            appendChild(new TextNode(text));
        return this;
    }
    public boolean hasText() {
        AtomicBoolean hasText = new AtomicBoolean(false);
        filter((node, depth) -> {
            if (node instanceof TextNode) {
                TextNode textNode = (TextNode) node;
                if (!textNode.isBlank()) {
                    hasText.set(true);
                    return NodeFilter.FilterResult.STOP;
                }
            }
            return NodeFilter.FilterResult.CONTINUE;
        });
        return hasText.get();
    }
    public String data() {
        StringBuilder sb = StringUtil.borrowBuilder();
        traverse((childNode, depth) -> {
            if (childNode instanceof DataNode) {
                DataNode data = (DataNode) childNode;
                sb.append(data.getWholeData());
            } else if (childNode instanceof Comment) {
                Comment comment = (Comment) childNode;
                sb.append(comment.getData());
            } else if (childNode instanceof CDataNode) {
                CDataNode cDataNode = (CDataNode) childNode;
                sb.append(cDataNode.getWholeText());
            }
        });
        return StringUtil.releaseBuilder(sb);
    }
    public String className() {
        return attr("class").trim();
    }
    public Set<String> classNames() {
        String[] names = ClassSplit.split(className());
        Set<String> classNames = new LinkedHashSet<>(Arrays.asList(names));
        classNames.remove("");
        return classNames;
    }
    public Element classNames(Set<String> classNames) {
        Validate.notNull(classNames);
        if (classNames.isEmpty()) {
            attributes().remove("class");
        } else {
            attributes().put("class", StringUtil.join(classNames, " "));
        }
        return this;
    }
    public boolean hasClass(String className) {
        if (attributes == null)
            return false;
        final String classAttr = attributes.getIgnoreCase("class");
        final int len = classAttr.length();
        final int wantLen = className.length();
        if (len == 0 || len < wantLen) {
            return false;
        }
        if (len == wantLen) {
            return className.equalsIgnoreCase(classAttr);
        }
        boolean inClass = false;
        int start = 0;
        for (int i = 0; i < len; i++) {
            if (Character.isWhitespace(classAttr.charAt(i))) {
                if (inClass) {
                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {
                        return true;
                    }
                    inClass = false;
                }
            } else {
                if (!inClass) {
                    inClass = true;
                    start = i;
                }
            }
        }
        if (inClass && len - start == wantLen) {
            return classAttr.regionMatches(true, start, className, 0, wantLen);
        }
        return false;
    }
    public Element addClass(String className) {
        Validate.notNull(className);
        Set<String> classes = classNames();
        classes.add(className);
        classNames(classes);
        return this;
    }
    public Element removeClass(String className) {
        Validate.notNull(className);
        Set<String> classes = classNames();
        classes.remove(className);
        classNames(classes);
        return this;
    }
    public Element toggleClass(String className) {
        Validate.notNull(className);
        Set<String> classes = classNames();
        if (classes.contains(className))
            classes.remove(className);
        else
            classes.add(className);
        classNames(classes);
        return this;
    }
    public String val() {
        if (elementIs("textarea", NamespaceHtml))
            return text();
        else
            return attr("value");
    }
    public Element val(String value) {
        if (elementIs("textarea", NamespaceHtml))
            text(value);
        else
            attr("value", value);
        return this;
    }
    public Range endSourceRange() {
        return Range.of(this, false);
    }
    void outerHtmlHead(final QuietAppendable accum, Document.OutputSettings out) {
        String tagName = safeTagName(out.syntax());
        accum.append('<').append(tagName);
        if (attributes != null)
            attributes.html(accum, out);
        if (childNodes.isEmpty()) {
            boolean xmlMode = out.syntax() == xml || !tag.namespace().equals(NamespaceHtml);
            if (xmlMode && (tag.is(Tag.SeenSelfClose) || (tag.isKnownTag() && (tag.isEmpty() || tag.isSelfClosing())))) {
                accum.append(" />");
            } else if (!xmlMode && tag.isEmpty()) {
                accum.append('>');
            } else {
                accum.append("></").append(tagName).append('>');
            }
        } else {
            accum.append('>');
        }
    }
    void outerHtmlTail(QuietAppendable accum, Document.OutputSettings out) {
        if (!childNodes.isEmpty())
            accum.append("</").append(safeTagName(out.syntax())).append('>');
    }
    private String safeTagName(Document.OutputSettings.Syntax syntax) {
        return syntax == xml ? Normalizer.xmlSafeTagName(tagName()) : tagName();
    }
    public String html() {
        StringBuilder sb = StringUtil.borrowBuilder();
        html(sb);
        String html = StringUtil.releaseBuilder(sb);
        return NodeUtils.outputSettings(this).prettyPrint() ? html.trim() : html;
    }
    public <T extends Appendable> T html(T accum) {
        Node child = firstChild();
        if (child != null) {
            Printer printer = Printer.printerFor(child, QuietAppendable.wrap(accum));
            while (child != null) {
                printer.traverse(child);
                child = child.nextSibling();
            }
        }
        return accum;
    }
    public Element html(String html) {
        empty();
        append(html);
        return this;
    }
    public Element clone() {
        return (Element) super.clone();
    }
    public Element shallowClone() {
        String baseUri = baseUri();
        if (baseUri.isEmpty())
            baseUri = null;
        return new Element(tag, baseUri, attributes == null ? null : attributes.clone());
    }
    protected Element doClone(@Nullable Node parent) {
        Element clone = (Element) super.doClone(parent);
        clone.childNodes = new NodeList(childNodes.size());
        clone.childNodes.addAll(childNodes);
        if (attributes != null) {
            clone.attributes = attributes.clone();
            clone.attributes.userData(childElsKey, null);
        }
        return clone;
    }
    public Element clearAttributes() {
        if (attributes != null) {
            super.clearAttributes();
            if (attributes.size == 0)
                attributes = null;
        }
        return this;
    }
    public Element removeAttr(String attributeKey) {
        return (Element) super.removeAttr(attributeKey);
    }
    public Element root() {
        return (Element) super.root();
    }
    public Element traverse(NodeVisitor nodeVisitor) {
        return (Element) super.traverse(nodeVisitor);
    }
    public Element forEachNode(Consumer<? super Node> action) {
        return (Element) super.forEachNode(action);
    }
    public void forEach(Consumer<? super Element> action) {
        stream().forEach(action);
    }
    public Iterator<Element> iterator() {
        return new NodeIterator<>(this, Element.class);
    }
    public Element filter(NodeFilter nodeFilter) {
        return (Element) super.filter(nodeFilter);
    }
    static final class NodeList extends ArrayList<Node> {
        boolean validChildren = true;
        public NodeList(int size) {
            super(size);
        }
        int modCount() {
            return this.modCount;
        }
        void incrementMod() {
            this.modCount++;
        }
    }
    void reindexChildren() {
        final int size = childNodes.size();
        for (int i = 0; i < size; i++) {
            childNodes.get(i).setSiblingIndex(i);
        }
        childNodes.validChildren = true;
    }
    void invalidateChildren() {
        childNodes.validChildren = false;
    }
    boolean hasValidChildren() {
        return childNodes.validChildren;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```