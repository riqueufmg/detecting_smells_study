##CONTEXT_SIZE=1853
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.parser;
public class TagSet {
    static final TagSet HtmlTagSet = initHtmlDefault();
    private final Map<String, Map<String, Tag>> tags = new HashMap<>();
    private final TagSet source;
    private ArrayList<Consumer<Tag>> customizers;
    public static TagSet Html() {
        return new TagSet(HtmlTagSet);
    }
    public TagSet() {
        source = null;
    }
    public TagSet(TagSet original) {
        this.source = original;
        if (original.customizers != null)
            this.customizers = new ArrayList<>(original.customizers);
    }
    public TagSet add(Tag tag) {
        tag.set(Tag.Known);
        doAdd(tag);
        return this;
    }
    private void doAdd(Tag tag) {
        if (customizers != null) {
            for (Consumer<Tag> customizer : customizers) {
                customizer.accept(tag);
            }
        }
        tags.computeIfAbsent(tag.namespace, ns -> new HashMap<>()).put(tag.tagName, tag);
    }
    public Tag get(String tagName, String namespace) {
        Validate.notNull(tagName);
        Validate.notNull(namespace);
        Map<String, Tag> nsTags = tags.get(namespace);
        if (nsTags != null) {
            Tag tag = nsTags.get(tagName);
            if (tag != null) {
                return tag;
            }
        }
        if (source != null) {
            Tag tag = source.get(tagName, namespace);
            if (tag != null) {
                Tag copy = tag.clone();
                doAdd(copy);
                return copy;
            }
        }
        return null;
    }
    Tag valueOf(String tagName, @Nullable String normalName, String namespace, boolean preserveTagCase) {
        Validate.notNull(tagName);
        Validate.notNull(namespace);
        tagName = tagName.trim();
        Validate.notEmpty(tagName);
        Tag tag = get(tagName, namespace);
        if (tag != null)
            return tag;
        if (normalName == null)
            normalName = ParseSettings.normalName(tagName);
        tagName = preserveTagCase ? tagName : normalName;
        tag = get(normalName, namespace);
        if (tag != null) {
            if (preserveTagCase && !tagName.equals(normalName)) {
                tag = tag.clone();
                tag.tagName = tagName;
                doAdd(tag);
            }
            return tag;
        }
        tag = new Tag(tagName, normalName, namespace);
        doAdd(tag);
        return tag;
    }
    public Tag valueOf(String tagName, String namespace, ParseSettings settings) {
        return valueOf(tagName, null, namespace, settings.preserveTagCase());
    }
    public Tag valueOf(String tagName, String namespace) {
        return valueOf(tagName, namespace, ParseSettings.preserveCase);
    }
    public TagSet onNewTag(Consumer<Tag> customizer) {
        Validate.notNull(customizer);
        if (customizers == null)
            customizers = new ArrayList<>();
        customizers.add(customizer);
        return this;
    }
    public boolean equals(Object o) {
        if (!(o instanceof TagSet))
            return false;
        TagSet tagSet = (TagSet) o;
        return Objects.equals(tags, tagSet.tags);
    }
    public int hashCode() {
        return Objects.hashCode(tags);
    }
    static TagSet initHtmlDefault() {
        String[] blockTags = { "html", "head", "body", "frameset", "script", "noscript", "style", "meta", "link", "title", "frame", "noframes", "section", "nav", "aside", "hgroup", "header", "footer", "p", "h1", "h2", "h3", "h4", "h5", "h6", "button", "ul", "ol", "pre", "div", "blockquote", "hr", "address", "figure", "figcaption", "form", "fieldset", "ins", "del", "dl", "dt", "dd", "li", "table", "caption", "thead", "tfoot", "tbody", "colgroup", "col", "tr", "th", "td", "video", "audio", "canvas", "details", "menu", "plaintext", "template", "article", "main", "center", "template", // deprecated but still known / special handling
        "dir", // deprecated but still known / special handling
        "applet", // deprecated but still known / special handling
        "marquee", "listing", "#root" };
        String[] inlineTags = { "object", "base", "font", "tt", "i", "b", "u", "big", "small", "em", "strong", "dfn", "code", "samp", "kbd", "var", "cite", "abbr", "time", "acronym", "mark", "ruby", "rt", "rp", "rtc", "a", "img", "wbr", "map", "q", "sub", "sup", "bdo", "iframe", "embed", "span", "input", "select", "textarea", "label", "optgroup", "option", "legend", "datalist", "keygen", "output", "progress", "meter", "area", "param", "source", "track", "summary", "command", "device", "area", "basefont", "bgsound", "menuitem", "param", "source", "track", "data", "bdi", "s", "strike", "nobr", "rb" };
        String[] inlineContainers = { "title", "a", "p", "h1", "h2", "h3", "h4", "h5", "h6", "pre", "address", "li", "th", "td", "script", "style", "ins", "del", "s", "button" };
        String[] voidTags = { "meta", "link", "base", "frame", "img", "br", "wbr", "embed", "hr", "input", "keygen", "col", "command", "device", "area", "basefont", "bgsound", "menuitem", "param", "source", "track" };
        String[] preserveWhitespaceTags = { "pre", "plaintext", "title", "textarea", "script" };
        String[] rcdataTags = { "title", "textarea" };
        String[] dataTags = { "iframe", "noembed", "noframes", "script", "style", "xmp" };
        String[] formSubmitTags = SharedConstants.FormSubmitTags;
        String[] blockMathTags = { "math" };
        String[] inlineMathTags = { "mi", "mo", "msup", "mn", "mtext" };
        String[] blockSvgTags = { "svg", "femerge", "femergenode" };
        String[] inlineSvgTags = { "text" };
        String[] dataSvgTags = { "script" };
        return new TagSet().setupTags(NamespaceHtml, blockTags, tag -> tag.set(Tag.Block)).setupTags(NamespaceHtml, inlineTags, tag -> tag.set(0)).setupTags(NamespaceHtml, inlineContainers, tag -> tag.set(Tag.InlineContainer)).setupTags(NamespaceHtml, voidTags, tag -> tag.set(Tag.Void)).setupTags(NamespaceHtml, preserveWhitespaceTags, tag -> tag.set(Tag.PreserveWhitespace)).setupTags(NamespaceHtml, rcdataTags, tag -> tag.set(Tag.RcData)).setupTags(NamespaceHtml, dataTags, tag -> tag.set(Tag.Data)).setupTags(NamespaceHtml, formSubmitTags, tag -> tag.set(Tag.FormSubmittable)).setupTags(NamespaceMathml, blockMathTags, tag -> tag.set(Tag.Block)).setupTags(NamespaceMathml, inlineMathTags, tag -> tag.set(0)).setupTags(NamespaceSvg, blockSvgTags, tag -> tag.set(Tag.Block)).setupTags(NamespaceSvg, inlineSvgTags, tag -> tag.set(0)).setupTags(NamespaceSvg, dataSvgTags, tag -> tag.set(Tag.Data));
    }
    private TagSet setupTags(String namespace, String[] tagNames, Consumer<Tag> tagModifier) {
        for (String tagName : tagNames) {
            Tag tag = get(tagName, namespace);
            if (tag == null) {
                tag = new Tag(tagName, tagName, namespace);
                tag.options = 0;
                add(tag);
            }
            tagModifier.accept(tag);
        }
        return this;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```