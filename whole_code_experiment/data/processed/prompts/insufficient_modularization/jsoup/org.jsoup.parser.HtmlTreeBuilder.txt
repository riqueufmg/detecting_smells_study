##CONTEXT_SIZE=6614
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.parser;
public class HtmlTreeBuilder extends TreeBuilder {
    static final String[] TagsSearchInScope = new String[] { "applet", "caption", "html", "marquee", "object", "table", "td", "template", "th" };
    static final String[] TagSearchInScopeMath = new String[] { "annotation-xml", "mi", "mn", "mo", "ms", "mtext" };
    static final String[] TagSearchInScopeSvg = new String[] { "desc", "foreignObject", "title" };
    static final String[] TagSearchList = new String[] { "ol", "ul" };
    static final String[] TagSearchButton = new String[] { "button" };
    static final String[] TagSearchTableScope = new String[] { "html", "table" };
    static final String[] TagSearchSelectScope = new String[] { "optgroup", "option" };
    static final String[] TagSearchEndTags = new String[] { "dd", "dt", "li", "optgroup", "option", "p", "rb", "rp", "rt", "rtc" };
    static final String[] TagThoroughSearchEndTags = new String[] { "caption", "colgroup", "dd", "dt", "li", "optgroup", "option", "p", "rb", "rp", "rt", "rtc", "tbody", "td", "tfoot", "th", "thead", "tr" };
    static final String[] TagSearchSpecial = new String[] { "address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "keygen", "li", "link", "listing", "main", "marquee", "menu", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "search", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp" };
    static String[] TagSearchSpecialMath = { "annotation-xml", "mi", "mn", "mo", "ms", "mtext" };
    static final String[] TagMathMlTextIntegration = new String[] { "mi", "mn", "mo", "ms", "mtext" };
    static final String[] TagSvgHtmlIntegration = new String[] { "desc", "foreignObject", "title" };
    static final String[] TagFormListed = { "button", "fieldset", "input", "keygen", "object", "output", "select", "textarea" };
    public static final int MaxScopeSearchDepth = 100;
    private HtmlTreeBuilderState state;
    private HtmlTreeBuilderState originalState;
    private boolean baseUriSetFromDoc;
    private Element headElement;
    private FormElement formElement;
    private Element contextElement;
    ArrayList<Element> formattingElements;
    private ArrayList<HtmlTreeBuilderState> tmplInsertMode;
    private List<Token.Character> pendingTableCharacters;
    private Token.EndTag emptyEnd;
    private boolean framesetOk;
    private boolean fosterInserts;
    private boolean fragmentParsing;
    ParseSettings defaultSettings() {
        return ParseSettings.htmlDefault;
    }
    HtmlTreeBuilder newInstance() {
        return new HtmlTreeBuilder();
    }
    protected void initialiseParse(Reader input, String baseUri, Parser parser) {
        super.initialiseParse(input, baseUri, parser);
        state = HtmlTreeBuilderState.Initial;
        originalState = null;
        baseUriSetFromDoc = false;
        headElement = null;
        formElement = null;
        contextElement = null;
        formattingElements = new ArrayList<>();
        tmplInsertMode = new ArrayList<>();
        pendingTableCharacters = new ArrayList<>();
        emptyEnd = new Token.EndTag(this);
        framesetOk = true;
        fosterInserts = false;
        fragmentParsing = false;
    }
    void initialiseParseFragment(@Nullable Element context) {
        state = HtmlTreeBuilderState.Initial;
        fragmentParsing = true;
        if (context != null) {
            final String contextName = context.normalName();
            contextElement = new Element(tagFor(contextName, contextName, defaultNamespace(), settings), baseUri);
            if (context.ownerDocument() != null)
                doc.quirksMode(context.ownerDocument().quirksMode());
            switch(contextName) {
                case "script":
                    tokeniser.transition(TokeniserState.ScriptData);
                    break;
                case "plaintext":
                    tokeniser.transition(TokeniserState.PLAINTEXT);
                    break;
                case "template":
                    tokeniser.transition(TokeniserState.Data);
                    pushTemplateMode(HtmlTreeBuilderState.InTemplate);
                    break;
                default:
                    Tag tag = contextElement.tag();
                    TokeniserState textState = tag.textState();
                    if (textState != null)
                        tokeniser.transition(textState);
                    else
                        tokeniser.transition(TokeniserState.Data);
            }
            doc.appendChild(contextElement);
            push(contextElement);
            resetInsertionMode();
            Element formSearch = context;
            while (formSearch != null) {
                if (formSearch instanceof FormElement) {
                    formElement = (FormElement) formSearch;
                    break;
                }
                formSearch = formSearch.parent();
            }
        }
    }
    List<Node> completeParseFragment() {
        if (contextElement != null) {
            List<Node> nodes = contextElement.siblingNodes();
            if (!nodes.isEmpty())
                contextElement.insertChildren(-1, nodes);
            return contextElement.childNodes();
        } else
            return doc.childNodes();
    }
    protected boolean process(Token token) {
        HtmlTreeBuilderState dispatch = useCurrentOrForeignInsert(token) ? this.state : ForeignContent;
        return dispatch.process(token, this);
    }
    boolean useCurrentOrForeignInsert(Token token) {
        if (stack.isEmpty())
            return true;
        final Element el = currentElement();
        final String ns = el.tag().namespace();
        if (NamespaceHtml.equals(ns))
            return true;
        if (isMathmlTextIntegration(el)) {
            if (token.isStartTag() && !"mglyph".equals(token.asStartTag().normalName) && !"malignmark".equals(token.asStartTag().normalName))
                return true;
            if (token.isCharacter())
                return true;
        }
        if (Parser.NamespaceMathml.equals(ns) && el.nameIs("annotation-xml") && token.isStartTag() && "svg".equals(token.asStartTag().normalName))
            return true;
        if (isHtmlIntegration(el) && (token.isStartTag() || token.isCharacter()))
            return true;
        return token.isEOF();
    }
    static boolean isMathmlTextIntegration(Element el) {
        return (Parser.NamespaceMathml.equals(el.tag().namespace()) && StringUtil.inSorted(el.normalName(), TagMathMlTextIntegration));
    }
    static boolean isHtmlIntegration(Element el) {
        if (Parser.NamespaceMathml.equals(el.tag().namespace()) && el.nameIs("annotation-xml")) {
            String encoding = Normalizer.normalize(el.attr("encoding"));
            if (encoding.equals("text/html") || encoding.equals("application/xhtml+xml"))
                return true;
        }
        return Parser.NamespaceSvg.equals(el.tag().namespace()) && StringUtil.in(el.tagName(), TagSvgHtmlIntegration);
    }
    boolean process(Token token, HtmlTreeBuilderState state) {
        return state.process(token, this);
    }
    void transition(HtmlTreeBuilderState state) {
        this.state = state;
    }
    HtmlTreeBuilderState state() {
        return state;
    }
    void markInsertionMode() {
        originalState = state;
    }
    HtmlTreeBuilderState originalState() {
        return originalState;
    }
    void framesetOk(boolean framesetOk) {
        this.framesetOk = framesetOk;
    }
    boolean framesetOk() {
        return framesetOk;
    }
    Document getDocument() {
        return doc;
    }
    String getBaseUri() {
        return baseUri;
    }
    void maybeSetBaseUri(Element base) {
        if (baseUriSetFromDoc)
            return;
        String href = base.absUrl("href");
        if (href.length() != 0) {
            baseUri = href;
            baseUriSetFromDoc = true;
            doc.setBaseUri(href);
        }
    }
    boolean isFragmentParsing() {
        return fragmentParsing;
    }
    void error(HtmlTreeBuilderState state) {
        if (parser.getErrors().canAddError())
            parser.getErrors().add(new ParseError(reader, "Unexpected %s token [%s] when in state [%s]", currentToken.tokenType(), currentToken, state));
    }
    Element createElementFor(Token.StartTag startTag, String namespace, boolean forcePreserveCase) {
        Attributes attributes = startTag.attributes;
        if (attributes != null && !attributes.isEmpty()) {
            if (!forcePreserveCase)
                settings.normalizeAttributes(attributes);
            int dupes = attributes.deduplicate(settings);
            if (dupes > 0) {
                error("Dropped duplicate attribute(s) in tag [%s]", startTag.normalName);
            }
        }
        Tag tag = tagFor(startTag.name(), startTag.normalName, namespace, forcePreserveCase ? ParseSettings.preserveCase : settings);
        return (tag.normalName().equals("form")) ? new FormElement(tag, null, attributes) : new Element(tag, null, attributes);
    }
    Element insertElementFor(final Token.StartTag startTag) {
        Element el = createElementFor(startTag, NamespaceHtml, false);
        doInsertElement(el);
        if (startTag.isSelfClosing()) {
            Tag tag = el.tag();
            tag.setSeenSelfClose();
            if (tag.isEmpty()) {
            } else if (tag.isKnownTag() && tag.isSelfClosing()) {
                tokeniser.transition(TokeniserState.Data);
                tokeniser.emit(emptyEnd.reset().name(el.tagName()));
            } else {
                tokeniser.error("Tag [%s] cannot be self-closing; not a void tag", tag.normalName());
            }
        }
        if (el.tag().isEmpty()) {
            pop();
        }
        return el;
    }
    Element insertForeignElementFor(final Token.StartTag startTag, String namespace) {
        Element el = createElementFor(startTag, namespace, true);
        doInsertElement(el);
        if (startTag.isSelfClosing()) {
            el.tag().setSeenSelfClose();
            pop();
        }
        return el;
    }
    Element insertEmptyElementFor(Token.StartTag startTag) {
        Element el = createElementFor(startTag, NamespaceHtml, false);
        doInsertElement(el);
        pop();
        return el;
    }
    FormElement insertFormElement(Token.StartTag startTag, boolean onStack, boolean checkTemplateStack) {
        FormElement el = (FormElement) createElementFor(startTag, NamespaceHtml, false);
        if (checkTemplateStack) {
            if (!onStack("template"))
                setFormElement(el);
        } else
            setFormElement(el);
        doInsertElement(el);
        if (!onStack)
            pop();
        return el;
    }
    private void doInsertElement(Element el) {
        enforceStackDepthLimit();
        if (formElement != null && el.tag().namespace.equals(NamespaceHtml) && StringUtil.inSorted(el.normalName(), TagFormListed))
            formElement.addElement(el);
        if (parser.getErrors().canAddError() && el.hasAttr("xmlns") && !el.attr("xmlns").equals(el.tag().namespace()))
            error("Invalid xmlns attribute [%s] on tag [%s]", el.attr("xmlns"), el.tagName());
        if (isFosterInserts() && StringUtil.inSorted(currentElement().normalName(), InTableFoster))
            insertInFosterParent(el);
        else
            currentElement().appendChild(el);
        push(el);
    }
    void insertCommentNode(Token.Comment token) {
        Comment node = new Comment(token.getData());
        currentElement().appendChild(node);
        onNodeInserted(node);
    }
    void insertCharacterNode(Token.Character characterToken) {
        insertCharacterNode(characterToken, false);
    }
    void insertCharacterNode(Token.Character characterToken, boolean replace) {
        characterToken.normalizeNulls(replace);
        Element el = currentElement();
        insertCharacterToElement(characterToken, el);
    }
    void insertCharacterToElement(Token.Character characterToken, Element el) {
        final Node node;
        final String data = characterToken.getData();
        if (characterToken.isCData())
            node = new CDataNode(data);
        else if (el.tag().is(Tag.Data))
            node = new DataNode(data);
        else
            node = new TextNode(data);
        el.appendChild(node);
        onNodeInserted(node);
    }
    ArrayList<Element> getStack() {
        return stack;
    }
    boolean onStack(Element el) {
        return onStack(stack, el);
    }
    boolean onStack(String elName) {
        return getFromStack(elName) != null;
    }
    private static final int maxQueueDepth = 256;
    private static boolean onStack(ArrayList<Element> queue, Element element) {
        final int bottom = queue.size() - 1;
        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;
        for (int pos = bottom; pos >= upper; pos--) {
            Element next = queue.get(pos);
            if (next == element) {
                return true;
            }
        }
        return false;
    }
    Element getFromStack(String elName) {
        final int bottom = stack.size() - 1;
        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;
        for (int pos = bottom; pos >= upper; pos--) {
            Element next = stack.get(pos);
            if (next.elementIs(elName, NamespaceHtml)) {
                return next;
            }
        }
        return null;
    }
    boolean removeFromStack(Element el) {
        for (int pos = stack.size() - 1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            if (next == el) {
                stack.remove(pos);
                onNodeClosed(el);
                return true;
            }
        }
        return false;
    }
    void onStackPrunedForDepth(Element element) {
        if (element == headElement)
            headElement = null;
        if (element == formElement)
            setFormElement(null);
        removeFromActiveFormattingElements(element);
        if (element.nameIs("template")) {
            clearFormattingElementsToLastMarker();
            if (templateModeSize() > 0)
                popTemplateMode();
            resetInsertionMode();
        }
    }
    Element popStackToClose(String elName) {
        for (int pos = stack.size() - 1; pos >= 0; pos--) {
            Element el = pop();
            if (el.elementIs(elName, NamespaceHtml)) {
                return el;
            }
        }
        return null;
    }
    Element popStackToCloseAnyNamespace(String elName) {
        for (int pos = stack.size() - 1; pos >= 0; pos--) {
            Element el = pop();
            if (el.nameIs(elName)) {
                return el;
            }
        }
        return null;
    }
    void popStackToClose(String... elNames) {
        for (int pos = stack.size() - 1; pos >= 0; pos--) {
            Element el = pop();
            if (inSorted(el.normalName(), elNames) && NamespaceHtml.equals(el.tag().namespace())) {
                break;
            }
        }
    }
    void clearStackToTableContext() {
        clearStackToContext("table", "template");
    }
    void clearStackToTableBodyContext() {
        clearStackToContext("tbody", "tfoot", "thead", "template");
    }
    void clearStackToTableRowContext() {
        clearStackToContext("tr", "template");
    }
    private void clearStackToContext(String... nodeNames) {
        for (int pos = stack.size() - 1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            if (NamespaceHtml.equals(next.tag().namespace()) && (StringUtil.in(next.normalName(), nodeNames) || next.nameIs("html")))
                break;
            else
                pop();
        }
    }
    Element aboveOnStack(Element el) {
        if (!onStack(el))
            return null;
        for (int pos = stack.size() - 1; pos > 0; pos--) {
            Element next = stack.get(pos);
            if (next == el) {
                return stack.get(pos - 1);
            }
        }
        return null;
    }
    void insertOnStackAfter(Element after, Element in) {
        int i = stack.lastIndexOf(after);
        if (i == -1) {
            error("Did not find element on stack to insert after");
            stack.add(in);
        } else {
            stack.add(i + 1, in);
        }
    }
    void replaceOnStack(Element out, Element in) {
        replaceInQueue(stack, out, in);
    }
    private static void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {
        int i = queue.lastIndexOf(out);
        Validate.isTrue(i != -1);
        queue.set(i, in);
    }
    boolean resetInsertionMode() {
        boolean last = false;
        final int bottom = stack.size() - 1;
        final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;
        final HtmlTreeBuilderState origState = this.state;
        if (stack.size() == 0) {
            transition(HtmlTreeBuilderState.InBody);
        }
        LOOP: for (int pos = bottom; pos >= upper; pos--) {
            Element node = stack.get(pos);
            if (pos == upper) {
                last = true;
                if (fragmentParsing)
                    node = contextElement;
            }
            String name = node != null ? node.normalName() : "";
            if (!NamespaceHtml.equals(node.tag().namespace()))
                continue;
            switch(name) {
                case "select":
                    transition(HtmlTreeBuilderState.InSelect);
                    break LOOP;
                case "td":
                case "th":
                    if (!last) {
                        transition(HtmlTreeBuilderState.InCell);
                        break LOOP;
                    }
                    break;
                case "tr":
                    transition(HtmlTreeBuilderState.InRow);
                    break LOOP;
                case "tbody":
                case "thead":
                case "tfoot":
                    transition(HtmlTreeBuilderState.InTableBody);
                    break LOOP;
                case "caption":
                    transition(HtmlTreeBuilderState.InCaption);
                    break LOOP;
                case "colgroup":
                    transition(HtmlTreeBuilderState.InColumnGroup);
                    break LOOP;
                case "table":
                    transition(HtmlTreeBuilderState.InTable);
                    break LOOP;
                case "template":
                    HtmlTreeBuilderState tmplState = currentTemplateMode();
                    Validate.notNull(tmplState, "Bug: no template insertion mode on stack!");
                    transition(tmplState);
                    break LOOP;
                case "head":
                    if (!last) {
                        transition(HtmlTreeBuilderState.InHead);
                        break LOOP;
                    }
                    break;
                case "body":
                    transition(HtmlTreeBuilderState.InBody);
                    break LOOP;
                case "frameset":
                    transition(HtmlTreeBuilderState.InFrameset);
                    break LOOP;
                case "html":
                    transition(headElement == null ? HtmlTreeBuilderState.BeforeHead : HtmlTreeBuilderState.AfterHead);
                    break LOOP;
            }
            if (last) {
                transition(HtmlTreeBuilderState.InBody);
                break;
            }
        }
        return state != origState;
    }
    void resetBody() {
        if (!onStack("body")) {
            stack.add(doc.body());
        }
        transition(HtmlTreeBuilderState.InBody);
    }
    private final String[] specificScopeTarget = { null };
    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {
        specificScopeTarget[0] = targetName;
        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);
    }
    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, @Nullable String[] extraTypes) {
        final int bottom = stack.size() - 1;
        for (int pos = bottom; pos >= 0; pos--) {
            Element el = stack.get(pos);
            String elName = el.normalName();
            String ns = el.tag().namespace();
            if (ns.equals(NamespaceHtml)) {
                if (inSorted(elName, targetNames))
                    return true;
                if (inSorted(elName, baseTypes))
                    return false;
                if (extraTypes != null && inSorted(elName, extraTypes))
                    return false;
            } else if (baseTypes == TagsSearchInScope) {
                if (ns.equals(NamespaceMathml) && inSorted(elName, TagSearchInScopeMath))
                    return false;
                if (ns.equals(NamespaceSvg) && inSorted(elName, TagSearchInScopeSvg))
                    return false;
            }
        }
        return false;
    }
    boolean inScope(String[] targetNames) {
        return inSpecificScope(targetNames, TagsSearchInScope, null);
    }
    boolean inScope(String targetName) {
        return inScope(targetName, null);
    }
    boolean inScope(String targetName, String[] extras) {
        return inSpecificScope(targetName, TagsSearchInScope, extras);
    }
    boolean inListItemScope(String targetName) {
        return inScope(targetName, TagSearchList);
    }
    boolean inButtonScope(String targetName) {
        return inScope(targetName, TagSearchButton);
    }
    boolean inTableScope(String targetName) {
        return inSpecificScope(targetName, TagSearchTableScope, null);
    }
    boolean inSelectScope(String targetName) {
        for (int pos = stack.size() - 1; pos >= 0; pos--) {
            Element el = stack.get(pos);
            String elName = el.normalName();
            if (elName.equals(targetName))
                return true;
            if (!inSorted(elName, TagSearchSelectScope))
                return false;
        }
        return false;
    }
    boolean onStackNot(String[] allowedTags) {
        for (int pos = stack.size() - 1; pos >= 0; pos--) {
            final String elName = stack.get(pos).normalName();
            if (!inSorted(elName, allowedTags))
                return true;
        }
        return false;
    }
    void setHeadElement(Element headElement) {
        this.headElement = headElement;
    }
    Element getHeadElement() {
        return headElement;
    }
    boolean isFosterInserts() {
        return fosterInserts;
    }
    void setFosterInserts(boolean fosterInserts) {
        this.fosterInserts = fosterInserts;
    }
    FormElement getFormElement() {
        return formElement;
    }
    void setFormElement(FormElement formElement) {
        this.formElement = formElement;
    }
    void resetPendingTableCharacters() {
        pendingTableCharacters.clear();
    }
    List<Token.Character> getPendingTableCharacters() {
        return pendingTableCharacters;
    }
    void addPendingTableCharacters(Token.Character c) {
        Token.Character copy = new Token.Character(c);
        pendingTableCharacters.add(copy);
    }
    void generateImpliedEndTags(String excludeTag) {
        while (inSorted(currentElement().normalName(), TagSearchEndTags)) {
            if (excludeTag != null && currentElementIs(excludeTag))
                break;
            pop();
        }
    }
    void generateImpliedEndTags() {
        generateImpliedEndTags(false);
    }
    void generateImpliedEndTags(boolean thorough) {
        final String[] search = thorough ? TagThoroughSearchEndTags : TagSearchEndTags;
        while (NamespaceHtml.equals(currentElement().tag().namespace()) && inSorted(currentElement().normalName(), search)) {
            pop();
        }
    }
    void closeElement(String name) {
        generateImpliedEndTags(name);
        if (!name.equals(currentElement().normalName()))
            error(state());
        popStackToClose(name);
    }
    static boolean isSpecial(Element el) {
        String namespace = el.tag().namespace();
        String name = el.normalName();
        switch(namespace) {
            case NamespaceHtml:
                return inSorted(name, TagSearchSpecial);
            case Parser.NamespaceMathml:
                return inSorted(name, TagSearchSpecialMath);
            case Parser.NamespaceSvg:
                return inSorted(name, TagSvgHtmlIntegration);
            default:
                return false;
        }
    }
    Element lastFormattingElement() {
        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size() - 1) : null;
    }
    int positionOfElement(Element el) {
        for (int i = 0; i < formattingElements.size(); i++) {
            if (el == formattingElements.get(i))
                return i;
        }
        return -1;
    }
    Element removeLastFormattingElement() {
        int size = formattingElements.size();
        if (size > 0)
            return formattingElements.remove(size - 1);
        else
            return null;
    }
    void pushActiveFormattingElements(Element in) {
        checkActiveFormattingElements(in);
        formattingElements.add(in);
    }
    void pushWithBookmark(Element in, int bookmark) {
        checkActiveFormattingElements(in);
        try {
            formattingElements.add(bookmark, in);
        } catch (IndexOutOfBoundsException e) {
            formattingElements.add(in);
        }
    }
    void checkActiveFormattingElements(Element in) {
        int numSeen = 0;
        final int size = formattingElements.size() - 1;
        int ceil = size - maxUsedFormattingElements;
        if (ceil < 0)
            ceil = 0;
        for (int pos = size; pos >= ceil; pos--) {
            Element el = formattingElements.get(pos);
            if (el == null)
                break;
            if (isSameFormattingElement(in, el))
                numSeen++;
            if (numSeen == 3) {
                formattingElements.remove(pos);
                break;
            }
        }
    }
    private static boolean isSameFormattingElement(Element a, Element b) {
        return a.normalName().equals(b.normalName()) && a.attributes().equals(b.attributes());
    }
    void reconstructFormattingElements() {
        if (stack.size() > maxQueueDepth)
            return;
        Element last = lastFormattingElement();
        if (last == null || onStack(last))
            return;
        Element entry = last;
        int size = formattingElements.size();
        int ceil = size - maxUsedFormattingElements;
        if (ceil < 0)
            ceil = 0;
        int pos = size - 1;
        boolean skip = false;
        while (true) {
            if (pos == ceil) {
                skip = true;
                break;
            }
            entry = formattingElements.get(--pos);
            if (entry == null || onStack(entry))
                break;
        }
        while (true) {
            if (!skip)
                entry = formattingElements.get(++pos);
            Validate.notNull(entry);
            skip = false;
            Element newEl = new Element(tagFor(entry.nodeName(), entry.normalName(), defaultNamespace(), settings), null, entry.attributes().clone());
            doInsertElement(newEl);
            formattingElements.set(pos, newEl);
            if (pos == size - 1)
                break;
        }
    }
    private static final int maxUsedFormattingElements = 12;
    void clearFormattingElementsToLastMarker() {
        while (!formattingElements.isEmpty()) {
            Element el = removeLastFormattingElement();
            if (el == null)
                break;
        }
    }
    void removeFromActiveFormattingElements(Element el) {
        for (int pos = formattingElements.size() - 1; pos >= 0; pos--) {
            Element next = formattingElements.get(pos);
            if (next == el) {
                formattingElements.remove(pos);
                break;
            }
        }
    }
    boolean isInActiveFormattingElements(Element el) {
        return onStack(formattingElements, el);
    }
    Element getActiveFormattingElement(String nodeName) {
        for (int pos = formattingElements.size() - 1; pos >= 0; pos--) {
            Element next = formattingElements.get(pos);
            if (next == null)
                break;
            else if (next.nameIs(nodeName))
                return next;
        }
        return null;
    }
    void replaceActiveFormattingElement(Element out, Element in) {
        replaceInQueue(formattingElements, out, in);
    }
    void insertMarkerToFormattingElements() {
        formattingElements.add(null);
    }
    void insertInFosterParent(Node in) {
        Element fosterParent;
        Element lastTable = getFromStack("table");
        boolean isLastTableParent = false;
        if (lastTable != null) {
            if (lastTable.parent() != null) {
                fosterParent = lastTable.parent();
                isLastTableParent = true;
            } else
                fosterParent = aboveOnStack(lastTable);
        } else {
            fosterParent = stack.get(0);
        }
        if (isLastTableParent) {
            Validate.notNull(lastTable);
            lastTable.before(in);
        } else
            fosterParent.appendChild(in);
    }
    void pushTemplateMode(HtmlTreeBuilderState state) {
        tmplInsertMode.add(state);
    }
    HtmlTreeBuilderState popTemplateMode() {
        if (tmplInsertMode.size() > 0) {
            return tmplInsertMode.remove(tmplInsertMode.size() - 1);
        } else {
            return null;
        }
    }
    int templateModeSize() {
        return tmplInsertMode.size();
    }
    HtmlTreeBuilderState currentTemplateMode() {
        return (tmplInsertMode.size() > 0) ? tmplInsertMode.get(tmplInsertMode.size() - 1) : null;
    }
    public String toString() {
        return "TreeBuilder{" + "currentToken=" + currentToken + ", state=" + state + ", currentElement=" + currentElement() + '}';
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```