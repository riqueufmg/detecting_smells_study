##CONTEXT_SIZE=998
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.parser;
public class StreamParser implements Closeable {
    final private Parser parser;
    final private TreeBuilder treeBuilder;
    final private ElementIterator it = new ElementIterator();
    private Document document;
    private boolean stopped = false;
    public StreamParser(Parser parser) {
        this.parser = parser;
        treeBuilder = parser.getTreeBuilder();
        treeBuilder.nodeListener(it);
    }
    public StreamParser parse(Reader input, String baseUri) {
        close();
        it.reset();
        treeBuilder.initialiseParse(input, baseUri, parser);
        document = treeBuilder.doc;
        return this;
    }
    public StreamParser parse(String input, String baseUri) {
        return parse(new StringReader(input), baseUri);
    }
    public StreamParser parseFragment(Reader input, @Nullable Element context, String baseUri) {
        parse(input, baseUri);
        treeBuilder.initialiseParseFragment(context);
        return this;
    }
    public StreamParser parseFragment(String input, @Nullable Element context, String baseUri) {
        return parseFragment(new StringReader(input), context, baseUri);
    }
    public Stream<Element> stream() {
        return StreamSupport.stream(Spliterators.spliteratorUnknownSize(it, Spliterator.DISTINCT | Spliterator.NONNULL | Spliterator.ORDERED), false);
    }
    public Iterator<Element> iterator() {
        return it;
    }
    public StreamParser stop() {
        stopped = true;
        return this;
    }
    public void close() {
        treeBuilder.completeParse();
    }
    public Document document() {
        document = treeBuilder.doc;
        Validate.notNull(document, "Must run parse() before calling.");
        return document;
    }
    public Document complete() throws IOException {
        Document doc = document();
        treeBuilder.runParser();
        return doc;
    }
    public List<Node> completeFragment() throws IOException {
        treeBuilder.runParser();
        return treeBuilder.completeParseFragment();
    }
    public Element selectFirst(String query) throws IOException {
        return selectFirst(Selector.evaluatorOf(query));
    }
    public Element expectFirst(String query) throws IOException {
        return Validate.expectNotNull(selectFirst(query), "No elements matched the query '%s' in the document.", query);
    }
    public Element selectFirst(Evaluator eval) throws IOException {
        final Document doc = document();
        Element first = doc.selectFirst(eval);
        if (first != null)
            return first;
        return selectNext(eval);
    }
    public Element selectNext(String query) throws IOException {
        return selectNext(Selector.evaluatorOf(query));
    }
    public Element expectNext(String query) throws IOException {
        return Validate.expectNotNull(selectNext(query), "No elements matched the query '%s' in the document.", query);
    }
    public Element selectNext(Evaluator eval) throws IOException {
        try {
            final Document doc = document();
            return stream().filter(eval.asPredicate(doc)).findFirst().orElse(null);
        } catch (UncheckedIOException e) {
            throw e.getCause();
        }
    }
    final class ElementIterator implements Iterator<Element>, NodeVisitor {
        final private Queue<Element> emitQueue = new LinkedList<>();
        private Element current;
        private Element next;
        private Element tail;
        void reset() {
            emitQueue.clear();
            current = next = tail = null;
            stopped = false;
        }
        public boolean hasNext() {
            maybeFindNext();
            return next != null;
        }
        public Element next() {
            maybeFindNext();
            if (next == null)
                throw new NoSuchElementException();
            current = next;
            next = null;
            return current;
        }
        private void maybeFindNext() {
            if (stopped || next != null)
                return;
            if (!emitQueue.isEmpty()) {
                next = emitQueue.remove();
                return;
            }
            while (treeBuilder.stepParser()) {
                if (!emitQueue.isEmpty()) {
                    next = emitQueue.remove();
                    return;
                }
            }
            stop();
            close();
            if (tail != null) {
                next = tail;
                tail = null;
            }
        }
        public void remove() {
            if (current == null)
                throw new NoSuchElementException();
            current.remove();
        }
        public void head(Node node, int depth) {
            if (node instanceof Element) {
                Element prev = node.previousElementSibling();
                if (prev != null)
                    emitQueue.add(prev);
            }
        }
        public void tail(Node node, int depth) {
            if (node instanceof Element) {
                tail = (Element) node;
                Element lastChild = tail.lastElementChild();
                if (lastChild != null)
                    emitQueue.add(lastChild);
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```