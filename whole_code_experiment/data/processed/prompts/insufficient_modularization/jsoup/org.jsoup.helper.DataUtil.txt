##CONTEXT_SIZE=2233
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.jsoup.helper;
public final class DataUtil {
    private static final Pattern charsetPattern = Pattern.compile("(?i)\\bcharset=\\s*(?:[\"'])?([^\\s,;\"']*)");
    public static final Charset UTF_8 = Charset.forName("UTF-8");
    static final String defaultCharsetName = UTF_8.name();
    private static final int firstReadBufferSize = 1024 * 5;
    private static final char[] mimeBoundaryChars = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
    static final int boundaryLength = 32;
    private DataUtil() {
    }
    public static Document load(File file, @Nullable String charsetName, String baseUri) throws IOException {
        return load(file.toPath(), charsetName, baseUri);
    }
    public static Document load(File file, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {
        return load(file.toPath(), charsetName, baseUri, parser);
    }
    public static Document load(Path path, @Nullable String charsetName, String baseUri) throws IOException {
        return load(path, charsetName, baseUri, Parser.htmlParser());
    }
    public static Document load(Path path, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {
        return parseInputStream(openStream(path), charsetName, baseUri, parser);
    }
    public static StreamParser streamParser(Path path, @Nullable Charset charset, String baseUri, Parser parser) throws IOException {
        StreamParser streamer = new StreamParser(parser);
        String charsetName = charset != null ? charset.name() : null;
        try {
            DataUtil.CharsetDoc charsetDoc = DataUtil.detectCharset(openStream(path), charsetName, baseUri, parser);
            Reader reader = new SimpleStreamReader(charsetDoc.input, charsetDoc.charset);
            streamer.parse(reader, baseUri);
        } catch (IOException e) {
            streamer.close();
            throw e;
        }
        return streamer;
    }
    private static ControllableInputStream openStream(Path path) throws IOException {
        final SeekableByteChannel byteChannel = Files.newByteChannel(path);
        InputStream stream = Channels.newInputStream(byteChannel);
        String name = Normalizer.lowerCase(path.getFileName().toString());
        if (name.endsWith(".gz") || name.endsWith(".z")) {
            try {
                final boolean zipped = (stream.read() == 0x1f && stream.read() == 0x8b);
                byteChannel.position(0);
                if (zipped)
                    stream = new GZIPInputStream(stream);
            } catch (IOException e) {
                stream.close();
                throw e;
            }
        }
        return ControllableInputStream.wrap(stream, 0);
    }
    public static Document load(InputStream in, @Nullable String charsetName, String baseUri) throws IOException {
        return parseInputStream(ControllableInputStream.wrap(in, 0), charsetName, baseUri, Parser.htmlParser());
    }
    public static Document load(InputStream in, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {
        return parseInputStream(ControllableInputStream.wrap(in, 0), charsetName, baseUri, parser);
    }
    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {
        final byte[] buffer = new byte[DefaultBufferSize];
        int len;
        while ((len = in.read(buffer)) != -1) {
            out.write(buffer, 0, len);
        }
    }
    static class CharsetDoc {
        Charset charset;
        InputStream input;
        Document doc;
        CharsetDoc(Charset charset, @Nullable Document doc, InputStream input) {
            this.charset = charset;
            this.input = input;
            this.doc = doc;
        }
    }
    static Document parseInputStream(@Nullable ControllableInputStream input, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {
        if (input == null)
            return new Document(baseUri);
        final Document doc;
        CharsetDoc charsetDoc = null;
        try {
            charsetDoc = detectCharset(input, charsetName, baseUri, parser);
            doc = parseInputStream(charsetDoc, baseUri, parser);
        } finally {
            if (charsetDoc != null)
                charsetDoc.input.close();
        }
        return doc;
    }
    private static final Evaluator metaCharset = Selector.evaluatorOf("meta[http-equiv=content-type], meta[charset]");
    static CharsetDoc detectCharset(ControllableInputStream input, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {
        Document doc = null;
        String bomCharset = detectCharsetFromBom(input);
        if (bomCharset != null)
            charsetName = bomCharset;
        if (charsetName == null) {
            int origMax = input.max();
            input.max(firstReadBufferSize);
            input.mark(firstReadBufferSize);
            input.allowClose(false);
            try (Reader reader = new SimpleStreamReader(input, UTF_8)) {
                doc = parser.parseInput(reader, baseUri);
                input.reset();
                input.max(origMax);
            } catch (UncheckedIOException e) {
                throw e.getCause();
            } finally {
                input.allowClose(true);
            }
            Elements metaElements = doc.select(metaCharset);
            String foundCharset = null;
            for (Element meta : metaElements) {
                if (meta.hasAttr("http-equiv"))
                    foundCharset = getCharsetFromContentType(meta.attr("content"));
                if (foundCharset == null && meta.hasAttr("charset"))
                    foundCharset = meta.attr("charset");
                if (foundCharset != null)
                    break;
            }
            if (foundCharset == null && doc.childNodeSize() > 0) {
                Node first = doc.childNode(0);
                XmlDeclaration decl = null;
                if (first instanceof XmlDeclaration)
                    decl = (XmlDeclaration) first;
                else if (first instanceof Comment) {
                    Comment comment = (Comment) first;
                    if (comment.isXmlDeclaration())
                        decl = comment.asXmlDeclaration();
                }
                if (decl != null && decl.name().equalsIgnoreCase("xml")) {
                    foundCharset = decl.attr("encoding");
                }
            }
            foundCharset = validateCharset(foundCharset);
            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharsetName)) {
                foundCharset = foundCharset.trim().replaceAll("[\"']", "");
                charsetName = foundCharset;
                doc = null;
            } else if (input.baseReadFully()) {
                input.close();
            } else {
                doc = null;
            }
        } else {
            Validate.notEmpty(charsetName, "Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML");
        }
        if (charsetName == null)
            charsetName = defaultCharsetName;
        Charset charset = charsetName.equals(defaultCharsetName) ? UTF_8 : Charset.forName(charsetName);
        return new CharsetDoc(charset, doc, input);
    }
    static Document parseInputStream(CharsetDoc charsetDoc, String baseUri, Parser parser) throws IOException {
        if (charsetDoc.doc != null)
            return charsetDoc.doc;
        final InputStream input = charsetDoc.input;
        Validate.notNull(input);
        final Document doc;
        final Charset charset = charsetDoc.charset;
        try (Reader reader = new SimpleStreamReader(input, charset)) {
            try {
                doc = parser.parseInput(reader, baseUri);
            } catch (UncheckedIOException e) {
                throw e.getCause();
            }
            doc.outputSettings().charset(charset);
            if (!charset.canEncode()) {
                doc.charset(UTF_8);
            }
        }
        return doc;
    }
    public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {
        return ControllableInputStream.readToByteBuffer(inStream, maxSize);
    }
    static ByteBuffer emptyByteBuffer() {
        return ByteBuffer.allocate(0);
    }
    static String getCharsetFromContentType(@Nullable String contentType) {
        if (contentType == null)
            return null;
        Matcher m = charsetPattern.matcher(contentType);
        if (m.find()) {
            String charset = m.group(1).trim();
            charset = charset.replace("charset=", "");
            return validateCharset(charset);
        }
        return null;
    }
    private static String validateCharset(@Nullable String cs) {
        if (cs == null || cs.length() == 0)
            return null;
        cs = cs.trim().replaceAll("[\"']", "");
        try {
            if (Charset.isSupported(cs))
                return cs;
            cs = cs.toUpperCase(Locale.ENGLISH);
            if (Charset.isSupported(cs))
                return cs;
        } catch (IllegalCharsetNameException e) {
        }
        return null;
    }
    static String mimeBoundary() {
        final StringBuilder mime = StringUtil.borrowBuilder();
        final Random rand = new Random();
        for (int i = 0; i < boundaryLength; i++) {
            mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);
        }
        return StringUtil.releaseBuilder(mime);
    }
    private static String detectCharsetFromBom(ControllableInputStream input) throws IOException {
        byte[] bom = new byte[4];
        input.mark(bom.length);
        input.read(bom, 0, 4);
        input.reset();
        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) {
            return "UTF-32";
        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {
            return "UTF-16";
        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {
            input.read(bom, 0, 3);
            return "UTF-8";
        }
        return null;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```