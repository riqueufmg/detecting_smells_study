##CONTEXT_SIZE=6541
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.zxing.datamatrix.encoder;
public final class MinimalEncoder {
    enum Mode {
        ASCII,
        C40,
        TEXT,
        X12,
        EDF,
        B256
    }
    static final char[] C40_SHIFT2_CHARS = { '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '^', '_' };
    private MinimalEncoder() {
    }
    static boolean isExtendedASCII(char ch, int fnc1) {
        return ch != fnc1 && ch >= 128 && ch <= 255;
    }
    private static boolean isInC40Shift1Set(char ch) {
        return ch <= 31;
    }
    private static boolean isInC40Shift2Set(char ch, int fnc1) {
        for (char c40Shift2Char : C40_SHIFT2_CHARS) {
            if (c40Shift2Char == ch) {
                return true;
            }
        }
        return ch == fnc1;
    }
    private static boolean isInTextShift1Set(char ch) {
        return isInC40Shift1Set(ch);
    }
    private static boolean isInTextShift2Set(char ch, int fnc1) {
        return isInC40Shift2Set(ch, fnc1);
    }
    public static String encodeHighLevel(String msg) {
        return encodeHighLevel(msg, null, -1, SymbolShapeHint.FORCE_NONE);
    }
    public static String encodeHighLevel(String msg, Charset priorityCharset, int fnc1, SymbolShapeHint shape) {
        int macroId = 0;
        if (msg.startsWith(HighLevelEncoder.MACRO_05_HEADER) && msg.endsWith(HighLevelEncoder.MACRO_TRAILER)) {
            macroId = 5;
            msg = msg.substring(HighLevelEncoder.MACRO_05_HEADER.length(), msg.length() - 2);
        } else if (msg.startsWith(HighLevelEncoder.MACRO_06_HEADER) && msg.endsWith(HighLevelEncoder.MACRO_TRAILER)) {
            macroId = 6;
            msg = msg.substring(HighLevelEncoder.MACRO_06_HEADER.length(), msg.length() - 2);
        }
        return new String(encode(msg, priorityCharset, fnc1, shape, macroId), StandardCharsets.ISO_8859_1);
    }
    static byte[] encode(String input, Charset priorityCharset, int fnc1, SymbolShapeHint shape, int macroId) {
        return encodeMinimally(new Input(input, priorityCharset, fnc1, shape, macroId)).getBytes();
    }
    static void addEdge(Edge[][] edges, Edge edge) {
        int vertexIndex = edge.fromPosition + edge.characterLength;
        if (edges[vertexIndex][edge.getEndMode().ordinal()] == null || edges[vertexIndex][edge.getEndMode().ordinal()].cachedTotalSize > edge.cachedTotalSize) {
            edges[vertexIndex][edge.getEndMode().ordinal()] = edge;
        }
    }
    static int getNumberOfC40Words(Input input, int from, boolean c40, int[] characterLength) {
        int thirdsCount = 0;
        for (int i = from; i < input.length(); i++) {
            if (input.isECI(i)) {
                characterLength[0] = 0;
                return 0;
            }
            char ci = input.charAt(i);
            if (c40 && HighLevelEncoder.isNativeC40(ci) || !c40 && HighLevelEncoder.isNativeText(ci)) {
                thirdsCount++;
            } else if (!isExtendedASCII(ci, input.getFNC1Character())) {
                thirdsCount += 2;
            } else {
                int asciiValue = ci & 0xff;
                if (asciiValue >= 128 && (c40 && HighLevelEncoder.isNativeC40((char) (asciiValue - 128)) || !c40 && HighLevelEncoder.isNativeText((char) (asciiValue - 128)))) {
                    thirdsCount += 3;
                } else {
                    thirdsCount += 4;
                }
            }
            if (thirdsCount % 3 == 0 || ((thirdsCount - 2) % 3 == 0 && i + 1 == input.length())) {
                characterLength[0] = i - from + 1;
                return (int) Math.ceil(((double) thirdsCount) / 3.0);
            }
        }
        characterLength[0] = 0;
        return 0;
    }
    static void addEdges(Input input, Edge[][] edges, int from, Edge previous) {
        if (input.isECI(from)) {
            addEdge(edges, new Edge(input, Mode.ASCII, from, 1, previous));
            return;
        }
        char ch = input.charAt(from);
        if (previous == null || previous.getEndMode() != Mode.EDF) {
            if (HighLevelEncoder.isDigit(ch) && input.haveNCharacters(from, 2) && HighLevelEncoder.isDigit(input.charAt(from + 1))) {
                addEdge(edges, new Edge(input, Mode.ASCII, from, 2, previous));
            } else {
                addEdge(edges, new Edge(input, Mode.ASCII, from, 1, previous));
            }
            Mode[] modes = { Mode.C40, Mode.TEXT };
            for (Mode mode : modes) {
                int[] characterLength = new int[1];
                if (getNumberOfC40Words(input, from, mode == Mode.C40, characterLength) > 0) {
                    addEdge(edges, new Edge(input, mode, from, characterLength[0], previous));
                }
            }
            if (input.haveNCharacters(from, 3) && HighLevelEncoder.isNativeX12(input.charAt(from)) && HighLevelEncoder.isNativeX12(input.charAt(from + 1)) && HighLevelEncoder.isNativeX12(input.charAt(from + 2))) {
                addEdge(edges, new Edge(input, Mode.X12, from, 3, previous));
            }
            addEdge(edges, new Edge(input, Mode.B256, from, 1, previous));
        }
        int i;
        for (i = 0; i < 3; i++) {
            int pos = from + i;
            if (input.haveNCharacters(pos, 1) && HighLevelEncoder.isNativeEDIFACT(input.charAt(pos))) {
                addEdge(edges, new Edge(input, Mode.EDF, from, i + 1, previous));
            } else {
                break;
            }
        }
        if (i == 3 && input.haveNCharacters(from, 4) && HighLevelEncoder.isNativeEDIFACT(input.charAt(from + 3))) {
            addEdge(edges, new Edge(input, Mode.EDF, from, 4, previous));
        }
    }
    static Result encodeMinimally(Input input) {
        @SuppressWarnings("checkstyle:lineLength")
        int inputLength = input.length();
        Edge[][] edges = new Edge[inputLength + 1][6];
        addEdges(input, edges, 0, null);
        for (int i = 1; i <= inputLength; i++) {
            for (int j = 0; j < 6; j++) {
                if (edges[i][j] != null && i < inputLength) {
                    addEdges(input, edges, i, edges[i][j]);
                }
            }
            for (int j = 0; j < 6; j++) {
                edges[i - 1][j] = null;
            }
        }
        int minimalJ = -1;
        int minimalSize = Integer.MAX_VALUE;
        for (int j = 0; j < 6; j++) {
            if (edges[inputLength][j] != null) {
                Edge edge = edges[inputLength][j];
                int size = j >= 1 && j <= 3 ? edge.cachedTotalSize + 1 : edge.cachedTotalSize;
                if (size < minimalSize) {
                    minimalSize = size;
                    minimalJ = j;
                }
            }
        }
        if (minimalJ < 0) {
            throw new IllegalStateException("Failed to encode \"" + input + "\"");
        }
        return new Result(edges[inputLength][minimalJ]);
    }
    private static final class Edge {
        private static final int[] allCodewordCapacities = { 3, 5, 8, 10, 12, 16, 18, 22, 30, 32, 36, 44, 49, 62, 86, 114, 144, 174, 204, 280, 368, 456, 576, 696, 816, 1050, 1304, 1558 };
        private static final int[] squareCodewordCapacities = { 3, 5, 8, 12, 18, 22, 30, 36, 44, 62, 86, 114, 144, 174, 204, 280, 368, 456, 576, 696, 816, 1050, 1304, 1558 };
        private static final int[] rectangularCodewordCapacities = { 5, 10, 16, 33, 32, 49 };
        private final Input input;
        private final Mode mode;
        private final int fromPosition;
        private final int characterLength;
        private final Edge previous;
        private final int cachedTotalSize;
        private Edge(Input input, Mode mode, int fromPosition, int characterLength, Edge previous) {
            this.input = input;
            this.mode = mode;
            this.fromPosition = fromPosition;
            this.characterLength = characterLength;
            this.previous = previous;
            assert fromPosition + characterLength <= input.length();
            int size = previous != null ? previous.cachedTotalSize : 0;
            Mode previousMode = getPreviousMode();
            switch(mode) {
                case ASCII:
                    size++;
                    if (input.isECI(fromPosition) || isExtendedASCII(input.charAt(fromPosition), input.getFNC1Character())) {
                        size++;
                    }
                    if (previousMode == Mode.C40 || previousMode == Mode.TEXT || previousMode == Mode.X12) {
                        size++;
                    }
                    break;
                case B256:
                    size++;
                    if (previousMode != Mode.B256) {
                        size++;
                    } else if (getB256Size() == 250) {
                        size++;
                    }
                    if (previousMode == Mode.ASCII) {
                        size++;
                    } else if (previousMode == Mode.C40 || previousMode == Mode.TEXT || previousMode == Mode.X12) {
                        size += 2;
                    }
                    break;
                case C40:
                case TEXT:
                case X12:
                    if (mode == Mode.X12) {
                        size += 2;
                    } else {
                        int[] charLen = new int[1];
                        size += getNumberOfC40Words(input, fromPosition, mode == Mode.C40, charLen) * 2;
                    }
                    if (previousMode == Mode.ASCII || previousMode == Mode.B256) {
                        size++;
                    } else if (previousMode != mode && (previousMode == Mode.C40 || previousMode == Mode.TEXT || previousMode == Mode.X12)) {
                        size += 2;
                    }
                    break;
                case EDF:
                    size += 3;
                    if (previousMode == Mode.ASCII || previousMode == Mode.B256) {
                        size++;
                    } else if (previousMode == Mode.C40 || previousMode == Mode.TEXT || previousMode == Mode.X12) {
                        size += 2;
                    }
                    break;
            }
            cachedTotalSize = size;
        }
        int getB256Size() {
            int cnt = 0;
            Edge current = this;
            while (current != null && current.mode == Mode.B256 && cnt <= 250) {
                cnt++;
                current = current.previous;
            }
            return cnt;
        }
        Mode getPreviousStartMode() {
            return previous == null ? Mode.ASCII : previous.mode;
        }
        Mode getPreviousMode() {
            return previous == null ? Mode.ASCII : previous.getEndMode();
        }
        Mode getEndMode() {
            if (mode == Mode.EDF) {
                if (characterLength < 4) {
                    return Mode.ASCII;
                }
                int lastASCII = getLastASCII();
                if (lastASCII > 0 && getCodewordsRemaining(cachedTotalSize + lastASCII) <= 2 - lastASCII) {
                    return Mode.ASCII;
                }
            }
            if (mode == Mode.C40 || mode == Mode.TEXT || mode == Mode.X12) {
                if (fromPosition + characterLength >= input.length() && getCodewordsRemaining(cachedTotalSize) == 0) {
                    return Mode.ASCII;
                }
                int lastASCII = getLastASCII();
                if (lastASCII == 1 && getCodewordsRemaining(cachedTotalSize + 1) == 0) {
                    return Mode.ASCII;
                }
            }
            return mode;
        }
        Mode getMode() {
            return mode;
        }
        int getLastASCII() {
            int length = input.length();
            int from = fromPosition + characterLength;
            if (length - from > 4 || from >= length) {
                return 0;
            }
            if (length - from == 1) {
                if (isExtendedASCII(input.charAt(from), input.getFNC1Character())) {
                    return 0;
                }
                return 1;
            }
            if (length - from == 2) {
                if (isExtendedASCII(input.charAt(from), input.getFNC1Character()) || isExtendedASCII(input.charAt(from + 1), input.getFNC1Character())) {
                    return 0;
                }
                if (HighLevelEncoder.isDigit(input.charAt(from)) && HighLevelEncoder.isDigit(input.charAt(from + 1))) {
                    return 1;
                }
                return 2;
            }
            if (length - from == 3) {
                if (HighLevelEncoder.isDigit(input.charAt(from)) && HighLevelEncoder.isDigit(input.charAt(from + 1)) && !isExtendedASCII(input.charAt(from + 2), input.getFNC1Character())) {
                    return 2;
                }
                if (HighLevelEncoder.isDigit(input.charAt(from + 1)) && HighLevelEncoder.isDigit(input.charAt(from + 2)) && !isExtendedASCII(input.charAt(from), input.getFNC1Character())) {
                    return 2;
                }
                return 0;
            }
            if (HighLevelEncoder.isDigit(input.charAt(from)) && HighLevelEncoder.isDigit(input.charAt(from + 1)) && HighLevelEncoder.isDigit(input.charAt(from + 2)) && HighLevelEncoder.isDigit(input.charAt(from + 3))) {
                return 2;
            }
            return 0;
        }
        int getMinSymbolSize(int minimum) {
            switch(input.getShapeHint()) {
                case FORCE_SQUARE:
                    for (int capacity : squareCodewordCapacities) {
                        if (capacity >= minimum) {
                            return capacity;
                        }
                    }
                    break;
                case FORCE_RECTANGLE:
                    for (int capacity : rectangularCodewordCapacities) {
                        if (capacity >= minimum) {
                            return capacity;
                        }
                    }
                    break;
            }
            for (int capacity : allCodewordCapacities) {
                if (capacity >= minimum) {
                    return capacity;
                }
            }
            return allCodewordCapacities[allCodewordCapacities.length - 1];
        }
        int getCodewordsRemaining(int minimum) {
            return getMinSymbolSize(minimum) - minimum;
        }
        static byte[] getBytes(int c) {
            byte[] result = new byte[1];
            result[0] = (byte) c;
            return result;
        }
        static byte[] getBytes(int c1, int c2) {
            byte[] result = new byte[2];
            result[0] = (byte) c1;
            result[1] = (byte) c2;
            return result;
        }
        static void setC40Word(byte[] bytes, int offset, int c1, int c2, int c3) {
            int val16 = (1600 * (c1 & 0xff)) + (40 * (c2 & 0xff)) + (c3 & 0xff) + 1;
            bytes[offset] = (byte) (val16 / 256);
            bytes[offset + 1] = (byte) (val16 % 256);
        }
        private static int getX12Value(char c) {
            return c == 13 ? 0 : c == 42 ? 1 : c == 62 ? 2 : c == 32 ? 3 : c >= 48 && c <= 57 ? c - 44 : c >= 65 && c <= 90 ? c - 51 : c;
        }
        byte[] getX12Words() {
            assert characterLength % 3 == 0;
            byte[] result = new byte[characterLength / 3 * 2];
            for (int i = 0; i < result.length; i += 2) {
                setC40Word(result, i, getX12Value(input.charAt(fromPosition + i / 2 * 3)), getX12Value(input.charAt(fromPosition + i / 2 * 3 + 1)), getX12Value(input.charAt(fromPosition + i / 2 * 3 + 2)));
            }
            return result;
        }
        static int getShiftValue(char c, boolean c40, int fnc1) {
            return (c40 && isInC40Shift1Set(c) || !c40 && isInTextShift1Set(c)) ? 0 : (c40 && isInC40Shift2Set(c, fnc1) || !c40 && isInTextShift2Set(c, fnc1)) ? 1 : 2;
        }
        private static int getC40Value(boolean c40, int setIndex, char c, int fnc1) {
            if (c == fnc1) {
                assert setIndex == 2;
                return 27;
            }
            if (c40) {
                return c <= 31 ? c : c == 32 ? 3 : c <= 47 ? c - 33 : c <= 57 ? c - 44 : c <= 64 ? c - 43 : c <= 90 ? c - 51 : c <= 95 ? c - 69 : c <= 127 ? c - 96 : c;
            } else {
                return c == 0 ? 0 : //is this a bug in the spec?
                setIndex == 0 && c <= 3 ? c - 1 : setIndex == 1 && c <= 31 ? c : c == 32 ? 3 : c >= 33 && c <= 47 ? c - 33 : c >= 48 && c <= 57 ? c - 44 : c >= 58 && c <= 64 ? c - 43 : c >= 65 && c <= 90 ? c - 64 : c >= 91 && c <= 95 ? c - 69 : c == 96 ? 0 : c >= 97 && c <= 122 ? c - 83 : c >= 123 && c <= 127 ? c - 96 : c;
            }
        }
        byte[] getC40Words(boolean c40, int fnc1) {
            List<Byte> c40Values = new ArrayList<>();
            for (int i = 0; i < characterLength; i++) {
                char ci = input.charAt(fromPosition + i);
                if (c40 && HighLevelEncoder.isNativeC40(ci) || !c40 && HighLevelEncoder.isNativeText(ci)) {
                    c40Values.add((byte) getC40Value(c40, 0, ci, fnc1));
                } else if (!isExtendedASCII(ci, fnc1)) {
                    int shiftValue = getShiftValue(ci, c40, fnc1);
                    c40Values.add((byte) shiftValue);
                    c40Values.add((byte) getC40Value(c40, shiftValue, ci, fnc1));
                } else {
                    char asciiValue = (char) ((ci & 0xff) - 128);
                    if (c40 && HighLevelEncoder.isNativeC40(asciiValue) || !c40 && HighLevelEncoder.isNativeText(asciiValue)) {
                        c40Values.add((byte) 1);
                        c40Values.add((byte) 30);
                        c40Values.add((byte) getC40Value(c40, 0, asciiValue, fnc1));
                    } else {
                        c40Values.add((byte) 1);
                        c40Values.add((byte) 30);
                        int shiftValue = getShiftValue(asciiValue, c40, fnc1);
                        c40Values.add((byte) shiftValue);
                        c40Values.add((byte) getC40Value(c40, shiftValue, asciiValue, fnc1));
                    }
                }
            }
            if ((c40Values.size() % 3) != 0) {
                assert (c40Values.size() - 2) % 3 == 0 && fromPosition + characterLength == input.length();
                c40Values.add((byte) 0);
            }
            byte[] result = new byte[c40Values.size() / 3 * 2];
            int byteIndex = 0;
            for (int i = 0; i < c40Values.size(); i += 3) {
                setC40Word(result, byteIndex, c40Values.get(i) & 0xff, c40Values.get(i + 1) & 0xff, c40Values.get(i + 2) & 0xff);
                byteIndex += 2;
            }
            return result;
        }
        byte[] getEDFBytes() {
            int numberOfThirds = (int) Math.ceil(characterLength / 4.0);
            byte[] result = new byte[numberOfThirds * 3];
            int pos = fromPosition;
            int endPos = Math.min(fromPosition + characterLength - 1, input.length() - 1);
            for (int i = 0; i < numberOfThirds; i += 3) {
                int[] edfValues = new int[4];
                for (int j = 0; j < 4; j++) {
                    if (pos <= endPos) {
                        edfValues[j] = input.charAt(pos++) & 0x3f;
                    } else {
                        edfValues[j] = pos == endPos + 1 ? 0x1f : 0;
                    }
                }
                int val24 = edfValues[0] << 18;
                val24 |= edfValues[1] << 12;
                val24 |= edfValues[2] << 6;
                val24 |= edfValues[3];
                result[i] = (byte) ((val24 >> 16) & 0xff);
                result[i + 1] = (byte) ((val24 >> 8) & 0xff);
                result[i + 2] = (byte) (val24 & 0xff);
            }
            return result;
        }
        byte[] getLatchBytes() {
            switch(getPreviousMode()) {
                case ASCII:
                case B256:
                    switch(mode) {
                        case B256:
                            return getBytes(231);
                        case C40:
                            return getBytes(230);
                        case TEXT:
                            return getBytes(239);
                        case X12:
                            return getBytes(238);
                        case EDF:
                            return getBytes(240);
                    }
                    break;
                case C40:
                case TEXT:
                case X12:
                    if (mode != getPreviousMode()) {
                        switch(mode) {
                            case ASCII:
                                return getBytes(254);
                            case B256:
                                return getBytes(254, 231);
                            case C40:
                                return getBytes(254, 230);
                            case TEXT:
                                return getBytes(254, 239);
                            case X12:
                                return getBytes(254, 238);
                            case EDF:
                                return getBytes(254, 240);
                        }
                    }
                    break;
                case EDF:
                    assert mode == Mode.EDF;
                    break;
            }
            return new byte[0];
        }
        byte[] getDataBytes() {
            switch(mode) {
                case ASCII:
                    if (input.isECI(fromPosition)) {
                        return getBytes(241, input.getECIValue(fromPosition) + 1);
                    } else if (isExtendedASCII(input.charAt(fromPosition), input.getFNC1Character())) {
                        return getBytes(235, input.charAt(fromPosition) - 127);
                    } else if (characterLength == 2) {
                        return getBytes((input.charAt(fromPosition) - '0') * 10 + input.charAt(fromPosition + 1) - '0' + 130);
                    } else if (input.isFNC1(fromPosition)) {
                        return getBytes(232);
                    } else {
                        return getBytes(input.charAt(fromPosition) + 1);
                    }
                case B256:
                    return getBytes(input.charAt(fromPosition));
                case C40:
                    return getC40Words(true, input.getFNC1Character());
                case TEXT:
                    return getC40Words(false, input.getFNC1Character());
                case X12:
                    return getX12Words();
                case EDF:
                    return getEDFBytes();
            }
            assert false;
            return new byte[0];
        }
    }
    private static final class Result {
        private final byte[] bytes;
        Result(Edge solution) {
            Input input = solution.input;
            int size = 0;
            List<Byte> bytesAL = new ArrayList<>();
            List<Integer> randomizePostfixLength = new ArrayList<>();
            List<Integer> randomizeLengths = new ArrayList<>();
            if ((solution.mode == Mode.C40 || solution.mode == Mode.TEXT || solution.mode == Mode.X12) && solution.getEndMode() != Mode.ASCII) {
                size += prepend(MinimalEncoder.Edge.getBytes(254), bytesAL);
            }
            Edge current = solution;
            while (current != null) {
                size += prepend(current.getDataBytes(), bytesAL);
                if (current.previous == null || current.getPreviousStartMode() != current.getMode()) {
                    if (current.getMode() == Mode.B256) {
                        if (size <= 249) {
                            bytesAL.add(0, (byte) size);
                            size++;
                        } else {
                            bytesAL.add(0, (byte) (size % 250));
                            bytesAL.add(0, (byte) (size / 250 + 249));
                            size += 2;
                        }
                        randomizePostfixLength.add(bytesAL.size());
                        randomizeLengths.add(size);
                    }
                    prepend(current.getLatchBytes(), bytesAL);
                    size = 0;
                }
                current = current.previous;
            }
            if (input.getMacroId() == 5) {
                size += prepend(MinimalEncoder.Edge.getBytes(236), bytesAL);
            } else if (input.getMacroId() == 6) {
                size += prepend(MinimalEncoder.Edge.getBytes(237), bytesAL);
            }
            if (input.getFNC1Character() > 0) {
                size += prepend(MinimalEncoder.Edge.getBytes(232), bytesAL);
            }
            for (int i = 0; i < randomizePostfixLength.size(); i++) {
                applyRandomPattern(bytesAL, bytesAL.size() - randomizePostfixLength.get(i), randomizeLengths.get(i));
            }
            int capacity = solution.getMinSymbolSize(bytesAL.size());
            if (bytesAL.size() < capacity) {
                bytesAL.add((byte) 129);
            }
            while (bytesAL.size() < capacity) {
                bytesAL.add((byte) randomize253State(bytesAL.size() + 1));
            }
            bytes = new byte[bytesAL.size()];
            for (int i = 0; i < bytes.length; i++) {
                bytes[i] = bytesAL.get(i);
            }
        }
        static int prepend(byte[] bytes, List<Byte> into) {
            for (int i = bytes.length - 1; i >= 0; i--) {
                into.add(0, bytes[i]);
            }
            return bytes.length;
        }
        private static int randomize253State(int codewordPosition) {
            int pseudoRandom = ((149 * codewordPosition) % 253) + 1;
            int tempVariable = 129 + pseudoRandom;
            return tempVariable <= 254 ? tempVariable : tempVariable - 254;
        }
        static void applyRandomPattern(List<Byte> bytesAL, int startPosition, int length) {
            for (int i = 0; i < length; i++) {
                int Pad_codeword_position = startPosition + i;
                int Pad_codeword_value = bytesAL.get(Pad_codeword_position) & 0xff;
                int pseudo_random_number = ((149 * (Pad_codeword_position + 1)) % 255) + 1;
                int temp_variable = Pad_codeword_value + pseudo_random_number;
                bytesAL.set(Pad_codeword_position, (byte) (temp_variable <= 255 ? temp_variable : temp_variable - 256));
            }
        }
        public byte[] getBytes() {
            return bytes;
        }
    }
    private static final class Input extends MinimalECIInput {
        private final SymbolShapeHint shape;
        private final int macroId;
        private Input(String stringToEncode, Charset priorityCharset, int fnc1, SymbolShapeHint shape, int macroId) {
            super(stringToEncode, priorityCharset, fnc1);
            this.shape = shape;
            this.macroId = macroId;
        }
        private int getMacroId() {
            return macroId;
        }
        private SymbolShapeHint getShapeHint() {
            return shape;
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```