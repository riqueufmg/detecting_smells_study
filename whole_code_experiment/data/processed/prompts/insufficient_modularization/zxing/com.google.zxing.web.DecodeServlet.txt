##CONTEXT_SIZE=2936
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.zxing.web;
public final class DecodeServlet extends HttpServlet {
    private static final Logger log = Logger.getLogger(DecodeServlet.class.getName());
    private static final Pattern WHITESPACE = Pattern.compile("\\s+");
    private static final long MAX_IMAGE_SIZE = 1L << 26;
    private static final int MAX_PIXELS = 1 << 25;
    private static final Map<DecodeHintType, Object> HINTS;
    private static final Map<DecodeHintType, Object> HINTS_PURE;
    static {
        HINTS = new EnumMap<>(DecodeHintType.class);
        HINTS.put(DecodeHintType.TRY_HARDER, Boolean.TRUE);
        HINTS.put(DecodeHintType.POSSIBLE_FORMATS, EnumSet.allOf(BarcodeFormat.class));
        HINTS_PURE = new EnumMap<>(HINTS);
        HINTS_PURE.put(DecodeHintType.PURE_BARCODE, Boolean.TRUE);
    }
    private Collection<String> blockedURLSubstrings;
    private Timer timer;
    private DoSTracker destHostTracker;
    public void init(ServletConfig servletConfig) throws ServletException {
        Logger logger = Logger.getLogger("com.google.zxing");
        ServletContext context = servletConfig.getServletContext();
        logger.addHandler(new ServletContextLogHandler(context));
        URL blockURL = context.getClassLoader().getResource("/private/uri-block-substrings.txt");
        if (blockURL == null) {
            blockedURLSubstrings = Collections.emptyList();
        } else {
            try {
                blockedURLSubstrings = Resources.readLines(blockURL, StandardCharsets.UTF_8);
            } catch (IOException ioe) {
                throw new ServletException(ioe);
            }
            log.info("Blocking URIs containing: " + blockedURLSubstrings);
        }
        int maxAccessPerTime = Integer.parseInt(servletConfig.getInitParameter("maxAccessPerTime"));
        int accessTimeSec = Integer.parseInt(servletConfig.getInitParameter("accessTimeSec"));
        long accessTimeMS = TimeUnit.MILLISECONDS.convert(accessTimeSec, TimeUnit.SECONDS);
        int maxEntries = Integer.parseInt(servletConfig.getInitParameter("maxEntries"));
        String name = getClass().getSimpleName();
        timer = new Timer(name);
        destHostTracker = new DoSTracker(timer, name, maxAccessPerTime, accessTimeMS, maxEntries, null);
    }
    public void destroy() {
        if (timer != null) {
            timer.cancel();
        }
    }
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String imageURIString = request.getParameter("u");
        if (imageURIString == null || imageURIString.isEmpty()) {
            log.info("URI was empty");
            errorResponse(request, response, "badurl");
            return;
        }
        imageURIString = WHITESPACE.matcher(imageURIString).replaceAll("");
        if (!blockedURLSubstrings.isEmpty()) {
            for (CharSequence substring : blockedURLSubstrings) {
                if (imageURIString.contains(substring)) {
                    log.info("Disallowed URI " + imageURIString);
                    errorResponse(request, response, HttpServletResponse.SC_FORBIDDEN, "badurl");
                    return;
                }
            }
        }
        URI imageURI;
        try {
            imageURI = new URI(imageURIString);
            if (imageURI.getScheme() == null) {
                imageURI = new URI("http://" + imageURIString);
            }
        } catch (URISyntaxException e) {
            log.info("Error " + e + " while parsing URI: " + imageURIString);
            errorResponse(request, response, "badurl");
            return;
        }
        if ("data".equals(imageURI.getScheme())) {
            BufferedImage image;
            try {
                image = ImageReader.readDataURIImage(imageURI);
            } catch (Exception e) {
                log.info("Error " + e + " while reading data URI: " + imageURIString);
                errorResponse(request, response, "badurl");
                return;
            }
            if (image == null) {
                log.info("Couldn't read data URI: " + imageURIString);
                errorResponse(request, response, "badimage");
                return;
            }
            try {
                processImage(image, request, response);
            } finally {
                image.flush();
            }
            return;
        }
        String host = imageURI.getHost();
        if (host == null || host.startsWith("10.") || host.startsWith("192.168.") || "127.0.0.1".equals(host) || "localhost".equals(host) || destHostTracker.isBanned(host)) {
            errorResponse(request, response, HttpServletResponse.SC_FORBIDDEN, "badurl");
            return;
        }
        URL imageURL;
        try {
            imageURL = imageURI.toURL();
        } catch (MalformedURLException ignored) {
            log.info("URI is not a URL: " + imageURIString);
            errorResponse(request, response, "badurl");
            return;
        }
        String protocol = imageURL.getProtocol();
        if (!"http".equalsIgnoreCase(protocol) && !"https".equalsIgnoreCase(protocol)) {
            log.info("URL protocol was not valid: " + imageURIString);
            errorResponse(request, response, "badurl");
            return;
        }
        HttpURLConnection connection;
        try {
            connection = (HttpURLConnection) imageURL.openConnection();
        } catch (IllegalArgumentException ignored) {
            log.info("URL could not be opened: " + imageURIString);
            errorResponse(request, response, "badurl");
            return;
        }
        connection.setAllowUserInteraction(false);
        connection.setInstanceFollowRedirects(true);
        connection.setReadTimeout(5000);
        connection.setConnectTimeout(5000);
        connection.setRequestProperty(HttpHeaders.USER_AGENT, "zxing.org");
        connection.setRequestProperty(HttpHeaders.CONNECTION, "close");
        try {
            connection.connect();
        } catch (Exception e) {
            log.info("Error " + e + " connecting to " + imageURIString);
            errorResponse(request, response, "badurl");
            return;
        }
        try (InputStream is = connection.getInputStream()) {
            if (connection.getResponseCode() != HttpServletResponse.SC_OK) {
                log.info("Unsuccessful return code " + connection.getResponseCode() + " from " + imageURIString);
                errorResponse(request, response, "badurl");
                return;
            }
            int contentLength = connection.getHeaderFieldInt(HttpHeaders.CONTENT_LENGTH, -1);
            if (contentLength <= 0) {
                log.info("Bad content length: " + imageURIString);
                errorResponse(request, response, HttpServletResponse.SC_LENGTH_REQUIRED, "badimage");
                return;
            }
            if (contentLength > MAX_IMAGE_SIZE) {
                log.info("Too large: " + imageURIString);
                errorResponse(request, response, HttpServletResponse.SC_REQUEST_ENTITY_TOO_LARGE, "badimage");
                return;
            }
            String contentType = connection.getContentType();
            if (contentType != null && !contentType.startsWith("image/")) {
                log.info("Wrong content type " + contentType + ": " + imageURIString);
                errorResponse(request, response, HttpServletResponse.SC_UNSUPPORTED_MEDIA_TYPE, "badimage");
                return;
            }
            log.info("Decoding " + imageURIString);
            processStream(is, request, response);
        } catch (IOException ioe) {
            log.info("Error " + ioe + " processing " + imageURIString);
            errorResponse(request, response, "badurl");
        } finally {
            connection.disconnect();
        }
    }
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        Collection<Part> parts;
        try {
            parts = request.getParts();
        } catch (Exception e) {
            log.info(e.toString());
            errorResponse(request, response, "badimage");
            return;
        }
        Part fileUploadPart = null;
        for (Part part : parts) {
            if (part.getHeader(HttpHeaders.CONTENT_DISPOSITION) != null) {
                fileUploadPart = part;
                break;
            }
        }
        if (fileUploadPart == null) {
            log.info("File upload was not multipart");
            errorResponse(request, response, "badimage");
        } else {
            log.info("Decoding uploaded file " + fileUploadPart.getSubmittedFileName());
            try (InputStream is = fileUploadPart.getInputStream()) {
                processStream(is, request, response);
            }
        }
    }
    private static void processStream(InputStream is, HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        BufferedImage image;
        try {
            image = ImageIO.read(is);
        } catch (Exception e) {
            log.info(e.toString());
            errorResponse(request, response, "badimage");
            return;
        }
        if (image == null) {
            errorResponse(request, response, "badimage");
            return;
        }
        try {
            int height = image.getHeight();
            int width = image.getWidth();
            if (height <= 1 || width <= 1) {
                log.info("Dimensions too small: " + width + 'x' + height);
                errorResponse(request, response, "badimage");
                return;
            } else if (height * width > MAX_PIXELS) {
                log.info("Dimensions too large: " + width + 'x' + height);
                errorResponse(request, response, HttpServletResponse.SC_REQUEST_ENTITY_TOO_LARGE, "badimage");
                return;
            }
            processImage(image, request, response);
        } finally {
            image.flush();
        }
    }
    private static void processImage(BufferedImage image, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
        LuminanceSource source = new BufferedImageLuminanceSource(image);
        BinaryBitmap bitmap = new BinaryBitmap(new GlobalHistogramBinarizer(source));
        Collection<Result> results = new ArrayList<>(1);
        try {
            Reader reader = new MultiFormatReader();
            ReaderException savedException = null;
            try {
                MultipleBarcodeReader multiReader = new GenericMultipleBarcodeReader(reader);
                Result[] theResults = multiReader.decodeMultiple(bitmap, HINTS);
                if (theResults != null) {
                    results.addAll(Arrays.asList(theResults));
                }
            } catch (ReaderException re) {
                savedException = re;
            }
            if (results.isEmpty() && !Thread.currentThread().isInterrupted()) {
                try {
                    Result theResult = reader.decode(bitmap, HINTS_PURE);
                    if (theResult != null) {
                        results.add(theResult);
                    }
                } catch (ReaderException re) {
                    savedException = re;
                }
            }
            if (results.isEmpty() && !Thread.currentThread().isInterrupted()) {
                try {
                    Result theResult = reader.decode(bitmap, HINTS);
                    if (theResult != null) {
                        results.add(theResult);
                    }
                } catch (ReaderException re) {
                    savedException = re;
                }
            }
            if (results.isEmpty() && !Thread.currentThread().isInterrupted()) {
                try {
                    BinaryBitmap hybridBitmap = new BinaryBitmap(new HybridBinarizer(source));
                    Result theResult = reader.decode(hybridBitmap, HINTS);
                    if (theResult != null) {
                        results.add(theResult);
                    }
                } catch (ReaderException re) {
                    savedException = re;
                }
            }
            if (results.isEmpty()) {
                try {
                    throw savedException == null ? NotFoundException.getNotFoundInstance() : savedException;
                } catch (FormatException | ChecksumException e) {
                    errorResponse(request, response, "format");
                } catch (ReaderException e) {
                    errorResponse(request, response, "notfound");
                }
                return;
            }
        } catch (RuntimeException re) {
            log.log(Level.WARNING, "Unexpected exception from library", re);
            throw new ServletException(re);
        }
        String fullParameter = request.getParameter("full");
        boolean minimalOutput = fullParameter != null && !Boolean.parseBoolean(fullParameter);
        if (minimalOutput) {
            response.setContentType(MediaType.PLAIN_TEXT_UTF_8.toString());
            response.setCharacterEncoding(StandardCharsets.UTF_8.name());
            try (Writer out = new OutputStreamWriter(response.getOutputStream(), StandardCharsets.UTF_8)) {
                for (Result result : results) {
                    out.write(result.getText());
                    out.write('\n');
                }
            }
        } else {
            request.setAttribute("results", results);
            request.getRequestDispatcher("decoderesult.jspx").forward(request, response);
        }
    }
    private static void errorResponse(HttpServletRequest request, HttpServletResponse response, String key) throws ServletException, IOException {
        errorResponse(request, response, HttpServletResponse.SC_BAD_REQUEST, key);
    }
    private static void errorResponse(HttpServletRequest request, HttpServletResponse response, int httpStatus, String key) throws ServletException, IOException {
        Locale locale = request.getLocale();
        if (locale == null) {
            locale = Locale.ENGLISH;
        }
        ResourceBundle bundle = ResourceBundle.getBundle("Strings", locale);
        String title = bundle.getString("response.error." + key + ".title");
        String text = bundle.getString("response.error." + key + ".text");
        request.setAttribute("title", title);
        request.setAttribute("text", text);
        RequestDispatcher dispatcher = request.getRequestDispatcher("response.jspx");
        if (dispatcher == null) {
            log.warning("Can't obtain RequestDispatcher");
        } else {
            response.setStatus(httpStatus);
            dispatcher.forward(request, response);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```