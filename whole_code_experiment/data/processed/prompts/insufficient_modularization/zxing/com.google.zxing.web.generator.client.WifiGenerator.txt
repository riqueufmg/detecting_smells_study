##CONTEXT_SIZE=975
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.zxing.web.generator.client;
public final class WifiGenerator implements GeneratorSource {
    private Grid table;
    private final TextBox ssid = new TextBox();
    private final TextBox password = new TextBox();
    private final ListBox networkType = new ListBox();
    private final CheckBox hidden = new CheckBox();
    public WifiGenerator(ChangeHandler handler, KeyPressHandler keyListener) {
        networkType.addItem("WEP", "WEP");
        networkType.addItem("WPA/WPA2", "WPA");
        networkType.addItem("No encryption", "nopass");
        TextBox[] widgets = { ssid, password };
        for (TextBox w : widgets) {
            w.addChangeHandler(handler);
            w.addKeyPressHandler(keyListener);
        }
    }
    public String getName() {
        return "Wifi network";
    }
    public String getText() throws GeneratorException {
        String ssid = getSsidField();
        String password = getPasswordField();
        String networkType = getNetworkTypeField();
        boolean hidden = getHiddenField();
        return getWifiString(ssid, password, networkType, hidden);
    }
    private static String getWifiString(String ssid, String password, String type, boolean hidden) {
        StringBuilder output = new StringBuilder(100);
        output.append("WIFI:");
        output.append("S:").append(ssid).append(';');
        if (type != null && !type.isEmpty() && !"nopass".equals(type)) {
            maybeAppend(output, "T:", type);
        }
        maybeAppend(output, "P:", password);
        if (hidden) {
            maybeAppend(output, "H:", "true");
        }
        output.append(';');
        return output.toString();
    }
    private static void maybeAppend(StringBuilder output, String prefix, String value) {
        if (value != null && !value.isEmpty()) {
            output.append(prefix).append(value).append(';');
        }
    }
    private static String parseTextField(String name, HasText textBox) throws GeneratorException {
        String input = textBox.getText();
        if (input.isEmpty()) {
            return "";
        }
        if (input.contains("\n")) {
            throw new GeneratorException(name + " field must not contain \\n characters.");
        }
        return input.replaceAll("([\\\\:;])", "\\\\$1");
    }
    private String getSsidField() throws GeneratorException {
        String input = ssid.getText();
        if (input.isEmpty()) {
            throw new GeneratorException("SSID must be at least 1 character.");
        }
        String parsed = parseTextField("SSID", ssid);
        return quoteHex(parsed);
    }
    private String getPasswordField() throws GeneratorException {
        return parseTextField("Password", password);
    }
    private String getNetworkTypeField() {
        return networkType.getValue(networkType.getSelectedIndex());
    }
    private boolean getHiddenField() {
        Boolean value = hidden.getValue();
        return value != null && value;
    }
    public Grid getWidget() {
        if (table != null) {
            return table;
        }
        table = new Grid(4, 2);
        table.setText(0, 0, "SSID");
        table.setWidget(0, 1, ssid);
        table.setText(1, 0, "Password");
        table.setWidget(1, 1, password);
        table.setText(2, 0, "Network Type");
        table.setWidget(2, 1, networkType);
        table.setText(3, 0, "Hidden?");
        table.setWidget(3, 1, hidden);
        ssid.addStyleName(StylesDefs.INPUT_FIELD_REQUIRED);
        return table;
    }
    public void validate(Widget widget) throws GeneratorException {
        if (widget == ssid) {
            getSsidField();
        }
        if (widget == password) {
            getPasswordField();
        }
        if (widget == networkType) {
            getNetworkTypeField();
        }
        if (widget == hidden) {
            getHiddenField();
        }
    }
    public void setFocus() {
        ssid.setFocus(true);
    }
    private static String quoteHex(String value) {
        if (value != null && value.matches("[0-9A-Fa-f]+")) {
            if (value.charAt(0) == '"' && value.charAt(value.length() - 1) == '"') {
                return value;
            }
            return '\"' + value + '\"';
        }
        return value;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```