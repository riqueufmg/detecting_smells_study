##CONTEXT_SIZE=1070
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.zxing.client.android.result.supplement;
public abstract class SupplementalInfoRetriever extends AsyncTask<Object, Object, Object> {
    private static final String TAG = "SupplementalInfo";
    static final String[] EMPTY_STR_ARRAY = new String[0];
    private final WeakReference<TextView> textViewRef;
    private final WeakReference<HistoryManager> historyManagerRef;
    private final Collection<Spannable> newContents;
    private final Collection<String[]> newHistories;
    public static void maybeInvokeRetrieval(TextView textView, ParsedResult result, HistoryManager historyManager, Context context) {
        try {
            if (result instanceof URIParsedResult) {
                SupplementalInfoRetriever uriRetriever = new URIResultInfoRetriever(textView, (URIParsedResult) result, historyManager, context);
                uriRetriever.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
                SupplementalInfoRetriever titleRetriever = new TitleRetriever(textView, (URIParsedResult) result, historyManager);
                titleRetriever.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
            } else if (result instanceof ProductParsedResult) {
                ProductParsedResult productParsedResult = (ProductParsedResult) result;
                String productID = productParsedResult.getProductID();
                SupplementalInfoRetriever productRetriever = new ProductResultInfoRetriever(textView, productID, historyManager, context);
                productRetriever.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
            } else if (result instanceof ISBNParsedResult) {
                String isbn = ((ISBNParsedResult) result).getISBN();
                SupplementalInfoRetriever productInfoRetriever = new ProductResultInfoRetriever(textView, isbn, historyManager, context);
                productInfoRetriever.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
                SupplementalInfoRetriever bookInfoRetriever = new BookResultInfoRetriever(textView, isbn, historyManager, context);
                bookInfoRetriever.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
            }
        } catch (RejectedExecutionException ree) {
        }
    }
    SupplementalInfoRetriever(TextView textView, HistoryManager historyManager) {
        textViewRef = new WeakReference<>(textView);
        historyManagerRef = new WeakReference<>(historyManager);
        newContents = new ArrayList<>();
        newHistories = new ArrayList<>();
    }
    public final Object doInBackground(Object... args) {
        try {
            retrieveSupplementalInfo();
        } catch (IOException e) {
            Log.w(TAG, e);
        }
        return null;
    }
    protected final void onPostExecute(Object arg) {
        TextView textView = textViewRef.get();
        if (textView != null) {
            for (CharSequence content : newContents) {
                textView.append(content);
            }
            textView.setMovementMethod(LinkMovementMethod.getInstance());
        }
        HistoryManager historyManager = historyManagerRef.get();
        if (historyManager != null) {
            for (String[] text : newHistories) {
                historyManager.addHistoryItemDetails(text[0], text[1]);
            }
        }
    }
    abstract void retrieveSupplementalInfo() throws IOException;
    final void append(String itemID, String source, String[] newTexts, String linkURL) {
        StringBuilder newTextCombined = new StringBuilder();
        if (source != null) {
            newTextCombined.append(source).append(' ');
        }
        int linkStart = newTextCombined.length();
        boolean first = true;
        for (String newText : newTexts) {
            if (first) {
                newTextCombined.append(newText);
                first = false;
            } else {
                newTextCombined.append(" [");
                newTextCombined.append(newText);
                newTextCombined.append(']');
            }
        }
        int linkEnd = newTextCombined.length();
        String newText = newTextCombined.toString();
        Spannable content = new SpannableString(newText + "\n\n");
        if (linkURL != null) {
            if (linkURL.startsWith("HTTP://")) {
                linkURL = "http" + linkURL.substring(4);
            } else if (linkURL.startsWith("HTTPS://")) {
                linkURL = "https" + linkURL.substring(5);
            }
            content.setSpan(new URLSpan(linkURL), linkStart, linkEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        newContents.add(content);
        newHistories.add(new String[] { itemID, newText });
    }
    static void maybeAddText(String text, Collection<String> texts) {
        if (text != null && !text.isEmpty()) {
            texts.add(text);
        }
    }
    static void maybeAddTextSeries(Collection<String> textSeries, Collection<String> texts) {
        if (textSeries != null && !textSeries.isEmpty()) {
            boolean first = true;
            StringBuilder authorsText = new StringBuilder();
            for (String author : textSeries) {
                if (first) {
                    first = false;
                } else {
                    authorsText.append(", ");
                }
                authorsText.append(author);
            }
            texts.add(authorsText.toString());
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```