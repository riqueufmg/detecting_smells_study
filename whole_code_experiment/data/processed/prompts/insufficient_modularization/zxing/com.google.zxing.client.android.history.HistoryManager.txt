##CONTEXT_SIZE=2064
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.zxing.client.android.history;
public final class HistoryManager {
    private static final String TAG = HistoryManager.class.getSimpleName();
    private static final int MAX_ITEMS = 2000;
    private static final String[] COLUMNS = { DBHelper.TEXT_COL, DBHelper.DISPLAY_COL, DBHelper.FORMAT_COL, DBHelper.TIMESTAMP_COL, DBHelper.DETAILS_COL };
    private static final String[] COUNT_COLUMN = { "COUNT(1)" };
    private static final String[] ID_COL_PROJECTION = { DBHelper.ID_COL };
    private static final String[] ID_DETAIL_COL_PROJECTION = { DBHelper.ID_COL, DBHelper.DETAILS_COL };
    private static final Pattern DOUBLE_QUOTE = Pattern.compile("\"", Pattern.LITERAL);
    private final Activity activity;
    private final boolean enableHistory;
    public HistoryManager(Activity activity) {
        this.activity = activity;
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(activity);
        enableHistory = prefs.getBoolean(PreferencesActivity.KEY_ENABLE_HISTORY, true);
    }
    public boolean hasHistoryItems() {
        SQLiteOpenHelper helper = new DBHelper(activity);
        try (SQLiteDatabase db = helper.getReadableDatabase();
            Cursor cursor = db.query(DBHelper.TABLE_NAME, COUNT_COLUMN, null, null, null, null, null)) {
            cursor.moveToFirst();
            return cursor.getInt(0) > 0;
        } catch (SQLException sqle) {
            Log.w(TAG, sqle);
            return false;
        }
    }
    public List<HistoryItem> buildHistoryItems() {
        SQLiteOpenHelper helper = new DBHelper(activity);
        List<HistoryItem> items = new ArrayList<>();
        try (SQLiteDatabase db = helper.getReadableDatabase();
            Cursor cursor = db.query(DBHelper.TABLE_NAME, COLUMNS, null, null, null, null, DBHelper.TIMESTAMP_COL + " DESC")) {
            while (cursor.moveToNext()) {
                String text = cursor.getString(0);
                String display = cursor.getString(1);
                String format = cursor.getString(2);
                long timestamp = cursor.getLong(3);
                String details = cursor.getString(4);
                Result result = new Result(text, null, null, BarcodeFormat.valueOf(format), timestamp);
                items.add(new HistoryItem(result, display, details));
            }
        } catch (CursorIndexOutOfBoundsException cioobe) {
            Log.w(TAG, cioobe);
        }
        return items;
    }
    public HistoryItem buildHistoryItem(int number) {
        SQLiteOpenHelper helper = new DBHelper(activity);
        try (SQLiteDatabase db = helper.getReadableDatabase();
            Cursor cursor = db.query(DBHelper.TABLE_NAME, COLUMNS, null, null, null, null, DBHelper.TIMESTAMP_COL + " DESC")) {
            cursor.move(number + 1);
            String text = cursor.getString(0);
            String display = cursor.getString(1);
            String format = cursor.getString(2);
            long timestamp = cursor.getLong(3);
            String details = cursor.getString(4);
            Result result = new Result(text, null, null, BarcodeFormat.valueOf(format), timestamp);
            return new HistoryItem(result, display, details);
        }
    }
    public void deleteHistoryItem(int number) {
        SQLiteOpenHelper helper = new DBHelper(activity);
        try (SQLiteDatabase db = helper.getWritableDatabase();
            Cursor cursor = db.query(DBHelper.TABLE_NAME, ID_COL_PROJECTION, null, null, null, null, DBHelper.TIMESTAMP_COL + " DESC")) {
            cursor.move(number + 1);
            db.delete(DBHelper.TABLE_NAME, DBHelper.ID_COL + '=' + cursor.getString(0), null);
        } catch (SQLException sqle) {
            Log.w(TAG, sqle);
        }
    }
    public void addHistoryItem(Result result, ResultHandler handler) {
        if (!activity.getIntent().getBooleanExtra(Intents.Scan.SAVE_HISTORY, true) || handler.areContentsSecure() || !enableHistory) {
            return;
        }
        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(activity);
        if (!prefs.getBoolean(PreferencesActivity.KEY_REMEMBER_DUPLICATES, false)) {
            deletePrevious(result.getText());
        }
        ContentValues values = new ContentValues();
        values.put(DBHelper.TEXT_COL, result.getText());
        values.put(DBHelper.FORMAT_COL, result.getBarcodeFormat().toString());
        values.put(DBHelper.DISPLAY_COL, handler.getDisplayContents().toString());
        values.put(DBHelper.TIMESTAMP_COL, System.currentTimeMillis());
        SQLiteOpenHelper helper = new DBHelper(activity);
        try (SQLiteDatabase db = helper.getWritableDatabase()) {
            db.insert(DBHelper.TABLE_NAME, DBHelper.TIMESTAMP_COL, values);
        } catch (SQLException sqle) {
            Log.w(TAG, sqle);
        }
    }
    public void addHistoryItemDetails(String itemID, String itemDetails) {
        SQLiteOpenHelper helper = new DBHelper(activity);
        try (SQLiteDatabase db = helper.getWritableDatabase();
            Cursor cursor = db.query(DBHelper.TABLE_NAME, ID_DETAIL_COL_PROJECTION, DBHelper.TEXT_COL + "=?", new String[] { itemID }, null, null, DBHelper.TIMESTAMP_COL + " DESC", "1")) {
            String oldID = null;
            String oldDetails = null;
            if (cursor.moveToNext()) {
                oldID = cursor.getString(0);
                oldDetails = cursor.getString(1);
            }
            if (oldID != null) {
                String newDetails;
                if (oldDetails == null) {
                    newDetails = itemDetails;
                } else if (oldDetails.contains(itemDetails)) {
                    newDetails = null;
                } else {
                    newDetails = oldDetails + " : " + itemDetails;
                }
                if (newDetails != null) {
                    ContentValues values = new ContentValues();
                    values.put(DBHelper.DETAILS_COL, newDetails);
                    db.update(DBHelper.TABLE_NAME, values, DBHelper.ID_COL + "=?", new String[] { oldID });
                }
            }
        } catch (SQLException sqle) {
            Log.w(TAG, sqle);
        }
    }
    private void deletePrevious(String text) {
        SQLiteOpenHelper helper = new DBHelper(activity);
        try (SQLiteDatabase db = helper.getWritableDatabase()) {
            db.delete(DBHelper.TABLE_NAME, DBHelper.TEXT_COL + "=?", new String[] { text });
        } catch (SQLException sqle) {
            Log.w(TAG, sqle);
        }
    }
    public void trimHistory() {
        SQLiteOpenHelper helper = new DBHelper(activity);
        try (SQLiteDatabase db = helper.getWritableDatabase();
            Cursor cursor = db.query(DBHelper.TABLE_NAME, ID_COL_PROJECTION, null, null, null, null, DBHelper.TIMESTAMP_COL + " DESC")) {
            cursor.move(MAX_ITEMS);
            while (cursor.moveToNext()) {
                String id = cursor.getString(0);
                Log.i(TAG, "Deleting scan history ID " + id);
                db.delete(DBHelper.TABLE_NAME, DBHelper.ID_COL + '=' + id, null);
            }
        } catch (SQLException sqle) {
            Log.w(TAG, sqle);
        }
    }
    CharSequence buildHistory() {
        StringBuilder historyText = new StringBuilder(1000);
        SQLiteOpenHelper helper = new DBHelper(activity);
        try (SQLiteDatabase db = helper.getReadableDatabase();
            Cursor cursor = db.query(DBHelper.TABLE_NAME, COLUMNS, null, null, null, null, DBHelper.TIMESTAMP_COL + " DESC")) {
            DateFormat format = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);
            while (cursor.moveToNext()) {
                historyText.append('"').append(massageHistoryField(cursor.getString(0))).append("\",");
                historyText.append('"').append(massageHistoryField(cursor.getString(1))).append("\",");
                historyText.append('"').append(massageHistoryField(cursor.getString(2))).append("\",");
                historyText.append('"').append(massageHistoryField(cursor.getString(3))).append("\",");
                long timestamp = cursor.getLong(3);
                historyText.append('"').append(massageHistoryField(format.format(timestamp))).append("\",");
                historyText.append('"').append(massageHistoryField(cursor.getString(4))).append("\"\r\n");
            }
        } catch (SQLException sqle) {
            Log.w(TAG, sqle);
        }
        return historyText;
    }
    void clearHistory() {
        SQLiteOpenHelper helper = new DBHelper(activity);
        try (SQLiteDatabase db = helper.getWritableDatabase()) {
            db.delete(DBHelper.TABLE_NAME, null, null);
        } catch (SQLException sqle) {
            Log.w(TAG, sqle);
        }
    }
    static Uri saveHistory(String history) {
        File bsRoot = new File(Environment.getExternalStorageDirectory(), "BarcodeScanner");
        File historyRoot = new File(bsRoot, "History");
        if (!historyRoot.mkdirs() && !historyRoot.isDirectory()) {
            Log.w(TAG, "Couldn't make dir " + historyRoot);
            return null;
        }
        File historyFile = new File(historyRoot, "history-" + System.currentTimeMillis() + ".csv");
        try (OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(historyFile), StandardCharsets.UTF_8)) {
            out.write(history);
            return Uri.parse("file://" + historyFile.getAbsolutePath());
        } catch (IOException ioe) {
            Log.w(TAG, "Couldn't access file " + historyFile + " due to " + ioe);
            return null;
        }
    }
    private static String massageHistoryField(String value) {
        return value == null ? "" : DOUBLE_QUOTE.matcher(value).replaceAll("\"\"");
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```