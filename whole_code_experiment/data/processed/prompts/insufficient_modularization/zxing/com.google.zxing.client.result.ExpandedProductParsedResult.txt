##CONTEXT_SIZE=1013
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
/*
 * These authors would like to acknowledge the Spanish Ministry of Industry,
 * Tourism and Trade, for the support in the project TSI020301-2008-2
 * "PIRAmIDE: Personalizable Interactions with Resources on AmI-enabled
 * Mobile Dynamic Environments", led by Treelogic
 * ( http://www.treelogic.com/ ):
 *
 *   http://www.piramidepse.com/
 */
package com.google.zxing.client.result;
public final class ExpandedProductParsedResult extends ParsedResult {
    public static final String KILOGRAM = "KG";
    public static final String POUND = "LB";
    private final String rawText;
    private final String productID;
    private final String sscc;
    private final String lotNumber;
    private final String productionDate;
    private final String packagingDate;
    private final String bestBeforeDate;
    private final String expirationDate;
    private final String weight;
    private final String weightType;
    private final String weightIncrement;
    private final String price;
    private final String priceIncrement;
    private final String priceCurrency;
    private final Map<String, String> uncommonAIs;
    public ExpandedProductParsedResult(String rawText, String productID, String sscc, String lotNumber, String productionDate, String packagingDate, String bestBeforeDate, String expirationDate, String weight, String weightType, String weightIncrement, String price, String priceIncrement, String priceCurrency, Map<String, String> uncommonAIs) {
        super(ParsedResultType.PRODUCT);
        this.rawText = rawText;
        this.productID = productID;
        this.sscc = sscc;
        this.lotNumber = lotNumber;
        this.productionDate = productionDate;
        this.packagingDate = packagingDate;
        this.bestBeforeDate = bestBeforeDate;
        this.expirationDate = expirationDate;
        this.weight = weight;
        this.weightType = weightType;
        this.weightIncrement = weightIncrement;
        this.price = price;
        this.priceIncrement = priceIncrement;
        this.priceCurrency = priceCurrency;
        this.uncommonAIs = uncommonAIs;
    }
    public boolean equals(Object o) {
        if (!(o instanceof ExpandedProductParsedResult)) {
            return false;
        }
        ExpandedProductParsedResult other = (ExpandedProductParsedResult) o;
        return Objects.equals(productID, other.productID) && Objects.equals(sscc, other.sscc) && Objects.equals(lotNumber, other.lotNumber) && Objects.equals(productionDate, other.productionDate) && Objects.equals(bestBeforeDate, other.bestBeforeDate) && Objects.equals(expirationDate, other.expirationDate) && Objects.equals(weight, other.weight) && Objects.equals(weightType, other.weightType) && Objects.equals(weightIncrement, other.weightIncrement) && Objects.equals(price, other.price) && Objects.equals(priceIncrement, other.priceIncrement) && Objects.equals(priceCurrency, other.priceCurrency) && Objects.equals(uncommonAIs, other.uncommonAIs);
    }
    public int hashCode() {
        int hash = Objects.hashCode(productID);
        hash ^= Objects.hashCode(sscc);
        hash ^= Objects.hashCode(lotNumber);
        hash ^= Objects.hashCode(productionDate);
        hash ^= Objects.hashCode(bestBeforeDate);
        hash ^= Objects.hashCode(expirationDate);
        hash ^= Objects.hashCode(weight);
        hash ^= Objects.hashCode(weightType);
        hash ^= Objects.hashCode(weightIncrement);
        hash ^= Objects.hashCode(price);
        hash ^= Objects.hashCode(priceIncrement);
        hash ^= Objects.hashCode(priceCurrency);
        hash ^= Objects.hashCode(uncommonAIs);
        return hash;
    }
    public String getRawText() {
        return rawText;
    }
    public String getProductID() {
        return productID;
    }
    public String getSscc() {
        return sscc;
    }
    public String getLotNumber() {
        return lotNumber;
    }
    public String getProductionDate() {
        return productionDate;
    }
    public String getPackagingDate() {
        return packagingDate;
    }
    public String getBestBeforeDate() {
        return bestBeforeDate;
    }
    public String getExpirationDate() {
        return expirationDate;
    }
    public String getWeight() {
        return weight;
    }
    public String getWeightType() {
        return weightType;
    }
    public String getWeightIncrement() {
        return weightIncrement;
    }
    public String getPrice() {
        return price;
    }
    public String getPriceIncrement() {
        return priceIncrement;
    }
    public String getPriceCurrency() {
        return priceCurrency;
    }
    public Map<String, String> getUncommonAIs() {
        return uncommonAIs;
    }
    public String getDisplayResult() {
        return String.valueOf(rawText);
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```