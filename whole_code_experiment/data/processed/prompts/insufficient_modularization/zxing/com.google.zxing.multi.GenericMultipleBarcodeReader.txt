##CONTEXT_SIZE=964
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.zxing.multi;
public final class GenericMultipleBarcodeReader implements MultipleBarcodeReader {
    private static final int MIN_DIMENSION_TO_RECUR = 100;
    private static final int MAX_DEPTH = 4;
    static final Result[] EMPTY_RESULT_ARRAY = new Result[0];
    private final Reader delegate;
    public GenericMultipleBarcodeReader(Reader delegate) {
        this.delegate = delegate;
    }
    public Result[] decodeMultiple(BinaryBitmap image) throws NotFoundException {
        return decodeMultiple(image, null);
    }
    public Result[] decodeMultiple(BinaryBitmap image, Map<DecodeHintType, ?> hints) throws NotFoundException {
        List<Result> results = new ArrayList<>();
        doDecodeMultiple(image, hints, results, 0, 0, 0);
        if (results.isEmpty()) {
            throw NotFoundException.getNotFoundInstance();
        }
        return results.toArray(EMPTY_RESULT_ARRAY);
    }
    private void doDecodeMultiple(BinaryBitmap image, Map<DecodeHintType, ?> hints, List<Result> results, int xOffset, int yOffset, int currentDepth) {
        if (currentDepth > MAX_DEPTH) {
            return;
        }
        Result result;
        try {
            result = delegate.decode(image, hints);
        } catch (ReaderException ignored) {
            return;
        }
        boolean alreadyFound = false;
        for (Result existingResult : results) {
            if (existingResult.getText().equals(result.getText())) {
                alreadyFound = true;
                break;
            }
        }
        if (!alreadyFound) {
            results.add(translateResultPoints(result, xOffset, yOffset));
        }
        ResultPoint[] resultPoints = result.getResultPoints();
        if (resultPoints == null || resultPoints.length == 0) {
            return;
        }
        int width = image.getWidth();
        int height = image.getHeight();
        float minX = width;
        float minY = height;
        float maxX = 0.0f;
        float maxY = 0.0f;
        for (ResultPoint point : resultPoints) {
            if (point == null) {
                continue;
            }
            float x = point.getX();
            float y = point.getY();
            if (x < minX) {
                minX = x;
            }
            if (y < minY) {
                minY = y;
            }
            if (x > maxX) {
                maxX = x;
            }
            if (y > maxY) {
                maxY = y;
            }
        }
        if (minX > MIN_DIMENSION_TO_RECUR) {
            doDecodeMultiple(image.crop(0, 0, (int) minX, height), hints, results, xOffset, yOffset, currentDepth + 1);
        }
        if (minY > MIN_DIMENSION_TO_RECUR) {
            doDecodeMultiple(image.crop(0, 0, width, (int) minY), hints, results, xOffset, yOffset, currentDepth + 1);
        }
        if (maxX < width - MIN_DIMENSION_TO_RECUR) {
            doDecodeMultiple(image.crop((int) maxX, 0, width - (int) maxX, height), hints, results, xOffset + (int) maxX, yOffset, currentDepth + 1);
        }
        if (maxY < height - MIN_DIMENSION_TO_RECUR) {
            doDecodeMultiple(image.crop(0, (int) maxY, width, height - (int) maxY), hints, results, xOffset, yOffset + (int) maxY, currentDepth + 1);
        }
    }
    private static Result translateResultPoints(Result result, int xOffset, int yOffset) {
        ResultPoint[] oldResultPoints = result.getResultPoints();
        if (oldResultPoints == null) {
            return result;
        }
        ResultPoint[] newResultPoints = new ResultPoint[oldResultPoints.length];
        for (int i = 0; i < oldResultPoints.length; i++) {
            ResultPoint oldPoint = oldResultPoints[i];
            if (oldPoint != null) {
                newResultPoints[i] = new ResultPoint(oldPoint.getX() + xOffset, oldPoint.getY() + yOffset);
            }
        }
        Result newResult = new Result(result.getText(), result.getRawBytes(), result.getNumBits(), newResultPoints, result.getBarcodeFormat(), result.getTimestamp());
        newResult.putAllMetadata(result.getResultMetadata());
        return newResult;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```