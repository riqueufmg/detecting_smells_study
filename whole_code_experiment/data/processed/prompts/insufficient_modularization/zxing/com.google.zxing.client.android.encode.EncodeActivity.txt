##CONTEXT_SIZE=1319
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.zxing.client.android.encode;
public final class EncodeActivity extends Activity {
    private static final String TAG = EncodeActivity.class.getSimpleName();
    private static final int MAX_BARCODE_FILENAME_LENGTH = 24;
    private static final Pattern NOT_ALPHANUMERIC = Pattern.compile("[^A-Za-z0-9]");
    private static final String USE_VCARD_KEY = "USE_VCARD";
    private QRCodeEncoder qrCodeEncoder;
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        Intent intent = getIntent();
        if (intent == null) {
            finish();
        } else {
            String action = intent.getAction();
            if (Intents.Encode.ACTION.equals(action) || Intent.ACTION_SEND.equals(action)) {
                setContentView(R.layout.encode);
            } else {
                finish();
            }
        }
    }
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater menuInflater = getMenuInflater();
        menuInflater.inflate(R.menu.encode, menu);
        boolean useVcard = qrCodeEncoder != null && qrCodeEncoder.isUseVCard();
        int encodeNameResource = useVcard ? R.string.menu_encode_mecard : R.string.menu_encode_vcard;
        MenuItem encodeItem = menu.findItem(R.id.menu_encode);
        encodeItem.setTitle(encodeNameResource);
        Intent intent = getIntent();
        if (intent != null) {
            String type = intent.getStringExtra(Intents.Encode.TYPE);
            encodeItem.setVisible(Contents.Type.CONTACT.equals(type));
        }
        return super.onCreateOptionsMenu(menu);
    }
    public boolean onOptionsItemSelected(MenuItem item) {
        switch(item.getItemId()) {
            case R.id.menu_share:
                share();
                return true;
            case R.id.menu_encode:
                Intent intent = getIntent();
                if (intent == null) {
                    return false;
                }
                intent.putExtra(USE_VCARD_KEY, !qrCodeEncoder.isUseVCard());
                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
                startActivity(intent);
                finish();
                return true;
            default:
                return false;
        }
    }
    private void share() {
        QRCodeEncoder encoder = qrCodeEncoder;
        if (encoder == null) {
            Log.w(TAG, "No existing barcode to send?");
            return;
        }
        String contents = encoder.getContents();
        if (contents == null) {
            Log.w(TAG, "No existing barcode to send?");
            return;
        }
        Bitmap bitmap;
        try {
            bitmap = encoder.encodeAsBitmap();
        } catch (WriterException we) {
            Log.w(TAG, we);
            return;
        }
        if (bitmap == null) {
            return;
        }
        File bsRoot = new File(Environment.getExternalStorageDirectory(), "BarcodeScanner");
        File barcodesRoot = new File(bsRoot, "Barcodes");
        if (!barcodesRoot.exists() && !barcodesRoot.mkdirs()) {
            Log.w(TAG, "Couldn't make dir " + barcodesRoot);
            showErrorMessage(R.string.msg_unmount_usb);
            return;
        }
        File barcodeFile = new File(barcodesRoot, makeBarcodeFileName(contents) + ".png");
        try (FileOutputStream fos = new FileOutputStream(barcodeFile)) {
            bitmap.compress(Bitmap.CompressFormat.PNG, 0, fos);
        } catch (IOException ioe) {
            Log.w(TAG, "Couldn't access barcode file", ioe);
            showErrorMessage(R.string.msg_unmount_usb);
            return;
        }
        Intent intent = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));
        intent.putExtra(Intent.EXTRA_SUBJECT, getString(R.string.app_name) + " - " + encoder.getTitle());
        intent.putExtra(Intent.EXTRA_TEXT, contents);
        intent.putExtra(Intent.EXTRA_STREAM, Uri.parse("file://" + barcodeFile.getAbsolutePath()));
        intent.setType("image/png");
        intent.addFlags(Intents.FLAG_NEW_DOC);
        startActivity(Intent.createChooser(intent, null));
    }
    private static CharSequence makeBarcodeFileName(CharSequence contents) {
        String fileName = NOT_ALPHANUMERIC.matcher(contents).replaceAll("_");
        if (fileName.length() > MAX_BARCODE_FILENAME_LENGTH) {
            fileName = fileName.substring(0, MAX_BARCODE_FILENAME_LENGTH);
        }
        return fileName;
    }
    protected void onResume() {
        super.onResume();
        WindowManager manager = (WindowManager) getSystemService(WINDOW_SERVICE);
        Display display = manager.getDefaultDisplay();
        Point displaySize = new Point();
        display.getSize(displaySize);
        int width = displaySize.x;
        int height = displaySize.y;
        int smallerDimension = Math.min(width, height);
        smallerDimension = smallerDimension * 7 / 8;
        Intent intent = getIntent();
        if (intent == null) {
            return;
        }
        try {
            boolean useVCard = intent.getBooleanExtra(USE_VCARD_KEY, false);
            qrCodeEncoder = new QRCodeEncoder(this, intent, smallerDimension, useVCard);
            Bitmap bitmap = qrCodeEncoder.encodeAsBitmap();
            if (bitmap == null) {
                Log.w(TAG, "Could not encode barcode");
                showErrorMessage(R.string.msg_encode_contents_failed);
                qrCodeEncoder = null;
                return;
            }
            ImageView view = (ImageView) findViewById(R.id.image_view);
            view.setImageBitmap(bitmap);
            TextView contents = (TextView) findViewById(R.id.contents_text_view);
            if (intent.getBooleanExtra(Intents.Encode.SHOW_CONTENTS, true)) {
                contents.setText(qrCodeEncoder.getDisplayContents());
                setTitle(qrCodeEncoder.getTitle());
            } else {
                contents.setText("");
                setTitle("");
            }
        } catch (WriterException e) {
            Log.w(TAG, "Could not encode barcode", e);
            showErrorMessage(R.string.msg_encode_contents_failed);
            qrCodeEncoder = null;
        }
    }
    private void showErrorMessage(int message) {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        builder.setMessage(message);
        builder.setPositiveButton(R.string.button_ok, new FinishListener(this));
        builder.setOnCancelListener(new FinishListener(this));
        builder.show();
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```