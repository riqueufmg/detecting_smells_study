##CONTEXT_SIZE=980
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.zxing.common;
public final class ECIEncoderSet {
    private static final List<CharsetEncoder> ENCODERS = new ArrayList<>();
    static {
        String[] names = { "IBM437", "ISO-8859-2", "ISO-8859-3", "ISO-8859-4", "ISO-8859-5", "ISO-8859-6", "ISO-8859-7", "ISO-8859-8", "ISO-8859-9", "ISO-8859-10", "ISO-8859-11", "ISO-8859-13", "ISO-8859-14", "ISO-8859-15", "ISO-8859-16", "windows-1250", "windows-1251", "windows-1252", "windows-1256", "Shift_JIS" };
        for (String name : names) {
            if (CharacterSetECI.getCharacterSetECIByName(name) != null) {
                try {
                    ENCODERS.add(Charset.forName(name).newEncoder());
                } catch (UnsupportedCharsetException e) {
                }
            }
        }
    }
    private final CharsetEncoder[] encoders;
    private final int priorityEncoderIndex;
    public ECIEncoderSet(String stringToEncode, Charset priorityCharset, int fnc1) {
        List<CharsetEncoder> neededEncoders = new ArrayList<>();
        neededEncoders.add(StandardCharsets.ISO_8859_1.newEncoder());
        boolean needUnicodeEncoder = priorityCharset != null && priorityCharset.name().startsWith("UTF");
        for (int i = 0; i < stringToEncode.length(); i++) {
            boolean canEncode = false;
            for (CharsetEncoder encoder : neededEncoders) {
                char c = stringToEncode.charAt(i);
                if (c == fnc1 || encoder.canEncode(c)) {
                    canEncode = true;
                    break;
                }
            }
            if (!canEncode) {
                for (CharsetEncoder encoder : ENCODERS) {
                    if (encoder.canEncode(stringToEncode.charAt(i))) {
                        neededEncoders.add(encoder);
                        canEncode = true;
                        break;
                    }
                }
            }
            if (!canEncode) {
                needUnicodeEncoder = true;
            }
        }
        if (neededEncoders.size() == 1 && !needUnicodeEncoder) {
            encoders = new CharsetEncoder[] { neededEncoders.get(0) };
        } else {
            encoders = new CharsetEncoder[neededEncoders.size() + 2];
            int index = 0;
            for (CharsetEncoder encoder : neededEncoders) {
                encoders[index++] = encoder;
            }
            encoders[index] = StandardCharsets.UTF_8.newEncoder();
            encoders[index + 1] = StandardCharsets.UTF_16BE.newEncoder();
        }
        int priorityEncoderIndexValue = -1;
        if (priorityCharset != null) {
            for (int i = 0; i < encoders.length; i++) {
                if (encoders[i] != null && priorityCharset.name().equals(encoders[i].charset().name())) {
                    priorityEncoderIndexValue = i;
                    break;
                }
            }
        }
        priorityEncoderIndex = priorityEncoderIndexValue;
        assert encoders[0].charset().equals(StandardCharsets.ISO_8859_1);
    }
    public int length() {
        return encoders.length;
    }
    public String getCharsetName(int index) {
        assert index < length();
        return encoders[index].charset().name();
    }
    public Charset getCharset(int index) {
        assert index < length();
        return encoders[index].charset();
    }
    public int getECIValue(int encoderIndex) {
        return CharacterSetECI.getCharacterSetECI(encoders[encoderIndex].charset()).getValue();
    }
    public int getPriorityEncoderIndex() {
        return priorityEncoderIndex;
    }
    public boolean canEncode(char c, int encoderIndex) {
        assert encoderIndex < length();
        CharsetEncoder encoder = encoders[encoderIndex];
        return encoder.canEncode("" + c);
    }
    public byte[] encode(char c, int encoderIndex) {
        assert encoderIndex < length();
        CharsetEncoder encoder = encoders[encoderIndex];
        assert encoder.canEncode("" + c);
        return ("" + c).getBytes(encoder.charset());
    }
    public byte[] encode(String s, int encoderIndex) {
        assert encoderIndex < length();
        CharsetEncoder encoder = encoders[encoderIndex];
        return s.getBytes(encoder.charset());
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```