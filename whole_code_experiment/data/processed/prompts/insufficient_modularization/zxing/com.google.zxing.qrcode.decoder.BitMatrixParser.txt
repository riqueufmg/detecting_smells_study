##CONTEXT_SIZE=1317
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.zxing.qrcode.decoder;
final class BitMatrixParser {
    private final BitMatrix bitMatrix;
    private Version parsedVersion;
    private FormatInformation parsedFormatInfo;
    private boolean mirror;
    BitMatrixParser(BitMatrix bitMatrix) throws FormatException {
        int dimension = bitMatrix.getHeight();
        if (dimension < 21 || (dimension & 0x03) != 1) {
            throw FormatException.getFormatInstance();
        }
        this.bitMatrix = bitMatrix;
    }
    FormatInformation readFormatInformation() throws FormatException {
        if (parsedFormatInfo != null) {
            return parsedFormatInfo;
        }
        int formatInfoBits1 = 0;
        for (int i = 0; i < 6; i++) {
            formatInfoBits1 = copyBit(i, 8, formatInfoBits1);
        }
        formatInfoBits1 = copyBit(7, 8, formatInfoBits1);
        formatInfoBits1 = copyBit(8, 8, formatInfoBits1);
        formatInfoBits1 = copyBit(8, 7, formatInfoBits1);
        for (int j = 5; j >= 0; j--) {
            formatInfoBits1 = copyBit(8, j, formatInfoBits1);
        }
        int dimension = bitMatrix.getHeight();
        int formatInfoBits2 = 0;
        int jMin = dimension - 7;
        for (int j = dimension - 1; j >= jMin; j--) {
            formatInfoBits2 = copyBit(8, j, formatInfoBits2);
        }
        for (int i = dimension - 8; i < dimension; i++) {
            formatInfoBits2 = copyBit(i, 8, formatInfoBits2);
        }
        parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits1, formatInfoBits2);
        if (parsedFormatInfo != null) {
            return parsedFormatInfo;
        }
        throw FormatException.getFormatInstance();
    }
    Version readVersion() throws FormatException {
        if (parsedVersion != null) {
            return parsedVersion;
        }
        int dimension = bitMatrix.getHeight();
        int provisionalVersion = (dimension - 17) / 4;
        if (provisionalVersion <= 6) {
            return Version.getVersionForNumber(provisionalVersion);
        }
        int versionBits = 0;
        int ijMin = dimension - 11;
        for (int j = 5; j >= 0; j--) {
            for (int i = dimension - 9; i >= ijMin; i--) {
                versionBits = copyBit(i, j, versionBits);
            }
        }
        Version theParsedVersion = Version.decodeVersionInformation(versionBits);
        if (theParsedVersion != null && theParsedVersion.getDimensionForVersion() == dimension) {
            parsedVersion = theParsedVersion;
            return theParsedVersion;
        }
        versionBits = 0;
        for (int i = 5; i >= 0; i--) {
            for (int j = dimension - 9; j >= ijMin; j--) {
                versionBits = copyBit(i, j, versionBits);
            }
        }
        theParsedVersion = Version.decodeVersionInformation(versionBits);
        if (theParsedVersion != null && theParsedVersion.getDimensionForVersion() == dimension) {
            parsedVersion = theParsedVersion;
            return theParsedVersion;
        }
        throw FormatException.getFormatInstance();
    }
    private int copyBit(int i, int j, int versionBits) {
        boolean bit = mirror ? bitMatrix.get(j, i) : bitMatrix.get(i, j);
        return bit ? (versionBits << 1) | 0x1 : versionBits << 1;
    }
    byte[] readCodewords() throws FormatException {
        FormatInformation formatInfo = readFormatInformation();
        Version version = readVersion();
        DataMask dataMask = DataMask.values()[formatInfo.getDataMask()];
        int dimension = bitMatrix.getHeight();
        dataMask.unmaskBitMatrix(bitMatrix, dimension);
        BitMatrix functionPattern = version.buildFunctionPattern();
        boolean readingUp = true;
        byte[] result = new byte[version.getTotalCodewords()];
        int resultOffset = 0;
        int currentByte = 0;
        int bitsRead = 0;
        for (int j = dimension - 1; j > 0; j -= 2) {
            if (j == 6) {
                j--;
            }
            for (int count = 0; count < dimension; count++) {
                int i = readingUp ? dimension - 1 - count : count;
                for (int col = 0; col < 2; col++) {
                    if (!functionPattern.get(j - col, i)) {
                        bitsRead++;
                        currentByte <<= 1;
                        if (bitMatrix.get(j - col, i)) {
                            currentByte |= 1;
                        }
                        if (bitsRead == 8) {
                            result[resultOffset++] = (byte) currentByte;
                            bitsRead = 0;
                            currentByte = 0;
                        }
                    }
                }
            }
            readingUp ^= true;
        }
        if (resultOffset != version.getTotalCodewords()) {
            throw FormatException.getFormatInstance();
        }
        return result;
    }
    void remask() {
        if (parsedFormatInfo == null) {
            return;
        }
        DataMask dataMask = DataMask.values()[parsedFormatInfo.getDataMask()];
        int dimension = bitMatrix.getHeight();
        dataMask.unmaskBitMatrix(bitMatrix, dimension);
    }
    void setMirror(boolean mirror) {
        parsedVersion = null;
        parsedFormatInfo = null;
        this.mirror = mirror;
    }
    void mirror() {
        for (int x = 0; x < bitMatrix.getWidth(); x++) {
            for (int y = x + 1; y < bitMatrix.getHeight(); y++) {
                if (bitMatrix.get(x, y) != bitMatrix.get(y, x)) {
                    bitMatrix.flip(y, x);
                    bitMatrix.flip(x, y);
                }
            }
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```