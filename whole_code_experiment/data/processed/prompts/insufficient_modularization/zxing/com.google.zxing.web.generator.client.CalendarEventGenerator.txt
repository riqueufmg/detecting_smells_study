##CONTEXT_SIZE=2354
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.zxing.web.generator.client;
public final class CalendarEventGenerator implements GeneratorSource {
    private static final String[] FULL_DAY_ONLY_IDS = { "fullDayOnlyInfo1", "fullDayOnlyInfo2", "fullDayOnlyInfo3", "fullDayOnlyInfo4" };
    private static final long ONE_HOUR = 60L * 60 * 1000;
    private Grid table;
    private final TextBox eventName = new TextBox();
    private final CheckBox fullDay = new CheckBox();
    private final DatePicker datePicker1 = new DatePicker();
    private final DatePicker datePicker2 = new DatePicker();
    private final TextBox timePicker1 = new TextBox();
    private final TextBox timePicker2 = new TextBox();
    private final CheckBox summerTime = new CheckBox();
    private final ListBox timeZones = new ListBox();
    private Date timePicker1PreviousDate;
    private final TextBox location = new TextBox();
    private final TextBox description = new TextBox();
    public CalendarEventGenerator(final ChangeHandler handler, KeyPressHandler keyListener) {
        eventName.addStyleName(StylesDefs.INPUT_FIELD_REQUIRED);
        eventName.addChangeHandler(handler);
        eventName.addKeyPressHandler(keyListener);
        setDateToTextBox(timePicker1, new Date());
        try {
            setDateToTextBox(timePicker2, addMilliseconds(getDateFromTextBox(timePicker1), ONE_HOUR));
            timePicker1PreviousDate = getDateFromTextBox(timePicker1);
        } catch (GeneratorException ge) {
            throw new IllegalStateException(ge);
        }
        buildTimeZoneList();
        timeZones.setSelectedIndex(25);
        timeZones.addKeyPressHandler(keyListener);
        timePicker1.addValueChangeHandler(new ValueChangeHandler<String>() {
            @Override
            public void onValueChange(ValueChangeEvent<String> valueChangeEvent) {
                Date time = timePicker1PreviousDate;
                Date time1;
                Date time2;
                try {
                    time1 = getDateFromTextBox(timePicker1);
                    time2 = getDateFromTextBox(timePicker2);
                } catch (GeneratorException e) {
                    return;
                }
                if (time2.after(time)) {
                    long diff = time2.getTime() - time.getTime();
                    setDateToTextBox(timePicker2, addMilliseconds(time1, diff));
                } else {
                    setDateToTextBox(timePicker2, addMilliseconds(time1, ONE_HOUR));
                }
                timePicker1PreviousDate = time1;
            }
        });
        timePicker2.addValueChangeHandler(new ValueChangeHandler<String>() {
            @Override
            public void onValueChange(ValueChangeEvent<String> valueChangeEvent) {
                ChangeEvent event = new ChangeEvent() {
                    @Override
                    public Object getSource() {
                        return timePicker2;
                    }
                };
                handler.onChange(event);
            }
        });
    }
    private void buildTimeZoneList() {
        for (TimeZoneInfo info : TimeZoneList.TIMEZONES) {
            timeZones.addItem(info.getGmtRelative() + ' ' + info.getAbbreviation(), String.valueOf(info.getGmtDiff()));
        }
    }
    public String getName() {
        return "Calendar event";
    }
    public Grid getWidget() {
        if (table != null) {
            return table;
        }
        datePicker1.setValue(new Date());
        datePicker2.setValue(new Date());
        table = new Grid(10, 2);
        table.setText(0, 0, "All day event");
        table.setWidget(0, 1, fullDay);
        table.setText(1, 0, "Event title");
        table.setWidget(1, 1, eventName);
        table.setText(2, 0, "Start date");
        table.setWidget(2, 1, datePicker1);
        table.setText(3, 0, "Time");
        table.setWidget(3, 1, timePicker1);
        table.setText(4, 0, "End date");
        table.setWidget(4, 1, datePicker2);
        table.setText(5, 0, "Time");
        table.setWidget(5, 1, timePicker2);
        table.setText(6, 0, "Time zone");
        table.setWidget(6, 1, timeZones);
        table.setText(7, 0, "Daylight savings");
        table.setWidget(7, 1, summerTime);
        table.setText(8, 0, "Location");
        table.setWidget(8, 1, location);
        table.setText(9, 0, "Description");
        table.setWidget(9, 1, description);
        table.getRowFormatter().getElement(3).setId(FULL_DAY_ONLY_IDS[0]);
        table.getRowFormatter().getElement(5).setId(FULL_DAY_ONLY_IDS[1]);
        table.getRowFormatter().getElement(6).setId(FULL_DAY_ONLY_IDS[2]);
        table.getRowFormatter().getElement(7).setId(FULL_DAY_ONLY_IDS[3]);
        fullDay.addClickHandler(new ClickHandler() {
            @Override
            public void onClick(ClickEvent event) {
                CheckBox cb = (CheckBox) event.getSource();
                for (String s : FULL_DAY_ONLY_IDS) {
                    Element element = DOM.getElementById(s);
                    String style = cb.getValue() ? "none" : "";
                    element.getStyle().setProperty("display", style);
                }
            }
        });
        return table;
    }
    public String getText() throws GeneratorException {
        String eventName = getEventNameField();
        String dates = getDateTimeFields();
        String location = getLocationField();
        String description = getDescriptionField();
        return "BEGIN:VEVENT\r\n" + eventName + dates + location + description + "END:VEVENT\r\n";
    }
    private String getEventNameField() throws GeneratorException {
        String inputName = eventName.getText();
        if (inputName.isEmpty()) {
            throw new GeneratorException("Event name must be at least 1 character.");
        }
        if (inputName.contains("\n")) {
            throw new GeneratorException("Event name should not contain \\n characters.");
        }
        return "SUMMARY:" + inputName + "\r\n";
    }
    private String getDateTimeFields() throws GeneratorException {
        if (fullDay.getValue()) {
            return getFullDayDateFields();
        }
        return getDateTimeValues();
    }
    private String getLocationField() throws GeneratorException {
        String locationString = location.getText();
        if (locationString.isEmpty()) {
            return "";
        }
        if (locationString.contains("\n")) {
            throw new GeneratorException("Location should not contain \\n characters.");
        }
        return "LOCATION:" + locationString + "\r\n";
    }
    private String getDescriptionField() throws GeneratorException {
        String descriptionString = description.getText();
        if (descriptionString.isEmpty()) {
            return "";
        }
        if (descriptionString.contains("\n")) {
            throw new GeneratorException("Description should not contain \\n characters.");
        }
        return "DESCRIPTION:" + descriptionString + "\r\n";
    }
    private String getFullDayDateFields() throws GeneratorException {
        Date date1 = datePicker1.getValue();
        Date date2 = datePicker2.getValue();
        if (date1 == null || date2 == null) {
            throw new GeneratorException("Start and end dates must be set.");
        }
        if (date1.after(date2)) {
            throw new GeneratorException("End date cannot be before start date.");
        }
        Date date2PlusDay = new Date(date2.getTime() + 24 * 60 * 60 * 1000);
        DateTimeFormat isoFormatter = DateTimeFormat.getFormat("yyyyMMdd");
        return "DTSTART;VALUE=DATE:" + isoFormatter.format(date1) + "\r\n" + "DTEND;VALUE=DATE:" + isoFormatter.format(date2PlusDay) + "\r\n";
    }
    private String getDateTimeValues() throws GeneratorException {
        Date date1 = datePicker1.getValue();
        Date date2 = datePicker2.getValue();
        Date time1 = getDateFromTextBox(timePicker1);
        Date time2 = getDateFromTextBox(timePicker2);
        if (date1 == null || date2 == null || time1 == null || time2 == null) {
            throw new GeneratorException("Start and end dates/times must be set.");
        }
        String timezoneDelta = timeZones.getValue(timeZones.getSelectedIndex());
        long diffTimeZone = Long.parseLong(timezoneDelta);
        if (summerTime.getValue()) {
            diffTimeZone += ONE_HOUR;
        }
        Date dateTime1 = addMilliseconds(mergeDateAndTime(date1, time1), -diffTimeZone);
        Date dateTime2 = addMilliseconds(mergeDateAndTime(date2, time2), -diffTimeZone);
        if (dateTime1.after(dateTime2)) {
            throw new GeneratorException("Ending date/time cannot be before starting date/time.");
        }
        DateTimeFormat isoFormatter = DateTimeFormat.getFormat("yyyyMMdd'T'HHmmss'Z'");
        return "DTSTART:" + isoFormatter.format(dateTime1) + "\r\n" + "DTEND:" + isoFormatter.format(dateTime2) + "\r\n";
    }
    private static Date mergeDateAndTime(Date date, Date time) {
        DateTimeFormat extractDate = DateTimeFormat.getFormat("yyyyMMdd");
        DateTimeFormat extractTime = DateTimeFormat.getFormat("HHmm");
        DateTimeFormat merger = DateTimeFormat.getFormat("yyyyMMddHHmmss");
        String d = extractDate.format(date);
        String t = extractTime.format(time) + "00";
        return merger.parse(d + t);
    }
    public void validate(Widget widget) throws GeneratorException {
        if (widget == eventName) {
            getEventNameField();
        } else if (widget == datePicker1 || widget == timePicker1 || widget == datePicker2 || widget == timePicker2) {
            getDateTimeFields();
        }
    }
    private static Date addMilliseconds(Date time1, long milliseconds) {
        return new Date(time1.getTime() + milliseconds);
    }
    private static Date getDateFromTextBox(HasText textBox) throws GeneratorException {
        DateTimeFormat extractTime = DateTimeFormat.getFormat("HHmm");
        try {
            return extractTime.parseStrict(textBox.getText());
        } catch (IllegalArgumentException iae) {
            throw new GeneratorException("Invalid time");
        }
    }
    private static void setDateToTextBox(HasText textBox, Date date) {
        DateTimeFormat extractTime = DateTimeFormat.getFormat("HHmm");
        textBox.setText(extractTime.format(date));
    }
    public void setFocus() {
        eventName.setFocus(true);
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```