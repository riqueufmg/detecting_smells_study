##CONTEXT_SIZE=4449
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.zxing.pdf417.decoder;
final class DecodedBitStreamParser {
    private enum Mode {
        ALPHA,
        LOWER,
        MIXED,
        PUNCT,
        ALPHA_SHIFT,
        PUNCT_SHIFT
    }
    private static final int TEXT_COMPACTION_MODE_LATCH = 900;
    private static final int BYTE_COMPACTION_MODE_LATCH = 901;
    private static final int NUMERIC_COMPACTION_MODE_LATCH = 902;
    private static final int BYTE_COMPACTION_MODE_LATCH_6 = 924;
    private static final int ECI_USER_DEFINED = 925;
    private static final int ECI_GENERAL_PURPOSE = 926;
    private static final int ECI_CHARSET = 927;
    private static final int BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;
    private static final int BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;
    private static final int MACRO_PDF417_TERMINATOR = 922;
    private static final int MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;
    private static final int MAX_NUMERIC_CODEWORDS = 15;
    private static final int MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;
    private static final int MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;
    private static final int MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;
    private static final int MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;
    private static final int MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;
    private static final int MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;
    private static final int MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;
    private static final int PL = 25;
    private static final int LL = 27;
    private static final int AS = 27;
    private static final int ML = 28;
    private static final int AL = 28;
    private static final int PS = 29;
    private static final int PAL = 29;
    private static final char[] PUNCT_CHARS = ";<>@[\\]_`~!\r\t,:\n-.$/\"|*()?{}'".toCharArray();
    private static final char[] MIXED_CHARS = "0123456789&\r\t,:#-.$/+%*=^".toCharArray();
    private static final BigInteger[] EXP900;
    static {
        EXP900 = new BigInteger[16];
        EXP900[0] = BigInteger.ONE;
        BigInteger nineHundred = BigInteger.valueOf(900);
        EXP900[1] = nineHundred;
        for (int i = 2; i < EXP900.length; i++) {
            EXP900[i] = EXP900[i - 1].multiply(nineHundred);
        }
    }
    private static final int NUMBER_OF_SEQUENCE_CODEWORDS = 2;
    private DecodedBitStreamParser() {
    }
    static DecoderResult decode(int[] codewords, String ecLevel) throws FormatException {
        ECIStringBuilder result = new ECIStringBuilder(codewords.length * 2);
        int codeIndex = textCompaction(codewords, 1, result);
        PDF417ResultMetadata resultMetadata = new PDF417ResultMetadata();
        while (codeIndex < codewords[0]) {
            int code = codewords[codeIndex++];
            switch(code) {
                case TEXT_COMPACTION_MODE_LATCH:
                    codeIndex = textCompaction(codewords, codeIndex, result);
                    break;
                case BYTE_COMPACTION_MODE_LATCH:
                case BYTE_COMPACTION_MODE_LATCH_6:
                    codeIndex = byteCompaction(code, codewords, codeIndex, result);
                    break;
                case MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append((char) codewords[codeIndex++]);
                    break;
                case NUMERIC_COMPACTION_MODE_LATCH:
                    codeIndex = numericCompaction(codewords, codeIndex, result);
                    break;
                case ECI_CHARSET:
                    result.appendECI(codewords[codeIndex++]);
                    break;
                case ECI_GENERAL_PURPOSE:
                    codeIndex += 2;
                    break;
                case ECI_USER_DEFINED:
                    codeIndex++;
                    break;
                case BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                    codeIndex = decodeMacroBlock(codewords, codeIndex, resultMetadata);
                    break;
                case BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                case MACRO_PDF417_TERMINATOR:
                    throw FormatException.getFormatInstance();
                default:
                    codeIndex--;
                    codeIndex = textCompaction(codewords, codeIndex, result);
                    break;
            }
        }
        if (result.isEmpty() && resultMetadata.getFileId() == null) {
            throw FormatException.getFormatInstance();
        }
        DecoderResult decoderResult = new DecoderResult(null, result.toString(), null, ecLevel);
        decoderResult.setOther(resultMetadata);
        return decoderResult;
    }
    static int decodeMacroBlock(int[] codewords, int codeIndex, PDF417ResultMetadata resultMetadata) throws FormatException {
        if (codeIndex + NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {
            throw FormatException.getFormatInstance();
        }
        int[] segmentIndexArray = new int[NUMBER_OF_SEQUENCE_CODEWORDS];
        for (int i = 0; i < NUMBER_OF_SEQUENCE_CODEWORDS; i++, codeIndex++) {
            segmentIndexArray[i] = codewords[codeIndex];
        }
        String segmentIndexString = decodeBase900toBase10(segmentIndexArray, NUMBER_OF_SEQUENCE_CODEWORDS);
        if (segmentIndexString.isEmpty()) {
            resultMetadata.setSegmentIndex(0);
        } else {
            try {
                resultMetadata.setSegmentIndex(Integer.parseInt(segmentIndexString));
            } catch (NumberFormatException nfe) {
                throw FormatException.getFormatInstance();
            }
        }
        StringBuilder fileId = new StringBuilder();
        while (codeIndex < codewords[0] && codeIndex < codewords.length && codewords[codeIndex] != MACRO_PDF417_TERMINATOR && codewords[codeIndex] != BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {
            fileId.append(String.format("%03d", codewords[codeIndex]));
            codeIndex++;
        }
        if (fileId.length() == 0) {
            throw FormatException.getFormatInstance();
        }
        resultMetadata.setFileId(fileId.toString());
        int optionalFieldsStart = -1;
        if (codewords[codeIndex] == BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {
            optionalFieldsStart = codeIndex + 1;
        }
        while (codeIndex < codewords[0]) {
            switch(codewords[codeIndex]) {
                case BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                    codeIndex++;
                    switch(codewords[codeIndex]) {
                        case MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:
                            ECIStringBuilder fileName = new ECIStringBuilder();
                            codeIndex = textCompaction(codewords, codeIndex + 1, fileName);
                            resultMetadata.setFileName(fileName.toString());
                            break;
                        case MACRO_PDF417_OPTIONAL_FIELD_SENDER:
                            ECIStringBuilder sender = new ECIStringBuilder();
                            codeIndex = textCompaction(codewords, codeIndex + 1, sender);
                            resultMetadata.setSender(sender.toString());
                            break;
                        case MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:
                            ECIStringBuilder addressee = new ECIStringBuilder();
                            codeIndex = textCompaction(codewords, codeIndex + 1, addressee);
                            resultMetadata.setAddressee(addressee.toString());
                            break;
                        case MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:
                            ECIStringBuilder segmentCount = new ECIStringBuilder();
                            codeIndex = numericCompaction(codewords, codeIndex + 1, segmentCount);
                            try {
                                resultMetadata.setSegmentCount(Integer.parseInt(segmentCount.toString()));
                            } catch (NumberFormatException nfe) {
                                throw FormatException.getFormatInstance();
                            }
                            break;
                        case MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:
                            ECIStringBuilder timestamp = new ECIStringBuilder();
                            codeIndex = numericCompaction(codewords, codeIndex + 1, timestamp);
                            try {
                                resultMetadata.setTimestamp(Long.parseLong(timestamp.toString()));
                            } catch (NumberFormatException nfe) {
                                throw FormatException.getFormatInstance();
                            }
                            break;
                        case MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:
                            ECIStringBuilder checksum = new ECIStringBuilder();
                            codeIndex = numericCompaction(codewords, codeIndex + 1, checksum);
                            try {
                                resultMetadata.setChecksum(Integer.parseInt(checksum.toString()));
                            } catch (NumberFormatException nfe) {
                                throw FormatException.getFormatInstance();
                            }
                            break;
                        case MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:
                            ECIStringBuilder fileSize = new ECIStringBuilder();
                            codeIndex = numericCompaction(codewords, codeIndex + 1, fileSize);
                            try {
                                resultMetadata.setFileSize(Long.parseLong(fileSize.toString()));
                            } catch (NumberFormatException nfe) {
                                throw FormatException.getFormatInstance();
                            }
                            break;
                        default:
                            throw FormatException.getFormatInstance();
                    }
                    break;
                case MACRO_PDF417_TERMINATOR:
                    codeIndex++;
                    resultMetadata.setLastSegment(true);
                    break;
                default:
                    throw FormatException.getFormatInstance();
            }
        }
        if (optionalFieldsStart != -1) {
            int optionalFieldsLength = codeIndex - optionalFieldsStart;
            if (resultMetadata.isLastSegment()) {
                optionalFieldsLength--;
            }
            if (optionalFieldsLength > 0) {
                resultMetadata.setOptionalData(Arrays.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));
            }
        }
        return codeIndex;
    }
    private static int textCompaction(int[] codewords, int codeIndex, ECIStringBuilder result) throws FormatException {
        int[] textCompactionData = new int[(codewords[0] - codeIndex) * 2];
        int[] byteCompactionData = new int[(codewords[0] - codeIndex) * 2];
        int index = 0;
        boolean end = false;
        Mode subMode = Mode.ALPHA;
        while ((codeIndex < codewords[0]) && !end) {
            int code = codewords[codeIndex++];
            if (code < TEXT_COMPACTION_MODE_LATCH) {
                textCompactionData[index] = code / 30;
                textCompactionData[index + 1] = code % 30;
                index += 2;
            } else {
                switch(code) {
                    case TEXT_COMPACTION_MODE_LATCH:
                        textCompactionData[index++] = TEXT_COMPACTION_MODE_LATCH;
                        break;
                    case BYTE_COMPACTION_MODE_LATCH:
                    case BYTE_COMPACTION_MODE_LATCH_6:
                    case NUMERIC_COMPACTION_MODE_LATCH:
                    case BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                    case BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                    case MACRO_PDF417_TERMINATOR:
                        codeIndex--;
                        end = true;
                        break;
                    case MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                        textCompactionData[index] = MODE_SHIFT_TO_BYTE_COMPACTION_MODE;
                        code = codewords[codeIndex++];
                        byteCompactionData[index] = code;
                        index++;
                        break;
                    case ECI_CHARSET:
                        subMode = decodeTextCompaction(textCompactionData, byteCompactionData, index, result, subMode);
                        result.appendECI(codewords[codeIndex++]);
                        if (codeIndex > codewords[0]) {
                            throw FormatException.getFormatInstance();
                        }
                        textCompactionData = new int[(codewords[0] - codeIndex) * 2];
                        byteCompactionData = new int[(codewords[0] - codeIndex) * 2];
                        index = 0;
                        break;
                }
            }
        }
        decodeTextCompaction(textCompactionData, byteCompactionData, index, result, subMode);
        return codeIndex;
    }
    private static Mode decodeTextCompaction(int[] textCompactionData, int[] byteCompactionData, int length, ECIStringBuilder result, Mode startMode) {
        Mode subMode = startMode;
        Mode priorToShiftMode = startMode;
        Mode latchedMode = startMode;
        int i = 0;
        while (i < length) {
            int subModeCh = textCompactionData[i];
            char ch = 0;
            switch(subMode) {
                case ALPHA:
                    if (subModeCh < 26) {
                        ch = (char) ('A' + subModeCh);
                    } else {
                        switch(subModeCh) {
                            case 26:
                                ch = ' ';
                                break;
                            case LL:
                                subMode = Mode.LOWER;
                                latchedMode = subMode;
                                break;
                            case ML:
                                subMode = Mode.MIXED;
                                latchedMode = subMode;
                                break;
                            case PS:
                                priorToShiftMode = subMode;
                                subMode = Mode.PUNCT_SHIFT;
                                break;
                            case MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                result.append((char) byteCompactionData[i]);
                                break;
                            case TEXT_COMPACTION_MODE_LATCH:
                                subMode = Mode.ALPHA;
                                latchedMode = subMode;
                                break;
                        }
                    }
                    break;
                case LOWER:
                    if (subModeCh < 26) {
                        ch = (char) ('a' + subModeCh);
                    } else {
                        switch(subModeCh) {
                            case 26:
                                ch = ' ';
                                break;
                            case AS:
                                priorToShiftMode = subMode;
                                subMode = Mode.ALPHA_SHIFT;
                                break;
                            case ML:
                                subMode = Mode.MIXED;
                                latchedMode = subMode;
                                break;
                            case PS:
                                priorToShiftMode = subMode;
                                subMode = Mode.PUNCT_SHIFT;
                                break;
                            case MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                result.append((char) byteCompactionData[i]);
                                break;
                            case TEXT_COMPACTION_MODE_LATCH:
                                subMode = Mode.ALPHA;
                                latchedMode = subMode;
                                break;
                        }
                    }
                    break;
                case MIXED:
                    if (subModeCh < PL) {
                        ch = MIXED_CHARS[subModeCh];
                    } else {
                        switch(subModeCh) {
                            case PL:
                                subMode = Mode.PUNCT;
                                latchedMode = subMode;
                                break;
                            case 26:
                                ch = ' ';
                                break;
                            case LL:
                                subMode = Mode.LOWER;
                                latchedMode = subMode;
                                break;
                            case AL:
                            case TEXT_COMPACTION_MODE_LATCH:
                                subMode = Mode.ALPHA;
                                latchedMode = subMode;
                                break;
                            case PS:
                                priorToShiftMode = subMode;
                                subMode = Mode.PUNCT_SHIFT;
                                break;
                            case MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                result.append((char) byteCompactionData[i]);
                                break;
                        }
                    }
                    break;
                case PUNCT:
                    if (subModeCh < PAL) {
                        ch = PUNCT_CHARS[subModeCh];
                    } else {
                        switch(subModeCh) {
                            case PAL:
                            case TEXT_COMPACTION_MODE_LATCH:
                                subMode = Mode.ALPHA;
                                latchedMode = subMode;
                                break;
                            case MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                result.append((char) byteCompactionData[i]);
                                break;
                        }
                    }
                    break;
                case ALPHA_SHIFT:
                    subMode = priorToShiftMode;
                    if (subModeCh < 26) {
                        ch = (char) ('A' + subModeCh);
                    } else {
                        switch(subModeCh) {
                            case 26:
                                ch = ' ';
                                break;
                            case TEXT_COMPACTION_MODE_LATCH:
                                subMode = Mode.ALPHA;
                                break;
                        }
                    }
                    break;
                case PUNCT_SHIFT:
                    subMode = priorToShiftMode;
                    if (subModeCh < PAL) {
                        ch = PUNCT_CHARS[subModeCh];
                    } else {
                        switch(subModeCh) {
                            case PAL:
                            case TEXT_COMPACTION_MODE_LATCH:
                                subMode = Mode.ALPHA;
                                break;
                            case MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                result.append((char) byteCompactionData[i]);
                                break;
                        }
                    }
                    break;
            }
            if (ch != 0) {
                result.append(ch);
            }
            i++;
        }
        return latchedMode;
    }
    private static int byteCompaction(int mode, int[] codewords, int codeIndex, ECIStringBuilder result) throws FormatException {
        boolean end = false;
        while (codeIndex < codewords[0] && !end) {
            while (codeIndex < codewords[0] && codewords[codeIndex] == ECI_CHARSET) {
                result.appendECI(codewords[++codeIndex]);
                codeIndex++;
            }
            if (codeIndex >= codewords[0] || codewords[codeIndex] >= TEXT_COMPACTION_MODE_LATCH) {
                end = true;
            } else {
                long value = 0;
                int count = 0;
                do {
                    value = 900 * value + codewords[codeIndex++];
                    count++;
                } while (count < 5 && codeIndex < codewords[0] && codewords[codeIndex] < TEXT_COMPACTION_MODE_LATCH);
                if (count == 5 && (mode == BYTE_COMPACTION_MODE_LATCH_6 || codeIndex < codewords[0] && codewords[codeIndex] < TEXT_COMPACTION_MODE_LATCH)) {
                    for (int i = 0; i < 6; i++) {
                        result.append((byte) (value >> (8 * (5 - i))));
                    }
                } else {
                    codeIndex -= count;
                    while ((codeIndex < codewords[0]) && !end) {
                        int code = codewords[codeIndex++];
                        if (code < TEXT_COMPACTION_MODE_LATCH) {
                            result.append((byte) code);
                        } else if (code == ECI_CHARSET) {
                            result.appendECI(codewords[codeIndex++]);
                        } else {
                            codeIndex--;
                            end = true;
                        }
                    }
                }
            }
        }
        return codeIndex;
    }
    private static int numericCompaction(int[] codewords, int codeIndex, ECIStringBuilder result) throws FormatException {
        int count = 0;
        boolean end = false;
        int[] numericCodewords = new int[MAX_NUMERIC_CODEWORDS];
        while (codeIndex < codewords[0] && !end) {
            int code = codewords[codeIndex++];
            if (codeIndex == codewords[0]) {
                end = true;
            }
            if (code < TEXT_COMPACTION_MODE_LATCH) {
                numericCodewords[count] = code;
                count++;
            } else {
                switch(code) {
                    case TEXT_COMPACTION_MODE_LATCH:
                    case BYTE_COMPACTION_MODE_LATCH:
                    case BYTE_COMPACTION_MODE_LATCH_6:
                    case BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                    case BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                    case MACRO_PDF417_TERMINATOR:
                    case ECI_CHARSET:
                        codeIndex--;
                        end = true;
                        break;
                }
            }
            if ((count % MAX_NUMERIC_CODEWORDS == 0 || code == NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {
                result.append(decodeBase900toBase10(numericCodewords, count));
                count = 0;
            }
        }
        return codeIndex;
    }
    private static String decodeBase900toBase10(int[] codewords, int count) throws FormatException {
        BigInteger result = BigInteger.ZERO;
        for (int i = 0; i < count; i++) {
            result = result.add(EXP900[count - i - 1].multiply(BigInteger.valueOf(codewords[i])));
        }
        String resultString = result.toString();
        if (resultString.charAt(0) != '1') {
            throw FormatException.getFormatInstance();
        }
        return resultString.substring(1);
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```