##CONTEXT_SIZE=4102
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.zxing.aztec.detector;
public final class Detector {
    private static final int[] EXPECTED_CORNER_BITS = { 0xee0, 0x1dc, 0x83b, 0x707 };
    private final BitMatrix image;
    private boolean compact;
    private int nbLayers;
    private int nbDataBlocks;
    private int nbCenterLayers;
    private int shift;
    public Detector(BitMatrix image) {
        this.image = image;
    }
    public AztecDetectorResult detect() throws NotFoundException {
        return detect(false);
    }
    public AztecDetectorResult detect(boolean isMirror) throws NotFoundException {
        Point pCenter = getMatrixCenter();
        ResultPoint[] bullsEyeCorners = getBullsEyeCorners(pCenter);
        if (isMirror) {
            ResultPoint temp = bullsEyeCorners[0];
            bullsEyeCorners[0] = bullsEyeCorners[2];
            bullsEyeCorners[2] = temp;
        }
        int errorsCorrected = extractParameters(bullsEyeCorners);
        BitMatrix bits = sampleGrid(image, bullsEyeCorners[shift % 4], bullsEyeCorners[(shift + 1) % 4], bullsEyeCorners[(shift + 2) % 4], bullsEyeCorners[(shift + 3) % 4]);
        ResultPoint[] corners = getMatrixCornerPoints(bullsEyeCorners);
        return new AztecDetectorResult(bits, corners, compact, nbDataBlocks, nbLayers, errorsCorrected);
    }
    private int extractParameters(ResultPoint[] bullsEyeCorners) throws NotFoundException {
        if (!isValid(bullsEyeCorners[0]) || !isValid(bullsEyeCorners[1]) || !isValid(bullsEyeCorners[2]) || !isValid(bullsEyeCorners[3])) {
            throw NotFoundException.getNotFoundInstance();
        }
        int length = 2 * nbCenterLayers;
        int[] sides = { sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length), sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length), sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length), sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) };
        shift = getRotation(sides, length);
        long parameterData = 0;
        for (int i = 0; i < 4; i++) {
            int side = sides[(shift + i) % 4];
            if (compact) {
                parameterData <<= 7;
                parameterData += (side >> 1) & 0x7F;
            } else {
                parameterData <<= 10;
                parameterData += ((side >> 2) & (0x1f << 5)) + ((side >> 1) & 0x1F);
            }
        }
        CorrectedParameter correctedParam = getCorrectedParameterData(parameterData, compact);
        int correctedData = correctedParam.getData();
        if (compact) {
            nbLayers = (correctedData >> 6) + 1;
            nbDataBlocks = (correctedData & 0x3F) + 1;
        } else {
            nbLayers = (correctedData >> 11) + 1;
            nbDataBlocks = (correctedData & 0x7FF) + 1;
        }
        return correctedParam.getErrorsCorrected();
    }
    private static int getRotation(int[] sides, int length) throws NotFoundException {
        int cornerBits = 0;
        for (int side : sides) {
            int t = ((side >> (length - 2)) << 1) + (side & 1);
            cornerBits = (cornerBits << 3) + t;
        }
        cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);
        for (int shift = 0; shift < 4; shift++) {
            if (Integer.bitCount(cornerBits ^ EXPECTED_CORNER_BITS[shift]) <= 2) {
                return shift;
            }
        }
        throw NotFoundException.getNotFoundInstance();
    }
    private static CorrectedParameter getCorrectedParameterData(long parameterData, boolean compact) throws NotFoundException {
        int numCodewords;
        int numDataCodewords;
        if (compact) {
            numCodewords = 7;
            numDataCodewords = 2;
        } else {
            numCodewords = 10;
            numDataCodewords = 4;
        }
        int numECCodewords = numCodewords - numDataCodewords;
        int[] parameterWords = new int[numCodewords];
        for (int i = numCodewords - 1; i >= 0; --i) {
            parameterWords[i] = (int) parameterData & 0xF;
            parameterData >>= 4;
        }
        int errorsCorrected = 0;
        try {
            ReedSolomonDecoder rsDecoder = new ReedSolomonDecoder(GenericGF.AZTEC_PARAM);
            errorsCorrected = rsDecoder.decodeWithECCount(parameterWords, numECCodewords);
        } catch (ReedSolomonException ignored) {
            throw NotFoundException.getNotFoundInstance();
        }
        int result = 0;
        for (int i = 0; i < numDataCodewords; i++) {
            result = (result << 4) + parameterWords[i];
        }
        return new CorrectedParameter(result, errorsCorrected);
    }
    private ResultPoint[] getBullsEyeCorners(Point pCenter) throws NotFoundException {
        Point pina = pCenter;
        Point pinb = pCenter;
        Point pinc = pCenter;
        Point pind = pCenter;
        boolean color = true;
        for (nbCenterLayers = 1; nbCenterLayers < 9; nbCenterLayers++) {
            Point pouta = getFirstDifferent(pina, color, 1, -1);
            Point poutb = getFirstDifferent(pinb, color, 1, 1);
            Point poutc = getFirstDifferent(pinc, color, -1, 1);
            Point poutd = getFirstDifferent(pind, color, -1, -1);
            if (nbCenterLayers > 2) {
                float q = distance(poutd, pouta) * nbCenterLayers / (distance(pind, pina) * (nbCenterLayers + 2));
                if (q < 0.75 || q > 1.25 || !isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {
                    break;
                }
            }
            pina = pouta;
            pinb = poutb;
            pinc = poutc;
            pind = poutd;
            color = !color;
        }
        if (nbCenterLayers != 5 && nbCenterLayers != 7) {
            throw NotFoundException.getNotFoundInstance();
        }
        compact = nbCenterLayers == 5;
        ResultPoint pinax = new ResultPoint(pina.getX() + 0.5f, pina.getY() - 0.5f);
        ResultPoint pinbx = new ResultPoint(pinb.getX() + 0.5f, pinb.getY() + 0.5f);
        ResultPoint pincx = new ResultPoint(pinc.getX() - 0.5f, pinc.getY() + 0.5f);
        ResultPoint pindx = new ResultPoint(pind.getX() - 0.5f, pind.getY() - 0.5f);
        return expandSquare(new ResultPoint[] { pinax, pinbx, pincx, pindx }, 2 * nbCenterLayers - 3, 2 * nbCenterLayers);
    }
    private Point getMatrixCenter() {
        ResultPoint pointA;
        ResultPoint pointB;
        ResultPoint pointC;
        ResultPoint pointD;
        try {
            ResultPoint[] cornerPoints = new WhiteRectangleDetector(image).detect();
            pointA = cornerPoints[0];
            pointB = cornerPoints[1];
            pointC = cornerPoints[2];
            pointD = cornerPoints[3];
        } catch (NotFoundException e) {
            int cx = image.getWidth() / 2;
            int cy = image.getHeight() / 2;
            pointA = getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();
            pointB = getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();
            pointC = getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();
            pointD = getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();
        }
        int cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0f);
        int cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0f);
        try {
            ResultPoint[] cornerPoints = new WhiteRectangleDetector(image, 15, cx, cy).detect();
            pointA = cornerPoints[0];
            pointB = cornerPoints[1];
            pointC = cornerPoints[2];
            pointD = cornerPoints[3];
        } catch (NotFoundException e) {
            pointA = getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();
            pointB = getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();
            pointC = getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();
            pointD = getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();
        }
        cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0f);
        cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0f);
        return new Point(cx, cy);
    }
    private ResultPoint[] getMatrixCornerPoints(ResultPoint[] bullsEyeCorners) {
        return expandSquare(bullsEyeCorners, 2 * nbCenterLayers, getDimension());
    }
    private BitMatrix sampleGrid(BitMatrix image, ResultPoint topLeft, ResultPoint topRight, ResultPoint bottomRight, ResultPoint bottomLeft) throws NotFoundException {
        GridSampler sampler = GridSampler.getInstance();
        int dimension = getDimension();
        float low = dimension / 2.0f - nbCenterLayers;
        float high = dimension / 2.0f + nbCenterLayers;
        return sampler.sampleGrid(image, dimension, dimension, // topleft
        low, low, // topright
        high, low, // bottomright
        high, high, // bottomleft
        low, high, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());
    }
    private int sampleLine(ResultPoint p1, ResultPoint p2, int size) {
        int result = 0;
        float d = distance(p1, p2);
        float moduleSize = d / size;
        float px = p1.getX();
        float py = p1.getY();
        float dx = moduleSize * (p2.getX() - p1.getX()) / d;
        float dy = moduleSize * (p2.getY() - p1.getY()) / d;
        for (int i = 0; i < size; i++) {
            if (image.get(MathUtils.round(px + i * dx), MathUtils.round(py + i * dy))) {
                result |= 1 << (size - i - 1);
            }
        }
        return result;
    }
    private boolean isWhiteOrBlackRectangle(Point p1, Point p2, Point p3, Point p4) {
        int corr = 3;
        p1 = new Point(Math.max(0, p1.getX() - corr), Math.min(image.getHeight() - 1, p1.getY() + corr));
        p2 = new Point(Math.max(0, p2.getX() - corr), Math.max(0, p2.getY() - corr));
        p3 = new Point(Math.min(image.getWidth() - 1, p3.getX() + corr), Math.max(0, Math.min(image.getHeight() - 1, p3.getY() - corr)));
        p4 = new Point(Math.min(image.getWidth() - 1, p4.getX() + corr), Math.min(image.getHeight() - 1, p4.getY() + corr));
        int cInit = getColor(p4, p1);
        if (cInit == 0) {
            return false;
        }
        int c = getColor(p1, p2);
        if (c != cInit) {
            return false;
        }
        c = getColor(p2, p3);
        if (c != cInit) {
            return false;
        }
        c = getColor(p3, p4);
        return c == cInit;
    }
    private int getColor(Point p1, Point p2) {
        float d = distance(p1, p2);
        if (d == 0.0f) {
            return 0;
        }
        float dx = (p2.getX() - p1.getX()) / d;
        float dy = (p2.getY() - p1.getY()) / d;
        int error = 0;
        float px = p1.getX();
        float py = p1.getY();
        boolean colorModel = image.get(p1.getX(), p1.getY());
        int iMax = (int) Math.floor(d);
        for (int i = 0; i < iMax; i++) {
            if (image.get(MathUtils.round(px), MathUtils.round(py)) != colorModel) {
                error++;
            }
            px += dx;
            py += dy;
        }
        float errRatio = error / d;
        if (errRatio > 0.1f && errRatio < 0.9f) {
            return 0;
        }
        return (errRatio <= 0.1f) == colorModel ? 1 : -1;
    }
    private Point getFirstDifferent(Point init, boolean color, int dx, int dy) {
        int x = init.getX() + dx;
        int y = init.getY() + dy;
        while (isValid(x, y) && image.get(x, y) == color) {
            x += dx;
            y += dy;
        }
        x -= dx;
        y -= dy;
        while (isValid(x, y) && image.get(x, y) == color) {
            x += dx;
        }
        x -= dx;
        while (isValid(x, y) && image.get(x, y) == color) {
            y += dy;
        }
        y -= dy;
        return new Point(x, y);
    }
    private static ResultPoint[] expandSquare(ResultPoint[] cornerPoints, int oldSide, int newSide) {
        float ratio = newSide / (2.0f * oldSide);
        float dx = cornerPoints[0].getX() - cornerPoints[2].getX();
        float dy = cornerPoints[0].getY() - cornerPoints[2].getY();
        float centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0f;
        float centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0f;
        ResultPoint result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
        ResultPoint result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);
        dx = cornerPoints[1].getX() - cornerPoints[3].getX();
        dy = cornerPoints[1].getY() - cornerPoints[3].getY();
        centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0f;
        centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0f;
        ResultPoint result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
        ResultPoint result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);
        return new ResultPoint[] { result0, result1, result2, result3 };
    }
    private boolean isValid(int x, int y) {
        return x >= 0 && x < image.getWidth() && y >= 0 && y < image.getHeight();
    }
    private boolean isValid(ResultPoint point) {
        int x = MathUtils.round(point.getX());
        int y = MathUtils.round(point.getY());
        return isValid(x, y);
    }
    private static float distance(Point a, Point b) {
        return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());
    }
    private static float distance(ResultPoint a, ResultPoint b) {
        return MathUtils.distance(a.getX(), a.getY(), b.getX(), b.getY());
    }
    private int getDimension() {
        if (compact) {
            return 4 * nbLayers + 11;
        }
        return 4 * nbLayers + 2 * ((2 * nbLayers + 6) / 15) + 15;
    }
    static final class Point {
        private final int x;
        private final int y;
        ResultPoint toResultPoint() {
            return new ResultPoint(x, y);
        }
        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
        int getX() {
            return x;
        }
        int getY() {
            return y;
        }
        public String toString() {
            return "<" + x + ' ' + y + '>';
        }
    }
    static final class CorrectedParameter {
        private final int data;
        private final int errorsCorrected;
        CorrectedParameter(int data, int errorsCorrected) {
            this.data = data;
            this.errorsCorrected = errorsCorrected;
        }
        int getData() {
            return data;
        }
        int getErrorsCorrected() {
            return errorsCorrected;
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```