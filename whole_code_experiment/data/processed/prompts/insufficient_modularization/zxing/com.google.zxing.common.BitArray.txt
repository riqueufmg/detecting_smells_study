##CONTEXT_SIZE=1842
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.zxing.common;
public final class BitArray implements Cloneable {
    private static final int[] EMPTY_BITS = {};
    private static final float LOAD_FACTOR = 0.75f;
    private int[] bits;
    private int size;
    public BitArray() {
        this.size = 0;
        this.bits = EMPTY_BITS;
    }
    public BitArray(int size) {
        this.size = size;
        this.bits = makeArray(size);
    }
    BitArray(int[] bits, int size) {
        this.bits = bits;
        this.size = size;
    }
    public int getSize() {
        return size;
    }
    public int getSizeInBytes() {
        return (size + 7) / 8;
    }
    private void ensureCapacity(int newSize) {
        if (newSize > bits.length * 32) {
            int[] newBits = makeArray((int) Math.ceil(newSize / LOAD_FACTOR));
            System.arraycopy(bits, 0, newBits, 0, bits.length);
            this.bits = newBits;
        }
    }
    public boolean get(int i) {
        return (bits[i / 32] & (1 << (i & 0x1F))) != 0;
    }
    public void set(int i) {
        bits[i / 32] |= 1 << (i & 0x1F);
    }
    public void flip(int i) {
        bits[i / 32] ^= 1 << (i & 0x1F);
    }
    public int getNextSet(int from) {
        if (from >= size) {
            return size;
        }
        int bitsOffset = from / 32;
        int currentBits = bits[bitsOffset];
        currentBits &= -(1 << (from & 0x1F));
        while (currentBits == 0) {
            if (++bitsOffset == bits.length) {
                return size;
            }
            currentBits = bits[bitsOffset];
        }
        int result = (bitsOffset * 32) + Integer.numberOfTrailingZeros(currentBits);
        return Math.min(result, size);
    }
    public int getNextUnset(int from) {
        if (from >= size) {
            return size;
        }
        int bitsOffset = from / 32;
        int currentBits = ~bits[bitsOffset];
        currentBits &= -(1 << (from & 0x1F));
        while (currentBits == 0) {
            if (++bitsOffset == bits.length) {
                return size;
            }
            currentBits = ~bits[bitsOffset];
        }
        int result = (bitsOffset * 32) + Integer.numberOfTrailingZeros(currentBits);
        return Math.min(result, size);
    }
    public void setBulk(int i, int newBits) {
        bits[i / 32] = newBits;
    }
    public void setRange(int start, int end) {
        if (end < start || start < 0 || end > size) {
            throw new IllegalArgumentException();
        }
        if (end == start) {
            return;
        }
        end--;
        int firstInt = start / 32;
        int lastInt = end / 32;
        for (int i = firstInt; i <= lastInt; i++) {
            int firstBit = i > firstInt ? 0 : start & 0x1F;
            int lastBit = i < lastInt ? 31 : end & 0x1F;
            int mask = (2 << lastBit) - (1 << firstBit);
            bits[i] |= mask;
        }
    }
    public void clear() {
        int max = bits.length;
        for (int i = 0; i < max; i++) {
            bits[i] = 0;
        }
    }
    public boolean isRange(int start, int end, boolean value) {
        if (end < start || start < 0 || end > size) {
            throw new IllegalArgumentException();
        }
        if (end == start) {
            return true;
        }
        end--;
        int firstInt = start / 32;
        int lastInt = end / 32;
        for (int i = firstInt; i <= lastInt; i++) {
            int firstBit = i > firstInt ? 0 : start & 0x1F;
            int lastBit = i < lastInt ? 31 : end & 0x1F;
            int mask = (2 << lastBit) - (1 << firstBit);
            if ((bits[i] & mask) != (value ? mask : 0)) {
                return false;
            }
        }
        return true;
    }
    public void appendBit(boolean bit) {
        ensureCapacity(size + 1);
        if (bit) {
            bits[size / 32] |= 1 << (size & 0x1F);
        }
        size++;
    }
    public void appendBits(int value, int numBits) {
        if (numBits < 0 || numBits > 32) {
            throw new IllegalArgumentException("Num bits must be between 0 and 32");
        }
        int nextSize = size;
        ensureCapacity(nextSize + numBits);
        for (int numBitsLeft = numBits - 1; numBitsLeft >= 0; numBitsLeft--) {
            if ((value & (1 << numBitsLeft)) != 0) {
                bits[nextSize / 32] |= 1 << (nextSize & 0x1F);
            }
            nextSize++;
        }
        size = nextSize;
    }
    public void appendBitArray(BitArray other) {
        int otherSize = other.size;
        ensureCapacity(size + otherSize);
        for (int i = 0; i < otherSize; i++) {
            appendBit(other.get(i));
        }
    }
    public void xor(BitArray other) {
        if (size != other.size) {
            throw new IllegalArgumentException("Sizes don't match");
        }
        for (int i = 0; i < bits.length; i++) {
            bits[i] ^= other.bits[i];
        }
    }
    public void toBytes(int bitOffset, byte[] array, int offset, int numBytes) {
        for (int i = 0; i < numBytes; i++) {
            int theByte = 0;
            for (int j = 0; j < 8; j++) {
                if (get(bitOffset)) {
                    theByte |= 1 << (7 - j);
                }
                bitOffset++;
            }
            array[offset + i] = (byte) theByte;
        }
    }
    public int[] getBitArray() {
        return bits;
    }
    public void reverse() {
        int[] newBits = new int[bits.length];
        int len = (size - 1) / 32;
        int oldBitsLen = len + 1;
        for (int i = 0; i < oldBitsLen; i++) {
            newBits[len - i] = Integer.reverse(bits[i]);
        }
        if (size != oldBitsLen * 32) {
            int leftOffset = oldBitsLen * 32 - size;
            int currentInt = newBits[0] >>> leftOffset;
            for (int i = 1; i < oldBitsLen; i++) {
                int nextInt = newBits[i];
                currentInt |= nextInt << (32 - leftOffset);
                newBits[i - 1] = currentInt;
                currentInt = nextInt >>> leftOffset;
            }
            newBits[oldBitsLen - 1] = currentInt;
        }
        bits = newBits;
    }
    private static int[] makeArray(int size) {
        return new int[(size + 31) / 32];
    }
    public boolean equals(Object o) {
        if (!(o instanceof BitArray)) {
            return false;
        }
        BitArray other = (BitArray) o;
        return size == other.size && Arrays.equals(bits, other.bits);
    }
    public int hashCode() {
        return 31 * size + Arrays.hashCode(bits);
    }
    public String toString() {
        StringBuilder result = new StringBuilder(size + (size / 8) + 1);
        for (int i = 0; i < size; i++) {
            if ((i & 0x07) == 0) {
                result.append(' ');
            }
            result.append(get(i) ? 'X' : '.');
        }
        return result.toString();
    }
    public BitArray clone() {
        return new BitArray(bits.clone(), size);
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```