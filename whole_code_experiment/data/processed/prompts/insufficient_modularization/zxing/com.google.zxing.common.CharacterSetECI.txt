##CONTEXT_SIZE=830
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package com.google.zxing.common;
public enum CharacterSetECI {
    Cp437(new int[] { 0, 2 }),
    ISO8859_1(new int[] { 1, 3 }, "ISO-8859-1"),
    ISO8859_2(4, "ISO-8859-2"),
    ISO8859_3(5, "ISO-8859-3"),
    ISO8859_4(6, "ISO-8859-4"),
    ISO8859_5(7, "ISO-8859-5"),
    ISO8859_6(8, "ISO-8859-6"),
    ISO8859_7(9, "ISO-8859-7"),
    ISO8859_8(10, "ISO-8859-8"),
    ISO8859_9(11, "ISO-8859-9"),
    ISO8859_10(12, "ISO-8859-10"),
    ISO8859_11(13, "ISO-8859-11"),
    ISO8859_13(15, "ISO-8859-13"),
    ISO8859_14(16, "ISO-8859-14"),
    ISO8859_15(17, "ISO-8859-15"),
    ISO8859_16(18, "ISO-8859-16"),
    SJIS(20, "Shift_JIS"),
    Cp1250(21, "windows-1250"),
    Cp1251(22, "windows-1251"),
    Cp1252(23, "windows-1252"),
    Cp1256(24, "windows-1256"),
    UnicodeBigUnmarked(25, "UTF-16BE", "UnicodeBig"),
    UTF8(26, "UTF-8"),
    ASCII(new int[] { 27, 170 }, "US-ASCII"),
    Big5(28),
    GB18030(29, "GB2312", "EUC_CN", "GBK"),
    EUC_KR(30, "EUC-KR");
    private static final Map<Integer, CharacterSetECI> VALUE_TO_ECI = new HashMap<>();
    private static final Map<String, CharacterSetECI> NAME_TO_ECI = new HashMap<>();
    static {
        for (CharacterSetECI eci : values()) {
            if (Charset.isSupported(eci.name())) {
                for (int value : eci.values) {
                    VALUE_TO_ECI.put(value, eci);
                }
                NAME_TO_ECI.put(eci.name(), eci);
                for (String name : eci.otherEncodingNames) {
                    NAME_TO_ECI.put(name, eci);
                }
            }
        }
    }
    private final int[] values;
    private final String[] otherEncodingNames;
    CharacterSetECI(int value) {
        this(new int[] { value });
    }
    CharacterSetECI(int value, String... otherEncodingNames) {
        this.values = new int[] { value };
        this.otherEncodingNames = otherEncodingNames;
    }
    CharacterSetECI(int[] values, String... otherEncodingNames) {
        this.values = values;
        this.otherEncodingNames = otherEncodingNames;
    }
    public int getValue() {
        return values[0];
    }
    public Charset getCharset() {
        return Charset.forName(name());
    }
    public static CharacterSetECI getCharacterSetECI(Charset charset) {
        return NAME_TO_ECI.get(charset.name());
    }
    public static CharacterSetECI getCharacterSetECIByValue(int value) throws FormatException {
        if (value < 0 || value >= 900) {
            throw FormatException.getFormatInstance();
        }
        return VALUE_TO_ECI.get(value);
    }
    public static CharacterSetECI getCharacterSetECIByName(String name) {
        return NAME_TO_ECI.get(name);
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```