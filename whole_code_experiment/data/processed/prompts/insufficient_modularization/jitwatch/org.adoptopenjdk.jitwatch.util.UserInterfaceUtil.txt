##CONTEXT_SIZE=1488
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.util;
public final class UserInterfaceUtil {
    private static final Logger logger = LoggerFactory.getLogger(UserInterfaceUtil.class);
    private static final String RESOURCE_NAME = "i18n.lang";
    private static final ObservableResourceFactory RESOURCE_FACTORY = new ObservableResourceFactory();
    static {
        RESOURCE_FACTORY.setResources(ResourceBundle.getBundle(RESOURCE_NAME));
    }
    public static final Image IMAGE_TICK;
    public static final Image IMAGE_CAMERA;
    public static final String FONT_MONOSPACE_FAMILY;
    public static final String FONT_MONOSPACE_SIZE;
    public static final boolean ADD_CLOSE_DECORATION;
    private UserInterfaceUtil() {
    }
    static {
        IMAGE_TICK = loadResource("/images/tick.png");
        IMAGE_CAMERA = loadResource("/images/camera.png");
        FONT_MONOSPACE_FAMILY = System.getProperty("monospaceFontFamily", Font.font(java.awt.Font.MONOSPACED, 12).getName());
        FONT_MONOSPACE_SIZE = System.getProperty("monospaceFontSize", "12");
        ADD_CLOSE_DECORATION = Boolean.getBoolean("addCloseDecoration");
    }
    public static void configureLocale(Locale locale) {
        UserInterfaceUtil.RESOURCE_FACTORY.setResources(ResourceBundle.getBundle(UserInterfaceUtil.RESOURCE_NAME, locale));
    }
    public static Button createButton(String langKey, ObservableValue<?>... observables) {
        Button button = new Button();
        button.textProperty().bind(RESOURCE_FACTORY.getStringBinding(langKey, observables));
        String tooltipKey = langKey + "_tt";
        if (RESOURCE_FACTORY.containsKey(tooltipKey)) {
            button.tooltipProperty().bind(new TooltipBinding(button.textProperty(), tooltipKey));
        }
        return button;
    }
    public static CheckBox createCheckBox(String langKey) {
        CheckBox checkBox = new CheckBox();
        checkBox.textProperty().bind(RESOURCE_FACTORY.getStringBinding(langKey));
        String tooltipKey = langKey + "_tt";
        if (RESOURCE_FACTORY.containsKey(tooltipKey)) {
            checkBox.tooltipProperty().bind(new TooltipBinding(checkBox.textProperty(), tooltipKey));
        }
        return checkBox;
    }
    public static Label createLabel(String langKey) {
        Label label = new Label();
        label.textProperty().bind(RESOURCE_FACTORY.getStringBinding(langKey));
        String tooltipKey = langKey + "_tt";
        if (RESOURCE_FACTORY.containsKey(tooltipKey)) {
            label.tooltipProperty().bind(new TooltipBinding(label.textProperty(), tooltipKey));
        }
        return label;
    }
    public static <S, T> TableColumn<S, T> createTableColumn(String langKey) {
        TableColumn<S, T> tableColumn = new TableColumn<>();
        tableColumn.textProperty().bind(RESOURCE_FACTORY.getStringBinding(langKey));
        return tableColumn;
    }
    private static Image loadResource(String path) {
        InputStream inputStream = UserInterfaceUtil.class.getResourceAsStream(path);
        Image result = null;
        if (inputStream != null) {
            result = new Image(inputStream);
        } else {
            logger.error("Could not load resource {}. If running in an IDE please add [ui,core]/src/main/resources to your classpath", path);
        }
        return result;
    }
    public static Button getSnapshotButton(final Scene scene, final String filenamePrefix) {
        Button buttonSnapShot = new Button();
        Image image = UserInterfaceUtil.IMAGE_CAMERA;
        buttonSnapShot.setGraphic(new ImageView(image));
        buttonSnapShot.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                takeSnapShot(scene, filenamePrefix);
            }
        });
        return buttonSnapShot;
    }
    private static void takeSnapShot(Scene scene, String filenamePrefix) {
        WritableImage imageSnap = new WritableImage((int) scene.getWidth(), (int) scene.getHeight());
        scene.snapshot(imageSnap);
        SimpleDateFormat sfd = new SimpleDateFormat("yyyy.MM.dd.HH.mm.ss");
        try {
            String snapshotFilename = filenamePrefix + "-snapshot-" + sfd.format(new Date()) + ".png";
            Class<?> classImageIO = Class.forName("javax.imageio.ImageIO");
            Class<?> classSwingFXUtils = Class.forName("javafx.embed.swing.SwingFXUtils");
            Method methodWrite = classImageIO.getMethod("write", java.awt.image.RenderedImage.class, String.class, File.class);
            Method methodFromFXImage = classSwingFXUtils.getMethod("fromFXImage", Image.class, java.awt.image.BufferedImage.class);
            methodWrite.invoke(null, methodFromFXImage.invoke(null, imageSnap, null), "png", new File(snapshotFilename));
        } catch (Throwable t) {
            logger.error("Could not create snapshot", t);
        }
    }
    public static Scene getScene(Parent rootNode, double width, double height) {
        Scene scene = new Scene(rootNode, width, height);
        String styleSheet = UserInterfaceUtil.class.getResource("/style.css").toExternalForm();
        scene.getStylesheets().add(styleSheet);
        return scene;
    }
    public static Color getColourForBytecodeAnnotation(BCAnnotationType type) {
        Color colourSuccess = Color.GREEN;
        Color colourFailure = Color.RED;
        Color colourInformation = Color.BLUE;
        switch(type) {
            case ELIMINATED_ALLOCATION:
            case INLINE_SUCCESS:
            case HOT_THROW_PREALLOCATED:
                return colourSuccess;
            case INLINE_FAIL:
            case HOT_THROW_NOT_PREALLOCATED:
            case VIRTUAL_CALL:
                return colourFailure;
            case BRANCH:
            case UNCOMMON_TRAP:
            case INTRINSIC_USED:
                return colourInformation;
            default:
                return Color.BLACK;
        }
    }
    public static double fix(double pixel) {
        return 0.5 + (int) pixel;
    }
    public static void initMacFonts() {
        try {
            final Class<?> macFontFinderClass = Class.forName("com.sun.t2k.MacFontFinder");
            final Field psNameToPathMap = macFontFinderClass.getDeclaredField("psNameToPathMap");
            psNameToPathMap.setAccessible(true);
            if (psNameToPathMap.get(null) == null) {
                psNameToPathMap.set(null, new HashMap<>());
            }
            final Field allAvailableFontFamilies = macFontFinderClass.getDeclaredField("allAvailableFontFamilies");
            allAvailableFontFamilies.setAccessible(true);
            if (allAvailableFontFamilies.get(null) == null) {
                allAvailableFontFamilies.set(null, new String[] {});
            }
        } catch (Exception e) {
            logger.error("Could not initialise Mac fonts", e);
        }
    }
    private static class TooltipBinding extends ObjectBinding<Tooltip> {
        private final String tooltipKey;
        public TooltipBinding(StringProperty text, String tooltipKey) {
            bind(text);
            this.tooltipKey = tooltipKey;
        }
        protected Tooltip computeValue() {
            return new Tooltip(RESOURCE_FACTORY.getString(tooltipKey));
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```