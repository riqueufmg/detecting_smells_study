##CONTEXT_SIZE=1109
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.ui.stage;
public class StageManager {
    private static Map<Stage, List<Stage>> openStages = new HashMap<>();
    private static List<IStageClosedListener> listenerStageClosed = new ArrayList<>();
    private static List<ICompilationChangeListener> listenerCompilationChanged = new ArrayList<>();
    private StageManager() {
    }
    public static void registerStageClosedListener(IStageClosedListener listener) {
        listenerStageClosed.add(listener);
    }
    public static void registerCompilationChangeListener(ICompilationChangeListener listener) {
        listenerCompilationChanged.add(listener);
    }
    public static void notifyCompilationChanged(IMetaMember member) {
        for (ICompilationChangeListener listener : listenerCompilationChanged) {
            listener.compilationChanged(member);
        }
    }
    private static void notifyStageClosedListeners(Stage stage) {
        for (IStageClosedListener listener : listenerStageClosed) {
            listener.handleStageClosed(stage);
            if (stage instanceof ICompilationChangeListener) {
                listenerCompilationChanged.remove((ICompilationChangeListener) stage);
            }
        }
    }
    public static void clearReportStages() {
        for (Stage rootStage : openStages.keySet()) {
            clearChildren(rootStage);
        }
    }
    public static void clearChildren(Stage stage) {
        if (openStages.containsKey(stage)) {
            for (Stage childStage : openStages.get(stage)) {
                clearChildren(childStage);
            }
        }
        if (stage instanceof ReportStage) {
            ((ReportStage) stage).clear();
        }
    }
    private static void addCloseButton(final Stage stage) {
        Scene scene = stage.getScene();
        Parent rootNode = scene.getRoot();
        Button btnClose = new Button("X");
        btnClose.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                closeStage(stage);
            }
        });
        HBox hbox = new HBox();
        hbox.setSpacing(16);
        hbox.getChildren().addAll(btnClose, new Label(stage.getTitle()));
        if (rootNode instanceof BorderPane) {
            BorderPane pane = (BorderPane) rootNode;
            Node topNode = pane.getTop();
            if (topNode instanceof VBox) {
                VBox vbox = (VBox) topNode;
                vbox.getChildren().add(0, hbox);
            } else {
                VBox newTopNode = new VBox();
                newTopNode.setPadding(new Insets(0));
                newTopNode.getChildren().addAll(hbox, topNode);
                pane.setTop(newTopNode);
            }
        } else {
            VBox newTopNode = new VBox();
            newTopNode.setPadding(new Insets(0));
            newTopNode.getChildren().addAll(hbox, rootNode);
            scene.setRoot(newTopNode);
        }
    }
    public static void addAndShow(final Stage parent, final Stage childStage) {
        addAndShow(parent, childStage, null);
        double width = childStage.getScene().widthProperty().get();
        double height = childStage.getScene().heightProperty().get();
        childStage.setWidth(width);
        childStage.setHeight(height);
    }
    public static void addAndShow(final Stage parent, final Stage childStage, final IStageClosedListener closedListener) {
        List<Stage> childrenOfParent = openStages.get(parent);
        if (childrenOfParent == null) {
            childrenOfParent = new ArrayList<>();
            openStages.put(parent, childrenOfParent);
        }
        childrenOfParent.add(childStage);
        if (childStage instanceof ICompilationChangeListener) {
            registerCompilationChangeListener((ICompilationChangeListener) childStage);
        }
        if (UserInterfaceUtil.ADD_CLOSE_DECORATION) {
            addCloseButton(childStage);
        }
        childStage.setOnCloseRequest(new EventHandler<WindowEvent>() {
            @Override
            public void handle(WindowEvent arg0) {
                if (closedListener != null) {
                    closedListener.handleStageClosed(childStage);
                }
                closeStage(childStage);
            }
        });
        childStage.show();
        double parentX = parent.getX();
        double parentY = parent.getY();
        double parentWidth = parent.getWidth();
        double parentHeight = parent.getHeight();
        double childWidth = childStage.getWidth();
        double childHeight = childStage.getHeight();
        double childX = parentX + (parentWidth - childWidth) / 2;
        double childY = parentY + (parentHeight - childHeight) / 2;
        childStage.setX(childX);
        childStage.setY(childY);
        childStage.requestFocus();
        childStage.toFront();
    }
    public static EventHandler<ActionEvent> getCloseHandler(final Stage stage) {
        return new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                StageManager.closeStage(stage);
            }
        };
    }
    public static void closeStage(Stage stage) {
        List<Stage> childrenOfParent = openStages.get(stage);
        if (childrenOfParent != null) {
            for (Stage child : childrenOfParent) {
                closeStage(child);
            }
        }
        notifyStageClosedListeners(stage);
        openStages.remove(stage);
        stage.close();
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```