##CONTEXT_SIZE=2127
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.parser.hotspot;
public class HotSpotLogParser extends AbstractLogParser {
    public HotSpotLogParser(IJITListener jitListener) {
        super(jitListener);
    }
    private static Architecture architecture;
    private void checkIfErrorDialogNeeded() {
        if (hasParseError) {
            errorListener.handleError(errorDialogTitle, errorDialogBody);
        }
    }
    private void parseHeaderLines() {
        if (DEBUG_LOGGING) {
            logger.debug("parseHeaderLines()");
        }
        for (NumberedLine numberedLine : splitLog.getHeaderLines()) {
            String lineContent = numberedLine.getLine();
            if (!skipLine(lineContent, SKIP_HEADER_TAGS)) {
                Tag tag = tagProcessor.processLine(lineContent);
                processLineNumber = numberedLine.getLineNumber();
                if (tag != null) {
                    handleTag(tag);
                }
            } else if (lineContent.startsWith(TAG_HOTSPOT_LOG)) {
                long baseTimestamp = getBaseTimestamp(lineContent);
                model.setBaseTimestamp(baseTimestamp);
            }
        }
    }
    private long getBaseTimestamp(String line) {
        String attributePart = line.substring(TAG_HOTSPOT_LOG.length());
        Map<String, String> attrs = StringUtil.attributeStringToMap(attributePart);
        String baseTimestampAttr = attrs.get(ATTR_TIME_MS);
        return ParseUtil.parseStamp(baseTimestampAttr) / 1000;
    }
    protected void parseLogFile() {
        parseHeaderLines();
        buildParsedClasspath();
        buildClassModel();
        parseLogCompilationLines();
        parseAssemblyLines();
        checkIfErrorDialogNeeded();
    }
    private void parseLogCompilationLines() {
        if (DEBUG_LOGGING) {
            logger.debug("parseLogCompilationLines()");
        }
        for (NumberedLine numberedLine : splitLog.getCompilationLines()) {
            if (!skipLine(numberedLine.getLine(), SKIP_BODY_TAGS)) {
                Tag tag = tagProcessor.processLine(numberedLine.getLine());
                processLineNumber = numberedLine.getLineNumber();
                if (tag != null) {
                    handleTag(tag);
                }
            }
        }
    }
    private void parseAssemblyLines() {
        AssemblyProcessor asmProcessor;
        if (DEBUG_LOGGING_ASSEMBLY) {
            logger.error("parseAssemblyLines()");
        }
        if (model.getJDKMajorVersion() > 11) {
            asmProcessor = new AssemblyProcessor(architecture);
        } else {
            asmProcessor = new AssemblyProcessor();
        }
        for (NumberedLine numberedLine : splitLog.getAssemblyLines()) {
            processLineNumber = numberedLine.getLineNumber();
            asmProcessor.handleLine(numberedLine.getLine());
        }
        asmProcessor.complete();
        asmProcessor.attachAssemblyToMembers(model.getPackageManager());
        asmProcessor.clear();
    }
    protected void splitLogFile(Reader hotspotLogReader) {
        reading = true;
        try (BufferedReader reader = new BufferedReader(hotspotLogReader, 65536)) {
            String currentLine = reader.readLine();
            while (reading && currentLine != null) {
                try {
                    String trimmedLine = currentLine.trim();
                    if (trimmedLine.length() > 0) {
                        char firstChar = trimmedLine.charAt(0);
                        if (firstChar == C_OPEN_ANGLE || firstChar == C_OPEN_SQUARE_BRACKET || firstChar == C_AT) {
                            currentLine = trimmedLine;
                        }
                        handleLogLine(currentLine);
                    }
                } catch (Exception ex) {
                    logger.error("Exception handling: '{}'", currentLine, ex);
                }
                currentLine = reader.readLine();
            }
        } catch (IOException ioe) {
            logger.error("Exception while splitting log file", ioe);
        }
    }
    private boolean skipLine(final String line, final Set<String> skipSet) {
        boolean isSkip = false;
        for (String skip : skipSet) {
            if (line.startsWith(skip)) {
                isSkip = true;
                break;
            }
        }
        return isSkip;
    }
    private void handleLogLine(final String inCurrentLine) {
        String currentLine = inCurrentLine;
        NumberedLine numberedLine = new NumberedLine(parseLineNumber++, currentLine);
        if (TAG_TTY.equals(currentLine)) {
            inHeader = false;
            return;
        } else if (currentLine.startsWith(TAG_XML)) {
            inHeader = true;
        }
        if (inHeader) {
            splitLog.addHeaderLine(numberedLine);
        } else {
            if (currentLine.startsWith(TAG_OPEN_CDATA) || currentLine.startsWith(TAG_CLOSE_CDATA) || currentLine.startsWith(TAG_OPEN_CLOSE_CDATA)) {
            } else if (currentLine.startsWith(S_OPEN_ANGLE)) {
                splitLog.addCompilationLine(numberedLine);
            } else if (currentLine.startsWith(LOADED)) {
                splitLog.addClassLoaderLine(numberedLine);
            } else if (currentLine.startsWith(S_AT)) {
            } else if (currentLine.indexOf(S_OPEN_ANGLE + TAG_NMETHOD) != -1) {
                int indexNMethod = currentLine.indexOf(S_OPEN_ANGLE + TAG_NMETHOD);
                if (DEBUG_LOGGING) {
                    logger.debug("detected nmethod tag mangled with assembly");
                }
                String assembly = currentLine.substring(0, indexNMethod);
                String remainder = currentLine.substring(indexNMethod);
                numberedLine.setLine(assembly);
                splitLog.addAssemblyLine(numberedLine);
                handleLogLine(remainder);
            } else if (currentLine.indexOf(S_OPEN_ANGLE + S_SLASH + TAG_PRINT_NMETHOD) != -1) {
                int indexClosePrintNmethod = currentLine.indexOf(S_OPEN_ANGLE + S_SLASH + TAG_PRINT_NMETHOD);
                if (DEBUG_LOGGING) {
                    logger.debug("detected </print_nmethod> tag mangled with assembly");
                }
                String assembly = currentLine.substring(0, indexClosePrintNmethod);
                String remainder = currentLine.substring(indexClosePrintNmethod);
                numberedLine.setLine(assembly);
                splitLog.addAssemblyLine(numberedLine);
                handleLogLine(remainder);
            } else {
                splitLog.addAssemblyLine(numberedLine);
            }
        }
    }
    protected void handleTag(Tag tag) {
        String tagName = tag.getName();
        switch(tagName) {
            case TAG_WRITER:
                handleWriterThread(tag);
                break;
            case TAG_VM_VERSION:
                handleVmVersion(tag);
                break;
            case TAG_TASK_QUEUED:
                handleTagQueued(tag);
                break;
            case TAG_NMETHOD:
                handleTagNMethod(tag);
                break;
            case TAG_TASK:
                handleTagTask((Task) tag);
                break;
            case TAG_SWEEPER:
                storeCodeCacheEvent(CodeCacheEventType.SWEEPER, tag);
                break;
            case TAG_CODE_CACHE_FULL:
                storeCodeCacheEvent(CodeCacheEventType.CACHE_FULL, tag);
                break;
            case TAG_HOTSPOT_LOG_DONE:
                model.setEndOfLog(tag);
                break;
            case TAG_START_COMPILE_THREAD:
                handleStartCompileThread(tag);
                break;
            case TAG_VM_ARGUMENTS:
                handleTagVmArguments(tag);
                break;
            default:
                break;
        }
    }
    private void handleVmVersion(Tag tag) {
        model.setJDKMajorVersion(VmVersionDetector.getMajorVersionFromHotSpotTag(tag));
        if (model.getJDKMajorVersion() > 11)
            architecture = Architecture.parseFromLogLine(VmVersionDetector.getArchitectureFromHotSpotTag(tag));
    }
    private void handleTagVmArguments(Tag tag) {
        List<Tag> tagCommandChildren = tag.getNamedChildren(TAG_COMMAND);
        if (tagCommandChildren.size() > 0) {
            vmCommand = tagCommandChildren.get(0).getTextContent();
            if (DEBUG_LOGGING) {
                logger.debug("VM Command: {}", vmCommand);
            }
        }
    }
    private void handleWriterThread(Tag tag) {
        String threadId = tag.getAttributes().get(ATTR_THREAD);
        if (threadId != null) {
        }
    }
    private void handleStartCompileThread(Tag tag) {
        String threadId = tag.getAttributes().get(ATTR_THREAD);
        String threadName = tag.getAttributes().get(ATTR_NAME);
        if (threadId != null) {
            currentCompilerThread = model.createCompilerThread(threadId, threadName);
        }
    }
    private void buildParsedClasspath() {
        if (DEBUG_LOGGING) {
            logger.debug("buildParsedClasspath()");
        }
        for (NumberedLine numberedLine : splitLog.getClassLoaderLines()) {
            buildParsedClasspath(numberedLine.getLine());
        }
    }
    private void buildClassModel() {
        if (DEBUG_LOGGING) {
            logger.debug("buildClassModel()");
        }
        for (NumberedLine numberedLine : splitLog.getClassLoaderLines()) {
            buildClassModel(numberedLine.getLine());
        }
    }
    private void buildParsedClasspath(String inCurrentLine) {
        final String FROM_SPACE = "from ";
        String originalLocation = null;
        int fromSpacePos = inCurrentLine.indexOf(FROM_SPACE);
        if (fromSpacePos != -1) {
            originalLocation = inCurrentLine.substring(fromSpacePos + FROM_SPACE.length(), inCurrentLine.length() - 1);
        }
        if (originalLocation != null && originalLocation.startsWith(S_FILE_COLON)) {
            originalLocation = originalLocation.substring(S_FILE_COLON.length());
            try {
                originalLocation = URLDecoder.decode(originalLocation, "UTF-8");
            } catch (UnsupportedEncodingException e) {
            }
            getParsedClasspath().addClassLocation(originalLocation);
        }
    }
    private void buildClassModel(String inCurrentLine) {
        String fqClassName = StringUtil.getSubstringBetween(inCurrentLine, LOADED, S_SPACE);
        if (fqClassName != null) {
            addToClassModel(fqClassName);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```