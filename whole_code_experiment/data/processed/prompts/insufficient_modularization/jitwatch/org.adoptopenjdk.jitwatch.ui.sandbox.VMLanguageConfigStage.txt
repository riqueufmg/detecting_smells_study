##CONTEXT_SIZE=849
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.ui.sandbox;
public class VMLanguageConfigStage extends Stage {
    private File lastFolder = null;
    private TextField tfLanguagePath;
    private IStageClosedListener parent;
    private JITWatchConfig config;
    public VMLanguageConfigStage(final IStageClosedListener parent, final JITWatchConfig config, final String language) {
        this.parent = parent;
        this.config = config;
        initStyle(StageStyle.UTILITY);
        VBox vbox = new VBox();
        vbox.setPadding(new Insets(15));
        vbox.setSpacing(10);
        vbox.getChildren().add(getVBoxLanguagePath(language));
        if (language != null) {
            tfLanguagePath.setText(config.getVMLanguagePath(language));
        }
        vbox.getChildren().add(getHBoxButtons(language));
        setTitle("VM Language Configuration");
        Scene scene = UserInterfaceUtil.getScene(vbox, 480, 120);
        setScene(scene);
    }
    private VBox getVBoxLanguagePath(final String language) {
        VBox vbox = new VBox();
        tfLanguagePath = new TextField();
        Button btnChoosePath = new Button("Choose");
        btnChoosePath.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                File languagePath = chooseFile(language + " Home Directory");
                if (languagePath != null) {
                    tfLanguagePath.setText(languagePath.getAbsolutePath());
                }
            }
        });
        HBox hboxCompiler = new HBox();
        hboxCompiler.setSpacing(10);
        hboxCompiler.getChildren().add(tfLanguagePath);
        hboxCompiler.getChildren().add(btnChoosePath);
        tfLanguagePath.prefWidthProperty().bind(hboxCompiler.widthProperty().multiply(0.8));
        btnChoosePath.prefWidthProperty().bind(hboxCompiler.widthProperty().multiply(0.2));
        vbox.getChildren().add(new Label(language + " Home Directory"));
        vbox.getChildren().add(hboxCompiler);
        return vbox;
    }
    private HBox getHBoxButtons(String language) {
        HBox hbox = new HBox();
        hbox.setSpacing(20);
        hbox.setAlignment(Pos.CENTER);
        Button btnSave = new Button("Save");
        Button btnCancel = new Button("Cancel");
        btnSave.setOnAction(getEventHandlerForSaveButton(language, parent, config));
        btnCancel.setOnAction(getEventHandlerForCancelButton(parent));
        hbox.getChildren().add(btnCancel);
        hbox.getChildren().add(btnSave);
        return hbox;
    }
    private File chooseFile(String name) {
        DirectoryChooser dc = new DirectoryChooser();
        dc.setTitle("Choose " + name + " folder");
        File dirFile = null;
        if (lastFolder == null) {
            dirFile = new File(System.getProperty("user.dir"));
        } else {
            dirFile = lastFolder;
        }
        dc.setInitialDirectory(dirFile);
        File result = dc.showDialog(null);
        if (result != null) {
            lastFolder = result;
        }
        return result;
    }
    private EventHandler<ActionEvent> getEventHandlerForCancelButton(final IStageClosedListener parent) {
        return new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                parent.handleStageClosed(VMLanguageConfigStage.this);
                close();
            }
        };
    }
    private EventHandler<ActionEvent> getEventHandlerForSaveButton(final String language, final IStageClosedListener parent, final JITWatchConfig config) {
        return new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                String languagePath = tfLanguagePath.getText();
                if (languagePath != null && languagePath.length() > 0) {
                    config.addOrUpdateVMLanguage(language, languagePath);
                    config.saveConfig();
                }
                parent.handleStageClosed(VMLanguageConfigStage.this);
                close();
            }
        };
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```