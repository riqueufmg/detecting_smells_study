##CONTEXT_SIZE=2782
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.sandbox;
public class Sandbox {
    private static final Logger logger = LoggerFactory.getLogger(Sandbox.class);
    private ILogListener logListener;
    private ISandboxStage sandboxStage;
    public static final Path SANDBOX_DIR;
    public static final Path SANDBOX_SOURCE_DIR;
    public static final Path SANDBOX_CLASS_DIR;
    public static final Path PATH_STD_ERR;
    public static final Path PATH_STD_OUT;
    private static final String SANDBOX_LOGFILE = "sandbox.log";
    private File sandboxLogFile = new File(SANDBOX_DIR.toFile(), SANDBOX_LOGFILE);
    private ILogParser logParser;
    private LanguageManager languageManager;
    private IExternalProcess lastProcess;
    static {
        String userDir = System.getProperty("user.dir");
        SANDBOX_DIR = Paths.get(userDir, "sandbox");
        SANDBOX_SOURCE_DIR = Paths.get(SANDBOX_DIR.toString(), "sources");
        SANDBOX_CLASS_DIR = Paths.get(SANDBOX_DIR.toString(), "classes");
        PATH_STD_ERR = new File(Sandbox.SANDBOX_DIR.toFile(), "sandbox.err").toPath();
        PATH_STD_OUT = new File(Sandbox.SANDBOX_DIR.toFile(), "sandbox.out").toPath();
        initialise();
    }
    private static void initialise() {
        File sandboxSources = SANDBOX_SOURCE_DIR.toFile();
        if (!sandboxSources.exists()) {
            logger.info("Creating Sandbox source directory {}", sandboxSources);
            sandboxSources.mkdirs();
            if (sandboxSources.exists()) {
                copyExamples();
            }
        }
        File sandboxClasses = SANDBOX_CLASS_DIR.toFile();
        if (!sandboxClasses.exists()) {
            sandboxClasses.mkdirs();
        }
    }
    public void reset() {
        logger.info("Resetting Sandbox to default settings");
        FileUtil.emptyDir(SANDBOX_DIR.toFile());
        initialise();
    }
    private static void copyExamples() {
        boolean runningFromJar = FileUtil.isRunningFromJar();
        logger.info("isRunningFromJar:{}", runningFromJar);
        File dstDir = SANDBOX_SOURCE_DIR.toFile();
        logger.info("Copying Sandbox examples to {}", dstDir);
        if (runningFromJar) {
            FileUtil.copyFilesFromJarToDir("examples", dstDir);
        } else {
            File srcDir = new File("core/src/main/resources/examples");
            FileUtil.copyFilesToDir(srcDir, dstDir);
        }
    }
    public Sandbox(ILogParser parser, ILogListener logger, ISandboxStage sandboxStage) {
        this.logParser = parser;
        this.logListener = logger;
        this.sandboxStage = sandboxStage;
        languageManager = new LanguageManager(logParser.getConfig(), logListener);
    }
    public void runSandbox(String language, List<File> compileList, File fileToRun) throws Exception {
        logListener.handleLogEntry("Running Sandbox");
        logListener.handleLogEntry("Language is " + language);
        String languagePath = logParser.getConfig().getVMLanguagePath(language);
        if (S_EMPTY.equals(languagePath) && (VM_LANGUAGE_JAVA.equals(language) || VM_LANGUAGE_JAVASCRIPT.equals(language))) {
            languagePath = System.getProperty("java.home");
            logListener.handleLogEntry("Using runtime JVM for " + language);
        }
        logListener.handleLogEntry(language + " home dir: " + languagePath);
        ICompiler compiler = languageManager.getCompiler(language, languagePath);
        if (compiler == null) {
            logListener.handleErrorEntry(language + " compiler path not set. Please click Configure Sandbox and set up the path.");
            return;
        }
        IRuntime runtime = languageManager.getRuntime(language, languagePath);
        if (runtime == null) {
            logListener.handleErrorEntry(language + " runtime path not set. Please click Configure Sandbox and set up the path.");
            return;
        }
        logListener.handleLogEntry("Compiling: " + StringUtil.listToString(compileList));
        lastProcess = compiler;
        String compilationSwitchesText = logParser.getConfig().getExtraVMCompilationSwitches().trim();
        List<String> compilationSwitches = new ArrayList<>();
        if (!compilationSwitchesText.isEmpty()) {
            compilationSwitches.addAll(Arrays.asList(compilationSwitchesText.split("\\s+")));
        }
        boolean compiledOK = compiler.compile(compileList, buildUniqueClasspath(logParser.getConfig()), compilationSwitches, SANDBOX_CLASS_DIR.toFile(), Collections.<String, String>emptyMap(), logListener);
        logListener.handleLogEntry("Compilation success: " + compiledOK);
        if (compiledOK) {
            String fqClassNameToRun = runtime.getClassToExecute(fileToRun);
            lastProcess = runtime;
            long start = System.currentTimeMillis();
            boolean executionSuccess = executeClass(fqClassNameToRun, runtime, logParser.getConfig().isSandboxIntelMode());
            long stop = System.currentTimeMillis();
            logListener.handleLogEntry("Execution success: " + executionSuccess + " in " + (stop - start) + "ms");
            if (executionSuccess) {
                runJITWatch();
                if (!logParser.hasParseError()) {
                    String fqClassNameForTriView = runtime.getClassForTriView(fileToRun);
                    showTriView(language, fqClassNameForTriView);
                }
            } else {
                sandboxStage.showError(runtime.getErrorStream());
            }
        } else {
            sandboxStage.showError(compiler.getErrorStream());
        }
    }
    public IExternalProcess getLastProcess() {
        return lastProcess;
    }
    private List<String> buildUniqueClasspath(JITWatchConfig config) {
        List<String> classpath = new ArrayList<>();
        classpath.add(SANDBOX_CLASS_DIR.toString());
        for (String path : config.getConfiguredClassLocations()) {
            if (!classpath.contains(path)) {
                classpath.add(path);
            }
        }
        return classpath;
    }
    private boolean executeClass(String fqClassName, IRuntime runtime, boolean intelMode) throws Exception {
        List<String> classpath = buildUniqueClasspath(logParser.getConfig());
        List<String> options = new ArrayList<>();
        options.add("-XX:+UnlockDiagnosticVMOptions");
        options.add("-XX:+LogCompilation");
        options.add("-XX:LogFile=" + sandboxLogFile.getCanonicalPath());
        if (logParser.getConfig().isPrintAssembly()) {
            options.add("-XX:+PrintAssembly");
            if (intelMode) {
                options.add("-XX:PrintAssemblyOptions=intel");
            }
        }
        boolean isDisableInlining = logParser.getConfig().isDisableInlining();
        if (isDisableInlining) {
            options.add("-XX:-Inline");
        }
        TieredCompilation tieredMode = logParser.getConfig().getTieredCompilationMode();
        if (tieredMode == TieredCompilation.FORCE_TIERED) {
            options.add("-XX:+TieredCompilation");
        } else if (tieredMode == TieredCompilation.FORCE_NO_TIERED) {
            options.add("-XX:-TieredCompilation");
        }
        CompressedOops oopsMode = logParser.getConfig().getCompressedOopsMode();
        if (oopsMode == CompressedOops.FORCE_COMPRESSED) {
            options.add("-XX:+UseCompressedOops");
        } else if (oopsMode == CompressedOops.FORCE_NO_COMPRESSED) {
            options.add("-XX:-UseCompressedOops");
        }
        BackgroundCompilation backgroundCompilationMode = logParser.getConfig().getBackgroundCompilationMode();
        if (backgroundCompilationMode == BackgroundCompilation.FORCE_BACKGROUND_COMPILATION) {
            options.add("-XX:+BackgroundCompilation");
        } else if (backgroundCompilationMode == BackgroundCompilation.FORCE_NO_BACKGROUND_COMPILATION) {
            options.add("-XX:-BackgroundCompilation");
        }
        OnStackReplacement onStackReplacementMode = logParser.getConfig().getOnStackReplacementMode();
        if (onStackReplacementMode == OnStackReplacement.FORCE_ON_STACK_REPLACEMENT) {
            options.add("-XX:+UseOnStackReplacement");
        } else if (onStackReplacementMode == OnStackReplacement.FORCE_NO_ON_STACK_REPLACEMENT) {
            options.add("-XX:-UseOnStackReplacement");
        }
        if (!isDisableInlining && logParser.getConfig().getFreqInlineSize() != JITWatchConstants.DEFAULT_FREQ_INLINE_SIZE) {
            options.add("-XX:FreqInlineSize=" + logParser.getConfig().getFreqInlineSize());
        }
        if (!isDisableInlining && logParser.getConfig().getMaxInlineSize() != JITWatchConstants.DEFAULT_MAX_INLINE_SIZE) {
            options.add("-XX:MaxInlineSize=" + logParser.getConfig().getMaxInlineSize());
        }
        if (logParser.getConfig().getCompileThreshold() != JITWatchConstants.DEFAULT_COMPILER_THRESHOLD) {
            options.add("-XX:CompileThreshold=" + logParser.getConfig().getCompileThreshold());
        }
        if (logParser.getConfig().getExtraVMRuntimeSwitches().length() > 0) {
            String extraSwitchString = logParser.getConfig().getExtraVMRuntimeSwitches();
            String[] switches = extraSwitchString.split(S_SPACE);
            for (String sw : switches) {
                options.add(sw);
            }
        }
        logListener.handleLogEntry("Executing: " + fqClassName);
        logListener.handleLogEntry("Classpath: " + StringUtil.listToString(classpath, File.pathSeparatorChar));
        logListener.handleLogEntry("VM options: " + StringUtil.listToString(options));
        Map<String, String> environment = new LinkedHashMap<>();
        if (DisassemblyUtil.downloadedDisassemblerPresent()) {
            environment.put(DisassemblyUtil.getDynamicLibraryPath(), Paths.get(DisassemblyUtil.getDisassemblerFilename()).toAbsolutePath().getParent().toString());
        }
        Path workingDirPath = null;
        if (!logParser.getConfig().getSandboxWorkingDir().isEmpty()) {
            workingDirPath = Paths.get(logParser.getConfig().getSandboxWorkingDir());
        }
        return runtime.execute(workingDirPath, fqClassName, classpath, options, environment, logListener);
    }
    private void runJITWatch() throws IOException {
        JITWatchConfig config = logParser.getConfig();
        List<String> sourceLocations = new ArrayList<>(config.getSourceLocations());
        List<String> classLocations = new ArrayList<>(config.getConfiguredClassLocations());
        String sandboxSourceDirString = SANDBOX_SOURCE_DIR.toString();
        String sandboxClassDirString = SANDBOX_CLASS_DIR.toString();
        boolean configChanged = false;
        if (!sourceLocations.contains(sandboxSourceDirString)) {
            configChanged = true;
            sourceLocations.add(sandboxSourceDirString);
        }
        if (!classLocations.contains(sandboxClassDirString)) {
            configChanged = true;
            classLocations.add(sandboxClassDirString);
        }
        File jdkSrcZip = FileUtil.getJDKSourceZip();
        if (jdkSrcZip != null) {
            String jdkSourceZipString = jdkSrcZip.toPath().toString();
            if (!sourceLocations.contains(jdkSourceZipString)) {
                configChanged = true;
                sourceLocations.add(jdkSourceZipString);
            }
        }
        config.setSourceLocations(sourceLocations);
        config.setClassLocations(classLocations);
        if (configChanged) {
            config.saveConfig();
        }
        logListener.handleLogEntry("Parsing JIT log: " + sandboxLogFile.toString());
        logParser.processLogFile(sandboxLogFile, sandboxStage);
        logListener.handleLogEntry("Parsing complete");
    }
    private void showTriView(String language, String openClassInTriView) {
        IReadOnlyJITDataModel model = logParser.getModel();
        IMetaMember triViewMember = getMemberForClass(openClassInTriView, model);
        if (triViewMember == null && VM_LANGUAGE_SCALA.equals(language) && openClassInTriView.endsWith(S_DOLLAR)) {
            triViewMember = getMemberForClass(openClassInTriView.substring(0, openClassInTriView.length() - 1), model);
        }
        sandboxStage.openTriView(triViewMember);
    }
    private IMetaMember getMemberForClass(String openClassInTriView, IReadOnlyJITDataModel model) {
        IMetaMember triViewMember = null;
        logListener.handleLogEntry("Looking up class: " + openClassInTriView);
        MetaClass metaClass = model.getPackageManager().getMetaClass(openClassInTriView);
        if (metaClass != null) {
            logListener.handleLogEntry("looking for compiled members of " + metaClass.getFullyQualifiedName());
            List<IMetaMember> memberList = metaClass.getMetaMembers();
            for (IMetaMember mm : memberList) {
                logListener.handleLogEntry("Checking JIT compilation status of " + mm.toString());
                if (triViewMember == null) {
                    triViewMember = mm;
                }
                if (mm.isCompiled()) {
                    triViewMember = mm;
                    break;
                }
            }
        }
        return triViewMember;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```