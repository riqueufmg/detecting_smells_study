##CONTEXT_SIZE=1486
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.ui;
public final class Dialogs {
    private Dialogs() {
    }
    public enum Response {
        NO, YES, NEVER
    }
    private static Response response = Response.NO;
    private static String textInput;
    public static String getTextInput() {
        return textInput;
    }
    static class Dialog extends Stage {
        public Dialog(String title, Stage owner, Scene scene) {
            setTitle(title);
            initStyle(StageStyle.UTILITY);
            initModality(Modality.APPLICATION_MODAL);
            initOwner(owner);
            setResizable(false);
            setScene(scene);
        }
        public void showDialog() {
            sizeToScene();
            centerOnScreen();
            showAndWait();
        }
    }
    public static Response showYesNoDialog(Stage owner, String title, String message) {
        VBox vBox = new VBox();
        vBox.setAlignment(Pos.CENTER);
        vBox.setSpacing(10);
        vBox.setPadding(new Insets(10));
        int width = Math.max(320, message == null ? 0 : message.length() * 10);
        Scene scene = UserInterfaceUtil.getScene(vBox, width, 80);
        final Dialog dialog = new Dialog(title, owner, scene);
        Button btnYes = UserInterfaceUtil.createButton("YES");
        btnYes.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                dialog.close();
                response = Response.YES;
            }
        });
        Button btnNo = UserInterfaceUtil.createButton("NO");
        btnNo.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                dialog.close();
                response = Response.NO;
            }
        });
        BorderPane bp = new BorderPane();
        HBox hBox = new HBox();
        hBox.setAlignment(Pos.CENTER);
        hBox.setSpacing(10);
        hBox.setPadding(new Insets(10));
        hBox.getChildren().addAll(btnYes, btnNo);
        bp.setCenter(hBox);
        vBox.getChildren().addAll(new Label(message), bp);
        dialog.showDialog();
        return response;
    }
    public static Response showYesNoDialogNever(Stage owner, String title, String message) {
        VBox vBox = new VBox();
        vBox.setAlignment(Pos.CENTER);
        vBox.setSpacing(10);
        vBox.setPadding(new Insets(10));
        String[] messageParts = message.split("\n");
        int width = 320;
        for (String part : messageParts) {
            vBox.getChildren().add(new Label(part));
            width = Math.max(width, part.length() * 10);
        }
        Scene scene = UserInterfaceUtil.getScene(vBox, width, 80 + messageParts.length * 30);
        final Dialog dialog = new Dialog(title, owner, scene);
        Button btnYes = UserInterfaceUtil.createButton("YES");
        btnYes.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                dialog.close();
                response = Response.YES;
            }
        });
        Button btnNo = UserInterfaceUtil.createButton("NO");
        btnNo.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                dialog.close();
                response = Response.NO;
            }
        });
        Button btnNever = UserInterfaceUtil.createButton("NEVER");
        btnNever.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                dialog.close();
                response = Response.NEVER;
            }
        });
        BorderPane borderPane = new BorderPane();
        HBox hBox = new HBox();
        hBox.setAlignment(Pos.CENTER);
        hBox.setSpacing(10);
        hBox.setPadding(new Insets(10));
        hBox.getChildren().addAll(btnYes, btnNo, btnNever);
        vBox.getChildren().add(borderPane);
        borderPane.setCenter(hBox);
        dialog.showDialog();
        return response;
    }
    public static Response showTextInputDialog(Stage owner, String title, String message) {
        VBox vBox = new VBox();
        vBox.setAlignment(Pos.CENTER);
        vBox.setSpacing(10);
        vBox.setPadding(new Insets(10));
        Scene scene = UserInterfaceUtil.getScene(vBox, 320, 100);
        final Dialog dialog = new Dialog(title, owner, scene);
        final TextField textInput = new TextField();
        textInput.setOnKeyPressed(new EventHandler<KeyEvent>() {
            @Override
            public void handle(javafx.scene.input.KeyEvent event) {
                if (KeyCode.ENTER.equals(event.getCode())) {
                    Dialogs.textInput = textInput.getText();
                    dialog.close();
                    response = Response.YES;
                }
            }
        });
        Button btnOK = UserInterfaceUtil.createButton("OK");
        btnOK.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                Dialogs.textInput = textInput.getText();
                dialog.close();
                response = Response.YES;
            }
        });
        Button btnCancel = UserInterfaceUtil.createButton("CANCEL");
        btnCancel.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                dialog.close();
                response = Response.NO;
            }
        });
        HBox hBox = new HBox();
        hBox.setAlignment(Pos.CENTER);
        hBox.setSpacing(10);
        hBox.setPadding(new Insets(10));
        hBox.getChildren().addAll(btnOK, btnCancel);
        if (message != null && message.length() > 0) {
            vBox.getChildren().add(new Label(message));
        }
        vBox.getChildren().add(textInput);
        vBox.getChildren().add(hBox);
        dialog.showDialog();
        textInput.requestFocus();
        return response;
    }
    public static void showOKDialog(Stage owner, String title, String message) {
        VBox vBox = new VBox();
        vBox.setSpacing(10);
        vBox.setAlignment(Pos.CENTER);
        vBox.setPadding(new Insets(10));
        String[] lines = message.split(S_NEWLINE);
        for (String line : lines) {
            Label label = new Label(line);
            vBox.getChildren().add(label);
        }
        int width = 640;
        if (lines.length == 1) {
            width = Math.max(320, message == null ? 0 : message.length() * 10);
        }
        Scene scene = UserInterfaceUtil.getScene(vBox, width, 60 + 20 * lines.length);
        final Dialog dialog = new Dialog(title, owner, scene);
        Button btnOK = UserInterfaceUtil.createButton("OK");
        btnOK.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                dialog.close();
            }
        });
        vBox.getChildren().add(btnOK);
        dialog.showDialog();
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```