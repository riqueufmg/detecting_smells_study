##CONTEXT_SIZE=632
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.model;
public class Task extends Tag {
    private static final Logger logger = LoggerFactory.getLogger(Task.class);
    private IParseDictionary parseDictionary;
    public Task(String attributeString, boolean selfClosing) {
        super(TAG_TASK, attributeString, selfClosing);
        parseDictionary = new ParseDictionary(getAttributes().get(ATTR_METHOD));
    }
    public IParseDictionary getParseDictionary() {
        return parseDictionary;
    }
    public void addBCIOpcodeMapping(String methodID, int bci, Opcode opcode) {
        if (DEBUG_LOGGING_PARSE_DICTIONARY) {
            logger.debug("Adding bci mapping: {} {} {}", methodID, bci, opcode);
        }
        parseDictionary.putBCIOpcode(methodID, bci, opcode);
    }
    public void addDictionaryType(String type, Tag tag) {
        if (DEBUG_LOGGING_PARSE_DICTIONARY) {
            logger.debug("Adding type: {}", type);
        }
        parseDictionary.putType(type, tag);
    }
    public void addDictionaryMethod(String method, Tag tag) {
        if (DEBUG_LOGGING_PARSE_DICTIONARY) {
            logger.debug("Adding method: {}", method);
        }
        parseDictionary.putMethod(method, tag);
    }
    public void addDictionaryKlass(String klass, Tag tag) {
        if (DEBUG_LOGGING_PARSE_DICTIONARY) {
            logger.debug("Adding klass: {}", klass);
        }
        parseDictionary.putKlass(klass, tag);
    }
    public String decodeParseMethod(String method) {
        StringBuilder builder = new StringBuilder();
        Tag methodTag = parseDictionary.getMethod(method);
        Map<String, String> methodTagAttrs = methodTag.getAttributes();
        String returnTypeID = methodTagAttrs.get(JITWatchConstants.ATTR_RETURN);
        String args = methodTagAttrs.get(JITWatchConstants.ATTR_ARGUMENTS);
        String methodName = methodTagAttrs.get(JITWatchConstants.ATTR_NAME);
        String klassId = methodTagAttrs.get(JITWatchConstants.ATTR_HOLDER);
        Tag klassTag = parseDictionary.getKlass(klassId);
        Map<String, String> klassTagAttrs = klassTag.getAttributes();
        String klassName = klassTagAttrs.get(JITWatchConstants.ATTR_NAME);
        klassName = klassName.replace(S_SLASH, S_DOT);
        builder.append(" <!-- ");
        builder.append(ParseUtil.lookupType(returnTypeID, parseDictionary));
        builder.append(C_SPACE);
        builder.append(klassName);
        builder.append(S_DOT);
        builder.append(methodName);
        builder.append(S_OPEN_PARENTHESES);
        if (args != null && args.length() > 0) {
            String[] ids = args.split(S_SPACE);
            for (String id : ids) {
                builder.append(ParseUtil.lookupType(id, parseDictionary));
                builder.append(S_COMMA);
            }
            builder.deleteCharAt(builder.length() - 1);
        }
        builder.append(") -->");
        return builder.toString();
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```