##CONTEXT_SIZE=3283
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.parser;
public abstract class AbstractLogParser implements ILogParser {
    protected static final Logger logger = LoggerFactory.getLogger(AbstractLogParser.class);
    protected JITDataModel model;
    protected CompilerThread currentCompilerThread = null;
    protected String vmCommand = null;
    protected boolean reading = false;
    protected boolean hasParseError = false;
    protected String errorDialogTitle;
    protected String errorDialogBody;
    protected IMetaMember currentMember = null;
    protected IJITListener jitListener = null;
    protected ILogParseErrorListener errorListener = null;
    protected boolean inHeader = false;
    protected long parseLineNumber;
    protected long processLineNumber;
    protected JITWatchConfig config = new JITWatchConfig();
    protected TagProcessor tagProcessor;
    protected SplitLog splitLog = new SplitLog();
    public AbstractLogParser(IJITListener jitListener) {
        model = new JITDataModel();
        this.jitListener = jitListener;
    }
    public void setConfig(JITWatchConfig config) {
        this.config = config;
    }
    public JITWatchConfig getConfig() {
        return config;
    }
    public SplitLog getSplitLog() {
        return splitLog;
    }
    public ParsedClasspath getParsedClasspath() {
        return config.getParsedClasspath();
    }
    protected void configureDisposableClassLoader() {
        if (DEBUG_LOGGING) {
            logger.debug("configureDisposableClassLoader()");
        }
        List<String> configuredClassLocations = config.getConfiguredClassLocations();
        List<String> parsedClassLocations = getParsedClasspath().getClassLocations();
        int configuredClasspathCount = configuredClassLocations.size();
        int parsedClasspathCount = parsedClassLocations.size();
        List<URL> classpathURLList = new ArrayList<>(configuredClasspathCount + parsedClasspathCount);
        for (String filename : configuredClassLocations) {
            URI uri = new File(filename).toURI();
            jitListener.handleLogEntry("Adding configured classpath: " + uri.toString());
            if (DEBUG_LOGGING) {
                logger.debug("adding to classpath {}", uri.toString());
            }
            try {
                classpathURLList.add(uri.toURL());
            } catch (MalformedURLException e) {
                logger.error("Could not create URL: {} ", uri, e);
            }
        }
        for (String filename : getParsedClasspath().getClassLocations()) {
            if (!configuredClassLocations.contains(filename)) {
                URI uri = new File(filename).toURI();
                jitListener.handleLogEntry("Adding parsed classpath: " + uri.toString());
                try {
                    classpathURLList.add(uri.toURL());
                } catch (MalformedURLException e) {
                    logger.error("Could not create URL: {} ", uri, e);
                }
            }
        }
        ClassUtil.initialise(classpathURLList);
    }
    protected void logEvent(JITEvent event) {
        if (jitListener != null) {
            jitListener.handleJITEvent(event);
        }
    }
    protected void logError(String entry) {
        if (jitListener != null) {
            jitListener.handleErrorEntry(entry);
        }
    }
    public JITDataModel getModel() {
        return model;
    }
    public void reset() {
        if (DEBUG_LOGGING) {
            logger.debug("Log parser reset()");
        }
        ClassUtil.clear();
        getModel().reset();
        splitLog.clear();
        hasParseError = false;
        errorDialogTitle = null;
        errorDialogBody = null;
        reading = false;
        inHeader = false;
        currentMember = null;
        vmCommand = null;
        parseLineNumber = 0;
        processLineNumber = 0;
        tagProcessor = new TagProcessor();
    }
    public void stopParsing() {
        reading = false;
    }
    public IMetaMember findMemberWithSignature(String logSignature) {
        IMetaMember result = null;
        try {
            result = ParseUtil.findMemberWithSignature(model, logSignature);
        } catch (LogParseException ex) {
            if (DEBUG_LOGGING) {
                logger.debug("Could not parse signature: {}", logSignature);
                logger.debug("Exception was {}", ex.getMessage());
            }
            logError("Could not parse line " + processLineNumber + " : " + logSignature + " : " + ex.getMessage());
        }
        return result;
    }
    public boolean hasParseError() {
        return hasParseError;
    }
    public String getVMCommand() {
        return vmCommand;
    }
    public void discardParsedLogs() {
        splitLog.clear();
        splitLog = new SplitLog();
    }
    protected void addToClassModel(String fqClassName) {
        if (DEBUG_LOGGING) {
            logger.debug("addToClassModel {}", fqClassName);
        }
        Class<?> clazz = null;
        MetaClass metaClass = model.getPackageManager().getMetaClass(fqClassName);
        if (metaClass != null) {
            return;
        }
        try {
            clazz = ClassUtil.loadClassWithoutInitialising(fqClassName);
            if (clazz != null) {
                model.buildAndGetMetaClass(clazz);
            }
        } catch (ClassNotFoundException cnf) {
            if (!ParseUtil.possibleLambdaMethod(fqClassName)) {
                logError("ClassNotFoundException: '" + fqClassName + C_QUOTE);
            }
        } catch (NoClassDefFoundError ncdf) {
            logError("NoClassDefFoundError: '" + fqClassName + C_SPACE + "requires " + ncdf.getMessage() + C_QUOTE);
        } catch (UnsupportedClassVersionError ucve) {
            hasParseError = true;
            errorDialogTitle = "UnsupportedClassVersionError for class " + fqClassName;
            errorDialogBody = "Could not load " + fqClassName + " as the class file version is too recent for this JVM.";
            logError("UnsupportedClassVersionError! Tried to load a class file with an unsupported format (later version than this JVM)");
            logger.error("Class file for {} created in a later JVM version", fqClassName, ucve);
        } catch (Throwable t) {
            logger.error("Could not addClassToModel {}", fqClassName, t);
            logError("Exception: '" + fqClassName + C_QUOTE);
        }
    }
    private void logSplitStats() {
        logger.debug("Header lines        : {}", splitLog.getHeaderLines().size());
        logger.debug("ClassLoader lines   : {}", splitLog.getClassLoaderLines().size());
        logger.debug("LogCompilation lines: {}", splitLog.getCompilationLines().size());
        logger.debug("Assembly lines      : {}", splitLog.getAssemblyLines().size());
    }
    public void processLogFile(Reader logFileReader, ILogParseErrorListener errorListener) {
        reset();
        configureDisposableClassLoader();
        jitListener.handleReadStart();
        this.errorListener = errorListener;
        splitLogFile(logFileReader);
        if (DEBUG_LOGGING) {
            logSplitStats();
        }
        parseLogFile();
        jitListener.handleReadComplete();
    }
    protected void handleTagQueued(Tag tag) {
        handleMethodLine(tag, EventType.QUEUE);
    }
    protected void handleTagNMethod(Tag tag) {
        Map<String, String> tagAttributes = tag.getAttributes();
        String attrCompiler = tagAttributes.get(ATTR_COMPILER);
        renameCompilationCompletedTimestamp(tag);
        if (attrCompiler != null && attrCompiler.length() > 0) {
            if (C1.equalsIgnoreCase(attrCompiler)) {
                handleMethodLine(tag, EventType.NMETHOD_C1);
            } else if (C2.equalsIgnoreCase(attrCompiler)) {
                handleMethodLine(tag, EventType.NMETHOD_C2);
            } else if (J9.equalsIgnoreCase(attrCompiler)) {
                handleMethodLine(tag, EventType.NMETHOD_J9);
            } else if (ZING.equalsIgnoreCase(attrCompiler)) {
                handleMethodLine(tag, EventType.NMETHOD_ZING);
            } else if (FALCON.equalsIgnoreCase(attrCompiler)) {
                handleMethodLine(tag, EventType.NMETHOD_FALCON);
            } else if (JVMCI.equalsIgnoreCase(attrCompiler)) {
                handleMethodLine(tag, EventType.NMETHOD_JVMCI);
            } else {
                logger.error("Unexpected Compiler attribute: {} {}", attrCompiler, tag.toString(true));
                logError("Unexpected Compiler attribute: " + attrCompiler);
            }
        } else {
            String attrCompileKind = tagAttributes.get(ATTR_COMPILE_KIND);
            if (attrCompileKind != null && C2N.equalsIgnoreCase(attrCompileKind)) {
                handleMethodLine(tag, EventType.NMETHOD_C2N);
            } else {
                logError("Missing Compiler attribute " + tag);
            }
        }
    }
    protected void handleTagTask(Task task) {
        handleMethodLine(task, EventType.TASK);
        Tag tagCodeCache = task.getFirstNamedChild(TAG_CODE_CACHE);
        Tag tagTaskDone = task.getFirstNamedChild(TAG_TASK_DONE);
        if (tagTaskDone != null) {
            handleTaskDone(tagTaskDone, currentMember);
            if (tagCodeCache != null) {
                long stamp = ParseUtil.parseStampFromTag(tagTaskDone);
                long freeCodeCache = ParseUtil.parseLongAttributeFromTag(tagCodeCache, ATTR_FREE_CODE_CACHE);
                long nativeCodeSize = ParseUtil.parseLongAttributeFromTag(tagTaskDone, ATTR_NMSIZE);
                storeCodeCacheEventDetail(CodeCacheEventType.COMPILATION, stamp, nativeCodeSize, freeCodeCache);
            }
        } else {
            logger.error("{} not found in {}", TAG_TASK_DONE, task);
        }
    }
    protected void storeCodeCacheEvent(CodeCacheEventType eventType, Tag tag) {
        storeCodeCacheEventDetail(eventType, ParseUtil.parseStampFromTag(tag), 0, 0);
    }
    private void storeCodeCacheEventDetail(CodeCacheEventType eventType, long stamp, long nativeCodeSize, long freeCodeCache) {
        CodeCacheEvent codeCacheEvent = new CodeCacheEvent(eventType, stamp, nativeCodeSize, freeCodeCache);
        model.addCodeCacheEvent(codeCacheEvent);
    }
    private void handleMethodLine(Tag tag, EventType eventType) {
        Map<String, String> attrs = tag.getAttributes();
        String attrMethod = attrs.get(ATTR_METHOD);
        if (attrMethod != null) {
            attrMethod = attrMethod.replace(S_SLASH, S_DOT);
            handleMember(attrMethod, attrs, eventType, tag);
        }
    }
    private Compilation createCompilation(IMetaMember member) {
        int nextIndex = member.getCompilations().size();
        Compilation compilation = new Compilation(member, nextIndex);
        return compilation;
    }
    protected void setTagTaskQueued(Tag tagTaskQueued, IMetaMember metaMember) {
        Compilation compilation = createCompilation(metaMember);
        compilation.setTagTaskQueued(tagTaskQueued);
        metaMember.storeCompilation(compilation);
    }
    protected void setTagNMethod(Tag tagNMethod, IMetaMember member) {
        member.setCompiled(true);
        String compileID = tagNMethod.getAttributes().get(ATTR_COMPILE_ID);
        Compilation compilation = member.getCompilationByCompileID(compileID);
        if (compilation != null) {
            compilation.setTagNMethod(tagNMethod);
        } else {
            String compileKind = tagNMethod.getAttributes().get(ATTR_COMPILE_KIND);
            if (C2N.equalsIgnoreCase(compileKind)) {
                compilation = createCompilation(member);
                compilation.setTagNMethod(tagNMethod);
                member.storeCompilation(compilation);
            } else {
                logger.warn("Didn't find compilation with ID {}", compileID);
            }
        }
        member.getMetaClass().getPackage().setHasCompiledClasses();
    }
    protected void setTagTask(Task tagTask, IMetaMember member) {
        String compileID = tagTask.getAttributes().get(ATTR_COMPILE_ID);
        Compilation compilation = member.getCompilationByCompileID(compileID);
        if (compilation != null) {
            compilation.setTagTask(tagTask);
            if (currentCompilerThread != null) {
                currentCompilerThread.addCompilation(compilation);
            } else {
                logger.warn("No compiler thread set when I saw {}", tagTask.toString());
            }
        } else {
            logger.warn("Didn't find compilation with ID {}", compileID);
        }
    }
    private void setTagTaskDone(String compileID, Tag tagTaskDone, IMetaMember member) {
        Compilation compilation = member.getCompilationByCompileID(compileID);
        if (compilation != null) {
            compilation.setTagTaskDone(tagTaskDone);
        } else {
            logger.warn("Didn't find compilation with ID {}", compileID);
        }
    }
    private void handleMember(String signature, Map<String, String> attrs, EventType type, Tag tag) {
        IMetaMember metaMember = findMemberWithSignature(signature);
        long stampTime = ParseUtil.getStamp(attrs);
        if (metaMember != null) {
            switch(type) {
                case QUEUE:
                    {
                        setTagTaskQueued(tag, metaMember);
                        JITEvent queuedEvent = new JITEvent(stampTime, type, metaMember);
                        model.addEvent(queuedEvent);
                        logEvent(queuedEvent);
                    }
                    break;
                case NMETHOD_C1:
                case NMETHOD_C2:
                case NMETHOD_C2N:
                case NMETHOD_J9:
                case NMETHOD_ZING:
                case NMETHOD_FALCON:
                case NMETHOD_JVMCI:
                    {
                        setTagNMethod(tag, metaMember);
                        metaMember.getMetaClass().incCompiledMethodCount();
                        JITEvent compiledEvent = new JITEvent(stampTime, type, metaMember);
                        model.addEvent(compiledEvent);
                        logEvent(compiledEvent);
                    }
                    break;
                case TASK:
                    {
                        setTagTask((Task) tag, metaMember);
                        currentMember = metaMember;
                        model.updateStats(metaMember, attrs);
                    }
                    break;
                default:
                    break;
            }
        }
    }
    protected void handleTaskDone(Tag tagTaskDone, IMetaMember member) {
        Map<String, String> attrs = tagTaskDone.getAttributes();
        if (attrs.containsKey(ATTR_NMSIZE)) {
            long nmsize = Long.parseLong(attrs.get(ATTR_NMSIZE));
            model.addNativeBytes(nmsize);
        }
        if (member != null) {
            Tag parent = tagTaskDone.getParent();
            String compileID = null;
            if (TAG_TASK.equals(parent.getName())) {
                compileID = parent.getAttributes().get(ATTR_COMPILE_ID);
                if (compileID != null) {
                    setTagTaskDone(compileID, tagTaskDone, member);
                } else {
                    logger.warn("No compile_id attribute found on task");
                }
            } else {
                logger.warn("Unexpected parent of task_done: {}", parent.getName());
            }
            currentMember = null;
        }
    }
    private void renameCompilationCompletedTimestamp(Tag tag) {
        String compilationCompletedStamp = tag.getAttributes().get(ATTR_STAMP);
        if (compilationCompletedStamp != null) {
            tag.getAttributes().remove(ATTR_STAMP);
            tag.getAttributes().put(ATTR_STAMP_COMPLETED, compilationCompletedStamp);
        }
    }
    protected abstract void parseLogFile();
    protected abstract void splitLogFile(Reader logFileReader);
    protected abstract void handleTag(Tag tag);
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```