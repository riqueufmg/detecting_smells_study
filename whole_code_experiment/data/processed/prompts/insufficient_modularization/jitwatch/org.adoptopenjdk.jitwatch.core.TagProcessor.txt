##CONTEXT_SIZE=1383
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.core;
public class TagProcessor {
    private static final Logger logger = LoggerFactory.getLogger(TagProcessor.class);
    private Stack<String> methodIDStack = new Stack<>();
    private Tag currentTag;
    private Tag topTag = null;
    private boolean fragmentSeen;
    public String getTopTagName() {
        String result = null;
        if (topTag != null) {
            result = topTag.getName();
        }
        return result;
    }
    public Tag processLine(String line) {
        Tag result = null;
        if (line != null) {
            if (line.length() > 3 && line.charAt(0) == C_OPEN_ANGLE) {
                result = handleTag(line);
            } else if (currentTag != null) {
                String closingTag = currentTag.getClosingTag();
                if (line.endsWith(closingTag)) {
                    line = line.substring(0, line.length() - closingTag.length());
                    currentTag.addTextContent(line);
                    processLine(closingTag);
                } else {
                    currentTag.addTextContent(line);
                }
            } else {
                if (DEBUG_LOGGING) {
                    logger.debug("Did not handle: {}", line);
                }
            }
        }
        if (DEBUG_LOGGING_TAGPROCESSOR) {
            logger.debug("returning tag: {}", result);
        }
        if (result != null) {
            resetState();
        }
        return result;
    }
    public boolean wasFragmentSeen() {
        return fragmentSeen;
    }
    private void resetState() {
        currentTag = null;
        topTag = null;
    }
    private Tag handleTag(String line) {
        Tag result = null;
        if (DEBUG_LOGGING_TAGPROCESSOR) {
            logger.debug("Handling line: {}", line);
        }
        if (line.charAt(1) == C_SLASH) {
            String closeName = line.substring(2, line.length() - 1);
            if (DEBUG_LOGGING_TAGPROCESSOR) {
                logger.debug("closeName:{}, currentTag:{}, topTag:{}", closeName, currentTag == null ? "null" : currentTag.getName(), topTag == null ? "null" : topTag.getName());
            }
            if (currentTag != null && closeName.equals(currentTag.getName())) {
                if (currentTag.getParent() == null) {
                    result = currentTag;
                } else {
                    currentTag = currentTag.getParent();
                }
                if (JITWatchConstants.TAG_PARSE.equals(currentTag.getName())) {
                    methodIDStack.pop();
                }
            } else if (S_FRAGMENT.equals(closeName)) {
                result = topTag;
            }
        } else {
            boolean selfClosing = (line.charAt(line.length() - 2) == C_SLASH);
            int indexEndName = line.indexOf(C_SPACE);
            if (indexEndName == -1) {
                indexEndName = line.indexOf(C_CLOSE_ANGLE);
                if (indexEndName > 0) {
                    if (selfClosing) {
                        indexEndName = line.length() - 2;
                    }
                }
            }
            if (indexEndName != -1) {
                result = processValidLine(line, indexEndName, selfClosing);
            }
        }
        return result;
    }
    private Tag processValidLine(String line, int indexEndName, boolean selfClosing) {
        if (DEBUG_LOGGING_TAGPROCESSOR) {
            logger.debug("processValidLine(line:{}, indexEndName:{}, selfClosing:{})", line, indexEndName, selfClosing);
        }
        Tag result = null;
        String name = line.substring(1, indexEndName);
        String attributeString = line.substring(indexEndName);
        Map<String, String> attrs = StringUtil.attributeStringToMap(attributeString);
        Tag nextTag;
        if (JITWatchConstants.TAG_TASK.equals(name)) {
            nextTag = new Task(attributeString, selfClosing);
        } else {
            nextTag = new Tag(name, attributeString, selfClosing);
        }
        if (DEBUG_LOGGING_TAGPROCESSOR) {
            logger.debug("top: {}", topTag);
        }
        if (DEBUG_LOGGING_TAGPROCESSOR) {
            logger.debug("currentTag: {}", currentTag);
        }
        if (DEBUG_LOGGING_TAGPROCESSOR) {
            logger.debug("t: {}", nextTag);
        }
        if (currentTag == null) {
            if (name.equals(S_FRAGMENT)) {
                logger.warn("Found a {} in the HotSpot log. The VM exited before the hotspot log was fully written. JIT information may have been lost.", TAG_OPEN_FRAGMENT);
                fragmentSeen = true;
                return null;
            } else {
                currentTag = nextTag;
                topTag = nextTag;
            }
        } else {
            currentTag.addChild(nextTag);
        }
        if (topTag instanceof Task) {
            switch(name) {
                case JITWatchConstants.TAG_TYPE:
                    ((Task) topTag).addDictionaryType(attrs.get(JITWatchConstants.ATTR_ID), nextTag);
                    break;
                case JITWatchConstants.TAG_METHOD:
                    ((Task) topTag).addDictionaryMethod(attrs.get(JITWatchConstants.ATTR_ID), nextTag);
                    break;
                case JITWatchConstants.TAG_KLASS:
                    ((Task) topTag).addDictionaryKlass(attrs.get(JITWatchConstants.ATTR_ID), nextTag);
                    break;
                case JITWatchConstants.TAG_PARSE:
                    String currentMethodID = attrs.get(JITWatchConstants.ATTR_METHOD);
                    methodIDStack.push(currentMethodID);
                    break;
                case JITWatchConstants.TAG_BC:
                    String bci = attrs.get(JITWatchConstants.ATTR_BCI);
                    String code = attrs.get(JITWatchConstants.ATTR_CODE);
                    try {
                        int bciValue = Integer.parseInt(bci);
                        int codeValue = Integer.parseInt(code);
                        Opcode opcode = Opcode.getByCode(codeValue);
                        ((Task) topTag).addBCIOpcodeMapping(methodIDStack.peek(), bciValue, opcode);
                    } catch (NumberFormatException nfe) {
                        logger.error("Couldn't parse bc tag {}", nextTag);
                    }
                    break;
                default:
                    break;
            }
        }
        if (selfClosing) {
            if (name.equals(currentTag.getName())) {
                if (currentTag.getParent() == null) {
                    result = currentTag;
                }
            }
        } else {
            currentTag = nextTag;
        }
        return result;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```