##CONTEXT_SIZE=2533
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.model;
public abstract class AbstractMetaMember implements IMetaMember, Comparable<IMetaMember> {
    protected static final Logger logger = LoggerFactory.getLogger(AbstractMetaMember.class);
    protected MetaClass metaClass;
    private List<Compilation> compilations;
    private int selectedCompilationIndex;
    private boolean isCompiled = false;
    protected boolean isVarArgs = false;
    protected boolean isPolymorphicSignature = false;
    protected int modifier;
    private String memberName;
    protected Class<?> returnType;
    protected List<Class<?>> paramTypes;
    public AbstractMetaMember(String memberName) {
        this.memberName = memberName;
        compilations = new ArrayList<>();
    }
    protected void checkPolymorphicSignature(Method method) {
        for (Annotation anno : method.getAnnotations()) {
            if (S_POLYMORPHIC_SIGNATURE.equals(anno.annotationType().getSimpleName())) {
                isPolymorphicSignature = true;
                break;
            }
        }
    }
    public String getMemberName() {
        return memberName;
    }
    public String getFullyQualifiedMemberName() {
        return metaClass.getFullyQualifiedName() + C_DOT + memberName;
    }
    public String getAbbreviatedFullyQualifiedMemberName() {
        return metaClass.getAbbreviatedFullyQualifiedName() + C_DOT + memberName;
    }
    public int getModifier() {
        return modifier;
    }
    public String getModifierString() {
        return Modifier.toString(modifier);
    }
    private boolean nameMatches(MemberSignatureParts msp) {
        if (DEBUG_LOGGING_SIG_MATCH) {
            logger.debug("nameMatches this.memberName: '{}' fq: '{}' other '{}' fq: '{}'", memberName, getFullyQualifiedMemberName(), msp.getMemberName(), msp.getFullyQualifiedClassName());
        }
        boolean match = memberName.equals(msp.getMemberName());
        if (DEBUG_LOGGING_SIG_MATCH) {
            logger.debug("nameMatches {}", match);
        }
        return match;
    }
    private boolean returnTypeMatches(MemberSignatureParts msp) throws ClassNotFoundException {
        boolean matched = false;
        String returnTypeClassName = msp.applyGenericSubstitutionsForClassLoading(msp.getReturnType());
        if (returnTypeClassName != null) {
            Class<?> sigReturnType = ParseUtil.findClassForLogCompilationParameter(returnTypeClassName);
            matched = returnType.equals(sigReturnType);
            if (DEBUG_LOGGING_SIG_MATCH) {
                logger.debug("Return: '{}' === '{}' ? {}", returnType.getName(), sigReturnType.getName(), matched);
            }
        } else {
            matched = (isConstructor());
            if (DEBUG_LOGGING_SIG_MATCH) {
                logger.debug("Constructor found");
            }
        }
        return matched;
    }
    public boolean matchesSignature(MemberSignatureParts msp, boolean matchTypesExactly) {
        boolean result = false;
        if (nameMatches(msp)) {
            if (DEBUG_LOGGING_SIG_MATCH) {
                logger.debug("Comparing:\n--------------\n{}\n--------------\n{}\n--------------", this, msp);
            }
            if (isPolymorphicSignature) {
                if (DEBUG_LOGGING_SIG_MATCH) {
                    logger.debug("Member has PolymorphicSignature");
                }
                result = true;
            } else {
                try {
                    if (returnTypeMatches(msp)) {
                        List<Class<?>> mspClassTypes = getClassesForParamTypes(msp);
                        if (ParseUtil.paramClassesMatch(isVarArgs, this.paramTypes, mspClassTypes, matchTypesExactly)) {
                            result = true;
                        }
                    }
                } catch (ClassNotFoundException cnfe) {
                    logger.error("Class not found while matching signature:\n{}", msp, cnfe);
                }
            }
            if (DEBUG_LOGGING_SIG_MATCH) {
                logger.debug("Match: {}", result);
            }
        }
        return result;
    }
    private List<Class<?>> getClassesForParamTypes(MemberSignatureParts msp) throws ClassNotFoundException {
        List<Class<?>> result = new ArrayList<>();
        for (String param : msp.getParamTypes()) {
            String paramClassName = msp.applyGenericSubstitutionsForClassLoading(param);
            Class<?> clazz = ParseUtil.findClassForLogCompilationParameter(paramClassName);
            result.add(clazz);
        }
        return result;
    }
    public String getReturnTypeName() {
        String result = null;
        if (isConstructor() || returnType == null) {
            result = S_TYPE_NAME_VOID;
        } else {
            result = ParseUtil.expandParameterType(returnType.getName());
        }
        return result;
    }
    public String[] getParamTypeNames() {
        List<String> typeNames = new ArrayList<>();
        for (Class<?> paramClass : paramTypes) {
            typeNames.add(ParseUtil.expandParameterType(paramClass.getName()));
        }
        return typeNames.toArray(new String[typeNames.size()]);
    }
    public MemberBytecode getMemberBytecode() {
        MemberBytecode result = null;
        if (metaClass != null) {
            ClassBC classBytecode = metaClass.getClassBytecode();
            if (classBytecode != null) {
                result = classBytecode.getMemberBytecode(this);
            }
        }
        return result;
    }
    public List<BytecodeInstruction> getInstructions() {
        List<BytecodeInstruction> result = null;
        MemberBytecode memberBytecode = getMemberBytecode();
        if (memberBytecode != null) {
            result = memberBytecode.getInstructions();
        } else {
            result = new ArrayList<>();
        }
        return result;
    }
    public MetaClass getMetaClass() {
        return metaClass;
    }
    public String getQueuedAttribute(String key) {
        return getLastCompilation() == null ? null : getLastCompilation().getQueuedAttribute(key);
    }
    public String getCompiledAttribute(String key) {
        return getLastCompilation() == null ? null : getLastCompilation().getCompiledAttribute(key);
    }
    public Compilation getCompilationByCompileID(String compileID) {
        Compilation result = null;
        for (Compilation compilation : compilations) {
            if (compileID.equals(compilation.getCompileID())) {
                result = compilation;
                break;
            }
        }
        return result;
    }
    public Compilation getCompilationByAddress(AssemblyMethod asmMethod) {
        Compilation result = null;
        String entryAddress = asmMethod.getEntryAddress();
        String nativeAddress = asmMethod.getNativeAddress();
        for (Compilation compilation : compilations) {
            if (entryAddress != null && entryAddress.equals(compilation.getEntryAddress())) {
                result = compilation;
                break;
            } else if (nativeAddress != null && nativeAddress.equals(compilation.getNativeAddress())) {
                result = compilation;
                break;
            }
        }
        return result;
    }
    public void storeCompilation(Compilation compilation) {
        compilations.add(compilation);
        selectedCompilationIndex = compilations.size() - 1;
    }
    public boolean isCompiled() {
        return isCompiled;
    }
    public void setCompiled(boolean compiled) {
        isCompiled = compiled;
    }
    public Map<String, String> getQueuedAttributes() {
        return getLastCompilation() == null ? null : getLastCompilation().getQueuedAttributes();
    }
    public Map<String, String> getCompiledAttributes() {
        return getLastCompilation() == null ? null : getLastCompilation().getCompiledAttributes();
    }
    public String toStringUnqualifiedMethodName(boolean visibilityAndReturnType, boolean fqParamTypes) {
        StringBuilder builder = new StringBuilder();
        if (visibilityAndReturnType) {
            if (modifier != 0) {
                builder.append(Modifier.toString(modifier)).append(C_SPACE);
            }
            if (!isConstructor() && returnType != null) {
                builder.append(expandParam(returnType.getName(), fqParamTypes)).append(C_SPACE);
            }
        }
        builder.append(memberName);
        builder.append(C_OPEN_PARENTHESES);
        if (paramTypes.size() > 0) {
            for (Class<?> paramClass : paramTypes) {
                builder.append(expandParam(paramClass.getName(), fqParamTypes)).append(C_COMMA);
            }
            builder.deleteCharAt(builder.length() - 1);
        }
        builder.append(C_CLOSE_PARENTHESES);
        return builder.toString();
    }
    public void addAssembly(AssemblyMethod asmMethod) {
        if (DEBUG_LOGGING_ASSEMBLY) {
            logger.debug("setAssembly on member {}", getFullyQualifiedMemberName());
        }
        Compilation compilation = getCompilationByAddress(asmMethod);
        if (compilation != null) {
            compilation.setAssembly(asmMethod);
        } else {
            logger.warn("{} Didn't find compilation to attach assembly for nativeAddress:{} or entryAddress:{}", getFullyQualifiedMemberName(), asmMethod.getNativeAddress(), asmMethod.getEntryAddress());
        }
    }
    public List<Compilation> getCompilations() {
        return compilations;
    }
    public boolean isConstructor() {
        return (this instanceof MetaConstructor);
    }
    public String getSourceMethodSignatureRegEx() {
        StringBuilder builder = new StringBuilder();
        builder.append(C_HAT);
        builder.append(REGEX_GROUP_ANY);
        String modifiers = Modifier.toString(modifier);
        if (modifiers.length() > 0) {
            builder.append(modifiers).append(C_SPACE);
        }
        if (!isConstructor() && returnType != null) {
            String rt = expandParamRegEx(returnType.getName());
            builder.append(rt);
            builder.append(C_SPACE);
        }
        if (isConstructor()) {
            builder.append(REGEX_UNICODE_PACKAGE_NAME);
            builder.append(StringUtil.getUnqualifiedClassName(memberName));
        } else {
            builder.append(memberName);
        }
        return builder.toString();
    }
    public static String expandParam(String inParamType, boolean fullyQualifiedType) {
        String paramType = inParamType;
        if (paramType.charAt(0) == C_OPEN_SQUARE_BRACKET) {
            paramType = ParseUtil.expandParameterType(paramType);
        }
        if (paramType.contains(S_DOT) && !fullyQualifiedType) {
            paramType = StringUtil.getUnqualifiedClassName(paramType);
        }
        return paramType;
    }
    public static String expandParamRegEx(String inParamType) {
        String paramType = inParamType;
        if (paramType.charAt(0) == C_OPEN_SQUARE_BRACKET) {
            paramType = ParseUtil.expandParameterType(paramType);
            paramType = paramType.replace(S_OPEN_SQUARE_BRACKET, S_ESCAPED_OPEN_SQUARE).replace(S_CLOSE_SQUARE_BRACKET, S_ESCAPED_CLOSE_SQUARE);
        }
        if (paramType.contains(S_DOT)) {
            paramType = REGEX_UNICODE_PACKAGE_NAME + StringUtil.getUnqualifiedClassName(paramType);
        }
        return paramType;
    }
    public Compilation getLastCompilation() {
        int compilationCount = compilations.size();
        Compilation result = null;
        if (compilationCount > 0) {
            result = compilations.get(compilationCount - 1);
        }
        return result;
    }
    private int makeSafeIndex(int index) {
        return Math.max(0, Math.min(index, compilations.size() - 1));
    }
    public Compilation getCompilation(int index) {
        Compilation result = null;
        if (index >= 0 && index < compilations.size()) {
            result = compilations.get(index);
        }
        return result;
    }
    public void setSelectedCompilation(int index) {
        this.selectedCompilationIndex = makeSafeIndex(index);
    }
    public Compilation getSelectedCompilation() {
        return getCompilation(selectedCompilationIndex);
    }
    public int compareTo(IMetaMember other) {
        if (other == null) {
            return -1;
        } else {
            return getMemberName().compareTo(other.getMemberName());
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```