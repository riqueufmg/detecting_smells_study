##CONTEXT_SIZE=1092
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.util;
public final class FileUtil {
    private static final Logger logger = LoggerFactory.getLogger(FileUtil.class);
    private FileUtil() {
    }
    public static boolean isRunningFromJar() {
        URL url = FileUtil.class.getResource("FileUtil.class");
        return url != null && url.toString().startsWith("jar");
    }
    public static void copyFilesFromJarToDir(String folderInJar, File targetDir) {
        try {
            final File jarFile = new File(FileUtil.class.getProtectionDomain().getCodeSource().getLocation().getPath());
            if (jarFile.isFile()) {
                JarFile jar = new JarFile(jarFile);
                Enumeration<JarEntry> entries = jar.entries();
                while (entries.hasMoreElements()) {
                    JarEntry entry = entries.nextElement();
                    String entryName = entry.getName();
                    if (entryName.startsWith(folderInJar + "/") && !entry.isDirectory()) {
                        File newFile = newFile(targetDir, entry);
                        try (InputStream inputStream = jar.getInputStream(entry)) {
                            Files.copy(inputStream, newFile.toPath());
                            logger.info("Wrote: {}", newFile);
                        }
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Could not copy files from jar folder {} to {}", folderInJar, targetDir, e);
        }
    }
    private static File newFile(File destinationDir, JarEntry jarEntry) throws IOException {
        File entryFile = new File(jarEntry.getName());
        return new File(destinationDir, entryFile.getName());
    }
    public static void copyFilesToDir(File sourceDir, File targetDir) {
        if (sourceDir.exists() && sourceDir.isDirectory()) {
            File[] sourceFiles = sourceDir.listFiles();
            if (DEBUG_LOGGING) {
                logger.info("Copying {} files", sourceFiles.length);
            }
            for (File exampleFile : sourceFiles) {
                try {
                    Path srcPath = exampleFile.toPath();
                    Path dstPath = targetDir.toPath().resolve(exampleFile.getName());
                    if (DEBUG_LOGGING) {
                        logger.info("Copying file {} -> {}", srcPath, dstPath);
                    }
                    Files.copy(srcPath, dstPath);
                } catch (IOException ioe) {
                    logger.error("Could not copy {} to {}", exampleFile, targetDir, ioe);
                }
            }
        } else {
            logger.error("Could not find source directory {}", sourceDir);
        }
    }
    public static File writeSource(File sourceDir, String fqClassName, String sourceCode) throws IOException {
        String[] parts = fqClassName.split(S_BACKSLASH + S_DOT);
        StringBuilder builder = new StringBuilder();
        builder.append(sourceDir.getAbsolutePath()).append(File.separatorChar);
        for (String part : parts) {
            builder.append(part).append(File.separatorChar);
        }
        builder.deleteCharAt(builder.length() - 1);
        builder.append(".java");
        String filePathString = builder.toString();
        int lastSep = filePathString.lastIndexOf(File.separatorChar);
        File sourceFile;
        if (lastSep != -1) {
            String dirPart = filePathString.substring(0, lastSep);
            String filePart = filePathString.substring(lastSep + 1);
            File dir = new File(dirPart);
            if (!dir.exists()) {
                dir.mkdirs();
            }
            sourceFile = new File(dir, filePart);
        } else {
            sourceFile = new File(filePathString);
        }
        if (DEBUG_LOGGING) {
            logger.debug("Writing source file: {}", sourceFile.getAbsolutePath());
        }
        BufferedWriter fout = new BufferedWriter(new FileWriter(sourceFile));
        try {
            fout.write(sourceCode);
            fout.flush();
        } finally {
            fout.close();
        }
        return sourceFile;
    }
    public static void emptyDir(File directory) {
        if (directory.exists() && directory.isDirectory()) {
            File[] contents = directory.listFiles();
            for (File file : contents) {
                if (file.isDirectory()) {
                    emptyDir(file);
                    file.delete();
                } else {
                    file.delete();
                }
            }
        }
    }
    public static File getJDKSourceZip() {
        String javaHome = System.getProperty("java.home");
        String srcDotZip = "src.zip";
        List<Path> possiblePaths = new ArrayList<>();
        possiblePaths.add(Paths.get(javaHome, srcDotZip));
        possiblePaths.add(Paths.get(javaHome, "jre", srcDotZip));
        possiblePaths.add(Paths.get(javaHome, "jre", "lib", srcDotZip));
        possiblePaths.add(Paths.get(javaHome, "lib", srcDotZip));
        if (javaHome.contains("jre")) {
            possiblePaths.add(Paths.get(javaHome, "..", srcDotZip));
        }
        File result = null;
        for (Path path : possiblePaths) {
            File file = path.toFile();
            if (file.exists() && file.isFile()) {
                result = file;
                break;
            }
        }
        return result;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```