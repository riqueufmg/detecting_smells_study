##CONTEXT_SIZE=544
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.histo;
public class Histo {
    private Map<Long, Integer> bucketMap = new HashMap<>();
    private List<Long> values = new ArrayList<>();
    private long lastTime = 0;
    private int maxCount = 0;
    private long resolution = 1;
    public Histo() {
    }
    public Histo(long resolution) {
        this.resolution = resolution;
    }
    public void addValue(long inValue) {
        long value = inValue;
        synchronized (values) {
            values.add(value);
        }
        if (resolution > 1) {
            value = (value / resolution) * resolution;
        }
        int newCount = 0;
        if (bucketMap.containsKey(value)) {
            newCount = bucketMap.get(value) + 1;
        } else {
            newCount = 1;
        }
        bucketMap.put(value, newCount);
        if (newCount > maxCount) {
            maxCount = newCount;
        }
        if (value > lastTime) {
            lastTime = value;
        }
    }
    public void clear() {
        bucketMap.clear();
        lastTime = 0;
        maxCount = 0;
    }
    public List<Map.Entry<Long, Integer>> getSortedData() {
        List<Map.Entry<Long, Integer>> result = new ArrayList<>(bucketMap.entrySet());
        Collections.sort(result, new Comparator<Map.Entry<Long, Integer>>() {
            @Override
            public int compare(Entry<Long, Integer> o1, Entry<Long, Integer> o2) {
                return o1.getValue().compareTo(o2.getValue());
            }
        });
        return result;
    }
    public long getPercentile(double percentile) {
        long result = 0;
        List<Long> valuesCopy = null;
        synchronized (values) {
            valuesCopy = new ArrayList<>(values);
        }
        Collections.sort(valuesCopy);
        int count = valuesCopy.size();
        if (percentile >= 100) {
            result = valuesCopy.get(count - 1);
        } else if (percentile <= 0) {
            result = 0;
        } else {
            double position = 0.5 + (percentile) / 100.0 * count;
            int index = (int) Math.round(position) - 1;
            result = valuesCopy.get(index);
        }
        return result;
    }
    public long getLastTime() {
        return lastTime;
    }
    public int getMaxCount() {
        return maxCount;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```