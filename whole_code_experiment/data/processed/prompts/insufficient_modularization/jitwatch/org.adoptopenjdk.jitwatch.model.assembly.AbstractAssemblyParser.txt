##CONTEXT_SIZE=1212
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.model.assembly;
public abstract class AbstractAssemblyParser implements IAssemblyParser {
    protected static final Logger logger = LoggerFactory.getLogger(AbstractAssemblyParser.class);
    protected Architecture architecture;
    protected AssemblyProcessor processor;
    public AbstractAssemblyParser(Architecture architecture) {
        this.architecture = architecture;
        processor = new AssemblyProcessor(architecture);
    }
    public Architecture getArchitecture() {
        return architecture;
    }
    public AssemblyMethod parseAssembly(final String assemblyString) {
        final AssemblyLabels labels = new AssemblyLabels();
        String[] lines = assemblyString.split(S_NEWLINE);
        StringBuilder headerBuilder = new StringBuilder();
        AssemblyBlock currentBlock = new AssemblyBlock();
        AssemblyInstruction lastInstruction = null;
        String lastLine = null;
        AssemblyMethod method = new AssemblyMethod(architecture);
        boolean seenInstructions = false;
        for (int i = 0; i < lines.length; i++) {
            if (DEBUG_LOGGING_ASSEMBLY) {
                logger.debug("line: '{}'", lines[i]);
            }
            if (lines[i].trim().startsWith("# {method}")) {
                method.setAssemblyMethodSignature(lines[i]);
            }
            String line = lines[i].replace(S_ENTITY_APOS, S_QUOTE);
            line = line.replaceFirst("^ +", "");
            if (line.startsWith(S_HASH)) {
                if (DEBUG_LOGGING_ASSEMBLY) {
                    logger.debug("Assembly header: {}", line);
                }
                headerBuilder.append(line).append(S_NEWLINE);
            } else if (line.startsWith(S_OPEN_SQUARE_BRACKET)) {
                if (!"[Constants]".equals(line)) {
                    if (currentBlock.getTitle() != null) {
                        method.addBlock(currentBlock);
                        if (DEBUG_LOGGING_ASSEMBLY) {
                            logger.debug("stored AssemblyBlock: {} at {}", currentBlock.getTitle(), method.getBlocks().size() - 1);
                        }
                    }
                    currentBlock = new AssemblyBlock();
                    currentBlock.setTitle(line);
                }
            } else if (line.startsWith(S_SEMICOLON)) {
                if (DEBUG_LOGGING_ASSEMBLY) {
                    logger.debug("Extended comment? '{}'", line);
                }
                if (lastInstruction != null) {
                    lastInstruction.addCommentLine(line);
                }
            } else {
                AssemblyInstruction instr = createInstruction(labels, line);
                if (instr == null && lastLine != null && lastLine.trim().startsWith(S_HASH) && !line.startsWith(S_HEX_PREFIX) && !line.contains(' ' + S_HEX_PREFIX)) {
                    if (headerBuilder.length() > 0) {
                        headerBuilder.setLength(headerBuilder.length() - S_NEWLINE.length());
                    }
                    headerBuilder.append(line).append(S_NEWLINE);
                    line = lastLine + line;
                } else if (instr == null && lastLine != null && lastLine.trim().startsWith(S_SEMICOLON) && lastInstruction != null) {
                    lastInstruction.appendToLastCommentLine(line);
                    line = lastLine + line;
                } else {
                    boolean replaceLast = false;
                    if (instr == null && i < lines.length - 1) {
                        String nextUntrimmedLine = lines[i + 1].replace(S_ENTITY_APOS, S_QUOTE);
                        boolean isNextLineAddress = nextUntrimmedLine.trim().matches("^0x[0-9a-f]+:.*");
                        boolean isNextLineDirective;
                        if (architecture == Architecture.ARM_32 || architecture == Architecture.ARM_64) {
                            isNextLineDirective = ARMDirective.isDirective(nextUntrimmedLine);
                        } else {
                            isNextLineDirective = X86Directive.isDirective(nextUntrimmedLine);
                        }
                        if (!isNextLineAddress && !isNextLineDirective) {
                            instr = createInstruction(labels, line + nextUntrimmedLine);
                            if (instr != null) {
                                i++;
                            }
                        }
                    }
                    if (instr == null && lastInstruction != null) {
                        boolean isCurrentLineAddress = line.trim().matches("^0x[0-9a-f]+:.*");
                        boolean isCurrentLineDirective;
                        if (architecture == Architecture.ARM_32 || architecture == Architecture.ARM_64) {
                            isCurrentLineDirective = ARMDirective.isDirective(line);
                        } else {
                            isCurrentLineDirective = X86Directive.isDirective(line);
                        }
                        if (!isCurrentLineAddress && !isCurrentLineDirective) {
                            instr = createInstruction(labels, lastLine + line);
                            if (instr != null) {
                                replaceLast = true;
                            }
                        }
                    }
                    if (instr != null) {
                        seenInstructions = true;
                        if (replaceLast) {
                            currentBlock.replaceLastInstruction(instr);
                        } else {
                            currentBlock.addInstruction(instr);
                            if (DEBUG_LOGGING_ASSEMBLY) {
                                logger.debug("Added instruction {} pos {}", instr.toString(), currentBlock.getInstructions().size() - 1);
                            }
                        }
                        if (currentBlock.getTitle() == null) {
                            currentBlock.setTitle(NATIVE_CODE_ENTRY_POINT);
                        }
                        lastInstruction = instr;
                    } else {
                        processor.handleLine(line.trim());
                    }
                }
            }
            lastLine = line;
        }
        if (DEBUG_LOGGING_ASSEMBLY) {
            logger.debug("default AssemblyBlock: {} at {}", currentBlock.getTitle(), method.getBlocks().size());
        }
        method.addBlock(currentBlock);
        method.setHeader(headerBuilder.toString());
        labels.buildLabels();
        return method;
    }
    public boolean isAddress(String mnemonic, String operand) {
        return (operand.startsWith(S_HEX_PREFIX) || operand.endsWith(S_HEX_POSTFIX)) && isJump(mnemonic);
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```