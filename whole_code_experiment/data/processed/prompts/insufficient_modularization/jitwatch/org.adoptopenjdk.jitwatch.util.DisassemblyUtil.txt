##CONTEXT_SIZE=828
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.util;
public final class DisassemblyUtil {
    private static final Logger logger = LoggerFactory.getLogger(DisassemblyUtil.class);
    private DisassemblyUtil() {
    }
    public static boolean isDisassemblerAvailable() {
        boolean found = downloadedDisassemblerPresent();
        Path binaryPath = getDisassemblerFilePath();
        if (binaryPath != null) {
            File hsdisFile = binaryPath.toFile();
            if (DEBUG_LOGGING_ASSEMBLY) {
                logger.debug("looking for hsdis binary: {}", hsdisFile);
            }
            if (hsdisFile.exists() && hsdisFile.isFile()) {
                found = true;
            }
        }
        return found;
    }
    public static String getDynamicLibraryPath() {
        switch(OSUtil.getOperatingSystem()) {
            case WIN:
                return "PATH";
            case MAC:
                return "DYLD_LIBRARY_PATH";
            case LINUX:
                return "LD_LIBRARY_PATH";
        }
        throw new RuntimeException("Unknown OS");
    }
    public static String getDisassemblerFilename() {
        OperatingSystem os = OSUtil.getOperatingSystem();
        String archName = System.getProperty("os.arch");
        if ("x86_64".equals(archName)) {
            archName = "amd64";
        }
        String binaryName = "hsdis-" + archName;
        if (os != null) {
            switch(os) {
                case WIN:
                    binaryName += ".dll";
                    break;
                case MAC:
                    binaryName += ".dylib";
                    break;
                case LINUX:
                    binaryName += ".so";
                    break;
            }
        }
        if (DEBUG_LOGGING_ASSEMBLY) {
            logger.debug("binaryName: {}", binaryName);
        }
        return binaryName;
    }
    public static boolean downloadedDisassemblerPresent() {
        return new File(getDisassemblerFilename()).exists();
    }
    public static Path getDisassemblerFilePath() {
        String binaryName = getDisassemblerFilename();
        String dynLibPath = System.getenv(getDynamicLibraryPath());
        if (dynLibPath != null) {
            String[] dirs = dynLibPath.split(":");
            for (String dir : dirs) {
                Path path = Paths.get(dir, binaryName);
                if (DEBUG_LOGGING_ASSEMBLY) {
                    logger.debug("looking in {}", path);
                }
                File file = path.toFile();
                if (file.exists() && file.isFile()) {
                    return path;
                }
            }
        }
        String javaHome = System.getProperty("java.home", "");
        if (DEBUG_LOGGING_ASSEMBLY) {
            logger.debug("java.home is {}", javaHome);
        }
        if (javaHome.endsWith("jre")) {
            javaHome = javaHome.substring(0, javaHome.length() - 3);
        }
        String[] jrePath = new String[] { "jre", "" };
        String[] libPath = new String[] { "lib", "bin", "" };
        String[] serverPath = new String[] { "server", "client", "" };
        String[] archPath = new String[] { "i386", "amd64", "arm", "aarch64", "" };
        for (String jre : jrePath) {
            for (String lib : libPath) {
                for (String server : serverPath) {
                    for (String arch : archPath) {
                        Path path = Paths.get(javaHome, jre, lib, server, arch, binaryName);
                        if (DEBUG_LOGGING_ASSEMBLY) {
                            logger.debug("looking in {}", path);
                        }
                        File file = path.toFile();
                        if (file.exists() && file.isFile()) {
                            return path;
                        }
                    }
                }
            }
        }
        if (downloadedDisassemblerPresent()) {
            return Paths.get(getDisassemblerFilename());
        }
        return null;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```