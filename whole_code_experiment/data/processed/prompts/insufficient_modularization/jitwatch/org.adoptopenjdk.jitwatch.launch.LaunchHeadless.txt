##CONTEXT_SIZE=1389
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.launch;
public class LaunchHeadless implements IJITListener, ILogParseErrorListener {
    private boolean showTimeLine;
    private boolean showErrors;
    private boolean showModel;
    private boolean showOnlyCompiledMethods;
    private boolean showSuggestions;
    private boolean outputFile;
    private boolean showInlineFailedCalls;
    private ILogParser parser;
    private JITWatchConfig config;
    private StringBuilder timelineBuilder = new StringBuilder();
    private StringBuilder errorBuilder = new StringBuilder();
    public LaunchHeadless(String[] args) throws IOException {
        LoggerFactory.setLogFile(Paths.get("jitwatch.out"));
        String compilationLog = args[args.length - 1];
        parseOptions(args);
        timelineBuilder.append("Timestamp").append(HEADLESS_SEPARATOR);
        timelineBuilder.append("Event").append(HEADLESS_SEPARATOR);
        timelineBuilder.append("Class").append(HEADLESS_SEPARATOR);
        timelineBuilder.append("Member").append(S_NEWLINE);
        config = new JITWatchConfig();
        String parserProperty = System.getProperty("jitwatch.parser", ParserType.HOTSPOT.toString());
        ParserType parserType = ParserType.fromString(parserProperty);
        parser = ParserFactory.getParser(parserType, this);
        parser.setConfig(config);
        parser.processLogFile(new File(compilationLog), this);
    }
    public void handleLogEntry(String entry) {
    }
    public void handleErrorEntry(String entry) {
        if (showErrors) {
            errorBuilder.append(entry).append(S_NEWLINE);
        }
    }
    public void handleJITEvent(JITEvent event) {
        if (showTimeLine) {
            timelineBuilder.append(StringUtil.formatTimestamp(event.getStamp(), true)).append(HEADLESS_SEPARATOR);
            timelineBuilder.append(event.getEventType().getText()).append(HEADLESS_SEPARATOR);
            timelineBuilder.append(event.getEventMember().getMetaClass().getFullyQualifiedName()).append(HEADLESS_SEPARATOR);
            timelineBuilder.append(event.getEventMember().toStringUnqualifiedMethodName(true, true)).append(S_NEWLINE);
        }
    }
    public void handleReadStart() {
    }
    public void handleError(String title, String body) {
        if (showErrors) {
            errorBuilder.append(title).append(HEADLESS_SEPARATOR).append(body).append(S_NEWLINE);
        }
    }
    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.err.println("Usage: LaunchHeadless <options> <hotspot log file>");
            System.err.println("options:");
            System.err.println("-e\tShow parse errors");
            System.err.println("-m\tShow model");
            System.err.println("-c\tShow only compiled methods in model (use with -m)");
            System.err.println("-s\tShow code suggestions");
            System.err.println("-t\tShow compilation timeline");
            System.err.println("-f\tWrite output to headless.csv");
            System.err.println("-i\tShow inline failed calls");
            System.exit(-1);
        }
        new LaunchHeadless(args);
    }
    private void parseOptions(String[] args) {
        for (int i = 0; i < args.length - 1; i++) {
            String arg = args[i];
            switch(arg) {
                case "-c":
                    showOnlyCompiledMethods = true;
                    break;
                case "-e":
                    showErrors = true;
                    break;
                case "-m":
                    showModel = true;
                    break;
                case "-s":
                    showSuggestions = true;
                    break;
                case "-t":
                    showTimeLine = true;
                    break;
                case "-f":
                    outputFile = true;
                    break;
                case "-i":
                    showInlineFailedCalls = true;
                    break;
            }
        }
    }
    public void handleReadComplete() {
        StringBuilder outputBuilder = new StringBuilder();
        if (showTimeLine) {
            outputBuilder.append(timelineBuilder.toString()).append(S_NEWLINE);
        }
        if (showErrors) {
            outputBuilder.append(errorBuilder.toString()).append(S_NEWLINE);
        }
        if (showModel) {
            IReadOnlyJITDataModel model = parser.getModel();
            String modelString = HeadlessUtil.modelToString(model, showOnlyCompiledMethods);
            outputBuilder.append(modelString).append(S_NEWLINE);
        }
        if (showSuggestions) {
            SuggestionWalker walker = new SuggestionWalker(parser.getModel());
            List<Report> suggestions = walker.getReports(new ScoreComparator());
            outputBuilder.append(getSuggestions(suggestions));
        }
        if (outputFile) {
            outputBuilder.insert(0, "sep=" + HEADLESS_SEPARATOR + S_NEWLINE);
            try {
                Files.write(Paths.get("headless.csv"), outputBuilder.toString().getBytes());
                System.out.println("Wrote to headless.csv");
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            System.out.println(outputBuilder.toString());
        }
        if (showInlineFailedCalls) {
            HeadlessInlineVisitor inlineVisitor = new HeadlessInlineVisitor(parser.getModel());
            TreeVisitor.walkTree(parser.getModel(), inlineVisitor);
            inlineVisitor.printFailedList(System.out);
        }
    }
    private String getSuggestions(List<Report> suggestions) {
        StringBuilder builder = new StringBuilder();
        builder.append("Type").append(HEADLESS_SEPARATOR);
        builder.append("Score").append(HEADLESS_SEPARATOR);
        builder.append("Caller Class").append(HEADLESS_SEPARATOR);
        builder.append("Caller Member").append(HEADLESS_SEPARATOR);
        builder.append("BCI").append(HEADLESS_SEPARATOR);
        builder.append("Suggestion").append(S_NEWLINE);
        for (Report suggestion : suggestions) {
            String callerClass;
            String callerMember;
            if (suggestion.getCaller() != null) {
                callerClass = suggestion.getCaller().getMetaClass().getFullyQualifiedName();
                callerMember = suggestion.getCaller().toStringUnqualifiedMethodName(true, true);
            } else {
                callerClass = "Unknown";
                callerMember = "Unknown";
            }
            String cleanText = suggestion.getText().replace(C_NEWLINE, C_SPACE);
            builder.append(suggestion.getType()).append(HEADLESS_SEPARATOR);
            builder.append(suggestion.getScore()).append(HEADLESS_SEPARATOR);
            builder.append(callerClass).append(HEADLESS_SEPARATOR);
            builder.append(callerMember).append(HEADLESS_SEPARATOR);
            builder.append(suggestion.getBytecodeOffset()).append(HEADLESS_SEPARATOR);
            builder.append(cleanText).append(S_NEWLINE);
        }
        return builder.toString();
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```