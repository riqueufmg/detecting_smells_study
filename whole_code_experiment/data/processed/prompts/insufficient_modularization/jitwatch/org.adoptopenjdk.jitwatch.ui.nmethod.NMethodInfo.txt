##CONTEXT_SIZE=1597
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.ui.nmethod;
public class NMethodInfo extends HBox {
    private Label lblCompileID;
    private Label lblClass;
    private Label lblMember;
    private Label lblCompilationNumber;
    private Label lblCompiler;
    private Label lblAddress;
    private Label lblBytecodeSize;
    private Label lblNativeSize;
    private Label lblQueuedTime;
    private Label lblCompilationStartTime;
    private Label lblNMethodEmittedTime;
    private Label lblCompileDuration;
    private List<Label> clearable = new ArrayList<>();
    private IPrevNextCompilationListener listener;
    private static final int DESCRIPTION_WIDTH = 128;
    public NMethodInfo(IPrevNextCompilationListener listener) {
        this.listener = listener;
        setPadding(new Insets(24, 4, 0, 4));
        setSpacing(16);
        getChildren().addAll(makeLeftColumn(), makeRightColumn());
    }
    private VBox makeLeftColumn() {
        VBox column = new VBox();
        column.setSpacing(8);
        lblCompileID = new Label();
        lblClass = new Label();
        lblMember = new Label();
        lblCompilationNumber = new Label();
        lblCompiler = new Label();
        column.getChildren().add(makeLabel("Compile ID", lblCompileID));
        column.getChildren().add(makeLabel("Class", lblClass));
        column.getChildren().add(makeLabel("Compiled Member", lblMember));
        column.getChildren().add(makeCompilationNavigator());
        column.getChildren().add(makeLabel("Compiler Used", lblCompiler));
        return column;
    }
    private VBox makeRightColumn() {
        VBox column = new VBox();
        column.setSpacing(8);
        lblAddress = new Label();
        lblBytecodeSize = new Label();
        lblNativeSize = new Label();
        lblQueuedTime = new Label();
        lblCompilationStartTime = new Label();
        lblNMethodEmittedTime = new Label();
        lblCompileDuration = new Label();
        column.getChildren().add(makeLabel("NMethod Address", lblAddress));
        column.getChildren().add(makeSizeInfo());
        column.getChildren().add(makeLabel("Queued at", lblQueuedTime));
        column.getChildren().add(makeTimingInfo());
        column.getChildren().add(makeLabel("Compile Duration", lblCompileDuration));
        return column;
    }
    private HBox makeCompilationNavigator() {
        HBox hbox = new HBox();
        hbox.setSpacing(8);
        Button btnPrev = new Button("Prev");
        Button btnNext = new Button("Next");
        btnPrev.setMinWidth(20);
        btnNext.setMinWidth(20);
        btnPrev.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                listener.selectPrevCompilation();
            }
        });
        btnNext.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                listener.selectNextCompilation();
            }
        });
        HBox hboxLabel = makeLabel("Compilation #", lblCompilationNumber);
        lblCompilationNumber.prefWidthProperty().unbind();
        lblCompilationNumber.prefWidthProperty().bind(widthProperty().multiply(0.25).subtract(DESCRIPTION_WIDTH));
        hbox.getChildren().addAll(hboxLabel, btnPrev, btnNext);
        return hbox;
    }
    private HBox makeSizeInfo() {
        HBox hbox = new HBox();
        hbox.setSpacing(8);
        HBox hboxBytecode = makeLabel("Bytecode Size", lblBytecodeSize);
        lblBytecodeSize.prefWidthProperty().unbind();
        lblBytecodeSize.prefWidthProperty().bind(widthProperty().multiply(0.25).subtract(DESCRIPTION_WIDTH));
        HBox hboxNative = makeLabel("Native Size", lblNativeSize, Pos.BASELINE_RIGHT);
        lblNativeSize.prefWidthProperty().unbind();
        lblNativeSize.prefWidthProperty().bind(widthProperty().multiply(0.25).subtract(DESCRIPTION_WIDTH));
        hbox.getChildren().addAll(hboxBytecode, hboxNative);
        return hbox;
    }
    private HBox makeTimingInfo() {
        HBox hbox = new HBox();
        hbox.setSpacing(8);
        HBox hboxTiming1 = makeLabel("Compile Start", lblCompilationStartTime);
        lblCompilationStartTime.prefWidthProperty().unbind();
        lblCompilationStartTime.prefWidthProperty().bind(widthProperty().multiply(0.25).subtract(DESCRIPTION_WIDTH));
        HBox hboxTiming2 = makeLabel("NMethod Emitted", lblNMethodEmittedTime, Pos.BASELINE_RIGHT);
        lblNMethodEmittedTime.prefWidthProperty().unbind();
        lblNMethodEmittedTime.prefWidthProperty().bind(widthProperty().multiply(0.25).subtract(DESCRIPTION_WIDTH));
        hbox.getChildren().addAll(hboxTiming1, hboxTiming2);
        return hbox;
    }
    private HBox makeLabel(String labelText, Label labelValue) {
        return makeLabel(labelText, labelValue, Pos.BASELINE_LEFT);
    }
    private HBox makeLabel(String labelText, Label labelValue, Pos labelAlignment) {
        HBox hbox = new HBox();
        hbox.setSpacing(16);
        Label descriptionLabel = new Label(labelText);
        descriptionLabel.setMinWidth(DESCRIPTION_WIDTH);
        descriptionLabel.setAlignment(labelAlignment);
        labelValue.getStyleClass().add("readonly-label");
        labelValue.prefWidthProperty().bind(widthProperty().multiply(0.5).subtract(DESCRIPTION_WIDTH));
        hbox.getChildren().addAll(descriptionLabel, labelValue);
        clearable.add(labelValue);
        return hbox;
    }
    public void setInfo(Compilation compilation) {
        IMetaMember compilationMember = compilation.getMember();
        int compilationCount = compilationMember.getCompilations().size();
        lblCompileID.setText(compilation.getCompileID());
        lblClass.setText(compilationMember.getMetaClass().getFullyQualifiedName());
        String fqMemberName = compilationMember.toStringUnqualifiedMethodName(true, true);
        lblMember.setText(fqMemberName);
        lblMember.setTooltip(new Tooltip(fqMemberName));
        String compilerString = compilation.getCompiler();
        if (compilation.getLevel() != -1) {
            compilerString += " (Level " + compilation.getLevel() + ")";
        }
        lblCompiler.setText(compilerString);
        lblCompilationNumber.setText(Integer.toString(1 + compilation.getIndex()) + " of " + compilationCount);
        lblBytecodeSize.setText(Long.toString(compilation.getBytecodeSize()) + " bytes");
        lblQueuedTime.setText(StringUtil.formatTimestamp(compilation.getStampTaskQueued(), true));
        lblCompilationStartTime.setText(StringUtil.formatTimestamp(compilation.getStampTaskCompilationStart(), true));
        if (compilation.isFailed()) {
            lblAddress.setText("Compilation failed, no nmethod emitted");
            lblNativeSize.setText("NA");
            lblCompileDuration.setText("NA");
            lblNMethodEmittedTime.setText("NA");
        } else {
            lblAddress.setText(compilation.getNativeAddress());
            lblNativeSize.setText(Long.toString(compilation.getNativeSize()) + " bytes");
            lblCompileDuration.setText(Long.toString(compilation.getCompilationDuration()) + "ms");
            lblNMethodEmittedTime.setText(StringUtil.formatTimestamp(compilation.getStampNMethodEmitted(), true));
        }
    }
    public void clear() {
        for (Label label : clearable) {
            label.setText(S_EMPTY);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```