##CONTEXT_SIZE=712
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.ui.report;
public class ReportStage extends Stage {
    private VBox vbox;
    private TableView<IReportRowBean> tableView;
    private ObservableList<IReportRowBean> observableList = FXCollections.observableArrayList();
    private Set<String> filterPackageSet = new HashSet<>();
    private List<Report> reportList;
    private ReportStageType type;
    public ReportStage(final IStageAccessProxy proxy, String title, ReportStageType type, List<Report> reportList) {
        this.reportList = reportList;
        this.type = type;
        MemberTableCell.setTriViewAccessor(proxy);
        LinkedBCICell.setTriViewAccessor(proxy);
        initStyle(StageStyle.DECORATED);
        BorderPane borderPane = new BorderPane();
        vbox = new VBox();
        ReportPackageFilter filter = new ReportPackageFilter(this);
        borderPane.setTop(filter);
        borderPane.setCenter(vbox);
        Scene scene = UserInterfaceUtil.getScene(borderPane, JITWatchUI.WINDOW_WIDTH, JITWatchUI.WINDOW_HEIGHT);
        switch(type) {
            case SUGGESTION:
                setTitle(title);
                tableView = SuggestionRowBuilder.buildTable(observableList);
                break;
            case ELIMINATED_ALLOCATION:
                setTitle(title);
                tableView = EliminatedAllocationRowBuilder.buildTable(observableList);
                break;
            case ELIDED_LOCK:
                setTitle(title);
                tableView = OptimisedLockRowBuilder.buildTable(observableList);
                break;
            case INLINING:
                setTitle(title);
                tableView = InliningRowBuilder.buildTable(observableList);
                break;
        }
        filter.prefWidthProperty().bind(scene.widthProperty());
        vbox.getChildren().add(tableView);
        tableView.prefHeightProperty().bind(scene.heightProperty());
        setScene(scene);
        display();
    }
    public void clear() {
        observableList.clear();
    }
    public ReportStageType getType() {
        return type;
    }
    private void display() {
        clear();
        if (reportList.isEmpty()) {
            vbox.getChildren().clear();
            vbox.getChildren().add(new Label("No results"));
        } else {
            for (Report report : reportList) {
                boolean show = false;
                if (filterPackageSet.isEmpty()) {
                    show = true;
                } else {
                    for (String allowedPackage : filterPackageSet) {
                        if (report.getCaller() != null && report.getCaller().getFullyQualifiedMemberName().startsWith(allowedPackage.trim())) {
                            show = true;
                        }
                    }
                }
                if (show) {
                    switch(type) {
                        case SUGGESTION:
                            observableList.add(new SuggestionRowBean(report));
                            break;
                        case ELIMINATED_ALLOCATION:
                            observableList.add(new EliminatedAllocationRowBean(report));
                            break;
                        case ELIDED_LOCK:
                            observableList.add(new OptimisedLockRowBean(report));
                            break;
                        case INLINING:
                            observableList.add(new InliningRowBean(report));
                            break;
                    }
                }
            }
        }
    }
    public void setFilter(String packageFilter) {
        String[] packages = packageFilter.split(JITWatchConstants.S_COMMA);
        filterPackageSet.clear();
        filterPackageSet.addAll(Arrays.asList(packages));
        display();
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```