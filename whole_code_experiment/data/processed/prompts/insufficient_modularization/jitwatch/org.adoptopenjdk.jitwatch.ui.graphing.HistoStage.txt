##CONTEXT_SIZE=940
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.ui.graphing;
public class HistoStage extends AbstractGraphStage {
    private Histo histo;
    private IHistoVisitable histoVisitable;
    public HistoStage(final JITWatchUI parent) {
        super(parent, JITWatchUI.WINDOW_WIDTH, JITWatchUI.WINDOW_HEIGHT, false);
        IReadOnlyJITDataModel model = parent.getJITDataModel();
        final Map<String, IHistoVisitable> attrMap = new HashMap<>();
        attrMap.put("JIT Compilation Times", new CompileTimeHistoWalker(model, 1));
        attrMap.put("Bytes per Compiled Method", new AttributeNameHistoWalker(model, true, ATTR_BYTES, 1));
        attrMap.put("Native Bytes per Compiled Method", new NativeSizeHistoWalker(model, 1));
        attrMap.put("Inlined Method Sizes", new InlineSizeHistoVisitable(model, 1));
        VBox vbox = new VBox();
        ObservableList<String> options = FXCollections.observableArrayList(attrMap.keySet());
        histoVisitable = attrMap.get(options.get(0));
        final ComboBox<String> comboBox = new ComboBox<>(options);
        comboBox.setValue(options.get(0));
        comboBox.valueProperty().addListener(new ChangeListener<String>() {
            @Override
            public void changed(ObservableValue<? extends String> ov, String oldVal, String newVal) {
                histoVisitable = attrMap.get(newVal);
                histo = histoVisitable.buildHistogram();
                redraw();
            }
        });
        HBox hbox = new HBox();
        hbox.setPadding(new Insets(4, 0, 0, graphGapLeft));
        hbox.getChildren().add(comboBox);
        hbox.setMinHeight(30);
        vbox.getChildren().add(hbox);
        vbox.getChildren().add(canvas);
        Scene scene = UserInterfaceUtil.getScene(vbox, width, height);
        canvas.widthProperty().bind(scene.widthProperty());
        canvas.heightProperty().bind(scene.heightProperty().subtract(30));
        setTitle("JITWatch Histogram");
        histo = histoVisitable.buildHistogram();
        setScene(scene);
        show();
        redraw();
    }
    public final void redraw() {
        super.baseRedraw();
        if (histo == null) {
            return;
        }
        List<Map.Entry<Long, Integer>> result = histo.getSortedData();
        if (result.size() > 0) {
            minX = 0;
            maxX = histo.getLastTime();
            minY = 0;
            maxY = histo.getMaxCount();
            gc.setStroke(Color.BLACK);
            gc.setFont(new Font("monospace", 10));
            drawAxes();
            Color colourLine = Color.RED;
            for (Map.Entry<Long, Integer> entry : result) {
                long key = entry.getKey();
                int value = entry.getValue();
                double x = graphGapLeft + normaliseX(key);
                gc.setLineWidth(2.0);
                gc.setStroke(colourLine);
                double y = graphGapTop + normaliseY(value);
                gc.strokeLine(fix(x), fix(graphGapTop + chartHeight), fix(x), fix(y));
            }
            double legendWidth = 100;
            double legendHeight = 220;
            double xPos = canvas.getWidth() - graphGapRight - legendWidth - 5;
            double yPos = graphGapTop + 5;
            gc.setFill(Color.WHITE);
            gc.setStroke(Color.BLACK);
            gc.fillRect(fix(xPos), fix(yPos), fix(legendWidth), fix(legendHeight));
            gc.strokeRect(fix(xPos), fix(yPos), fix(legendWidth), fix(legendHeight));
            xPos += 5;
            yPos += 5;
            for (double percent : new double[] { 50, 90, 95, 99, 99.9, 99.99, 99.999, 100 }) {
                setStrokeForText();
                gc.fillText(percent + "% : " + histo.getPercentile(percent), fix(xPos), fix(yPos));
                yPos += 20;
            }
        } else {
            setStrokeForText();
            gc.fillText("No data for histogram.", fix(graphGapLeft + 8), fix(graphGapTop + 16));
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```