##CONTEXT_SIZE=743
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.process;
public abstract class AbstractProcess implements IExternalProcess {
    protected static final Logger logger = LoggerFactory.getLogger(RuntimeJava.class);
    private Path stdErr;
    private Path stdOut;
    public AbstractProcess() {
        try {
            stdErr = Files.createTempFile("stream", ".err");
            stdOut = Files.createTempFile("stream", ".out");
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }
    public String getExecutableSuffix() {
        return isWindows() ? ".exe" : "";
    }
    public String getLaunchScriptSuffix() {
        return isWindows() ? ".bat" : ".sh";
    }
    public boolean isWindows() {
        return System.getProperty("os.name", S_EMPTY).contains("Windows");
    }
    public String getOutputStream() {
        String result = null;
        if (stdOut.toFile().exists()) {
            try {
                result = new String(Files.readAllBytes(stdOut), StandardCharsets.UTF_8);
            } catch (IOException ioe) {
                ioe.printStackTrace();
            }
        }
        return result;
    }
    public String getErrorStream() {
        String result = null;
        if (stdErr.toFile().exists()) {
            try {
                result = new String(Files.readAllBytes(stdErr), StandardCharsets.UTF_8);
            } catch (IOException ioe) {
                ioe.printStackTrace();
            }
        }
        return result;
    }
    protected String makeClassPath(List<String> classpathEntries) {
        StringBuilder cpBuilder = new StringBuilder();
        for (String cp : classpathEntries) {
            cpBuilder.append(cp).append(File.pathSeparatorChar);
        }
        if (cpBuilder.length() > 0) {
            cpBuilder.deleteCharAt(cpBuilder.length() - 1);
        }
        return cpBuilder.toString();
    }
    protected boolean runCommands(List<String> commands, Map<String, String> environment, ILogListener logListener) {
        return runCommands(commands, null, environment, logListener);
    }
    protected boolean runCommands(List<String> commands, Path workingDirectory, Map<String, String> environment, ILogListener logListener) {
        StringBuilder cmdBuilder = new StringBuilder();
        for (String part : commands) {
            cmdBuilder.append(part).append(C_SPACE);
        }
        logger.info("Process: {}", cmdBuilder.toString());
        if (logListener != null) {
            logListener.handleLogEntry("Running: " + cmdBuilder.toString());
        }
        int result = -1;
        try {
            ProcessBuilder pb = new ProcessBuilder(commands);
            if (environment != null) {
                Map<String, String> processEnvironment = pb.environment();
                for (Map.Entry<String, String> entry : environment.entrySet()) {
                    processEnvironment.put(entry.getKey(), entry.getValue());
                    logListener.handleLogEntry("Environment: " + entry.getKey() + "=" + entry.getValue());
                }
            }
            if (workingDirectory != null) {
                pb.directory(workingDirectory.toFile());
            }
            pb.redirectError(stdErr.toFile());
            pb.redirectOutput(stdOut.toFile());
            Process proc = pb.start();
            result = proc.waitFor();
        } catch (Exception e) {
            if (logListener != null) {
                logListener.handleErrorEntry("Could not run external process:" + e);
            }
            logger.error("Could not run external process:", e);
        }
        return result == 0;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```