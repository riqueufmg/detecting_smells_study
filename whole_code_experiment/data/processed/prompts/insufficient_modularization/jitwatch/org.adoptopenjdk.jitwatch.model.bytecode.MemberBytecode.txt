##CONTEXT_SIZE=879
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.model.bytecode;
public class MemberBytecode {
    private List<BytecodeInstruction> bytecodeInstructions = new ArrayList<>();
    private LineTable lineTable;
    private ExceptionTable exceptionTable;
    private MemberSignatureParts msp;
    private ClassBC classBytecode;
    private int size = 0;
    private static final Logger logger = LoggerFactory.getLogger(MemberBytecode.class);
    private BytecodeAnnotations bytecodeAnnotations = new BytecodeAnnotations();
    public MemberBytecode(ClassBC classBytecode, MemberSignatureParts msp) {
        this.msp = msp;
        this.classBytecode = classBytecode;
        lineTable = new LineTable(this);
        exceptionTable = new ExceptionTable();
    }
    public ClassBC getClassBytecode() {
        return classBytecode;
    }
    public BytecodeAnnotations getBytecodeAnnotations() {
        return bytecodeAnnotations;
    }
    public MemberSignatureParts getMemberSignatureParts() {
        return msp;
    }
    public void setInstructions(List<BytecodeInstruction> bytecodeInstructions) {
        this.bytecodeInstructions = bytecodeInstructions;
        if (!bytecodeInstructions.isEmpty()) {
            BytecodeInstruction instruction = bytecodeInstructions.get(bytecodeInstructions.size() - 1);
            if (instruction != null) {
                int bci = instruction.getOffset();
                size = bci + 1;
            }
        }
    }
    public int size() {
        return size;
    }
    public List<BytecodeInstruction> getInstructions() {
        return bytecodeInstructions;
    }
    public BytecodeInstruction getInstructionAtBCI(int bci) {
        if (DEBUG_LOGGING_BYTECODE) {
            logger.debug("getInstructionAtBCI({})", bci);
        }
        BytecodeInstruction result = null;
        for (BytecodeInstruction instruction : bytecodeInstructions) {
            if (DEBUG_LOGGING_BYTECODE) {
                logger.debug("checking: {}", instruction);
            }
            if (instruction.getOffset() == bci) {
                result = instruction;
                break;
            }
        }
        if (DEBUG_LOGGING_BYTECODE) {
            logger.debug("found: {}", result);
        }
        return result;
    }
    public int findLastBackBranchToBCI(int bci) {
        if (DEBUG_LOGGING_BYTECODE) {
            logger.debug("findLastBackBranchToBCI({})", bci);
        }
        int lastBackBranchBCI = -1;
        boolean inLoop = false;
        for (BytecodeInstruction instruction : bytecodeInstructions) {
            if (instruction.getOffset() == bci) {
                inLoop = true;
            }
            if (inLoop) {
                Opcode opCode = instruction.getOpcode();
                if (opCode == Opcode.GOTO || opCode == Opcode.GOTO_W) {
                    List<IBytecodeParam> gotoParams = instruction.getParameters();
                    int paramCount = gotoParams.size();
                    if (paramCount == 1) {
                        IBytecodeParam param = gotoParams.get(0);
                        if (param instanceof BCParamNumeric) {
                            int gotoTarget = ((BCParamNumeric) param).getValue();
                            if (gotoTarget == bci) {
                                lastBackBranchBCI = instruction.getOffset();
                            }
                        }
                    } else {
                        logger.error("Unexpected param count for {} {}", opCode, paramCount);
                    }
                }
            }
        }
        return lastBackBranchBCI;
    }
    public void addLineTableEntry(LineTableEntry entry) {
        lineTable.add(entry);
    }
    public LineTable getLineTable() {
        return lineTable;
    }
    public void addExceptionTableEntry(ExceptionTableEntry entry) {
        exceptionTable.add(entry);
    }
    public ExceptionTable getExceptionTable() {
        return exceptionTable;
    }
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("MemberBytcode signature:\n").append(msp).append(S_NEWLINE);
        for (BytecodeInstruction instruction : bytecodeInstructions) {
            builder.append(instruction.toString()).append(S_NEWLINE);
        }
        return builder.toString();
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```