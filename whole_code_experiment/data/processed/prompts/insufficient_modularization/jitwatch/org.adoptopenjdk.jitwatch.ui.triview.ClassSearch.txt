##CONTEXT_SIZE=753
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.ui.triview;
public class ClassSearch extends Region {
    private TextField tfSearch;
    private ContextMenu dropMenu = new ContextMenu();
    private PackageManager pm;
    private TriView triView;
    private static final int MAX_SEARCH_RESULTS = 20;
    private boolean ignoreChanges = false;
    public ClassSearch(TriView triView, PackageManager pm) {
        this.triView = triView;
        this.pm = pm;
        tfSearch = new TextField();
        tfSearch.setPromptText("Enter class name");
        tfSearch.prefWidthProperty().bind(widthProperty());
        getChildren().add(tfSearch);
        tfSearch.setOnKeyReleased(new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent keyEvent) {
                if (keyEvent.getCode() == KeyCode.DOWN) {
                    dropMenu.requestFocus();
                }
            }
        });
        tfSearch.textProperty().addListener(new ChangeListener<String>() {
            @Override
            public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
                if (!ignoreChanges) {
                    if (tfSearch.getText().length() == 0) {
                        if (dropMenu != null) {
                            dropMenu.hide();
                        }
                    } else {
                        performActionUsingSearchResults();
                    }
                }
            }
        });
    }
    public void clear() {
        tfSearch.clear();
    }
    private void performActionUsingSearchResults() {
        List<String> results = search(tfSearch.getText());
        if (results.size() > 0) {
            buildResultsMenu(results);
            if (!dropMenu.isShowing()) {
                dropMenu.show(this, Side.BOTTOM, 10, -5);
            }
        } else {
            dropMenu.hide();
        }
    }
    public void setText(String text) {
        ignoreChanges = true;
        tfSearch.setText(text);
        ignoreChanges = false;
    }
    private List<String> search(String term) {
        List<String> results = new ArrayList<>();
        List<MetaPackage> roots = pm.getRootPackages();
        for (MetaPackage mp : roots) {
            walkTree(mp, results, term.toLowerCase());
            if (results.size() >= MAX_SEARCH_RESULTS) {
                break;
            }
        }
        return results;
    }
    private void walkTree(MetaPackage mp, List<String> results, String term) {
        if (results.size() >= MAX_SEARCH_RESULTS) {
            return;
        }
        List<MetaPackage> childPackages = mp.getChildPackages();
        for (MetaPackage childPackage : childPackages) {
            walkTree(childPackage, results, term);
        }
        List<MetaClass> packageClasses = mp.getPackageClasses();
        for (MetaClass mc : packageClasses) {
            if (mc.getFullyQualifiedName().toLowerCase().contains(term)) {
                results.add(mc.getFullyQualifiedName());
                if (results.size() >= MAX_SEARCH_RESULTS) {
                    break;
                }
            }
        }
    }
    private void buildResultsMenu(List<String> items) {
        dropMenu.getItems().clear();
        for (String item : items) {
            final MenuItem mi = new MenuItem(item);
            mi.setOnAction(new EventHandler<ActionEvent>() {
                @Override
                public void handle(ActionEvent e) {
                    dropMenu.hide();
                    MetaClass metaClass = pm.getMetaClass(mi.getText());
                    triView.setMetaClass(metaClass);
                }
            });
            dropMenu.getItems().add(mi);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```