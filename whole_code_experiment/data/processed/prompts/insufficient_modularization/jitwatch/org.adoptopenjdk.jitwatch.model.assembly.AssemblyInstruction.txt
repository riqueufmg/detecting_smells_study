##CONTEXT_SIZE=1263
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.model.assembly;
public class AssemblyInstruction {
    private String annotation;
    private long address;
    private List<String> prefixes;
    private String mnemonic;
    private List<String> operands = new ArrayList<>();
    private List<String> commentLines = new ArrayList<>();
    private final AssemblyLabels labels;
    private boolean isSafePoint = false;
    public AssemblyInstruction(String annotation, long address, List<String> prefixes, String mnemonic, List<String> operands, String firstComment, AssemblyLabels labels) {
        this.annotation = annotation;
        this.address = address;
        this.prefixes = prefixes;
        this.mnemonic = mnemonic;
        this.operands = operands;
        this.labels = labels;
        if (firstComment != null) {
            this.commentLines.add(firstComment.trim());
        }
    }
    public String getAnnotation() {
        return annotation;
    }
    public long getAddress() {
        return address;
    }
    public List<String> getPrefixes() {
        return prefixes;
    }
    public String getMnemonic() {
        return mnemonic;
    }
    public List<String> getOperands() {
        return operands;
    }
    public String getComment() {
        StringBuilder builder = new StringBuilder();
        if (commentLines.size() > 0) {
            for (String line : commentLines) {
                builder.append(line).append(S_NEWLINE);
            }
            builder.deleteCharAt(builder.length() - 1);
        }
        return builder.toString();
    }
    public List<String> getCommentLines() {
        return commentLines;
    }
    public void addCommentLine(String comment) {
        if (comment != null) {
            commentLines.add(comment);
            if (!isSafePoint) {
                isSafePoint = comment.contains(S_SAFEPOINT_POLL) || comment.contains(S_SAFEPOINT_POLL_RETURN);
            }
        }
    }
    public boolean isSafePoint() {
        return isSafePoint;
    }
    public void appendToLastCommentLine(String comment) {
        if (comment != null) {
            String lastCommentLine = commentLines.get(commentLines.size() - 1);
            commentLines.set(commentLines.size() - 1, lastCommentLine + comment);
        }
    }
    public boolean isOptimizedVCall() {
        boolean result = false;
        int commentLineCount = commentLines.size();
        if (commentLineCount > 1) {
            String lastLine = commentLines.get(commentLineCount - 1);
            if (lastLine.contains(S_OPTIMIZED_VIRTUAL_CALL)) {
                result = true;
            }
        }
        return result;
    }
    public String toString() {
        return toString(0, false);
    }
    public String toString(int annoWidth, boolean useLocalLabels) {
        StringBuilder builder = new StringBuilder();
        builder.append(StringUtil.alignLeft(annotation, annoWidth));
        if (useLocalLabels) {
            labels.formatAddress(address, builder);
        } else {
            builder.append(S_HEX_PREFIX).append(StringUtil.pad(Long.toHexString(address), 16, '0', true));
        }
        builder.append(C_COLON).append(C_SPACE);
        if (!prefixes.isEmpty()) {
            for (String prefix : prefixes) {
                builder.append(prefix);
                builder.append(C_SPACE);
            }
        }
        builder.append(mnemonic);
        if (useLocalLabels) {
            labels.formatOperands(this, builder);
        } else {
            if (operands.size() > 0) {
                builder.append(C_SPACE);
                for (String op : operands) {
                    builder.append(op).append(S_COMMA);
                }
                builder.deleteCharAt(builder.length() - 1);
            }
        }
        int lineLength = builder.length();
        if (commentLines.size() > 0) {
            boolean first = true;
            for (String commentLine : commentLines) {
                if (first) {
                    builder.append(S_DOUBLE_SPACE).append(commentLine).append(S_NEWLINE);
                    first = false;
                } else {
                    builder.append(StringUtil.repeat(C_SPACE, lineLength + 2));
                    builder.append(commentLine).append(S_NEWLINE);
                }
            }
        } else {
            builder.append(S_NEWLINE);
        }
        return StringUtil.rtrim(builder.toString());
    }
    public String toString(int annoWidth, int line, boolean useLocalLabels) {
        StringBuilder builder = new StringBuilder();
        builder.append(StringUtil.alignLeft(annotation, annoWidth));
        if (useLocalLabels) {
            labels.formatAddress(address, builder);
        } else {
            builder.append(S_HEX_PREFIX).append(StringUtil.pad(Long.toHexString(address), 16, '0', true));
        }
        builder.append(C_COLON).append(C_SPACE);
        if (!prefixes.isEmpty()) {
            for (String prefix : prefixes) {
                builder.append(prefix);
                builder.append(C_SPACE);
            }
        }
        builder.append(mnemonic);
        if (useLocalLabels) {
            labels.formatOperands(this, builder);
        } else {
            if (operands.size() > 0) {
                builder.append(C_SPACE);
                for (String op : operands) {
                    builder.append(op).append(S_COMMA);
                }
                builder.deleteCharAt(builder.length() - 1);
            }
        }
        int lineLength = builder.length();
        if (commentLines.size() > 0) {
            String comment = commentLines.get(line);
            if (line == 0) {
                builder.append(S_DOUBLE_SPACE).append(comment);
            } else {
                builder.delete(0, builder.length());
                builder.append(StringUtil.repeat(C_SPACE, lineLength + 2));
                builder.append(comment);
            }
            if (comment.contains(S_SAFEPOINT_POLL) || comment.contains(S_SAFEPOINT_POLL_RETURN)) {
                builder.append(" *** SAFEPOINT POLL ***");
            }
            builder.append(S_NEWLINE);
        } else {
            builder.append(S_NEWLINE);
        }
        return StringUtil.rtrim(builder.toString());
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```