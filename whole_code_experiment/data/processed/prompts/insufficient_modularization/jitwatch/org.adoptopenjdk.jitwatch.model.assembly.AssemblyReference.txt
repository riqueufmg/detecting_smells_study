##CONTEXT_SIZE=2191
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.model.assembly;
public final class AssemblyReference {
    private static Map<String, String> x86MnemonicMap = null;
    private static Map<String, String> aarch64MnemonicMap = null;
    private static Map<Pattern, MnemonicEntry> patternMapAARCH64 = null;
    private static Map<String, String> aarch64DirectiveMap = null;
    private static final Logger LOGGER = LoggerFactory.getLogger(AssemblyReference.class);
    private static final String ASM_REF_PATH_X86 = "/x86reference.xml";
    private static final String ASM_REF_PATH_AARCH64 = "/aarch64reference.xml";
    private AssemblyReference() {
    }
    private static class AssemblyReferenceHandler extends DefaultHandler {
        private final Map<String, String> resultMap = new HashMap<>();
        private final Map<Pattern, MnemonicEntry> patternMapAARCH64 = new HashMap<Pattern, MnemonicEntry>();
        private final Map<String, String> directiveMap = new HashMap<String, String>();
        private final Set<String> currentMnemonics = new HashSet<>();
        private final StringBuilder txtBuffer = new StringBuilder();
        private String currentBrief = "";
        private boolean insideMnem = false;
        private boolean insideBrief = false;
        private boolean insideInsFormat = false;
        public void startElement(String uri, String localname, String qname, Attributes attributes) {
            if ("mnem".equalsIgnoreCase(qname)) {
                insideMnem = true;
                txtBuffer.setLength(0);
            } else if ("brief".equalsIgnoreCase(qname)) {
                insideBrief = true;
                txtBuffer.setLength(0);
            } else if ("insFormat".equalsIgnoreCase(qname)) {
                insideInsFormat = true;
                txtBuffer.setLength(0);
            } else if ("directive".equalsIgnoreCase(qname)) {
                String directiveName = attributes.getValue("name");
                String directiveDescription = attributes.getValue("description");
                if (directiveName != null && directiveDescription != null) {
                    directiveMap.put(directiveName, directiveDescription);
                }
            }
        }
        public void characters(char[] character, int start, int length) {
            txtBuffer.append(character, start, length);
        }
        public void endElement(String uri, String localname, String qname) {
            if ("mnem".equalsIgnoreCase(qname)) {
                currentMnemonics.clear();
                currentMnemonics.add(txtBuffer.toString().trim().toLowerCase());
                insideMnem = false;
            } else if ("brief".equalsIgnoreCase(qname)) {
                String brief = txtBuffer.toString().trim();
                currentBrief = brief;
                for (String mnemonic : currentMnemonics) {
                    resultMap.put(mnemonic, brief);
                }
                insideBrief = false;
            } else if ("insFormat".equalsIgnoreCase(qname)) {
                String regexPattern = txtBuffer.toString().trim();
                try {
                    Pattern compiledPattern = Pattern.compile(regexPattern);
                    for (String mnemonic : currentMnemonics) {
                        resultMap.remove(mnemonic);
                        patternMapAARCH64.put(compiledPattern, new MnemonicEntry(mnemonic, currentBrief));
                    }
                } catch (PatternSyntaxException pse) {
                    LOGGER.error("Invalid regex pattern for mnemonics: " + currentMnemonics + " - " + regexPattern, pse);
                }
                currentMnemonics.clear();
                insideInsFormat = false;
            }
        }
        public Map<String, String> getMnemonicMap() {
            if (!patternMapAARCH64.isEmpty()) {
                for (Pattern pattern : patternMapAARCH64.keySet()) {
                    MnemonicEntry entry = patternMapAARCH64.get(pattern);
                    resultMap.remove(entry.mnemonic);
                }
            }
            return resultMap;
        }
        public Map<Pattern, MnemonicEntry> getPatternMapAARCH64() {
            return patternMapAARCH64;
        }
        public Map<String, String> getDirectiveMap() {
            return directiveMap;
        }
    }
    private static synchronized Map<String, String> getX86MnemonicMap() {
        if (x86MnemonicMap == null) {
            x86MnemonicMap = loadReferenceFile(ASM_REF_PATH_X86);
            x86MnemonicMap.put("movabs", "Move a 64-bit value");
            if (x86MnemonicMap.get("retn") != null)
                x86MnemonicMap.put("ret", x86MnemonicMap.get("retn"));
            if (x86MnemonicMap.get("movsxd") != null)
                x86MnemonicMap.put("movslq", x86MnemonicMap.get("movsxd"));
        }
        return x86MnemonicMap;
    }
    private static synchronized Map<String, String> getAarch64MnemonicMap() {
        if (aarch64MnemonicMap == null)
            aarch64MnemonicMap = loadReferenceFile(ASM_REF_PATH_AARCH64);
        return aarch64MnemonicMap;
    }
    private static synchronized Map<Pattern, MnemonicEntry> getAarch64PatternMap() {
        if (patternMapAARCH64 == null)
            patternMapAARCH64 = loadPatternReferenceFile(ASM_REF_PATH_AARCH64);
        return patternMapAARCH64;
    }
    private static synchronized Map<String, String> getAarch64DirectiveMap() {
        if (aarch64DirectiveMap == null) {
            aarch64DirectiveMap = loadDirectiveReferenceFile(ASM_REF_PATH_AARCH64);
        }
        return aarch64DirectiveMap;
    }
    private static Map<String, String> loadReferenceFile(String path) {
        try {
            InputStream asmRefInputStream = AssemblyReference.class.getResourceAsStream(path);
            if (asmRefInputStream == null) {
                LOGGER.error("Could not find assembly reference {}. If launching from an IDE please add /src/main/resources to your classpath", path);
                return new HashMap<>();
            }
            SAXParserFactory assemblyRefFactory = SAXParserFactory.newInstance();
            SAXParser xmlparser = assemblyRefFactory.newSAXParser();
            AssemblyReferenceHandler handler = new AssemblyReferenceHandler();
            xmlparser.parse(asmRefInputStream, handler);
            return handler.getMnemonicMap();
        } catch (IOException ioe) {
            LOGGER.error("Could not load assembly reference " + path, ioe);
        } catch (ParserConfigurationException pce) {
            LOGGER.error("The XML Parser suffered a malformed configuration when trying to load in the assembly reference " + path, pce);
        } catch (SAXException saxe) {
            LOGGER.error("The SAX XML Parser failed when trying to load in the assembly reference " + path, saxe);
        }
        return new HashMap<>();
    }
    private static Map<Pattern, MnemonicEntry> loadPatternReferenceFile(String path) {
        try {
            InputStream asmRefInputStream = AssemblyReference.class.getResourceAsStream(path);
            if (asmRefInputStream == null) {
                LOGGER.error("Could not find assembly reference {}", path);
                return new HashMap<>();
            }
            SAXParserFactory assemblyRefFactory = SAXParserFactory.newInstance();
            SAXParser xmlparser = assemblyRefFactory.newSAXParser();
            AssemblyReferenceHandler handler = new AssemblyReferenceHandler();
            xmlparser.parse(asmRefInputStream, handler);
            return handler.getPatternMapAARCH64();
        } catch (IOException | ParserConfigurationException | SAXException e) {
            LOGGER.error("Could not load assembly reference patterns " + path, e);
            return new HashMap<>();
        }
    }
    private static Map<String, String> loadDirectiveReferenceFile(String path) {
        try {
            InputStream asmRefInputStream = AssemblyReference.class.getResourceAsStream(path);
            if (asmRefInputStream == null) {
                LOGGER.error("Could not find assembly reference {}", path);
                return new HashMap<>();
            }
            SAXParserFactory assemblyRefFactory = SAXParserFactory.newInstance();
            SAXParser xmlparser = assemblyRefFactory.newSAXParser();
            AssemblyReferenceHandler handler = new AssemblyReferenceHandler();
            xmlparser.parse(asmRefInputStream, handler);
            return handler.getDirectiveMap();
        } catch (IOException | ParserConfigurationException | SAXException e) {
            LOGGER.error("Could not load assembly directive reference " + path, e);
            return new HashMap<>();
        }
    }
    public static String lookupMnemonic(String mnemonic, Architecture arch) {
        Map<String, String> mnemonicMap;
        if (arch == Architecture.ARM_32 || arch == Architecture.ARM_64) {
            mnemonicMap = getAarch64MnemonicMap();
        } else {
            mnemonicMap = getX86MnemonicMap();
        }
        String result = mnemonicMap.get(mnemonic);
        if (result == null && (arch == Architecture.ARM_64 || arch == Architecture.ARM_32)) {
            for (String key : mnemonicMap.keySet()) {
                String[] mnemonics = key.split(",");
                for (String mn : mnemonics) {
                    if (mn.trim().equalsIgnoreCase(mnemonic)) {
                        result = mnemonicMap.get(key);
                        break;
                    }
                }
                if (result != null)
                    break;
            }
        }
        if (result == null && mnemonic != null)
            if (mnemonic.endsWith("b") || mnemonic.endsWith("w") || mnemonic.endsWith("l") || mnemonic.endsWith("q"))
                result = mnemonicMap.get(mnemonic.substring(0, mnemonic.length() - 1));
        return result;
    }
    public static MnemonicEntry lookupMnemonicInfo(String assemblyLine, Architecture arch) {
        if (arch == Architecture.ARM_32 || arch == Architecture.ARM_64) {
            Map<Pattern, MnemonicEntry> patternMap = getAarch64PatternMap();
            for (Map.Entry<Pattern, MnemonicEntry> entry : patternMap.entrySet()) {
                if (entry.getKey().matcher(assemblyLine).matches()) {
                    return entry.getValue();
                }
            }
        }
        return null;
    }
    public static String lookupDirective(String directiveName, Architecture arch) {
        if (arch == Architecture.ARM_32 || arch == Architecture.ARM_64) {
            Map<String, String> directiveMap = getAarch64DirectiveMap();
            return directiveMap.get(directiveName);
        }
        return null;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```