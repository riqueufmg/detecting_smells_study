##CONTEXT_SIZE=872
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.loader;
public final class ResourceLoader {
    private static final Logger logger = LoggerFactory.getLogger(ResourceLoader.class);
    private ResourceLoader() {
    }
    public static String getSourceForClassName(String moduleName, String fqName, List<String> sourceLocations) {
        List<String> searchLocations = new ArrayList<>(sourceLocations);
        if (searchLocations.isEmpty()) {
            File jdkSrcZip = FileUtil.getJDKSourceZip();
            if (jdkSrcZip != null) {
                searchLocations.add(jdkSrcZip.toPath().toString());
            }
        }
        int dollarPos = fqName.indexOf(C_DOLLAR);
        if (dollarPos != -1) {
            fqName = fqName.substring(0, dollarPos);
        }
        List<String> fileExtensions = LanguageManager.getKnownFilenameExtensions();
        String result = null;
        for (String suffix : fileExtensions) {
            String filename = fqName.replace(S_DOT, File.separator) + S_DOT + suffix;
            result = getSourceForFilename(moduleName, filename, searchLocations);
            if (result != null) {
                break;
            }
        }
        return result;
    }
    public static String getSourceForFilename(String moduleName, String fileName, List<String> locations) {
        if (fileName.startsWith(S_SLASH)) {
            return readFile(new File(fileName));
        }
        String source = null;
        for (String location : locations) {
            File locationFile = new File(location);
            if (locationFile.exists()) {
                if (locationFile.isDirectory()) {
                    source = readFileInDirectory(locationFile, fileName);
                    if (source != null) {
                        break;
                    }
                } else {
                    source = readFileFromZip(moduleName, locationFile, fileName);
                    if (source != null) {
                        break;
                    }
                }
            }
        }
        return source;
    }
    public static String readFileInDirectory(File dir, String fileName) {
        File sourceFile = new File(dir, fileName);
        return readFile(sourceFile);
    }
    public static String readFile(File sourceFile) {
        String result = null;
        if (sourceFile != null && sourceFile.exists()) {
            try {
                byte[] fileBytes = Files.readAllBytes(sourceFile.toPath());
                result = new String(fileBytes, StandardCharsets.UTF_8);
            } catch (IOException ioe) {
                logger.error("Failed to read file: {}", sourceFile, ioe);
            }
        }
        return result;
    }
    public static Properties readManifestFromZip(File zipFile) {
        Properties result = new Properties();
        String manifestSource = readFileFromZip(null, zipFile, "META-INF/MANIFEST.MF");
        if (manifestSource != null) {
            try {
                result.load(new StringReader(manifestSource));
            } catch (IOException e) {
                logger.error("Couldn't read manifest from {}", zipFile, e);
            }
        }
        return result;
    }
    public static String readFileFromZip(String moduleName, File zipFileName, String sourceFileName) {
        String result = null;
        sourceFileName = sourceFileName.replace(S_BACKSLASH, S_SLASH);
        if (moduleName != null) {
            sourceFileName = moduleName + S_SLASH + sourceFileName;
        }
        try (ZipFile zipFile = new ZipFile(zipFileName)) {
            ZipEntry entry = zipFile.getEntry(sourceFileName);
            if (entry != null) {
                try (BufferedReader reader = new BufferedReader(new InputStreamReader(zipFile.getInputStream(entry)))) {
                    StringBuilder sb = new StringBuilder();
                    String line = reader.readLine();
                    while (line != null) {
                        sb.append(line).append(S_NEWLINE);
                        line = reader.readLine();
                    }
                    result = sb.toString();
                }
            }
        } catch (IOException ioe) {
            logger.error("Could not read file {} from zip {}", sourceFileName, zipFileName.getName(), ioe);
        }
        return result;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```