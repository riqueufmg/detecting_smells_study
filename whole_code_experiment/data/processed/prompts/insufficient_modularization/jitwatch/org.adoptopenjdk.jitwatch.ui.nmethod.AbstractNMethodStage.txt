##CONTEXT_SIZE=994
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.ui.nmethod;
public abstract class AbstractNMethodStage extends Stage implements IRedrawable, ICompilationChangeListener, IPrevNextCompilationListener {
    protected double width;
    protected double height;
    protected Scene scene;
    protected VBox vBoxStack;
    protected Pane pane;
    protected ScrollPane scrollPane;
    protected VBox vBoxControls;
    private NMethodInfo nMethodInfo;
    protected JITWatchUI parent;
    protected Button btnZoomIn;
    protected Button btnZoomOut;
    protected Button btnZoomReset;
    protected double zoom = 1;
    protected static final Color COLOR_UNSELECTED_COMPILATION = Color.rgb(0, 196, 0);
    protected static final Color COLOR_SELECTED_COMPILATION = Color.rgb(0, 220, 255);
    protected static final Color COLOR_OTHER_MEMBER_COMPILATIONS = Color.rgb(0, 0, 160);
    public AbstractNMethodStage(final JITWatchUI parent, String title) {
        this.parent = parent;
        initStyle(StageStyle.DECORATED);
        vBoxStack = new VBox();
        vBoxStack.setSpacing(0);
        scrollPane = new ScrollPane();
        pane = new Pane();
        scrollPane.setContent(pane);
        scrollPane.setFitToHeight(true);
        nMethodInfo = new NMethodInfo(this);
        scene = UserInterfaceUtil.getScene(vBoxStack, JITWatchUI.WINDOW_WIDTH, JITWatchUI.WINDOW_HEIGHT);
        vBoxControls = buildControls(scene);
        vBoxStack.getChildren().addAll(scrollPane, vBoxControls, nMethodInfo);
        scrollPane.prefWidthProperty().bind(vBoxStack.widthProperty());
        vBoxControls.prefWidthProperty().bind(vBoxStack.widthProperty());
        nMethodInfo.prefWidthProperty().bind(vBoxStack.widthProperty());
        pane.prefHeightProperty().bind(vBoxStack.heightProperty().multiply(0.975).subtract(vBoxControls.heightProperty()).subtract(nMethodInfo.heightProperty()));
        RateLimitedResizeListener resizeListener = new RateLimitedResizeListener(this, 100);
        scene.widthProperty().addListener(resizeListener);
        scene.heightProperty().addListener(resizeListener);
        setTitle(title);
        setScene(scene);
        pane.setStyle("-fx-background-color: #000000");
    }
    protected abstract VBox buildControls(Scene scene);
    protected void plotMarker(double x, double y, Compilation compilation) {
        plotMarker(x, y, compilation, false);
    }
    protected void plotMarker(double x, double y, Compilation compilation, boolean invert) {
        double side = 12;
        double centre = x;
        double left = x - side / 2;
        double right = x + side / 2;
        double top;
        double bottom;
        if (invert) {
            top = y + side;
            bottom = y;
        } else {
            top = y - side;
            bottom = y;
        }
        Polygon triangle = new Polygon();
        triangle.getPoints().addAll(new Double[] { left, bottom, centre, top, right, bottom });
        triangle.setFill(Color.WHITE);
        triangle.setStroke(Color.BLACK);
        attachListener(triangle, compilation);
        pane.getChildren().add(triangle);
    }
    protected void attachListener(Shape shape, final Compilation compilation) {
        shape.setOnMouseClicked(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent arg0) {
                selectCompilation(compilation.getMember(), compilation.getIndex());
            }
        });
    }
    public void selectPrevCompilation() {
        IMetaMember selectedMember = parent.getSelectedMember();
        if (selectedMember != null && selectedMember.getSelectedCompilation() != null) {
            int prevIndex = selectedMember.getSelectedCompilation().getIndex() - 1;
            selectCompilation(selectedMember, prevIndex);
        }
    }
    public void selectNextCompilation() {
        IMetaMember selectedMember = parent.getSelectedMember();
        if (selectedMember != null && selectedMember.getSelectedCompilation() != null) {
            int nextIndex = selectedMember.getSelectedCompilation().getIndex() + 1;
            selectCompilation(selectedMember, nextIndex);
        }
    }
    private void selectCompilation(final IMetaMember member, final int index) {
        parent.selectCompilation(member, index);
    }
    public void compilationChanged(IMetaMember member) {
        redraw();
    }
    protected void clear() {
        pane.getChildren().clear();
        nMethodInfo.clear();
        IMetaMember member = parent.getSelectedMember();
        Compilation selectedCompilation = (member == null) ? null : member.getSelectedCompilation();
        if (selectedCompilation != null) {
            nMethodInfo.setInfo(selectedCompilation);
        }
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```