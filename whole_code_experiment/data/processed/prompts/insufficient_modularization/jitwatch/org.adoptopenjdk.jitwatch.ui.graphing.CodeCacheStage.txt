##CONTEXT_SIZE=1000
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.ui.graphing;
public class CodeCacheStage extends AbstractGraphStage {
    private boolean labelLeft = true;
    public CodeCacheStage(JITWatchUI parent) {
        super(parent, JITWatchUI.WINDOW_WIDTH, JITWatchUI.WINDOW_HEIGHT, true);
        StackPane root = new StackPane();
        Scene scene = UserInterfaceUtil.getScene(root, width, height);
        canvas.widthProperty().bind(root.widthProperty());
        canvas.heightProperty().bind(root.heightProperty());
        root.getChildren().add(canvas);
        setTitle("JITWatch Free Code Cache");
        setScene(scene);
        show();
        redraw();
    }
    public final void redraw() {
        super.baseRedraw();
        labelLeft = true;
        List<CodeCacheEvent> codeCacheEvents = mainUI.getJITDataModel().getCodeCacheEvents();
        Collections.sort(codeCacheEvents, new Comparator<CodeCacheEvent>() {
            @Override
            public int compare(CodeCacheEvent e1, CodeCacheEvent e2) {
                return Long.compare(e1.getStamp(), e2.getStamp());
            }
        });
        if (codeCacheEvents.size() > 0) {
            CodeCacheEvent firstEvent = codeCacheEvents.get(0);
            minX = firstEvent.getStamp();
            double firstNonZeroY = 0;
            Tag endOfLogTag = mainUI.getJITDataModel().getEndOfLogTag();
            if (endOfLogTag != null) {
                maxX = getStampFromTag(endOfLogTag);
            } else {
                CodeCacheEvent lastEvent = codeCacheEvents.get(codeCacheEvents.size() - 1);
                maxX = lastEvent.getStamp();
            }
            minY = firstEvent.getFreeCodeCache();
            maxY = firstEvent.getFreeCodeCache();
            if (minY != 0) {
                firstNonZeroY = minY;
            }
            for (CodeCacheEvent event : codeCacheEvents) {
                long freeCodeCache = event.getFreeCodeCache();
                if (freeCodeCache > 0) {
                    if (minY == 0) {
                        minY = freeCodeCache;
                        firstNonZeroY = minY;
                    }
                    if (freeCodeCache > maxY) {
                        maxY = freeCodeCache;
                    } else if (freeCodeCache < minY) {
                        minY = freeCodeCache;
                    }
                }
            }
            drawAxes();
            double lastCX = graphGapLeft + normaliseX(minX);
            double lastCY = graphGapTop + normaliseY(firstNonZeroY);
            Color colourLine = Color.BLUE;
            double lineWidth = 2.0;
            for (CodeCacheEvent event : codeCacheEvents) {
                long stamp = event.getStamp();
                double x = graphGapLeft + normaliseX(stamp);
                double y = lastCY;
                switch(event.getEventType()) {
                    case COMPILATION:
                        y = addToGraph(lastCX, lastCY, colourLine, lineWidth, event, x);
                        lastCX = x;
                        lastCY = y;
                        break;
                    case SWEEPER:
                        showLabel("Sweep", Color.WHITE, x, y);
                        break;
                    case CACHE_FULL:
                        showLabel("Code Cache Full", Color.RED, x, y);
                        break;
                }
            }
            continueLineToEndOfXAxis(lastCX, lastCY, colourLine, lineWidth);
        } else {
            gc.fillText("No code cache information in log", fix(10), fix(10));
        }
    }
    private double addToGraph(double lastCX, double lastCY, Color colourLine, double lineWidth, CodeCacheEvent event, double x) {
        long freeCodeCache = event.getFreeCodeCache();
        double y = graphGapTop + normaliseY(freeCodeCache);
        gc.setFill(colourLine);
        gc.setStroke(colourLine);
        gc.setLineWidth(lineWidth);
        gc.strokeLine(fix(lastCX), fix(lastCY), fix(x), fix(y));
        return y;
    }
    private void showLabel(String text, Color background, double x, double y) {
        double labelX;
        double labelY;
        if (labelLeft) {
            labelX = x - getApproximateStringWidth(text) - 16;
            labelY = Math.min(y - getStringHeight(), graphGapTop + chartHeight - 32);
        } else {
            labelX = x + 8;
            labelY = Math.min(y, graphGapTop + chartHeight - 32);
        }
        drawLabel(text, labelX, labelY, background);
        labelLeft = !labelLeft;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```