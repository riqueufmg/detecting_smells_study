##CONTEXT_SIZE=3745
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.ui.sandbox;
public class SandboxStage extends Stage implements ISandboxStage, IStageClosedListener, ILogListener, ILogParseErrorListener {
    private static final Logger logger = LoggerFactory.getLogger(SandboxStage.class);
    private TextArea taLog;
    private IStageAccessProxy accessProxy;
    private Sandbox sandbox;
    private TabPane tabPane;
    private Button btnSandboxConfig;
    private Button btnRun;
    private SandboxConfigStage sandboxConfigStage;
    private ObservableList<String> languageList = FXCollections.observableArrayList();
    private ComboBox<String> comboBoxVMLanguage = new ComboBox<>(languageList);
    private JITWatchConfig config;
    public SandboxStage(final IStageClosedListener closeListener, IStageAccessProxy proxy, final ILogParser parser) {
        this.accessProxy = proxy;
        config = parser.getConfig();
        config.switchToSandbox();
        setupVMLanguages();
        sandbox = new Sandbox(parser, this, this);
        setTitle("Sandbox - Code, Compile, Execute, and Analyse JIT logs");
        tabPane = new TabPane();
        tabPane.getSelectionModel().selectedItemProperty().addListener(new ChangeListener<Tab>() {
            @Override
            public void changed(ObservableValue<? extends Tab> ov, Tab t, Tab t1) {
                Tab selectedTab = tabPane.getSelectionModel().getSelectedItem();
                if (selectedTab != null) {
                    EditorPane pane = (EditorPane) selectedTab.getContent();
                    setVMLanguage(pane);
                }
            }
        });
        SplitPane splitVertical = new SplitPane();
        splitVertical.setOrientation(Orientation.VERTICAL);
        taLog = new TextArea();
        String style = "-fx-font-family:" + FONT_MONOSPACE_FAMILY + "; -fx-font-size:" + FONT_MONOSPACE_SIZE + "px; -fx-background-color:white;";
        taLog.setStyle(style);
        Button btnNewEditor = UserInterfaceUtil.createButton("SANDBOX_NEW_EDITOR");
        btnNewEditor.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                addEditor(null);
            }
        });
        Button btnOpen = UserInterfaceUtil.createButton("SANDBOX_OPEN_FILE");
        btnOpen.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                if (tabPane.getSelectionModel().getSelectedItem() == null) {
                    addEditor(null);
                }
                Tab selectedTab = tabPane.getSelectionModel().getSelectedItem();
                EditorPane pane = (EditorPane) selectedTab.getContent();
                if (pane.isModified()) {
                    pane.promptSave();
                }
                FileChooser fc = new FileChooser();
                fc.setTitle("Choose source file");
                fc.setInitialDirectory(Sandbox.SANDBOX_SOURCE_DIR.toFile());
                File result = fc.showOpenDialog(getStageForChooser());
                if (result != null) {
                    pane.loadSource(result);
                    selectedTab.setText(pane.getName());
                    setVMLanguage(pane);
                    saveEditorPaneConfig();
                }
            }
        });
        Button btnSave = UserInterfaceUtil.createButton("SANDBOX_SAVE_FILE");
        btnSave.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                Tab selectedTab = tabPane.getSelectionModel().getSelectedItem();
                if (selectedTab != null) {
                    EditorPane pane = (EditorPane) selectedTab.getContent();
                    pane.saveFile();
                    selectedTab.setText(pane.getName());
                    setVMLanguage(pane);
                }
            }
        });
        btnSandboxConfig = UserInterfaceUtil.createButton("SANDBOX_CONFIGURE");
        btnSandboxConfig.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                sandboxConfigStage = new SandboxConfigStage(SandboxStage.this, parser.getConfig());
                StageManager.addAndShow(SandboxStage.this, sandboxConfigStage, SandboxStage.this);
                btnSandboxConfig.setDisable(true);
            }
        });
        Button btnResetSandbox = UserInterfaceUtil.createButton("SANDBOX_RESET");
        btnResetSandbox.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                Response resp = Dialogs.showYesNoDialog(SandboxStage.this, "Reset Sandbox?", "Delete all modified Sandbox sources and classes?");
                if (resp == Response.YES) {
                    initialiseLog();
                    sandbox.reset();
                    loadDefaultEditors();
                }
            }
        });
        comboBoxVMLanguage.valueProperty().addListener(new ChangeListener<String>() {
            @Override
            public void changed(ObservableValue<? extends String> ov, String oldVal, String newVal) {
                if (newVal != null) {
                    log("Changed language to " + newVal);
                }
            }
        });
        btnRun = UserInterfaceUtil.createButton("SANDBOX_RUN");
        btnRun.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                btnRun.setDisable(true);
                Tab selectedTab = tabPane.getSelectionModel().getSelectedItem();
                if (selectedTab != null) {
                    EditorPane pane = (EditorPane) selectedTab.getContent();
                    if (pane.isModified()) {
                        pane.promptSave();
                    }
                    setVMLanguage(pane);
                    runFile(pane);
                }
            }
        });
        Button btnOutput = UserInterfaceUtil.createButton("SANDBOX_VIEW_OUTPUT");
        btnOutput.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                IExternalProcess lastProcess = sandbox.getLastProcess();
                String outputString;
                if (lastProcess != null) {
                    outputString = lastProcess.getOutputStream();
                } else {
                    outputString = "No output";
                }
                showOutput(outputString);
            }
        });
        BorderPane borderPane = new BorderPane();
        Scene scene = UserInterfaceUtil.getScene(borderPane, JITWatchUI.WINDOW_WIDTH, JITWatchUI.WINDOW_HEIGHT);
        HBox hBoxTools = new HBox();
        hBoxTools.setSpacing(10);
        hBoxTools.setPadding(new Insets(10));
        hBoxTools.getChildren().add(btnNewEditor);
        hBoxTools.getChildren().add(btnOpen);
        hBoxTools.getChildren().add(btnSave);
        hBoxTools.getChildren().add(btnSandboxConfig);
        hBoxTools.getChildren().add(btnResetSandbox);
        hBoxTools.getChildren().add(comboBoxVMLanguage);
        hBoxTools.getChildren().add(btnRun);
        hBoxTools.getChildren().add(btnOutput);
        Region spacer = new Region();
        HBox.setHgrow(spacer, Priority.ALWAYS);
        Button buttonSnapShot = UserInterfaceUtil.getSnapshotButton(scene, "Sandbox");
        hBoxTools.getChildren().add(spacer);
        hBoxTools.getChildren().add(buttonSnapShot);
        splitVertical.getItems().add(tabPane);
        splitVertical.getItems().add(taLog);
        splitVertical.setDividerPositions(0.75, 0.25);
        VBox vBoxMain = new VBox();
        vBoxMain.getChildren().add(hBoxTools);
        vBoxMain.getChildren().add(splitVertical);
        borderPane.setTop(hBoxTools);
        borderPane.setCenter(splitVertical);
        initialiseLog();
        setScene(scene);
        setOnCloseRequest(new EventHandler<WindowEvent>() {
            @Override
            public void handle(WindowEvent arg0) {
                saveEditorPaneConfig();
                closeListener.handleStageClosed(SandboxStage.this);
            }
        });
        loadLastEditorPanes();
    }
    public void setModified(EditorPane pane, boolean isModified) {
        for (Tab tab : tabPane.getTabs()) {
            EditorPane currentPane = (EditorPane) tab.getContent();
            if (currentPane == pane) {
                String tabText = tab.getText();
                if (isModified) {
                    if (!tabText.endsWith(S_ASTERISK)) {
                        tab.setText(tabText + S_ASTERISK);
                    }
                } else {
                    tab.setText(pane.getName());
                }
            }
        }
    }
    private void setVMLanguage(EditorPane pane) {
        if (pane != null) {
            setVMLanguageFromFile(pane.getSourceFile());
        }
    }
    public void runFile(final EditorPane pane) {
        saveUnsavedEditors();
        new Thread(new Runnable() {
            @Override
            public void run() {
                runSandbox(pane.getSourceFile());
                btnRun.setDisable(false);
            }
        }).start();
    }
    private void initialiseLog() {
        taLog.setText(S_EMPTY);
        log("Sandbox ready. OS is '" + System.getProperty("os.name") + "' Architecture is '" + System.getProperty("os.arch") + "'");
    }
    public void checkHsdis() {
        String disassemblerFilename = DisassemblyUtil.getDisassemblerFilename();
        log("Looking for disassembler: " + disassemblerFilename);
        Path downloadPath = Paths.get(disassemblerFilename);
        Path disassemblerPath = DisassemblyUtil.getDisassemblerFilePath();
        boolean noPromptHsdis = config.isNoPromptHsdis();
        if (!noPromptHsdis && !DisassemblyUtil.isDisassemblerAvailable()) {
            log("Disassembler not found");
            String hsdisDownloadUrl = "https://chriswhocodes.com/hsdis/";
            String message = "The disassembly plugin " + disassemblerFilename + " could not be found.\n Would you like to download it from " + hsdisDownloadUrl + " ?";
            Response response = Dialogs.showYesNoDialogNever(SandboxStage.this, "Download disassembly plugin", message);
            switch(response) {
                case YES:
                    {
                        String url = hsdisDownloadUrl + disassemblerFilename;
                        log("Downloading hsdis from " + url);
                        NetUtil.fetchBinary(url, downloadPath);
                        if (downloadPath.toFile().exists()) {
                            log("Downloaded OK");
                        } else {
                            log("Download failed");
                        }
                    }
                    break;
                case NEVER:
                    {
                        config.setNoPromptHsdis(true);
                        config.saveConfig();
                    }
                    break;
            }
        }
        if (DisassemblyUtil.downloadedDisassemblerPresent()) {
            log("Disassembler available: " + downloadPath.toAbsolutePath());
        } else if (disassemblerPath != null) {
            log("Disassembler available: " + disassemblerPath);
        }
    }
    private void loadLastEditorPanes() {
        List<String> panes = config.getLastEditorPaneList();
        if (panes.isEmpty()) {
            loadDefaultEditors();
        } else {
            tabPane.getTabs().clear();
            for (String panePath : panes) {
                addEditor(new File(panePath));
            }
        }
    }
    private void loadDefaultEditors() {
        tabPane.getTabs().clear();
        addEditor(new File(Sandbox.SANDBOX_SOURCE_DIR.toFile(), "SimpleInliningTest.java"));
        saveEditorPaneConfig();
    }
    private void addEditor(File filename) {
        final EditorPane pane = new EditorPane(this);
        if (filename != null) {
            pane.loadSource(filename);
        }
        final Tab tab = new Tab();
        tab.setContent(pane);
        tab.setText(pane.getName());
        EventHandler<Event> closeHandler = new EventHandler<Event>() {
            @Override
            public void handle(Event e) {
                if (pane.isModified()) {
                    pane.promptSave();
                }
                tabPane.getTabs().remove(tab);
            }
        };
        if (JITWatchUI.IS_JAVA_FX2) {
            tab.setOnClosed(closeHandler);
        } else {
            try {
                MethodType mt = MethodType.methodType(void.class, EventHandler.class);
                MethodHandle mh = MethodHandles.lookup().findVirtual(Tab.class, "setOnCloseRequest", mt);
                mh.invoke(tab, closeHandler);
            } catch (Throwable t) {
                logger.error("Exception: {}", t.getMessage(), t);
            }
        }
        tabPane.getTabs().add(tab);
        pane.requestFocus();
        setVMLanguage(pane);
        saveEditorPaneConfig();
    }
    private void saveEditorPaneConfig() {
        List<String> editorPanePaths = new ArrayList<>();
        for (Tab tab : tabPane.getTabs()) {
            EditorPane pane = (EditorPane) tab.getContent();
            if (pane != null && pane.getSourceFile() != null) {
                String editorPanePath = pane.getSourceFile().getAbsolutePath();
                editorPanePaths.add(editorPanePath);
            }
        }
        config.setLastEditorPaneList(editorPanePaths);
        config.saveConfig();
    }
    private void saveUnsavedEditors() {
        for (Tab tab : tabPane.getTabs()) {
            EditorPane pane = (EditorPane) tab.getContent();
            pane.promptSave();
        }
    }
    private void runSandbox(File fileToRun) {
        try {
            Platform.runLater(new Runnable() {
                @Override
                public void run() {
                    taLog.setText(S_EMPTY);
                }
            });
            String language = comboBoxVMLanguage.getValue();
            if (language != null) {
                List<File> compileList = new ArrayList<>();
                for (Tab tab : tabPane.getTabs()) {
                    EditorPane pane = (EditorPane) tab.getContent();
                    File sourceFile = pane.getSourceFile();
                    if (sourceFile != null) {
                        if (LanguageManager.isCompilable(language, sourceFile)) {
                            compileList.add(sourceFile);
                        }
                    }
                }
                if (compileList.size() > 0) {
                    sandbox.runSandbox(language, compileList, fileToRun);
                } else {
                    log("Nothing to compile?");
                }
            }
        } catch (Exception e) {
            logger.error("Sandbox failure", e);
        }
    }
    public void addSourceFolder(File sourceFolder) {
        config.addSourceFolder(sourceFolder);
    }
    private void setVMLanguageFromFile(File sourceFile) {
        String language = LanguageManager.getLanguageFromFile(sourceFile);
        if (language != null) {
            comboBoxVMLanguage.getSelectionModel().select(language);
        }
    }
    public void handleLogEntry(String text) {
        log(text);
    }
    public void handleErrorEntry(String text) {
        log(text);
    }
    public void log(final String text) {
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                taLog.appendText(text + S_NEWLINE);
            }
        });
    }
    public void openTriView(final IMetaMember member) {
        log("Launching TriView for " + member);
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                accessProxy.openTriView(member, 0);
            }
        });
    }
    public void showOutput(final String output) {
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                accessProxy.openTextViewer("Sandbox Output", output, false, false);
            }
        });
    }
    public void showError(final String error) {
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                accessProxy.openTextViewer("Error", error, false, false);
            }
        });
    }
    public void handleStageClosed(Stage stage) {
        StageManager.closeStage(stage);
        if (stage instanceof SandboxConfigStage) {
            btnSandboxConfig.setDisable(false);
        }
    }
    private void setupVMLanguages() {
        List<String> vmLanguageList = config.getVMLanguageList();
        addVMLanguages(config);
        vmLanguageList = config.getVMLanguageList();
        Collections.sort(vmLanguageList);
        languageList.addAll(vmLanguageList);
        comboBoxVMLanguage.getSelectionModel().select(VM_LANGUAGE_JAVA);
    }
    private void addVMLanguages(JITWatchConfig config) {
        List<String> vmLanguageList = config.getVMLanguageList();
        if (!vmLanguageList.contains(JITWatchConstants.VM_LANGUAGE_JAVA)) {
            config.addOrUpdateVMLanguage(VM_LANGUAGE_JAVA, S_EMPTY);
        }
        if (!vmLanguageList.contains(JITWatchConstants.VM_LANGUAGE_SCALA)) {
            config.addOrUpdateVMLanguage(VM_LANGUAGE_SCALA, S_EMPTY);
        }
        if (!vmLanguageList.contains(JITWatchConstants.VM_LANGUAGE_JRUBY)) {
            config.addOrUpdateVMLanguage(VM_LANGUAGE_JRUBY, S_EMPTY);
        }
        if (!vmLanguageList.contains(JITWatchConstants.VM_LANGUAGE_GROOVY)) {
            config.addOrUpdateVMLanguage(VM_LANGUAGE_GROOVY, S_EMPTY);
        }
        if (!vmLanguageList.contains(JITWatchConstants.VM_LANGUAGE_KOTLIN)) {
            config.addOrUpdateVMLanguage(VM_LANGUAGE_KOTLIN, S_EMPTY);
        }
        if (!vmLanguageList.contains(JITWatchConstants.VM_LANGUAGE_JAVASCRIPT)) {
            config.addOrUpdateVMLanguage(VM_LANGUAGE_JAVASCRIPT, S_EMPTY);
        }
        if (!vmLanguageList.contains(JITWatchConstants.VM_LANGUAGE_CLOJURE)) {
            config.addOrUpdateVMLanguage(VM_LANGUAGE_CLOJURE, S_EMPTY);
        }
        config.saveConfig();
    }
    public void handleError(final String title, final String body) {
        logger.error(title);
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                Dialogs.showOKDialog(SandboxStage.this, title, body);
            }
        });
    }
    public Stage getStageForChooser() {
        return this;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```