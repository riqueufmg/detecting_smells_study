##CONTEXT_SIZE=1559
# Task

You are a software engineering expert in software refactoring.

Your task is to detect the smell: Insufficient Modularization.

Definition:
Insufficient Modularization arises when a class represents an abstraction that has not been
adequately decomposed, resulting in excessive size, complexity, or a bloated interface.
Such classes are difficult to understand, maintain, and evolve, and often concentrate
responsibilities that could be separated into smaller, more cohesive abstractions.

# Constraints

- Perform the analysis should happen in the class provided in the **##Input** field.
- Use the package data only as contextual information to support class-level judgments.
- Give the answer exactly in the structure defined in the **#Successful Output** section.
- Do not include comments, explanations, or text outside the defined output format.
- All fields in the **#Successful Output** are mandatory.
- Only perform the analysis if the provided data are sufficient; otherwise, follow the **#Unsuccessful Output** format.

# Input

Assess whether the following class has the smell Insufficient Modularization:

```java
package org.adoptopenjdk.jitwatch.model.assembly.x86;
public final class AssemblyParserX86 extends AbstractAssemblyParser {
    private static final String PART_ADDRESS = "(" + S_HEX_PREFIX + "[a-f0-9]+):";
    private static final String PART_INSTRUCTION = "([0-9a-zA-Z:_\\(\\)\\[\\]\\+\\*\\$,\\-%\\s]+)";
    private static final String PART_COMMENT = "([;#].*)?";
    private static final Pattern ASSEMBLY_CONSTANT = Pattern.compile("^([\\$]?(" + S_HEX_PREFIX + ")?[a-f0-9]+[" + S_HEX_POSTFIX + "]?)$");
    private static final Pattern PATTERN_ASSEMBLY_INSTRUCTION = Pattern.compile("^" + PART_ADDRESS + "\\s+" + PART_INSTRUCTION + PART_COMMENT);
    public final Architecture architecture;
    public AssemblyParserX86(Architecture architecture) {
        super(architecture);
        this.architecture = architecture;
    }
    public AssemblyInstruction createInstruction(final AssemblyLabels labels, final String inLine) {
        if (DEBUG_LOGGING_ASSEMBLY) {
            logger.debug("Trying to parse instruction : {}", inLine);
        }
        String line = inLine;
        AssemblyInstruction instr = null;
        String annotation = S_EMPTY;
        if (!line.startsWith(S_HEX_PREFIX)) {
            int addressIndex = line.indexOf(' ' + S_HEX_PREFIX);
            if (addressIndex != -1) {
                annotation = line.substring(0, addressIndex) + ' ';
                line = line.substring(addressIndex + 1);
            }
        }
        Matcher matcher = PATTERN_ASSEMBLY_INSTRUCTION.matcher(line);
        if (matcher.find()) {
            if (DEBUG_LOGGING_ASSEMBLY) {
                for (int i = 1; i <= matcher.groupCount(); i++) {
                    logger.debug("parts : '{}'='{}'", i, matcher.group(i));
                }
            }
            if (matcher.groupCount() == 3) {
                String address = matcher.group(1);
                String instructionString = matcher.group(2);
                String comment = matcher.group(3);
                if (DEBUG_LOGGING_ASSEMBLY) {
                    logger.debug("Annotation : '{}'", annotation);
                    logger.debug("Address    : '{}'", address);
                    logger.debug("Instruction: '{}'", instructionString);
                    logger.debug("Comment    : '{}'", comment);
                }
                long addressValue = AssemblyUtil.getValueFromAddress(address);
                if (instructionString != null && instructionString.trim().length() > 0) {
                    instr = parseInstruction(instructionString, addressValue, comment, annotation, labels);
                    labels.newInstruction(instr);
                }
            }
        }
        return instr;
    }
    public AssemblyInstruction parseInstruction(String input, long address, String comment, String annotation, AssemblyLabels labels) {
        input = input.replaceAll("\\s+", S_SPACE).trim();
        int length = input.length();
        boolean inBrackets = false;
        String mnemonic = null;
        List<String> prefixes = new ArrayList<>();
        List<String> operands = new ArrayList<>();
        StringBuilder partBuilder = new StringBuilder();
        for (int pos = 0; pos < length; pos++) {
            char c = input.charAt(pos);
            if (c == C_OPEN_PARENTHESES || c == C_OPEN_SQUARE_BRACKET) {
                inBrackets = true;
            } else if (c == C_CLOSE_PARENTHESES || c == C_CLOSE_SQUARE_BRACKET) {
                inBrackets = false;
            }
            if (c == C_SPACE && mnemonic == null) {
                String part = partBuilder.toString();
                partBuilder.delete(0, partBuilder.length());
                if (DEBUG_LOGGING_ASSEMBLY) {
                    logger.debug("part: '{}'", part);
                }
                if (mnemonic == null) {
                    if ("data64".equals(part) || "data32".equals(part) || "data16".equals(part) || "data8".equals(part) || "lock".equals(part)) {
                        prefixes.add(part);
                    } else {
                        mnemonic = part;
                        if (DEBUG_LOGGING_ASSEMBLY) {
                            logger.debug("mnemonic: '{}'", mnemonic);
                        }
                    }
                }
            } else if (c == C_COMMA && !inBrackets) {
                String operand = partBuilder.toString();
                partBuilder.delete(0, partBuilder.length());
                operands.add(operand);
                if (DEBUG_LOGGING_ASSEMBLY) {
                    logger.debug("operand1: '{}'", operand);
                }
            } else {
                partBuilder.append(c);
            }
        }
        if (partBuilder.length() > 0) {
            String part = partBuilder.toString();
            partBuilder.delete(0, partBuilder.length() - 1);
            if (mnemonic == null) {
                mnemonic = part;
                if (DEBUG_LOGGING_ASSEMBLY) {
                    logger.debug("mnemonic: '{}'", part);
                }
            } else {
                operands.add(part);
                if (DEBUG_LOGGING_ASSEMBLY) {
                    logger.debug("operand2: '{}'", part);
                }
            }
        }
        return new AssemblyInstruction(annotation, address, prefixes, mnemonic, operands, comment, labels);
    }
    public boolean isConstant(String mnemonic, String operand) {
        return ASSEMBLY_CONSTANT.matcher(operand).find() && !isJump(mnemonic);
    }
    public boolean isRegister(String mnemonic, String operand) {
        return operand.startsWith(S_PERCENT) || operand.contains("(%") || operand.contains(S_OPEN_SQUARE_BRACKET) || (!isConstant(mnemonic, operand) && !isAddress(mnemonic, operand));
    }
    public boolean isJump(String mnemonic) {
        boolean result = false;
        if (mnemonic != null) {
            result = mnemonic.toLowerCase().startsWith("j") || mnemonic.toLowerCase().startsWith("call");
        }
        return result;
    }
    public String extractRegisterName(final String input) {
        String regName = input;
        int indexOpenParentheses = input.indexOf(C_OPEN_PARENTHESES);
        int indexCloseParentheses = input.indexOf(C_CLOSE_PARENTHESES);
        if (indexOpenParentheses != -1 && indexCloseParentheses != -1) {
            regName = regName.substring(indexOpenParentheses + 1, indexCloseParentheses);
        }
        int indexOpenSquareBracket = regName.indexOf(C_OPEN_SQUARE_BRACKET);
        int indexCloseSquareBracket = regName.indexOf(C_CLOSE_SQUARE_BRACKET);
        if (indexOpenSquareBracket != -1 && indexCloseSquareBracket != -1) {
            regName = regName.substring(indexOpenSquareBracket + 1, indexCloseSquareBracket);
        }
        if (regName.startsWith("*")) {
            regName = regName.substring(1);
        }
        if (regName.startsWith(S_PERCENT)) {
            regName = regName.substring(1);
        }
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < regName.length(); i++) {
            char c = regName.charAt(i);
            if (Character.isAlphabetic(c) || Character.isDigit(c)) {
                builder.append(c);
            } else {
                break;
            }
        }
        regName = builder.toString();
        return regName;
    }
}


```

# Successful Output

Provide the output in this structure:

```json
{
    "smell": "Insufficient Modularization",
    "class": [class name],
    "detection": [true/false],
    "justification": [Reasons for the detection result, citing the elements that justify the decision]
}
```

# Unsucessfull Output

If the available data are insufficient to detect this smell, return:

```json
{
    "message": "It is impossible to detect Insufficient Modularization with the available data."
}
```